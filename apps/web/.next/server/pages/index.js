"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/index";
exports.ids = ["pages/index"];
exports.modules = {

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"next/head\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ui */ \"../../packages/ui/dist/index.js\");\n/* harmony import */ var ui__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ui__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable react/jsx-no-comment-textnodes */ \n\n\n\n\nfunction Home() {\n    console.log(\"âœ… Pylar AI\");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-w-screen flex min-h-screen flex-col bg-white\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Pylar AI by Pencil\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\mgarg\\\\Documents\\\\Next13-Gallery-Image-Turbo\\\\apps\\\\web\\\\src\\\\pages\\\\index.tsx\",\n                        lineNumber: 13,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"./favicon.ico\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\mgarg\\\\Documents\\\\Next13-Gallery-Image-Turbo\\\\apps\\\\web\\\\src\\\\pages\\\\index.tsx\",\n                        lineNumber: 14,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\mgarg\\\\Documents\\\\Next13-Gallery-Image-Turbo\\\\apps\\\\web\\\\src\\\\pages\\\\index.tsx\",\n                lineNumber: 12,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ui__WEBPACK_IMPORTED_MODULE_2__.Menu, {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mgarg\\\\Documents\\\\Next13-Gallery-Image-Turbo\\\\apps\\\\web\\\\src\\\\pages\\\\index.tsx\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ui__WEBPACK_IMPORTED_MODULE_2__.TitlePylar, {}, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\mgarg\\\\Documents\\\\Next13-Gallery-Image-Turbo\\\\apps\\\\web\\\\src\\\\pages\\\\index.tsx\",\n                        lineNumber: 18,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"pylarDiv\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                            className: \"pylarDimension\",\n                            src: \"https://raw.githubusercontent.com/miguelgargallo/Next13-Gallery-Image-Turbo/main/Data.pylar/Images/Pylar-v1.1/A_photography_of_the_earth__from_the_moon_on_a_fis_AAAGOLjw_RealESRGAN_x4plus.jpeg\",\n                            alt: \"Pylar AI\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mgarg\\\\Documents\\\\Next13-Gallery-Image-Turbo\\\\apps\\\\web\\\\src\\\\pages\\\\index.tsx\",\n                            lineNumber: 21,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\mgarg\\\\Documents\\\\Next13-Gallery-Image-Turbo\\\\apps\\\\web\\\\src\\\\pages\\\\index.tsx\",\n                        lineNumber: 19,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\mgarg\\\\Documents\\\\Next13-Gallery-Image-Turbo\\\\apps\\\\web\\\\src\\\\pages\\\\index.tsx\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ui__WEBPACK_IMPORTED_MODULE_2__.Footer, {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mgarg\\\\Documents\\\\Next13-Gallery-Image-Turbo\\\\apps\\\\web\\\\src\\\\pages\\\\index.tsx\",\n                lineNumber: 28,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\mgarg\\\\Documents\\\\Next13-Gallery-Image-Turbo\\\\apps\\\\web\\\\src\\\\pages\\\\index.tsx\",\n        lineNumber: 11,\n        columnNumber: 5\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXgudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpREFBaUQsR0FDakQ7QUFBNkI7QUFDSDtBQUNNO0FBQ0o7QUFHYixTQUFTSSxPQUFPO0lBQzdCQyxRQUFRQyxHQUFHLENBQUM7SUFDWixxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNSLGtEQUFJQTs7a0NBQ0gsOERBQUNTO2tDQUFNOzs7Ozs7a0NBQ1AsOERBQUNDO3dCQUFLQyxLQUFJO3dCQUFPQyxNQUFLOzs7Ozs7Ozs7Ozs7MEJBRXhCLDhEQUFDWCxvQ0FBSUE7Ozs7OzBCQUNMLDhEQUFDWTs7a0NBQ0MsOERBQUNYLDBDQUFVQTs7Ozs7a0NBQ1gsOERBQUNLO3dCQUFJQyxXQUFVO2tDQUViLDRFQUFDTTs0QkFDQ04sV0FBVTs0QkFDVk8sS0FBSTs0QkFDSkMsS0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBSVYsOERBQUNiLHNDQUFNQTs7Ozs7Ozs7Ozs7QUFHYixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vc3JjL3BhZ2VzL2luZGV4LnRzeD8xOWEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L2pzeC1uby1jb21tZW50LXRleHRub2RlcyAqL1xyXG5pbXBvcnQgSGVhZCBmcm9tIFwibmV4dC9oZWFkXCI7XHJcbmltcG9ydCB7IE1lbnUgfSBmcm9tIFwidWlcIjtcclxuaW1wb3J0IHsgVGl0bGVQeWxhciB9IGZyb20gXCJ1aVwiO1xyXG5pbXBvcnQgeyBGb290ZXIgfSBmcm9tIFwidWlcIjtcclxuaW1wb3J0IEltYWdlIGZyb20gXCJuZXh0L2ltYWdlXCJcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XHJcbiAgY29uc29sZS5sb2coXCLinIUgUHlsYXIgQUlcIik7XHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWluLXctc2NyZWVuIGZsZXggbWluLWgtc2NyZWVuIGZsZXgtY29sIGJnLXdoaXRlXCI+XHJcbiAgICAgIDxIZWFkPlxyXG4gICAgICAgIDx0aXRsZT5QeWxhciBBSSBieSBQZW5jaWw8L3RpdGxlPlxyXG4gICAgICAgIDxsaW5rIHJlbD1cImljb25cIiBocmVmPVwiLi9mYXZpY29uLmljb1wiIC8+XHJcbiAgICAgIDwvSGVhZD5cclxuICAgICAgPE1lbnUgLz5cclxuICAgICAgPG1haW4+XHJcbiAgICAgICAgPFRpdGxlUHlsYXIgLz5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInB5bGFyRGl2XCI+XHJcbiAgICAgICAgIFxyXG4gICAgICAgICAgPGltZ1xyXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJweWxhckRpbWVuc2lvblwiXHJcbiAgICAgICAgICAgIHNyYz1cImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9taWd1ZWxnYXJnYWxsby9OZXh0MTMtR2FsbGVyeS1JbWFnZS1UdXJiby9tYWluL0RhdGEucHlsYXIvSW1hZ2VzL1B5bGFyLXYxLjEvQV9waG90b2dyYXBoeV9vZl90aGVfZWFydGhfX2Zyb21fdGhlX21vb25fb25fYV9maXNfQUFBR09MandfUmVhbEVTUkdBTl94NHBsdXMuanBlZ1wiXHJcbiAgICAgICAgICAgIGFsdD1cIlB5bGFyIEFJXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvbWFpbj5cclxuICAgICAgPEZvb3RlciAvPlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiSGVhZCIsIk1lbnUiLCJUaXRsZVB5bGFyIiwiRm9vdGVyIiwiSG9tZSIsImNvbnNvbGUiLCJsb2ciLCJkaXYiLCJjbGFzc05hbWUiLCJ0aXRsZSIsImxpbmsiLCJyZWwiLCJocmVmIiwibWFpbiIsImltZyIsInNyYyIsImFsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n");

/***/ }),

/***/ "../../packages/ui/dist/index.js":
/*!***************************************!*\
  !*** ../../packages/ui/dist/index.js ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a2, b2) => {\n  for (var prop in b2 || (b2 = {}))\n    if (__hasOwnProp.call(b2, prop))\n      __defNormalProp(a2, prop, b2[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b2)) {\n      if (__propIsEnum.call(b2, prop))\n        __defNormalProp(a2, prop, b2[prop]);\n    }\n  return a2;\n};\nvar __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb2, mod) => function __require() {\n  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// ../../node_modules/@emotion/memoize/dist/memoize.esm.js\nfunction memoize(fn) {\n  var cache = {};\n  return function(arg) {\n    if (cache[arg] === void 0)\n      cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\nvar memoize_esm_default;\nvar init_memoize_esm = __esm({\n  \"../../node_modules/@emotion/memoize/dist/memoize.esm.js\"() {\n    memoize_esm_default = memoize;\n  }\n});\n\n// ../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\nvar is_prop_valid_esm_exports = {};\n__export(is_prop_valid_esm_exports, {\n  default: () => is_prop_valid_esm_default\n});\nvar reactPropsRegex, index, is_prop_valid_esm_default;\nvar init_is_prop_valid_esm = __esm({\n  \"../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\"() {\n    init_memoize_esm();\n    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;\n    index = memoize_esm_default(\n      function(prop) {\n        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;\n      }\n    );\n    is_prop_valid_esm_default = index;\n  }\n});\n\n// ../../node_modules/popmotion/node_modules/tslib/tslib.js\nvar require_tslib = __commonJS({\n  \"../../node_modules/popmotion/node_modules/tslib/tslib.js\"(exports, module2) {\n    var __extends3;\n    var __assign3;\n    var __rest3;\n    var __decorate3;\n    var __param3;\n    var __metadata3;\n    var __awaiter3;\n    var __generator3;\n    var __exportStar3;\n    var __values3;\n    var __read3;\n    var __spread3;\n    var __spreadArrays3;\n    var __spreadArray3;\n    var __await3;\n    var __asyncGenerator3;\n    var __asyncDelegator3;\n    var __asyncValues3;\n    var __makeTemplateObject3;\n    var __importStar3;\n    var __importDefault3;\n    var __classPrivateFieldGet3;\n    var __classPrivateFieldSet3;\n    var __classPrivateFieldIn3;\n    var __createBinding3;\n    (function(factory) {\n      var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n      if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function(exports2) {\n          factory(createExporter(root, createExporter(exports2)));\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      } else {}\n      function createExporter(exports2, previous) {\n        if (exports2 !== root) {\n          if (typeof Object.create === \"function\") {\n            Object.defineProperty(exports2, \"__esModule\", { value: true });\n          } else {\n            exports2.__esModule = true;\n          }\n        }\n        return function(id2, v) {\n          return exports2[id2] = previous ? previous(id2, v) : v;\n        };\n      }\n    })(function(exporter) {\n      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p2 in b2)\n          if (Object.prototype.hasOwnProperty.call(b2, p2))\n            d2[p2] = b2[p2];\n      };\n      __extends3 = function(d2, b2) {\n        if (typeof b2 !== \"function\" && b2 !== null)\n          throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n        extendStatics(d2, b2);\n        function __() {\n          this.constructor = d2;\n        }\n        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n      };\n      __assign3 = Object.assign || function(t) {\n        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {\n          s = arguments[i2];\n          for (var p2 in s)\n            if (Object.prototype.hasOwnProperty.call(s, p2))\n              t[p2] = s[p2];\n        }\n        return t;\n      };\n      __rest3 = function(s, e) {\n        var t = {};\n        for (var p2 in s)\n          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)\n            t[p2] = s[p2];\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {\n            if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))\n              t[p2[i2]] = s[p2[i2]];\n          }\n        return t;\n      };\n      __decorate3 = function(decorators, target, key, desc) {\n        var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n          r = Reflect.decorate(decorators, target, key, desc);\n        else\n          for (var i2 = decorators.length - 1; i2 >= 0; i2--)\n            if (d2 = decorators[i2])\n              r = (c3 < 3 ? d2(r) : c3 > 3 ? d2(target, key, r) : d2(target, key)) || r;\n        return c3 > 3 && r && Object.defineProperty(target, key, r), r;\n      };\n      __param3 = function(paramIndex, decorator) {\n        return function(target, key) {\n          decorator(target, key, paramIndex);\n        };\n      };\n      __metadata3 = function(metadataKey, metadataValue) {\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n          return Reflect.metadata(metadataKey, metadataValue);\n      };\n      __awaiter3 = function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      __generator3 = function(thisArg, body) {\n        var _ = { label: 0, sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        }, trys: [], ops: [] }, f2, y, t, g2;\n        return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n          return this;\n        }), g2;\n        function verb(n) {\n          return function(v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f2)\n            throw new TypeError(\"Generator is already executing.\");\n          while (_)\n            try {\n              if (f2 = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                return t;\n              if (y = 0, t)\n                op = [op[0] & 2, t.value];\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n                case 4:\n                  _.label++;\n                  return { value: op[1], done: false };\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n                case 7:\n                  op = _.ops.pop();\n                  _.trys.pop();\n                  continue;\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n                    _.ops.push(op);\n                    break;\n                  }\n                  if (t[2])\n                    _.ops.pop();\n                  _.trys.pop();\n                  continue;\n              }\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f2 = t = 0;\n            }\n          if (op[0] & 5)\n            throw op[1];\n          return { value: op[0] ? op[1] : void 0, done: true };\n        }\n      };\n      __exportStar3 = function(m, o) {\n        for (var p2 in m)\n          if (p2 !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p2))\n            __createBinding3(o, m, p2);\n      };\n      __createBinding3 = Object.create ? function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        var desc = Object.getOwnPropertyDescriptor(m, k2);\n        if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n          desc = { enumerable: true, get: function() {\n            return m[k2];\n          } };\n        }\n        Object.defineProperty(o, k22, desc);\n      } : function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        o[k22] = m[k2];\n      };\n      __values3 = function(o) {\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i2 = 0;\n        if (m)\n          return m.call(o);\n        if (o && typeof o.length === \"number\")\n          return {\n            next: function() {\n              if (o && i2 >= o.length)\n                o = void 0;\n              return { value: o && o[i2++], done: !o };\n            }\n          };\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n      };\n      __read3 = function(o, n) {\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n        if (!m)\n          return o;\n        var i2 = m.call(o), r, ar = [], e;\n        try {\n          while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)\n            ar.push(r.value);\n        } catch (error) {\n          e = { error };\n        } finally {\n          try {\n            if (r && !r.done && (m = i2[\"return\"]))\n              m.call(i2);\n          } finally {\n            if (e)\n              throw e.error;\n          }\n        }\n        return ar;\n      };\n      __spread3 = function() {\n        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)\n          ar = ar.concat(__read3(arguments[i2]));\n        return ar;\n      };\n      __spreadArrays3 = function() {\n        for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n          s += arguments[i2].length;\n        for (var r = Array(s), k2 = 0, i2 = 0; i2 < il; i2++)\n          for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k2++)\n            r[k2] = a2[j];\n        return r;\n      };\n      __spreadArray3 = function(to, from, pack) {\n        if (pack || arguments.length === 2)\n          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {\n            if (ar || !(i2 in from)) {\n              if (!ar)\n                ar = Array.prototype.slice.call(from, 0, i2);\n              ar[i2] = from[i2];\n            }\n          }\n        return to.concat(ar || Array.prototype.slice.call(from));\n      };\n      __await3 = function(v) {\n        return this instanceof __await3 ? (this.v = v, this) : new __await3(v);\n      };\n      __asyncGenerator3 = function(thisArg, _arguments, generator) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];\n        return i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2;\n        function verb(n) {\n          if (g2[n])\n            i2[n] = function(v) {\n              return new Promise(function(a2, b2) {\n                q.push([n, v, a2, b2]) > 1 || resume(n, v);\n              });\n            };\n        }\n        function resume(n, v) {\n          try {\n            step(g2[n](v));\n          } catch (e) {\n            settle(q[0][3], e);\n          }\n        }\n        function step(r) {\n          r.value instanceof __await3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n        }\n        function fulfill(value) {\n          resume(\"next\", value);\n        }\n        function reject(value) {\n          resume(\"throw\", value);\n        }\n        function settle(f2, v) {\n          if (f2(v), q.shift(), q.length)\n            resume(q[0][0], q[0][1]);\n        }\n      };\n      __asyncDelegator3 = function(o) {\n        var i2, p2;\n        return i2 = {}, verb(\"next\"), verb(\"throw\", function(e) {\n          throw e;\n        }), verb(\"return\"), i2[Symbol.iterator] = function() {\n          return this;\n        }, i2;\n        function verb(n, f2) {\n          i2[n] = o[n] ? function(v) {\n            return (p2 = !p2) ? { value: __await3(o[n](v)), done: n === \"return\" } : f2 ? f2(v) : v;\n          } : f2;\n        }\n      };\n      __asyncValues3 = function(o) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var m = o[Symbol.asyncIterator], i2;\n        return m ? m.call(o) : (o = typeof __values3 === \"function\" ? __values3(o) : o[Symbol.iterator](), i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2);\n        function verb(n) {\n          i2[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n              v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n          };\n        }\n        function settle(resolve, reject, d2, v) {\n          Promise.resolve(v).then(function(v2) {\n            resolve({ value: v2, done: d2 });\n          }, reject);\n        }\n      };\n      __makeTemplateObject3 = function(cooked, raw) {\n        if (Object.defineProperty) {\n          Object.defineProperty(cooked, \"raw\", { value: raw });\n        } else {\n          cooked.raw = raw;\n        }\n        return cooked;\n      };\n      var __setModuleDefault = Object.create ? function(o, v) {\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n      } : function(o, v) {\n        o[\"default\"] = v;\n      };\n      __importStar3 = function(mod) {\n        if (mod && mod.__esModule)\n          return mod;\n        var result = {};\n        if (mod != null) {\n          for (var k2 in mod)\n            if (k2 !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k2))\n              __createBinding3(result, mod, k2);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n      };\n      __importDefault3 = function(mod) {\n        return mod && mod.__esModule ? mod : { \"default\": mod };\n      };\n      __classPrivateFieldGet3 = function(receiver, state, kind, f2) {\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a getter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n        return kind === \"m\" ? f2 : kind === \"a\" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);\n      };\n      __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {\n        if (kind === \"m\")\n          throw new TypeError(\"Private method is not writable\");\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a setter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n        return kind === \"a\" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;\n      };\n      __classPrivateFieldIn3 = function(state, receiver) {\n        if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\")\n          throw new TypeError(\"Cannot use 'in' operator on non-object\");\n        return typeof state === \"function\" ? receiver === state : state.has(receiver);\n      };\n      exporter(\"__extends\", __extends3);\n      exporter(\"__assign\", __assign3);\n      exporter(\"__rest\", __rest3);\n      exporter(\"__decorate\", __decorate3);\n      exporter(\"__param\", __param3);\n      exporter(\"__metadata\", __metadata3);\n      exporter(\"__awaiter\", __awaiter3);\n      exporter(\"__generator\", __generator3);\n      exporter(\"__exportStar\", __exportStar3);\n      exporter(\"__createBinding\", __createBinding3);\n      exporter(\"__values\", __values3);\n      exporter(\"__read\", __read3);\n      exporter(\"__spread\", __spread3);\n      exporter(\"__spreadArrays\", __spreadArrays3);\n      exporter(\"__spreadArray\", __spreadArray3);\n      exporter(\"__await\", __await3);\n      exporter(\"__asyncGenerator\", __asyncGenerator3);\n      exporter(\"__asyncDelegator\", __asyncDelegator3);\n      exporter(\"__asyncValues\", __asyncValues3);\n      exporter(\"__makeTemplateObject\", __makeTemplateObject3);\n      exporter(\"__importStar\", __importStar3);\n      exporter(\"__importDefault\", __importDefault3);\n      exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet3);\n      exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet3);\n      exporter(\"__classPrivateFieldIn\", __classPrivateFieldIn3);\n    });\n  }\n});\n\n// ../../node_modules/tslib/tslib.js\nvar require_tslib2 = __commonJS({\n  \"../../node_modules/tslib/tslib.js\"(exports, module2) {\n    var __extends3;\n    var __assign3;\n    var __rest3;\n    var __decorate3;\n    var __param3;\n    var __metadata3;\n    var __awaiter3;\n    var __generator3;\n    var __exportStar3;\n    var __values3;\n    var __read3;\n    var __spread3;\n    var __spreadArrays3;\n    var __spreadArray3;\n    var __await3;\n    var __asyncGenerator3;\n    var __asyncDelegator3;\n    var __asyncValues3;\n    var __makeTemplateObject3;\n    var __importStar3;\n    var __importDefault3;\n    var __classPrivateFieldGet3;\n    var __classPrivateFieldSet3;\n    var __classPrivateFieldIn3;\n    var __createBinding3;\n    (function(factory) {\n      var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n      if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function(exports2) {\n          factory(createExporter(root, createExporter(exports2)));\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      } else {}\n      function createExporter(exports2, previous) {\n        if (exports2 !== root) {\n          if (typeof Object.create === \"function\") {\n            Object.defineProperty(exports2, \"__esModule\", { value: true });\n          } else {\n            exports2.__esModule = true;\n          }\n        }\n        return function(id2, v) {\n          return exports2[id2] = previous ? previous(id2, v) : v;\n        };\n      }\n    })(function(exporter) {\n      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p2 in b2)\n          if (Object.prototype.hasOwnProperty.call(b2, p2))\n            d2[p2] = b2[p2];\n      };\n      __extends3 = function(d2, b2) {\n        if (typeof b2 !== \"function\" && b2 !== null)\n          throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n        extendStatics(d2, b2);\n        function __() {\n          this.constructor = d2;\n        }\n        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n      };\n      __assign3 = Object.assign || function(t) {\n        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {\n          s = arguments[i2];\n          for (var p2 in s)\n            if (Object.prototype.hasOwnProperty.call(s, p2))\n              t[p2] = s[p2];\n        }\n        return t;\n      };\n      __rest3 = function(s, e) {\n        var t = {};\n        for (var p2 in s)\n          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)\n            t[p2] = s[p2];\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {\n            if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))\n              t[p2[i2]] = s[p2[i2]];\n          }\n        return t;\n      };\n      __decorate3 = function(decorators, target, key, desc) {\n        var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n          r = Reflect.decorate(decorators, target, key, desc);\n        else\n          for (var i2 = decorators.length - 1; i2 >= 0; i2--)\n            if (d2 = decorators[i2])\n              r = (c3 < 3 ? d2(r) : c3 > 3 ? d2(target, key, r) : d2(target, key)) || r;\n        return c3 > 3 && r && Object.defineProperty(target, key, r), r;\n      };\n      __param3 = function(paramIndex, decorator) {\n        return function(target, key) {\n          decorator(target, key, paramIndex);\n        };\n      };\n      __metadata3 = function(metadataKey, metadataValue) {\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n          return Reflect.metadata(metadataKey, metadataValue);\n      };\n      __awaiter3 = function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      __generator3 = function(thisArg, body) {\n        var _ = { label: 0, sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        }, trys: [], ops: [] }, f2, y, t, g2;\n        return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n          return this;\n        }), g2;\n        function verb(n) {\n          return function(v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f2)\n            throw new TypeError(\"Generator is already executing.\");\n          while (g2 && (g2 = 0, op[0] && (_ = 0)), _)\n            try {\n              if (f2 = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                return t;\n              if (y = 0, t)\n                op = [op[0] & 2, t.value];\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n                case 4:\n                  _.label++;\n                  return { value: op[1], done: false };\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n                case 7:\n                  op = _.ops.pop();\n                  _.trys.pop();\n                  continue;\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n                    _.ops.push(op);\n                    break;\n                  }\n                  if (t[2])\n                    _.ops.pop();\n                  _.trys.pop();\n                  continue;\n              }\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f2 = t = 0;\n            }\n          if (op[0] & 5)\n            throw op[1];\n          return { value: op[0] ? op[1] : void 0, done: true };\n        }\n      };\n      __exportStar3 = function(m, o) {\n        for (var p2 in m)\n          if (p2 !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p2))\n            __createBinding3(o, m, p2);\n      };\n      __createBinding3 = Object.create ? function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        var desc = Object.getOwnPropertyDescriptor(m, k2);\n        if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n          desc = { enumerable: true, get: function() {\n            return m[k2];\n          } };\n        }\n        Object.defineProperty(o, k22, desc);\n      } : function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        o[k22] = m[k2];\n      };\n      __values3 = function(o) {\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i2 = 0;\n        if (m)\n          return m.call(o);\n        if (o && typeof o.length === \"number\")\n          return {\n            next: function() {\n              if (o && i2 >= o.length)\n                o = void 0;\n              return { value: o && o[i2++], done: !o };\n            }\n          };\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n      };\n      __read3 = function(o, n) {\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n        if (!m)\n          return o;\n        var i2 = m.call(o), r, ar = [], e;\n        try {\n          while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)\n            ar.push(r.value);\n        } catch (error) {\n          e = { error };\n        } finally {\n          try {\n            if (r && !r.done && (m = i2[\"return\"]))\n              m.call(i2);\n          } finally {\n            if (e)\n              throw e.error;\n          }\n        }\n        return ar;\n      };\n      __spread3 = function() {\n        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)\n          ar = ar.concat(__read3(arguments[i2]));\n        return ar;\n      };\n      __spreadArrays3 = function() {\n        for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n          s += arguments[i2].length;\n        for (var r = Array(s), k2 = 0, i2 = 0; i2 < il; i2++)\n          for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k2++)\n            r[k2] = a2[j];\n        return r;\n      };\n      __spreadArray3 = function(to, from, pack) {\n        if (pack || arguments.length === 2)\n          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {\n            if (ar || !(i2 in from)) {\n              if (!ar)\n                ar = Array.prototype.slice.call(from, 0, i2);\n              ar[i2] = from[i2];\n            }\n          }\n        return to.concat(ar || Array.prototype.slice.call(from));\n      };\n      __await3 = function(v) {\n        return this instanceof __await3 ? (this.v = v, this) : new __await3(v);\n      };\n      __asyncGenerator3 = function(thisArg, _arguments, generator) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];\n        return i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2;\n        function verb(n) {\n          if (g2[n])\n            i2[n] = function(v) {\n              return new Promise(function(a2, b2) {\n                q.push([n, v, a2, b2]) > 1 || resume(n, v);\n              });\n            };\n        }\n        function resume(n, v) {\n          try {\n            step(g2[n](v));\n          } catch (e) {\n            settle(q[0][3], e);\n          }\n        }\n        function step(r) {\n          r.value instanceof __await3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n        }\n        function fulfill(value) {\n          resume(\"next\", value);\n        }\n        function reject(value) {\n          resume(\"throw\", value);\n        }\n        function settle(f2, v) {\n          if (f2(v), q.shift(), q.length)\n            resume(q[0][0], q[0][1]);\n        }\n      };\n      __asyncDelegator3 = function(o) {\n        var i2, p2;\n        return i2 = {}, verb(\"next\"), verb(\"throw\", function(e) {\n          throw e;\n        }), verb(\"return\"), i2[Symbol.iterator] = function() {\n          return this;\n        }, i2;\n        function verb(n, f2) {\n          i2[n] = o[n] ? function(v) {\n            return (p2 = !p2) ? { value: __await3(o[n](v)), done: n === \"return\" } : f2 ? f2(v) : v;\n          } : f2;\n        }\n      };\n      __asyncValues3 = function(o) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var m = o[Symbol.asyncIterator], i2;\n        return m ? m.call(o) : (o = typeof __values3 === \"function\" ? __values3(o) : o[Symbol.iterator](), i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2);\n        function verb(n) {\n          i2[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n              v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n          };\n        }\n        function settle(resolve, reject, d2, v) {\n          Promise.resolve(v).then(function(v2) {\n            resolve({ value: v2, done: d2 });\n          }, reject);\n        }\n      };\n      __makeTemplateObject3 = function(cooked, raw) {\n        if (Object.defineProperty) {\n          Object.defineProperty(cooked, \"raw\", { value: raw });\n        } else {\n          cooked.raw = raw;\n        }\n        return cooked;\n      };\n      var __setModuleDefault = Object.create ? function(o, v) {\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n      } : function(o, v) {\n        o[\"default\"] = v;\n      };\n      __importStar3 = function(mod) {\n        if (mod && mod.__esModule)\n          return mod;\n        var result = {};\n        if (mod != null) {\n          for (var k2 in mod)\n            if (k2 !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k2))\n              __createBinding3(result, mod, k2);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n      };\n      __importDefault3 = function(mod) {\n        return mod && mod.__esModule ? mod : { \"default\": mod };\n      };\n      __classPrivateFieldGet3 = function(receiver, state, kind, f2) {\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a getter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n        return kind === \"m\" ? f2 : kind === \"a\" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);\n      };\n      __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {\n        if (kind === \"m\")\n          throw new TypeError(\"Private method is not writable\");\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a setter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n        return kind === \"a\" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;\n      };\n      __classPrivateFieldIn3 = function(state, receiver) {\n        if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\")\n          throw new TypeError(\"Cannot use 'in' operator on non-object\");\n        return typeof state === \"function\" ? receiver === state : state.has(receiver);\n      };\n      exporter(\"__extends\", __extends3);\n      exporter(\"__assign\", __assign3);\n      exporter(\"__rest\", __rest3);\n      exporter(\"__decorate\", __decorate3);\n      exporter(\"__param\", __param3);\n      exporter(\"__metadata\", __metadata3);\n      exporter(\"__awaiter\", __awaiter3);\n      exporter(\"__generator\", __generator3);\n      exporter(\"__exportStar\", __exportStar3);\n      exporter(\"__createBinding\", __createBinding3);\n      exporter(\"__values\", __values3);\n      exporter(\"__read\", __read3);\n      exporter(\"__spread\", __spread3);\n      exporter(\"__spreadArrays\", __spreadArrays3);\n      exporter(\"__spreadArray\", __spreadArray3);\n      exporter(\"__await\", __await3);\n      exporter(\"__asyncGenerator\", __asyncGenerator3);\n      exporter(\"__asyncDelegator\", __asyncDelegator3);\n      exporter(\"__asyncValues\", __asyncValues3);\n      exporter(\"__makeTemplateObject\", __makeTemplateObject3);\n      exporter(\"__importStar\", __importStar3);\n      exporter(\"__importDefault\", __importDefault3);\n      exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet3);\n      exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet3);\n      exporter(\"__classPrivateFieldIn\", __classPrivateFieldIn3);\n    });\n  }\n});\n\n// src/index.tsx\nvar src_exports = {};\n__export(src_exports, {\n  Footer: () => Footer,\n  ListPylar: () => ListPylar,\n  Menu: () => Menu,\n  MenuPylar: () => MenuPylar,\n  Scrollable: () => Scrollable,\n  TitlePylar: () => TitlePylar,\n  Version: () => Version,\n  blog: () => blog,\n  post12032022: () => post12032022\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// ../../node_modules/meshgrad/dist/index.mjs\nvar i = () => Math.round(Math.random() * 360);\nvar c = (n) => Math.round(Math.random() * (n * 100) % 100);\nvar g = (n, t, e) => Math.round(t / e * (n * 100) % 100);\nvar d = (n) => {\n  if (!!n) {\n    n = n.replace(/#/g, \"\"), n.length === 3 && (n = n.split(\"\").map(function(b2) {\n      return b2 + b2;\n    }).join(\"\"));\n    var t = /^([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})[\\da-z]{0,0}$/i.exec(n);\n    if (!!t) {\n      var e = parseInt(t[1], 16), r = parseInt(t[2], 16), a2 = parseInt(t[3], 16);\n      e /= 255, r /= 255, a2 /= 255;\n      var o = Math.max(e, r, a2), s = Math.min(e, r, a2), u = (o + s) / 2;\n      if (o == s)\n        u = 0;\n      else {\n        var m = o - s;\n        switch (o) {\n          case e:\n            u = (r - a2) / m + (r < a2 ? 6 : 0);\n            break;\n          case r:\n            u = (a2 - e) / m + 2;\n            break;\n          case a2:\n            u = (e - r) / m + 4;\n            break;\n        }\n        u /= 6;\n      }\n      return u = Math.round(360 * u), u;\n    }\n  }\n};\nvar p = (n, t) => Array.from({ length: n }, (e, r) => r === 0 ? `hsl(${t}, 100%, 80%)` : r < n / 1.4 ? `hsl(${t - 30 * (1 - 2 * (r % 2)) * (r > 2 ? r / 2 : r)}, 100%, ${76 - r * (1 - 2 * (r % 2)) * 1.75}%)` : `hsl(${t - 150 * (1 - 2 * (r % 2))}, 100%, ${76 - r * (1 - 2 * (r % 2)) * 1.25}%)`);\nvar M = (n, t, e) => Array.from({ length: n }, (r, a2) => `radial-gradient(at ${e ? g(a2, e, n) : c(a2)}% ${e ? g(a2 * 10, e, n) : c(a2 * 10)}%, ${t[a2]} 0px, transparent 50%)\n`);\nvar f = (n, t, e) => {\n  let r = p(n, t || i()), a2 = M(n, r, e || void 0);\n  return [r[0], a2.join(\",\")];\n};\nvar k = (n, t, e) => {\n  let [r, a2] = f(n, d(t) ? d(t) : void 0, e || void 0);\n  return { backgroundColor: r, backgroundImage: a2 };\n};\n\n// src/Version.tsx\nvar import_jsx_runtime = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar ELEMENTS = 8;\nvar Version = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(\"button\", {\n    className: \"m-2 hidden rounded-full py-2 px-4 text-xs font-bold text-black shadow-md hover:shadow-xl md:block\",\n    style: k(ELEMENTS),\n    children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(\"a\", {\n      href: \"http://github.com/miguelgargallo/next13-gallery-image-turbo\",\n      target: \"_blank\",\n      rel: \"noopener noreferrer\",\n      children: \"v1.0.2\"\n    })\n  });\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/index.mjs\nvar React = __toESM(__webpack_require__(/*! react */ \"react\"), 1);\nvar import_react13 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs\nvar import_react = __webpack_require__(/*! react */ \"react\");\nvar MotionConfigContext = (0, import_react.createContext)({\n  transformPagePoint: (p2) => p2,\n  isStatic: false,\n  reducedMotion: \"never\"\n});\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/index.mjs\nvar import_react2 = __webpack_require__(/*! react */ \"react\");\nvar MotionContext = (0, import_react2.createContext)({});\nfunction useVisualElementContext() {\n  return (0, import_react2.useContext)(MotionContext).visualElement;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\nvar import_react6 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/context/PresenceContext.mjs\nvar import_react3 = __webpack_require__(/*! react */ \"react\");\nvar PresenceContext = (0, import_react3.createContext)(null);\n\n// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\nvar import_react4 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/utils/is-browser.mjs\nvar isBrowser = typeof document !== \"undefined\";\n\n// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\nvar useIsomorphicLayoutEffect = isBrowser ? import_react4.useLayoutEffect : import_react4.useEffect;\n\n// ../../node_modules/framer-motion/dist/es/context/LazyContext.mjs\nvar import_react5 = __webpack_require__(/*! react */ \"react\");\nvar LazyContext = (0, import_react5.createContext)({ strict: false });\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n  const parent = useVisualElementContext();\n  const lazyContext = (0, import_react6.useContext)(LazyContext);\n  const presenceContext = (0, import_react6.useContext)(PresenceContext);\n  const reducedMotionConfig = (0, import_react6.useContext)(MotionConfigContext).reducedMotion;\n  const visualElementRef = (0, import_react6.useRef)();\n  createVisualElement = createVisualElement || lazyContext.renderer;\n  if (!visualElementRef.current && createVisualElement) {\n    visualElementRef.current = createVisualElement(Component, {\n      visualState,\n      parent,\n      props,\n      presenceId: presenceContext ? presenceContext.id : void 0,\n      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,\n      reducedMotionConfig\n    });\n  }\n  const visualElement = visualElementRef.current;\n  useIsomorphicLayoutEffect(() => {\n    visualElement && visualElement.render();\n  });\n  (0, import_react6.useEffect)(() => {\n    if (visualElement && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n  });\n  useIsomorphicLayoutEffect(() => () => visualElement && visualElement.notify(\"Unmount\"), []);\n  return visualElement;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\nvar import_react7 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/utils/is-ref-object.mjs\nfunction isRefObject(ref) {\n  return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\nfunction useMotionRef(visualState, visualElement, externalRef) {\n  return (0, import_react7.useCallback)(\n    (instance) => {\n      instance && visualState.mount && visualState.mount(instance);\n      if (visualElement) {\n        instance ? visualElement.mount(instance) : visualElement.unmount();\n      }\n      if (externalRef) {\n        if (typeof externalRef === \"function\") {\n          externalRef(instance);\n        } else if (isRefObject(externalRef)) {\n          externalRef.current = instance;\n        }\n      }\n    },\n    [visualElement]\n  );\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\nvar import_react8 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs\nfunction isVariantLabel(v) {\n  return typeof v === \"string\" || Array.isArray(v);\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs\nfunction isAnimationControls(v) {\n  return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs\nvar variantProps = [\n  \"initial\",\n  \"animate\",\n  \"exit\",\n  \"whileHover\",\n  \"whileDrag\",\n  \"whileTap\",\n  \"whileFocus\",\n  \"whileInView\"\n];\nfunction isControllingVariants(props) {\n  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));\n}\nfunction isVariantNode(props) {\n  return Boolean(isControllingVariants(props) || props.variants);\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs\nfunction getCurrentTreeVariants(props, context) {\n  if (isControllingVariants(props)) {\n    const { initial, animate: animate3 } = props;\n    return {\n      initial: initial === false || isVariantLabel(initial) ? initial : void 0,\n      animate: isVariantLabel(animate3) ? animate3 : void 0\n    };\n  }\n  return props.inherit !== false ? context : {};\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\nfunction useCreateMotionContext(props) {\n  const { initial, animate: animate3 } = getCurrentTreeVariants(props, (0, import_react8.useContext)(MotionContext));\n  return (0, import_react8.useMemo)(() => ({ initial, animate: animate3 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate3)]);\n}\nfunction variantLabelsAsDependency(prop) {\n  return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/definitions.mjs\nvar createDefinition = (propNames) => ({\n  isEnabled: (props) => propNames.some((name) => !!props[name])\n});\nvar featureDefinitions = {\n  measureLayout: createDefinition([\"layout\", \"layoutId\", \"drag\"]),\n  animation: createDefinition([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileFocus\",\n    \"whileDrag\",\n    \"whileInView\"\n  ]),\n  exit: createDefinition([\"exit\"]),\n  drag: createDefinition([\"drag\", \"dragControls\"]),\n  focus: createDefinition([\"whileFocus\"]),\n  hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n  tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n  pan: createDefinition([\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanSessionStart\",\n    \"onPanEnd\"\n  ]),\n  inView: createDefinition([\n    \"whileInView\",\n    \"onViewportEnter\",\n    \"onViewportLeave\"\n  ])\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/load-features.mjs\nfunction loadFeatures(features) {\n  for (const key in features) {\n    if (key === \"projectionNodeConstructor\") {\n      featureDefinitions.projectionNodeConstructor = features[key];\n    } else {\n      featureDefinitions[key].Component = features[key];\n    }\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/use-constant.mjs\nvar import_react9 = __webpack_require__(/*! react */ \"react\");\nfunction useConstant(init) {\n  const ref = (0, import_react9.useRef)(null);\n  if (ref.current === null) {\n    ref.current = init();\n  }\n  return ref.current;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/node/state.mjs\nvar globalProjectionState = {\n  hasAnimatedSinceResize: true,\n  hasEverUpdated: false\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/node/id.mjs\nvar id = 1;\nfunction useProjectionId() {\n  return useConstant(() => {\n    if (globalProjectionState.hasEverUpdated) {\n      return id++;\n    }\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs\nvar import_react10 = __webpack_require__(/*! react */ \"react\");\nvar LayoutGroupContext = (0, import_react10.createContext)({});\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/VisualElementHandler.mjs\nvar import_react11 = __toESM(__webpack_require__(/*! react */ \"react\"), 1);\nvar VisualElementHandler = class extends import_react11.default.Component {\n  getSnapshotBeforeUpdate() {\n    const { visualElement, props } = this.props;\n    if (visualElement)\n      visualElement.setProps(props);\n    return null;\n  }\n  componentDidUpdate() {\n  }\n  render() {\n    return this.props.children;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs\nvar import_react12 = __webpack_require__(/*! react */ \"react\");\nvar SwitchLayoutGroupContext = (0, import_react12.createContext)({});\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/symbol.mjs\nvar motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n\n// ../../node_modules/framer-motion/dist/es/motion/index.mjs\nfunction createMotionComponent({ preloadedFeatures, createVisualElement, projectionNodeConstructor, useRender, useVisualState, Component }) {\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  function MotionComponent(props, externalRef) {\n    const configAndProps = __spreadProps(__spreadValues(__spreadValues({}, (0, import_react13.useContext)(MotionConfigContext)), props), {\n      layoutId: useLayoutId(props)\n    });\n    const { isStatic } = configAndProps;\n    let features = null;\n    const context = useCreateMotionContext(props);\n    const projectionId = isStatic ? void 0 : useProjectionId();\n    const visualState = useVisualState(props, isStatic);\n    if (!isStatic && isBrowser) {\n      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);\n      const lazyStrictMode = (0, import_react13.useContext)(LazyContext).strict;\n      const initialLayoutGroupConfig = (0, import_react13.useContext)(SwitchLayoutGroupContext);\n      if (context.visualElement) {\n        features = context.visualElement.loadFeatures(\n          configAndProps,\n          lazyStrictMode,\n          preloadedFeatures,\n          projectionId,\n          projectionNodeConstructor || featureDefinitions.projectionNodeConstructor,\n          initialLayoutGroupConfig\n        );\n      }\n    }\n    return React.createElement(\n      VisualElementHandler,\n      { visualElement: context.visualElement, props: configAndProps },\n      features,\n      React.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement))\n    );\n  }\n  const ForwardRefComponent = (0, import_react13.forwardRef)(MotionComponent);\n  ForwardRefComponent[motionComponentSymbol] = Component;\n  return ForwardRefComponent;\n}\nfunction useLayoutId({ layoutId }) {\n  const layoutGroupId = (0, import_react13.useContext)(LayoutGroupContext).id;\n  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs\nfunction createMotionProxy(createConfig) {\n  function custom(Component, customMotionComponentConfig = {}) {\n    return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n  }\n  if (typeof Proxy === \"undefined\") {\n    return custom;\n  }\n  const componentCache = /* @__PURE__ */ new Map();\n  return new Proxy(custom, {\n    get: (_target, key) => {\n      if (!componentCache.has(key)) {\n        componentCache.set(key, custom(key));\n      }\n      return componentCache.get(key);\n    }\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs\nvar lowercaseSVGElements = [\n  \"animate\",\n  \"circle\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"g\",\n  \"image\",\n  \"line\",\n  \"filter\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"rect\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"tspan\",\n  \"use\",\n  \"view\"\n];\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs\nfunction isSVGComponent(Component) {\n  if (typeof Component !== \"string\" || Component.includes(\"-\")) {\n    return false;\n  } else if (lowercaseSVGElements.indexOf(Component) > -1 || /[A-Z]/.test(Component)) {\n    return true;\n  }\n  return false;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/use-render.mjs\nvar import_react16 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/render/html/use-props.mjs\nvar import_react14 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs\nvar scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n  Object.assign(scaleCorrectors, correctors);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/transform.mjs\nvar transformPropOrder = [\n  \"transformPerspective\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"translateX\",\n  \"translateY\",\n  \"translateZ\",\n  \"scale\",\n  \"scaleX\",\n  \"scaleY\",\n  \"rotate\",\n  \"rotateX\",\n  \"rotateY\",\n  \"rotateZ\",\n  \"skew\",\n  \"skewX\",\n  \"skewY\"\n];\nvar transformProps = new Set(transformPropOrder);\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n  return transformProps.has(key) || key.startsWith(\"origin\") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === \"opacity\");\n}\n\n// ../../node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs\nvar isMotionValue = (value) => !!(value === null || value === void 0 ? void 0 : value.getVelocity);\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\nvar sortTransformProps = (a2, b2) => transformPropOrder.indexOf(a2) - transformPropOrder.indexOf(b2);\nfunction buildTransform({ transform, transformKeys: transformKeys2 }, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {\n  let transformString = \"\";\n  transformKeys2.sort(sortTransformProps);\n  for (const key of transformKeys2) {\n    transformString += `${translateAlias[key] || key}(${transform[key]}) `;\n  }\n  if (enableHardwareAcceleration && !transform.z) {\n    transformString += \"translateZ(0)\";\n  }\n  transformString = transformString.trim();\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n  return transformString;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs\nfunction isCSSVariable(key) {\n  return key.startsWith(\"--\");\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs\nvar getValueAsType = (value, type) => {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n\n// ../../node_modules/style-value-types/dist/es/utils.mjs\nvar clamp = (min, max) => (v) => Math.max(Math.min(v, max), min);\nvar sanitize = (v) => v % 1 ? Number(v.toFixed(5)) : v;\nvar floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nvar colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))/gi;\nvar singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))$/i;\nfunction isString(v) {\n  return typeof v === \"string\";\n}\n\n// ../../node_modules/style-value-types/dist/es/numbers/index.mjs\nvar number = {\n  test: (v) => typeof v === \"number\",\n  parse: parseFloat,\n  transform: (v) => v\n};\nvar alpha = Object.assign(Object.assign({}, number), { transform: clamp(0, 1) });\nvar scale = Object.assign(Object.assign({}, number), { default: 1 });\n\n// ../../node_modules/style-value-types/dist/es/numbers/units.mjs\nvar createUnitType = (unit) => ({\n  test: (v) => isString(v) && v.endsWith(unit) && v.split(\" \").length === 1,\n  parse: parseFloat,\n  transform: (v) => `${v}${unit}`\n});\nvar degrees = createUnitType(\"deg\");\nvar percent = createUnitType(\"%\");\nvar px = createUnitType(\"px\");\nvar vh = createUnitType(\"vh\");\nvar vw = createUnitType(\"vw\");\nvar progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v) => percent.parse(v) / 100, transform: (v) => percent.transform(v * 100) });\n\n// ../../node_modules/style-value-types/dist/es/color/utils.mjs\nvar isColorString = (type, testProp) => (v) => {\n  return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));\n};\nvar splitColor = (aName, bName, cName) => (v) => {\n  if (!isString(v))\n    return v;\n  const [a2, b2, c3, alpha2] = v.match(floatRegex);\n  return {\n    [aName]: parseFloat(a2),\n    [bName]: parseFloat(b2),\n    [cName]: parseFloat(c3),\n    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1\n  };\n};\n\n// ../../node_modules/style-value-types/dist/es/color/hsla.mjs\nvar hsla = {\n  test: isColorString(\"hsl\", \"hue\"),\n  parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n    return \"hsla(\" + Math.round(hue) + \", \" + percent.transform(sanitize(saturation)) + \", \" + percent.transform(sanitize(lightness)) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\";\n  }\n};\n\n// ../../node_modules/style-value-types/dist/es/color/rgba.mjs\nvar clampRgbUnit = clamp(0, 255);\nvar rgbUnit = Object.assign(Object.assign({}, number), { transform: (v) => Math.round(clampRgbUnit(v)) });\nvar rgba = {\n  test: isColorString(\"rgb\", \"red\"),\n  parse: splitColor(\"red\", \"green\", \"blue\"),\n  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" + rgbUnit.transform(red) + \", \" + rgbUnit.transform(green) + \", \" + rgbUnit.transform(blue) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\"\n};\n\n// ../../node_modules/style-value-types/dist/es/color/hex.mjs\nfunction parseHex(v) {\n  let r = \"\";\n  let g2 = \"\";\n  let b2 = \"\";\n  let a2 = \"\";\n  if (v.length > 5) {\n    r = v.substr(1, 2);\n    g2 = v.substr(3, 2);\n    b2 = v.substr(5, 2);\n    a2 = v.substr(7, 2);\n  } else {\n    r = v.substr(1, 1);\n    g2 = v.substr(2, 1);\n    b2 = v.substr(3, 1);\n    a2 = v.substr(4, 1);\n    r += r;\n    g2 += g2;\n    b2 += b2;\n    a2 += a2;\n  }\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g2, 16),\n    blue: parseInt(b2, 16),\n    alpha: a2 ? parseInt(a2, 16) / 255 : 1\n  };\n}\nvar hex = {\n  test: isColorString(\"#\"),\n  parse: parseHex,\n  transform: rgba.transform\n};\n\n// ../../node_modules/style-value-types/dist/es/color/index.mjs\nvar color = {\n  test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n  parse: (v) => {\n    if (rgba.test(v)) {\n      return rgba.parse(v);\n    } else if (hsla.test(v)) {\n      return hsla.parse(v);\n    } else {\n      return hex.parse(v);\n    }\n  },\n  transform: (v) => {\n    return isString(v) ? v : v.hasOwnProperty(\"red\") ? rgba.transform(v) : hsla.transform(v);\n  }\n};\n\n// ../../node_modules/style-value-types/dist/es/complex/index.mjs\nvar colorToken = \"${c}\";\nvar numberToken = \"${n}\";\nfunction test(v) {\n  var _a, _b, _c, _d;\n  return isNaN(v) && isString(v) && ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;\n}\nfunction analyse(v) {\n  if (typeof v === \"number\")\n    v = `${v}`;\n  const values = [];\n  let numColors = 0;\n  const colors = v.match(colorRegex);\n  if (colors) {\n    numColors = colors.length;\n    v = v.replace(colorRegex, colorToken);\n    values.push(...colors.map(color.parse));\n  }\n  const numbers = v.match(floatRegex);\n  if (numbers) {\n    v = v.replace(floatRegex, numberToken);\n    values.push(...numbers.map(number.parse));\n  }\n  return { values, numColors, tokenised: v };\n}\nfunction parse(v) {\n  return analyse(v).values;\n}\nfunction createTransformer(v) {\n  const { values, numColors, tokenised } = analyse(v);\n  const numValues = values.length;\n  return (v2) => {\n    let output = tokenised;\n    for (let i2 = 0; i2 < numValues; i2++) {\n      output = output.replace(i2 < numColors ? colorToken : numberToken, i2 < numColors ? color.transform(v2[i2]) : sanitize(v2[i2]));\n    }\n    return output;\n  };\n}\nvar convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone(v) {\n  const parsed = parse(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\nvar complex = { test, parse, createTransformer, getAnimatableNone };\n\n// ../../node_modules/style-value-types/dist/es/complex/filter.mjs\nvar maxDefaults = /* @__PURE__ */ new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n  let [name, value] = v.slice(0, -1).split(\"(\");\n  if (name === \"drop-shadow\")\n    return v;\n  const [number2] = value.match(floatRegex) || [];\n  if (!number2)\n    return v;\n  const unit = value.replace(number2, \"\");\n  let defaultValue = maxDefaults.has(name) ? 1 : 0;\n  if (number2 !== value)\n    defaultValue *= 100;\n  return name + \"(\" + defaultValue + unit + \")\";\n}\nvar functionRegex = /([a-z-]*)\\(.*?\\)/g;\nvar filter = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v) => {\n  const functions = v.match(functionRegex);\n  return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n} });\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs\nvar int = __spreadProps(__spreadValues({}, number), {\n  transform: Math.round\n});\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs\nvar numberValueTypes = {\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  transformPerspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  zIndex: int,\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n  const { style, vars, transform, transformKeys: transformKeys2, transformOrigin } = state;\n  transformKeys2.length = 0;\n  let hasTransform2 = false;\n  let hasTransformOrigin = false;\n  let transformIsNone = true;\n  for (const key in latestValues) {\n    const value = latestValues[key];\n    if (isCSSVariable(key)) {\n      vars[key] = value;\n      continue;\n    }\n    const valueType = numberValueTypes[key];\n    const valueAsType = getValueAsType(value, valueType);\n    if (transformProps.has(key)) {\n      hasTransform2 = true;\n      transform[key] = valueAsType;\n      transformKeys2.push(key);\n      if (!transformIsNone)\n        continue;\n      if (value !== (valueType.default || 0))\n        transformIsNone = false;\n    } else if (key.startsWith(\"origin\")) {\n      hasTransformOrigin = true;\n      transformOrigin[key] = valueAsType;\n    } else {\n      style[key] = valueAsType;\n    }\n  }\n  if (!latestValues.transform) {\n    if (hasTransform2 || transformTemplate) {\n      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n    } else if (style.transform) {\n      style.transform = \"none\";\n    }\n  }\n  if (hasTransformOrigin) {\n    const { originX = \"50%\", originY = \"50%\", originZ = 0 } = transformOrigin;\n    style.transformOrigin = `${originX} ${originY} ${originZ}`;\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs\nvar createHtmlRenderState = () => ({\n  style: {},\n  transform: {},\n  transformKeys: [],\n  transformOrigin: {},\n  vars: {}\n});\n\n// ../../node_modules/framer-motion/dist/es/render/html/use-props.mjs\nfunction copyRawValuesOnly(target, source, props) {\n  for (const key in source) {\n    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState, isStatic) {\n  return (0, import_react14.useMemo)(() => {\n    const state = createHtmlRenderState();\n    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);\n    return Object.assign({}, state.vars, state.style);\n  }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n  const styleProp = props.style || {};\n  const style = {};\n  copyRawValuesOnly(style, styleProp, props);\n  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n  return props.transformValues ? props.transformValues(style) : style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n  const htmlProps = {};\n  const style = useStyle(props, visualState, isStatic);\n  if (props.drag && props.dragListener !== false) {\n    htmlProps.draggable = false;\n    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n    style.touchAction = props.drag === true ? \"none\" : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n  }\n  htmlProps.style = style;\n  return htmlProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs\nvar animationProps = [\n  \"animate\",\n  \"exit\",\n  \"variants\",\n  \"whileHover\",\n  \"whileTap\",\n  \"whileFocus\",\n  \"whileDrag\",\n  \"whileInView\"\n];\nvar tapProps = [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"];\nvar panProps = [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"];\nvar inViewProps = [\n  \"whileInView\",\n  \"onViewportEnter\",\n  \"onViewportLeave\",\n  \"viewport\"\n];\nvar validMotionProps = /* @__PURE__ */ new Set([\n  \"initial\",\n  \"style\",\n  \"values\",\n  \"variants\",\n  \"transition\",\n  \"transformTemplate\",\n  \"transformValues\",\n  \"custom\",\n  \"inherit\",\n  \"layout\",\n  \"layoutId\",\n  \"layoutDependency\",\n  \"onLayoutAnimationStart\",\n  \"onLayoutAnimationComplete\",\n  \"onLayoutMeasure\",\n  \"onBeforeLayoutMeasure\",\n  \"onAnimationStart\",\n  \"onAnimationComplete\",\n  \"onUpdate\",\n  \"onDragStart\",\n  \"onDrag\",\n  \"onDragEnd\",\n  \"onMeasureDragConstraints\",\n  \"onDirectionLock\",\n  \"onDragTransitionEnd\",\n  \"drag\",\n  \"dragControls\",\n  \"dragListener\",\n  \"dragConstraints\",\n  \"dragDirectionLock\",\n  \"dragSnapToOrigin\",\n  \"_dragX\",\n  \"_dragY\",\n  \"dragElastic\",\n  \"dragMomentum\",\n  \"dragPropagation\",\n  \"dragTransition\",\n  \"onHoverStart\",\n  \"onHoverEnd\",\n  \"layoutScroll\",\n  ...inViewProps,\n  ...tapProps,\n  ...animationProps,\n  ...panProps\n]);\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs\nvar shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n  if (!isValidProp)\n    return;\n  shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\ntry {\n  loadExternalIsValidProp((init_is_prop_valid_esm(), __toCommonJS(is_prop_valid_esm_exports)).default);\n} catch (_a) {\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n  const filteredProps = {};\n  for (const key in props) {\n    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props[\"draggable\"] && key.startsWith(\"onDrag\")) {\n      filteredProps[key] = props[key];\n    }\n  }\n  return filteredProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/use-props.mjs\nvar import_react15 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs\nfunction calcOrigin(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n  return `${pxOriginX} ${pxOriginY}`;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/path.mjs\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n  attrs.pathLength = 1;\n  const keys2 = useDashCase ? dashKeys : camelKeys;\n  attrs[keys2.offset] = px.transform(-offset);\n  const pathLength = px.transform(length);\n  const pathSpacing = px.transform(spacing);\n  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs\nfunction buildSVGAttrs(state, _a, options, transformTemplate) {\n  var _b = _a, {\n    attrX,\n    attrY,\n    originX,\n    originY,\n    pathLength,\n    pathSpacing = 1,\n    pathOffset = 0\n  } = _b, latest = __objRest(_b, [\n    \"attrX\",\n    \"attrY\",\n    \"originX\",\n    \"originY\",\n    \"pathLength\",\n    \"pathSpacing\",\n    \"pathOffset\"\n  ]);\n  buildHTMLStyles(state, latest, options, transformTemplate);\n  state.attrs = state.style;\n  state.style = {};\n  const { attrs, style, dimensions } = state;\n  if (attrs.transform) {\n    if (dimensions)\n      style.transform = attrs.transform;\n    delete attrs.transform;\n  }\n  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);\n  }\n  if (attrX !== void 0)\n    attrs.x = attrX;\n  if (attrY !== void 0)\n    attrs.y = attrY;\n  if (pathLength !== void 0) {\n    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs\nvar createSvgRenderState = () => __spreadProps(__spreadValues({}, createHtmlRenderState()), {\n  attrs: {}\n});\n\n// ../../node_modules/framer-motion/dist/es/render/svg/use-props.mjs\nfunction useSVGProps(props, visualState) {\n  const visualProps = (0, import_react15.useMemo)(() => {\n    const state = createSvgRenderState();\n    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);\n    return __spreadProps(__spreadValues({}, state.attrs), {\n      style: __spreadValues({}, state.style)\n    });\n  }, [visualState]);\n  if (props.style) {\n    const rawStyles = {};\n    copyRawValuesOnly(rawStyles, props.style, props);\n    visualProps.style = __spreadValues(__spreadValues({}, rawStyles), visualProps.style);\n  }\n  return visualProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/use-render.mjs\nfunction createUseRender(forwardMotionProps = false) {\n  const useRender = (Component, props, projectionId, ref, { latestValues }, isStatic) => {\n    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;\n    const visualProps = useVisualProps(props, latestValues, isStatic);\n    const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n    const elementProps = __spreadProps(__spreadValues(__spreadValues({}, filteredProps), visualProps), {\n      ref\n    });\n    if (projectionId) {\n      elementProps[\"data-projection-id\"] = projectionId;\n    }\n    return (0, import_react16.createElement)(Component, elementProps);\n  };\n  return useRender;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs\nvar camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/render.mjs\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n  for (const key in vars) {\n    element.style.setProperty(key, vars[key]);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs\nvar camelCaseAttributes = /* @__PURE__ */ new Set([\n  \"baseFrequency\",\n  \"diffuseConstant\",\n  \"kernelMatrix\",\n  \"kernelUnitLength\",\n  \"keySplines\",\n  \"keyTimes\",\n  \"limitingConeAngle\",\n  \"markerHeight\",\n  \"markerWidth\",\n  \"numOctaves\",\n  \"targetX\",\n  \"targetY\",\n  \"surfaceScale\",\n  \"specularConstant\",\n  \"specularExponent\",\n  \"stdDeviation\",\n  \"tableValues\",\n  \"viewBox\",\n  \"gradientTransform\",\n  \"pathLength\"\n]);\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/render.mjs\nfunction renderSVG(element, renderState, _styleProp, projection) {\n  renderHTML(element, renderState, void 0, projection);\n  for (const key in renderState.attrs) {\n    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs\nfunction scrapeMotionValuesFromProps(props) {\n  const { style } = props;\n  const newValues = {};\n  for (const key in style) {\n    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n      newValues[key] = style[key];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs\nfunction scrapeMotionValuesFromProps2(props) {\n  const newValues = scrapeMotionValuesFromProps(props);\n  for (const key in props) {\n    if (isMotionValue(props[key])) {\n      const targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n      newValues[targetKey] = props[key];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\nvar import_react17 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs\nfunction resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n  }\n  if (typeof definition === \"string\") {\n    definition = props.variants && props.variants[definition];\n  }\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n  }\n  return definition;\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs\nvar isKeyframesTarget = (v) => {\n  return Array.isArray(v);\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/resolve-value.mjs\nvar isCustomValue = (v) => {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = (v) => {\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n// ../../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs\nfunction resolveMotionValue(value) {\n  const unwrappedValue = isMotionValue(value) ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\nfunction makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props, context, presenceContext) {\n  const state = {\n    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),\n    renderState: createRenderState()\n  };\n  if (onMount) {\n    state.mount = (instance) => onMount(props, instance, state);\n  }\n  return state;\n}\nvar makeUseVisualState = (config) => (props, isStatic) => {\n  const context = (0, import_react17.useContext)(MotionContext);\n  const presenceContext = (0, import_react17.useContext)(PresenceContext);\n  const make = () => makeState(config, props, context, presenceContext);\n  return isStatic ? make() : useConstant(make);\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n  const values = {};\n  const motionValues = scrapeMotionValues(props);\n  for (const key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n  let { initial, animate: animate3 } = props;\n  const isControllingVariants$1 = isControllingVariants(props);\n  const isVariantNode$1 = isVariantNode(props);\n  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {\n    if (initial === void 0)\n      initial = context.initial;\n    if (animate3 === void 0)\n      animate3 = context.animate;\n  }\n  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;\n  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n  const variantToSet = isInitialAnimationBlocked ? animate3 : initial;\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n    list.forEach((definition) => {\n      const resolved = resolveVariantFromProps(props, definition);\n      if (!resolved)\n        return;\n      const _a = resolved, { transitionEnd, transition } = _a, target = __objRest(_a, [\"transitionEnd\", \"transition\"]);\n      for (const key in target) {\n        let valueTarget = target[key];\n        if (Array.isArray(valueTarget)) {\n          const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;\n          valueTarget = valueTarget[index2];\n        }\n        if (valueTarget !== null) {\n          values[key] = valueTarget;\n        }\n      }\n      for (const key in transitionEnd)\n        values[key] = transitionEnd[key];\n    });\n  }\n  return values;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/config-motion.mjs\nvar svgMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,\n    createRenderState: createSvgRenderState,\n    onMount: (props, instance, { renderState, latestValues }) => {\n      try {\n        renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n      } catch (e) {\n        renderState.dimensions = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);\n      renderSVG(instance, renderState);\n    }\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/config-motion.mjs\nvar htmlMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps,\n    createRenderState: createHtmlRenderState\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs\nfunction createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures, createVisualElement, projectionNodeConstructor) {\n  const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;\n  return __spreadProps(__spreadValues({}, baseConfig), {\n    preloadedFeatures,\n    useRender: createUseRender(forwardMotionProps),\n    createVisualElement,\n    projectionNodeConstructor,\n    Component\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/types.mjs\nvar AnimationType;\n(function(AnimationType2) {\n  AnimationType2[\"Animate\"] = \"animate\";\n  AnimationType2[\"Hover\"] = \"whileHover\";\n  AnimationType2[\"Tap\"] = \"whileTap\";\n  AnimationType2[\"Drag\"] = \"whileDrag\";\n  AnimationType2[\"Focus\"] = \"whileFocus\";\n  AnimationType2[\"InView\"] = \"whileInView\";\n  AnimationType2[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\n// ../../node_modules/framer-motion/dist/es/events/use-dom-event.mjs\nvar import_react18 = __webpack_require__(/*! react */ \"react\");\nfunction addDomEvent(target, eventName, handler, options = { passive: true }) {\n  target.addEventListener(eventName, handler, options);\n  return () => target.removeEventListener(eventName, handler);\n}\nfunction useDomEvent(ref, eventName, handler, options) {\n  (0, import_react18.useEffect)(() => {\n    const element = ref.current;\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-focus-gesture.mjs\nfunction useFocusGesture({ whileFocus, visualElement }) {\n  const { animationState } = visualElement;\n  const onFocus = () => {\n    animationState && animationState.setActive(AnimationType.Focus, true);\n  };\n  const onBlur = () => {\n    animationState && animationState.setActive(AnimationType.Focus, false);\n  };\n  useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : void 0);\n  useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : void 0);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/utils/event-type.mjs\nfunction isMouseEvent(event) {\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n  return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n  const hasTouches = !!event.touches;\n  return hasTouches;\n}\n\n// ../../node_modules/framer-motion/dist/es/events/event-info.mjs\nfunction filterPrimaryPointer(eventHandler) {\n  return (event) => {\n    const isMouseEvent2 = event instanceof MouseEvent;\n    const isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType = \"page\") {\n  const primaryTouch = e.touches[0] || e.changedTouches[0];\n  const point2 = primaryTouch || defaultPagePoint;\n  return {\n    x: point2[pointType + \"X\"],\n    y: point2[pointType + \"Y\"]\n  };\n}\nfunction pointFromMouse(point2, pointType = \"page\") {\n  return {\n    x: point2[pointType + \"X\"],\n    y: point2[pointType + \"Y\"]\n  };\n}\nfunction extractEventInfo(event, pointType = \"page\") {\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\nvar wrapHandler = (handler, shouldFilterPrimaryPointer = false) => {\n  const listener = (event) => handler(event, extractEventInfo(event));\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n\n// ../../node_modules/framer-motion/dist/es/events/utils.mjs\nvar supportsPointerEvents = () => isBrowser && window.onpointerdown === null;\nvar supportsTouchEvents = () => isBrowser && window.ontouchstart === null;\nvar supportsMouseEvents = () => isBrowser && window.onmousedown === null;\n\n// ../../node_modules/framer-motion/dist/es/events/use-pointer-event.mjs\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n  return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs\nfunction createLock(name) {\n  let lock = null;\n  return () => {\n    const openLock = () => {\n      lock = null;\n    };\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n    return false;\n  };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag2) {\n  let lock = false;\n  if (drag2 === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag2 === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    const openHorizontal = globalHorizontalLock();\n    const openVertical = globalVerticalLock();\n    if (openHorizontal && openVertical) {\n      lock = () => {\n        openHorizontal();\n        openVertical();\n      };\n    } else {\n      if (openHorizontal)\n        openHorizontal();\n      if (openVertical)\n        openVertical();\n    }\n  }\n  return lock;\n}\nfunction isDragActive() {\n  const openGestureLock = getGlobalLock(true);\n  if (!openGestureLock)\n    return true;\n  openGestureLock();\n  return false;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-hover-gesture.mjs\nfunction createHoverEvent(visualElement, isActive, callback) {\n  return (event, info) => {\n    if (!isMouseEvent(event) || isDragActive())\n      return;\n    if (visualElement.animationState) {\n      visualElement.animationState.setActive(AnimationType.Hover, isActive);\n    }\n    callback && callback(event, info);\n  };\n}\nfunction useHoverGesture({ onHoverStart, onHoverEnd, whileHover, visualElement }) {\n  usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover ? createHoverEvent(visualElement, true, onHoverStart) : void 0, { passive: !onHoverStart });\n  usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover ? createHoverEvent(visualElement, false, onHoverEnd) : void 0, { passive: !onHoverEnd });\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs\nvar import_react20 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs\nvar isNodeOrChild = (parent, child) => {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs\nvar import_react19 = __webpack_require__(/*! react */ \"react\");\nfunction useUnmountEffect(callback) {\n  return (0, import_react19.useEffect)(() => () => callback(), []);\n}\n\n// ../../node_modules/popmotion/node_modules/tslib/modules/index.js\nvar import_tslib = __toESM(require_tslib(), 1);\nvar {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __exportStar,\n  __createBinding,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn\n} = import_tslib.default;\n\n// ../../node_modules/hey-listen/dist/hey-listen.es.js\nvar warning = function() {\n};\nvar invariant = function() {\n};\nif (true) {\n  warning = function(check, message) {\n    if (!check && typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n  };\n  invariant = function(check, message) {\n    if (!check) {\n      throw new Error(message);\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/clamp.mjs\nvar clamp2 = (min, max, v) => Math.min(Math.max(v, min), max);\n\n// ../../node_modules/popmotion/dist/es/animations/utils/find-spring.mjs\nvar safeMin = 1e-3;\nvar minDuration = 0.01;\nvar maxDuration = 10;\nvar minDamping = 0.05;\nvar maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {\n  let envelope;\n  let derivative;\n  warning(duration <= maxDuration * 1e3, \"Spring duration must be 10 seconds or less\");\n  let dampingRatio = 1 - bounce;\n  dampingRatio = clamp2(minDamping, maxDamping, dampingRatio);\n  duration = clamp2(minDuration, maxDuration, duration / 1e3);\n  if (dampingRatio < 1) {\n    envelope = (undampedFreq2) => {\n      const exponentialDecay = undampedFreq2 * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const a2 = exponentialDecay - velocity;\n      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);\n      const c3 = Math.exp(-delta);\n      return safeMin - a2 / b2 * c3;\n    };\n    derivative = (undampedFreq2) => {\n      const exponentialDecay = undampedFreq2 * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const d2 = delta * velocity + velocity;\n      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;\n      const f2 = Math.exp(-delta);\n      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);\n      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;\n      return factor * ((d2 - e) * f2) / g2;\n    };\n  } else {\n    envelope = (undampedFreq2) => {\n      const a2 = Math.exp(-undampedFreq2 * duration);\n      const b2 = (undampedFreq2 - velocity) * duration + 1;\n      return -safeMin + a2 * b2;\n    };\n    derivative = (undampedFreq2) => {\n      const a2 = Math.exp(-undampedFreq2 * duration);\n      const b2 = (velocity - undampedFreq2) * (duration * duration);\n      return a2 * b2;\n    };\n  }\n  const initialGuess = 5 / duration;\n  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = duration * 1e3;\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration\n    };\n  } else {\n    const stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\nvar rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  let result = initialGuess;\n  for (let i2 = 1; i2 < rootIterations; i2++) {\n    result = result - envelope(result) / derivative(result);\n  }\n  return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\n// ../../node_modules/popmotion/dist/es/animations/generators/spring.mjs\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys2) {\n  return keys2.some((key) => options[key] !== void 0);\n}\nfunction getSpringOptions(options) {\n  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\nfunction spring(_a) {\n  var { from = 0, to = 1, restSpeed = 2, restDelta } = _a, options = __rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n  const state = { done: false, value: from };\n  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);\n  let resolveSpring = zero;\n  let resolveVelocity = zero;\n  function createSpring() {\n    const initialVelocity = velocity ? -(velocity / 1e3) : 0;\n    const initialDelta = to - from;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;\n    if (restDelta === void 0) {\n      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n    }\n    if (dampingRatio < 1) {\n      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n      resolveSpring = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n      resolveVelocity = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      resolveSpring = (t) => to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n      resolveSpring = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n  createSpring();\n  return {\n    next: (t) => {\n      const current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        const currentVelocity = resolveVelocity(t) * 1e3;\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? to : current;\n      return state;\n    },\n    flipTarget: () => {\n      velocity = -velocity;\n      [from, to] = [to, from];\n      createSpring();\n    }\n  };\n}\nspring.needsInterpolation = (a2, b2) => typeof a2 === \"string\" || typeof b2 === \"string\";\nvar zero = (_t) => 0;\n\n// ../../node_modules/popmotion/dist/es/utils/progress.mjs\nvar progress = (from, to, value) => {\n  const toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\n// ../../node_modules/popmotion/dist/es/utils/mix.mjs\nvar mix = (from, to, progress3) => -progress3 * from + progress3 * to + from;\n\n// ../../node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs\nfunction hueToRgb(p2, q, t) {\n  if (t < 0)\n    t += 1;\n  if (t > 1)\n    t -= 1;\n  if (t < 1 / 6)\n    return p2 + (q - p2) * 6 * t;\n  if (t < 1 / 2)\n    return q;\n  if (t < 2 / 3)\n    return p2 + (q - p2) * (2 / 3 - t) * 6;\n  return p2;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {\n  hue /= 360;\n  saturation /= 100;\n  lightness /= 100;\n  let red = 0;\n  let green = 0;\n  let blue = 0;\n  if (!saturation) {\n    red = green = blue = lightness;\n  } else {\n    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n    const p2 = 2 * lightness - q;\n    red = hueToRgb(p2, q, hue + 1 / 3);\n    green = hueToRgb(p2, q, hue);\n    blue = hueToRgb(p2, q, hue - 1 / 3);\n  }\n  return {\n    red: Math.round(red * 255),\n    green: Math.round(green * 255),\n    blue: Math.round(blue * 255),\n    alpha: alpha2\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/mix-color.mjs\nvar mixLinearColor = (from, to, v) => {\n  const fromExpo = from * from;\n  const toExpo = to * to;\n  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nvar colorTypes = [hex, rgba, hsla];\nvar getColorType = (v) => colorTypes.find((type) => type.test(v));\nvar notAnimatable = (color2) => `'${color2}' is not an animatable color. Use the equivalent color code instead.`;\nvar mixColor = (from, to) => {\n  let fromColorType = getColorType(from);\n  let toColorType = getColorType(to);\n  invariant(!!fromColorType, notAnimatable(from));\n  invariant(!!toColorType, notAnimatable(to));\n  let fromColor = fromColorType.parse(from);\n  let toColor = toColorType.parse(to);\n  if (fromColorType === hsla) {\n    fromColor = hslaToRgba(fromColor);\n    fromColorType = rgba;\n  }\n  if (toColorType === hsla) {\n    toColor = hslaToRgba(toColor);\n    toColorType = rgba;\n  }\n  const blended = Object.assign({}, fromColor);\n  return (v) => {\n    for (const key in blended) {\n      if (key !== \"alpha\") {\n        blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n      }\n    }\n    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n    return fromColorType.transform(blended);\n  };\n};\n\n// ../../node_modules/popmotion/dist/es/utils/inc.mjs\nvar isNum = (v) => typeof v === \"number\";\n\n// ../../node_modules/popmotion/dist/es/utils/pipe.mjs\nvar combineFunctions = (a2, b2) => (v) => b2(a2(v));\nvar pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n// ../../node_modules/popmotion/dist/es/utils/mix-complex.mjs\nfunction getMixer(origin, target) {\n  if (isNum(origin)) {\n    return (v) => mix(origin, target, v);\n  } else if (color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return mixComplex(origin, target);\n  }\n}\nvar mixArray = (from, to) => {\n  const output = [...from];\n  const numValues = output.length;\n  const blendValue = from.map((fromThis, i2) => getMixer(fromThis, to[i2]));\n  return (v) => {\n    for (let i2 = 0; i2 < numValues; i2++) {\n      output[i2] = blendValue[i2](v);\n    }\n    return output;\n  };\n};\nvar mixObject = (origin, target) => {\n  const output = Object.assign(Object.assign({}, origin), target);\n  const blendValue = {};\n  for (const key in output) {\n    if (origin[key] !== void 0 && target[key] !== void 0) {\n      blendValue[key] = getMixer(origin[key], target[key]);\n    }\n  }\n  return (v) => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n    return output;\n  };\n};\nfunction analyse2(value) {\n  const parsed = complex.parse(value);\n  const numValues = parsed.length;\n  let numNumbers = 0;\n  let numRGB = 0;\n  let numHSL = 0;\n  for (let i2 = 0; i2 < numValues; i2++) {\n    if (numNumbers || typeof parsed[i2] === \"number\") {\n      numNumbers++;\n    } else {\n      if (parsed[i2].hue !== void 0) {\n        numHSL++;\n      } else {\n        numRGB++;\n      }\n    }\n  }\n  return { parsed, numNumbers, numRGB, numHSL };\n}\nvar mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyse2(origin);\n  const targetStats = analyse2(target);\n  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n  } else {\n    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return (p2) => `${p2 > 0 ? target : origin}`;\n  }\n};\n\n// ../../node_modules/popmotion/dist/es/utils/interpolate.mjs\nvar mixNumber = (from, to) => (p2) => mix(from, to, p2);\nfunction detectMixerFactory(v) {\n  if (typeof v === \"number\") {\n    return mixNumber;\n  } else if (typeof v === \"string\") {\n    if (color.test(v)) {\n      return mixColor;\n    } else {\n      return mixComplex;\n    }\n  } else if (Array.isArray(v)) {\n    return mixArray;\n  } else if (typeof v === \"object\") {\n    return mixObject;\n  }\n}\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || detectMixerFactory(output[0]);\n  const numMixers = output.length - 1;\n  for (let i2 = 0; i2 < numMixers; i2++) {\n    let mixer = mixerFactory(output[i2], output[i2 + 1]);\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i2] : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n    mixers.push(mixer);\n  }\n  return mixers;\n}\nfunction fastInterpolate([from, to], [mixer]) {\n  return (v) => mixer(progress(from, to, v));\n}\nfunction slowInterpolate(input, mixers) {\n  const inputLength = input.length;\n  const lastInputIndex = inputLength - 1;\n  return (v) => {\n    let mixerIndex = 0;\n    let foundMixerIndex = false;\n    if (v <= input[0]) {\n      foundMixerIndex = true;\n    } else if (v >= input[lastInputIndex]) {\n      mixerIndex = lastInputIndex - 1;\n      foundMixerIndex = true;\n    }\n    if (!foundMixerIndex) {\n      let i2 = 1;\n      for (; i2 < inputLength; i2++) {\n        if (input[i2] > v || i2 === lastInputIndex) {\n          break;\n        }\n      }\n      mixerIndex = i2 - 1;\n    }\n    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n    return mixers[mixerIndex](progressInRange);\n  };\n}\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n  const inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, \"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.\");\n  if (input[0] > input[inputLength - 1]) {\n    input = [].concat(input);\n    output = [].concat(output);\n    input.reverse();\n    output.reverse();\n  }\n  const mixers = createMixers(output, ease, mixer);\n  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);\n  return isClamp ? (v) => interpolator(clamp2(input[0], input[inputLength - 1], v)) : interpolator;\n}\n\n// ../../node_modules/popmotion/dist/es/easing/utils.mjs\nvar reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);\nvar mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;\nvar createExpoIn = (power) => (p2) => Math.pow(p2, power);\nvar createBackIn = (power) => (p2) => p2 * p2 * ((power + 1) * p2 - power);\nvar createAnticipate = (power) => {\n  const backEasing = createBackIn(power);\n  return (p2) => (p2 *= 2) < 1 ? 0.5 * backEasing(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));\n};\n\n// ../../node_modules/popmotion/dist/es/easing/index.mjs\nvar DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nvar BOUNCE_FIRST_THRESHOLD = 4 / 11;\nvar BOUNCE_SECOND_THRESHOLD = 8 / 11;\nvar BOUNCE_THIRD_THRESHOLD = 9 / 10;\nvar linear = (p2) => p2;\nvar easeIn = createExpoIn(2);\nvar easeOut = reverseEasing(easeIn);\nvar easeInOut = mirrorEasing(easeIn);\nvar circIn = (p2) => 1 - Math.sin(Math.acos(p2));\nvar circOut = reverseEasing(circIn);\nvar circInOut = mirrorEasing(circOut);\nvar backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nvar backOut = reverseEasing(backIn);\nvar backInOut = mirrorEasing(backIn);\nvar anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nvar ca = 4356 / 361;\nvar cb = 35442 / 1805;\nvar cc = 16061 / 1805;\nvar bounceOut = (p2) => {\n  if (p2 === 1 || p2 === 0)\n    return p2;\n  const p22 = p2 * p2;\n  return p2 < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p22 : p2 < BOUNCE_SECOND_THRESHOLD ? 9.075 * p22 - 9.9 * p2 + 3.4 : p2 < BOUNCE_THIRD_THRESHOLD ? ca * p22 - cb * p2 + cc : 10.8 * p2 * p2 - 20.52 * p2 + 10.72;\n};\nvar bounceIn = reverseEasing(bounceOut);\nvar bounceInOut = (p2) => p2 < 0.5 ? 0.5 * (1 - bounceOut(1 - p2 * 2)) : 0.5 * bounceOut(p2 * 2 - 1) + 0.5;\n\n// ../../node_modules/popmotion/dist/es/animations/generators/keyframes.mjs\nfunction defaultEasing(values, easing) {\n  return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n  const numValues = values.length;\n  return values.map((_value, i2) => i2 !== 0 ? i2 / (numValues - 1) : 0);\n}\nfunction convertOffsetToTimes(offset, duration) {\n  return offset.map((o) => o * duration);\n}\nfunction keyframes({ from = 0, to = 1, ease, offset, duration = 300 }) {\n  const state = { done: false, value: from };\n  const values = Array.isArray(to) ? to : [from, to];\n  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);\n  function createInterpolator() {\n    return interpolate(times, values, {\n      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)\n    });\n  }\n  let interpolator = createInterpolator();\n  return {\n    next: (t) => {\n      state.value = interpolator(t);\n      state.done = t >= duration;\n      return state;\n    },\n    flipTarget: () => {\n      values.reverse();\n      interpolator = createInterpolator();\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/animations/generators/decay.mjs\nfunction decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {\n  const state = { done: false, value: from };\n  let amplitude = power * velocity;\n  const ideal = from + amplitude;\n  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);\n  if (target !== ideal)\n    amplitude = target - from;\n  return {\n    next: (t) => {\n      const delta = -amplitude * Math.exp(-t / timeConstant);\n      state.done = !(delta > restDelta || delta < -restDelta);\n      state.value = state.done ? target : target + delta;\n      return state;\n    },\n    flipTarget: () => {\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs\nvar types = { keyframes, spring, decay };\nfunction detectAnimationFromOptions(config) {\n  if (Array.isArray(config.to)) {\n    return keyframes;\n  } else if (types[config.type]) {\n    return types[config.type];\n  }\n  const keys2 = new Set(Object.keys(config));\n  if (keys2.has(\"ease\") || keys2.has(\"duration\") && !keys2.has(\"dampingRatio\")) {\n    return keyframes;\n  } else if (keys2.has(\"dampingRatio\") || keys2.has(\"stiffness\") || keys2.has(\"mass\") || keys2.has(\"damping\") || keys2.has(\"restSpeed\") || keys2.has(\"restDelta\")) {\n    return spring;\n  }\n  return keyframes;\n}\n\n// ../../node_modules/framesync/dist/es/on-next-frame.mjs\nvar defaultTimestep = 1 / 60 * 1e3;\nvar getCurrentTime = typeof performance !== \"undefined\" ? () => performance.now() : () => Date.now();\nvar onNextFrame = typeof window !== \"undefined\" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);\n\n// ../../node_modules/framesync/dist/es/create-render-step.mjs\nfunction createRenderStep(runNextFrame2) {\n  let toRun = [];\n  let toRunNextFrame = [];\n  let numToRun = 0;\n  let isProcessing2 = false;\n  let flushNextFrame = false;\n  const toKeepAlive = /* @__PURE__ */ new WeakSet();\n  const step = {\n    schedule: (callback, keepAlive = false, immediate = false) => {\n      const addToCurrentFrame = immediate && isProcessing2;\n      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n      if (keepAlive)\n        toKeepAlive.add(callback);\n      if (buffer.indexOf(callback) === -1) {\n        buffer.push(callback);\n        if (addToCurrentFrame && isProcessing2)\n          numToRun = toRun.length;\n      }\n      return callback;\n    },\n    cancel: (callback) => {\n      const index2 = toRunNextFrame.indexOf(callback);\n      if (index2 !== -1)\n        toRunNextFrame.splice(index2, 1);\n      toKeepAlive.delete(callback);\n    },\n    process: (frameData) => {\n      if (isProcessing2) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing2 = true;\n      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\n      toRunNextFrame.length = 0;\n      numToRun = toRun.length;\n      if (numToRun) {\n        for (let i2 = 0; i2 < numToRun; i2++) {\n          const callback = toRun[i2];\n          callback(frameData);\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame2();\n          }\n        }\n      }\n      isProcessing2 = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\n\n// ../../node_modules/framesync/dist/es/index.mjs\nvar maxElapsed = 40;\nvar useDefaultElapsed = true;\nvar runNextFrame = false;\nvar isProcessing = false;\nvar frame = {\n  delta: 0,\n  timestamp: 0\n};\nvar stepsOrder = [\n  \"read\",\n  \"update\",\n  \"preRender\",\n  \"render\",\n  \"postRender\"\n];\nvar steps = stepsOrder.reduce((acc, key) => {\n  acc[key] = createRenderStep(() => runNextFrame = true);\n  return acc;\n}, {});\nvar sync = stepsOrder.reduce((acc, key) => {\n  const step = steps[key];\n  acc[key] = (process2, keepAlive = false, immediate = false) => {\n    if (!runNextFrame)\n      startLoop();\n    return step.schedule(process2, keepAlive, immediate);\n  };\n  return acc;\n}, {});\nvar cancelSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = steps[key].cancel;\n  return acc;\n}, {});\nvar flushSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = () => steps[key].process(frame);\n  return acc;\n}, {});\nvar processStep = (stepId) => steps[stepId].process(frame);\nvar processFrame = (timestamp) => {\n  runNextFrame = false;\n  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\n  frame.timestamp = timestamp;\n  isProcessing = true;\n  stepsOrder.forEach(processStep);\n  isProcessing = false;\n  if (runNextFrame) {\n    useDefaultElapsed = false;\n    onNextFrame(processFrame);\n  }\n};\nvar startLoop = () => {\n  runNextFrame = true;\n  useDefaultElapsed = true;\n  if (!isProcessing)\n    onNextFrame(processFrame);\n};\nvar getFrameData = () => frame;\nvar es_default = sync;\n\n// ../../node_modules/popmotion/dist/es/animations/utils/elapsed.mjs\nfunction loopElapsed(elapsed, duration, delay2 = 0) {\n  return elapsed - duration - delay2;\n}\nfunction reverseElapsed(elapsed, duration, delay2 = 0, isForwardPlayback = true) {\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay2) : duration - (elapsed - duration) + delay2;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay2, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay2 : elapsed <= -delay2;\n}\n\n// ../../node_modules/popmotion/dist/es/animations/index.mjs\nvar framesync = (update) => {\n  const passTimestamp = ({ delta }) => update(delta);\n  return {\n    start: () => es_default.update(passTimestamp, true),\n    stop: () => cancelSync.update(passTimestamp)\n  };\n};\nfunction animate(_a) {\n  var _b, _c;\n  var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n  let { to } = options;\n  let driverControls;\n  let repeatCount = 0;\n  let computedDuration = options.duration;\n  let latest;\n  let isComplete = false;\n  let isForwardPlayback = true;\n  let interpolateFromNumber;\n  const animator = detectAnimationFromOptions(options);\n  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n    interpolateFromNumber = interpolate([0, 100], [from, to], {\n      clamp: false\n    });\n    from = 0;\n    to = 100;\n  }\n  const animation = animator(Object.assign(Object.assign({}, options), { from, to }));\n  function repeat() {\n    repeatCount++;\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\")\n        animation.flipTarget();\n    }\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n  function complete() {\n    driverControls.stop();\n    onComplete && onComplete();\n  }\n  function update(delta) {\n    if (!isForwardPlayback)\n      delta = -delta;\n    elapsed += delta;\n    if (!isComplete) {\n      const state = animation.next(Math.max(0, elapsed));\n      latest = state.value;\n      if (interpolateFromNumber)\n        latest = interpolateFromNumber(latest);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n    if (isComplete) {\n      if (repeatCount === 0)\n        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n  function play() {\n    onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n  autoplay && play();\n  return {\n    stop: () => {\n      onStop === null || onStop === void 0 ? void 0 : onStop();\n      driverControls.stop();\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/velocity-per-second.mjs\nfunction velocityPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1e3 / frameDuration) : 0;\n}\n\n// ../../node_modules/popmotion/dist/es/animations/inertia.mjs\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {\n  let currentAnimation;\n  function isOutOfBounds(v) {\n    return min !== void 0 && v < min || max !== void 0 && v > max;\n  }\n  function boundaryNearest(v) {\n    if (min === void 0)\n      return max;\n    if (max === void 0)\n      return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  }\n  function startAnimation2(options) {\n    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n    currentAnimation = animate(Object.assign(Object.assign({}, options), {\n      driver,\n      onUpdate: (v) => {\n        var _a;\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n      },\n      onComplete,\n      onStop\n    }));\n  }\n  function startSpring(options) {\n    startAnimation2(Object.assign({ type: \"spring\", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));\n  }\n  if (isOutOfBounds(from)) {\n    startSpring({ from, velocity, to: boundaryNearest(from) });\n  } else {\n    let target = power * velocity + from;\n    if (typeof modifyTarget !== \"undefined\")\n      target = modifyTarget(target);\n    const boundary = boundaryNearest(target);\n    const heading = boundary === min ? -1 : 1;\n    let prev;\n    let current;\n    const checkBoundary = (v) => {\n      prev = current;\n      current = v;\n      velocity = velocityPerSecond(v - prev, getFrameData().delta);\n      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {\n        startSpring({ from: v, to: boundary, velocity });\n      }\n    };\n    startAnimation2({\n      type: \"decay\",\n      from,\n      velocity,\n      timeConstant,\n      power,\n      restDelta,\n      modifyTarget,\n      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0\n    });\n  }\n  return {\n    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/is-point.mjs\nvar isPoint = (point2) => point2.hasOwnProperty(\"x\") && point2.hasOwnProperty(\"y\");\n\n// ../../node_modules/popmotion/dist/es/utils/is-point-3d.mjs\nvar isPoint3D = (point2) => isPoint(point2) && point2.hasOwnProperty(\"z\");\n\n// ../../node_modules/popmotion/dist/es/utils/distance.mjs\nvar distance1D = (a2, b2) => Math.abs(a2 - b2);\nfunction distance(a2, b2) {\n  if (isNum(a2) && isNum(b2)) {\n    return distance1D(a2, b2);\n  } else if (isPoint(a2) && isPoint(b2)) {\n    const xDelta = distance1D(a2.x, b2.x);\n    const yDelta = distance1D(a2.y, b2.y);\n    const zDelta = isPoint3D(a2) && isPoint3D(b2) ? distance1D(a2.z, b2.z) : 0;\n    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n  }\n}\n\n// ../../node_modules/popmotion/dist/es/easing/cubic-bezier.mjs\nvar a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\nvar b = (a1, a2) => 3 * a2 - 6 * a1;\nvar c2 = (a1) => 3 * a1;\nvar calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c2(a1)) * t;\nvar getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c2(a1);\nvar subdivisionPrecision = 1e-7;\nvar subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX;\n  let currentT;\n  let i2 = 0;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);\n  return currentT;\n}\nvar newtonIterations = 8;\nvar newtonMinSlope = 1e-3;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i2 = 0; i2 < newtonIterations; ++i2) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0) {\n      return aGuessT;\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  if (mX1 === mY1 && mX2 === mY2)\n    return linear;\n  const sampleValues = new Float32Array(kSplineTableSize);\n  for (let i2 = 0; i2 < kSplineTableSize; ++i2) {\n    sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);\n  }\n  function getTForX(aX) {\n    let intervalStart = 0;\n    let currentSample = 1;\n    const lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= newtonMinSlope) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs\nfunction useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement }) {\n  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  const isPressing = (0, import_react20.useRef)(false);\n  const cancelPointerEndListeners = (0, import_react20.useRef)(null);\n  const eventOptions = {\n    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)\n  };\n  function removePointerEndListener() {\n    cancelPointerEndListeners.current && cancelPointerEndListeners.current();\n    cancelPointerEndListeners.current = null;\n  }\n  function checkPointerEnd() {\n    removePointerEndListener();\n    isPressing.current = false;\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, false);\n    return !isDragActive();\n  }\n  function onPointerUp(event, info) {\n    if (!checkPointerEnd())\n      return;\n    !isNodeOrChild(visualElement.current, event.target) ? onTapCancel && onTapCancel(event, info) : onTap && onTap(event, info);\n  }\n  function onPointerCancel(event, info) {\n    if (!checkPointerEnd())\n      return;\n    onTapCancel && onTapCancel(event, info);\n  }\n  function onPointerDown(event, info) {\n    removePointerEndListener();\n    if (isPressing.current)\n      return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, true);\n    onTapStart && onTapStart(event, info);\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : void 0, eventOptions);\n  useUnmountEffect(removePointerEndListener);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/process.mjs\nvar defaultEnvironment = \"production\";\nvar env = typeof process === \"undefined\" || process.env === void 0 ? defaultEnvironment : \"development\" || 0;\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs\nvar import_react21 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/utils/warn-once.mjs\nvar warned = /* @__PURE__ */ new Set();\nfunction warnOnce(condition, message, element) {\n  if (condition || warned.has(message))\n    return;\n  console.warn(message);\n  if (element)\n    console.warn(element);\n  warned.add(message);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs\nvar observerCallbacks = /* @__PURE__ */ new WeakMap();\nvar observers = /* @__PURE__ */ new WeakMap();\nvar fireObserverCallback = (entry) => {\n  const callback = observerCallbacks.get(entry.target);\n  callback && callback(entry);\n};\nvar fireAllObserverCallbacks = (entries) => {\n  entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_a) {\n  var _b = _a, { root } = _b, options = __objRest(_b, [\"root\"]);\n  const lookupRoot = root || document;\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n  const rootObservers = observers.get(lookupRoot);\n  const key = JSON.stringify(options);\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __spreadValues({ root }, options));\n  }\n  return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n  const rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return () => {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs\nfunction useViewport({ visualElement, whileInView, onViewportEnter, onViewportLeave, viewport = {} }) {\n  const state = (0, import_react21.useRef)({\n    hasEnteredView: false,\n    isInView: false\n  });\n  let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n  if (viewport.once && state.current.hasEnteredView)\n    shouldObserve = false;\n  const useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n  useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nvar thresholdNames = {\n  some: 0,\n  all: 1\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, { root, margin: rootMargin, amount = \"some\", once }) {\n  (0, import_react21.useEffect)(() => {\n    if (!shouldObserve || !visualElement.current)\n      return;\n    const options = {\n      root: root === null || root === void 0 ? void 0 : root.current,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    const intersectionCallback = (entry) => {\n      const { isIntersecting } = entry;\n      if (state.isInView === isIntersecting)\n        return;\n      state.isInView = isIntersecting;\n      if (once && !isIntersecting && state.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        state.hasEnteredView = true;\n      }\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, isIntersecting);\n      }\n      const props = visualElement.getProps();\n      const callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(visualElement.current, options, intersectionCallback);\n  }, [shouldObserve, root, rootMargin, amount]);\n}\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, { fallback = true }) {\n  (0, import_react21.useEffect)(() => {\n    if (!shouldObserve || !fallback)\n      return;\n    if (env !== \"production\") {\n      warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n    }\n    requestAnimationFrame(() => {\n      state.hasEnteredView = true;\n      const { onViewportEnter } = visualElement.getProps();\n      onViewportEnter && onViewportEnter(null);\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, true);\n      }\n    });\n  }, [shouldObserve]);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/make-renderless-component.mjs\nvar makeRenderlessComponent = (hook) => (props) => {\n  hook(props);\n  return null;\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/gestures.mjs\nvar gestureAnimations = {\n  inView: makeRenderlessComponent(useViewport),\n  tap: makeRenderlessComponent(useTapGesture),\n  focus: makeRenderlessComponent(useFocusGesture),\n  hover: makeRenderlessComponent(useHoverGesture)\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/animations.mjs\nvar import_react23 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs\nvar import_react22 = __webpack_require__(/*! react */ \"react\");\nfunction usePresence() {\n  const context = (0, import_react22.useContext)(PresenceContext);\n  if (context === null)\n    return [true, null];\n  const { isPresent, onExitComplete, register } = context;\n  const id2 = (0, import_react22.useId)();\n  (0, import_react22.useEffect)(() => register(id2), []);\n  const safeToRemove = () => onExitComplete && onExitComplete(id2);\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/shallow-compare.mjs\nfunction shallowCompare(next, prev) {\n  if (!Array.isArray(prev))\n    return false;\n  const prevLength = prev.length;\n  if (prevLength !== next.length)\n    return false;\n  for (let i2 = 0; i2 < prevLength; i2++) {\n    if (prev[i2] !== next[i2])\n      return false;\n  }\n  return true;\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/time-conversion.mjs\nvar secondsToMilliseconds = (seconds) => seconds * 1e3;\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/easing.mjs\nvar easingLookup = {\n  linear,\n  easeIn,\n  easeInOut,\n  easeOut,\n  circIn,\n  circInOut,\n  circOut,\n  backIn,\n  backInOut,\n  backOut,\n  anticipate,\n  bounceIn,\n  bounceInOut,\n  bounceOut\n};\nvar easingDefinitionToFunction = (definition) => {\n  if (Array.isArray(definition)) {\n    invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n    const [x1, y1, x2, y2] = definition;\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);\n    return easingLookup[definition];\n  }\n  return definition;\n};\nvar isEasingArray = (ease) => {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs\nvar isAnimatable = (key, value) => {\n  if (key === \"zIndex\")\n    return false;\n  if (typeof value === \"number\" || Array.isArray(value))\n    return true;\n  if (typeof value === \"string\" && complex.test(value) && !value.startsWith(\"url(\")) {\n    return true;\n  }\n  return false;\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs\nvar underDampedSpring = () => ({\n  type: \"spring\",\n  stiffness: 500,\n  damping: 25,\n  restSpeed: 10\n});\nvar criticallyDampedSpring = (to) => ({\n  type: \"spring\",\n  stiffness: 550,\n  damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n  restSpeed: 10\n});\nvar linearTween = () => ({\n  type: \"keyframes\",\n  ease: \"linear\",\n  duration: 0.3\n});\nvar keyframes2 = (values) => ({\n  type: \"keyframes\",\n  duration: 0.8,\n  values\n});\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: criticallyDampedSpring,\n  scaleY: criticallyDampedSpring,\n  scale: criticallyDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: criticallyDampedSpring\n};\nvar getDefaultTransition = (valueKey, to) => {\n  let transitionFactory;\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes2;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n  return __spreadValues({ to }, transitionFactory(to));\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs\nvar defaultValueTypes = __spreadProps(__spreadValues({}, numberValueTypes), {\n  color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  filter,\n  WebkitFilter: filter\n});\nvar getDefaultValueType = (key) => defaultValueTypes[key];\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs\nfunction getAnimatableNone2(key, value) {\n  var _a;\n  let defaultValueType = getDefaultValueType(key);\n  if (defaultValueType !== filter)\n    defaultValueType = complex;\n  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs\nvar instantAnimationState = {\n  current: false\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/delay.mjs\nfunction delay(callback, timeout) {\n  const start = performance.now();\n  const checkElapsed = ({ timestamp }) => {\n    const elapsed = timestamp - start;\n    if (elapsed >= timeout) {\n      cancelSync.read(checkElapsed);\n      callback(elapsed - timeout);\n    }\n  };\n  es_default.read(checkElapsed, true);\n  return () => cancelSync.read(checkElapsed);\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/transitions.mjs\nfunction isTransitionDefined(_a) {\n  var _b = _a, { when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from } = _b, transition = __objRest(_b, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n  return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\nfunction convertTransitionToAnimationOptions(_a) {\n  var _b = _a, { ease, times, yoyo, flip, loop } = _b, transition = __objRest(_b, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n  const options = __spreadValues({}, transition);\n  if (times)\n    options[\"offset\"] = times;\n  if (transition.duration)\n    options[\"duration\"] = secondsToMilliseconds(transition.duration);\n  if (transition.repeatDelay)\n    options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n  if (ease) {\n    options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  }\n  if (transition.type === \"tween\")\n    options.type = \"keyframes\";\n  if (yoyo || loop || flip) {\n    warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n    legacyRepeatWarning = true;\n    if (yoyo) {\n      options.repeatType = \"reverse\";\n    } else if (loop) {\n      options.repeatType = \"loop\";\n    } else if (flip) {\n      options.repeatType = \"mirror\";\n    }\n    options.repeat = loop || yoyo || flip || transition.repeat;\n  }\n  if (transition.type !== \"spring\")\n    options.type = \"keyframes\";\n  return options;\n}\nfunction getDelayFromTransition(transition, key) {\n  var _a, _b;\n  const valueTransition = getValueTransition(transition, key) || {};\n  return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\nfunction hydrateKeyframes(options) {\n  if (Array.isArray(options.to) && options.to[0] === null) {\n    options.to = [...options.to];\n    options.to[0] = options.from;\n  }\n  return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n  if (Array.isArray(options.to) && transition.duration === void 0) {\n    transition.duration = 0.8;\n  }\n  hydrateKeyframes(options);\n  if (!isTransitionDefined(transition)) {\n    transition = __spreadValues(__spreadValues({}, transition), getDefaultTransition(key, options.to));\n  }\n  return __spreadValues(__spreadValues({}, options), convertTransitionToAnimationOptions(transition));\n}\nfunction getAnimation(key, value, target, transition, onComplete) {\n  const valueTransition = getValueTransition(transition, key) || {};\n  let origin = valueTransition.from !== void 0 ? valueTransition.from : value.get();\n  const isTargetAnimatable = isAnimatable(key, target);\n  if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n    origin = getAnimatableNone2(key, target);\n  } else if (isZero(origin) && typeof target === \"string\") {\n    origin = getZeroUnit(target);\n  } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n    target = getZeroUnit(origin);\n  }\n  const isOriginAnimatable = isAnimatable(key, origin);\n  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${key} from \"${origin}\" to \"${target}\". ${origin} is not an animatable value - to enable this animation set ${origin} to a value animatable to ${target} via the \\`style\\` property.`);\n  function start() {\n    const options = {\n      from: origin,\n      to: target,\n      velocity: value.getVelocity(),\n      onComplete,\n      onUpdate: (v) => value.set(v)\n    };\n    return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? inertia(__spreadValues(__spreadValues({}, options), valueTransition)) : animate(__spreadProps(__spreadValues({}, getPopmotionAnimationOptions(valueTransition, options, key)), {\n      onUpdate: (v) => {\n        options.onUpdate(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: () => {\n        options.onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      }\n    }));\n  }\n  function set() {\n    const finalTarget = resolveFinalValueInKeyframes(target);\n    value.set(finalTarget);\n    onComplete();\n    valueTransition.onUpdate && valueTransition.onUpdate(finalTarget);\n    valueTransition.onComplete && valueTransition.onComplete();\n    return { stop: () => {\n    } };\n  }\n  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\nfunction isZero(value) {\n  return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\nfunction getZeroUnit(potentialUnitType) {\n  return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone2(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\nfunction startAnimation(key, value, target, transition = {}) {\n  if (instantAnimationState.current) {\n    transition = { type: false };\n  }\n  return value.start((onComplete) => {\n    let controls;\n    const animation = getAnimation(key, value, target, transition, onComplete);\n    const delayBy = getDelayFromTransition(transition, key);\n    const start = () => controls = animation();\n    let cancelDelay;\n    if (delayBy) {\n      cancelDelay = delay(start, secondsToMilliseconds(delayBy));\n    } else {\n      start();\n    }\n    return () => {\n      cancelDelay && cancelDelay();\n      controls && controls.stop();\n    };\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs\nvar isNumericalString = (v) => /^\\-?\\d*\\.?\\d+$/.test(v);\n\n// ../../node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs\nvar isZeroValueString = (v) => /^0[^.\\s]+$/.test(v);\n\n// ../../node_modules/framer-motion/dist/es/utils/array.mjs\nfunction addUniqueItem(arr, item) {\n  if (arr.indexOf(item) === -1)\n    arr.push(item);\n}\nfunction removeItem(arr, item) {\n  const index2 = arr.indexOf(item);\n  if (index2 > -1)\n    arr.splice(index2, 1);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/subscription-manager.mjs\nvar SubscriptionManager = class {\n  constructor() {\n    this.subscriptions = [];\n  }\n  add(handler) {\n    addUniqueItem(this.subscriptions, handler);\n    return () => removeItem(this.subscriptions, handler);\n  }\n  notify(a2, b2, c3) {\n    const numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions)\n      return;\n    if (numSubscriptions === 1) {\n      this.subscriptions[0](a2, b2, c3);\n    } else {\n      for (let i2 = 0; i2 < numSubscriptions; i2++) {\n        const handler = this.subscriptions[i2];\n        handler && handler(a2, b2, c3);\n      }\n    }\n  }\n  getSize() {\n    return this.subscriptions.length;\n  }\n  clear() {\n    this.subscriptions.length = 0;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/value/index.mjs\nvar isFloat = (value) => {\n  return !isNaN(parseFloat(value));\n};\nvar MotionValue = class {\n  constructor(init) {\n    this.version = \"7.6.7\";\n    this.timeDelta = 0;\n    this.lastUpdated = 0;\n    this.updateSubscribers = new SubscriptionManager();\n    this.velocityUpdateSubscribers = new SubscriptionManager();\n    this.renderSubscribers = new SubscriptionManager();\n    this.canTrackVelocity = false;\n    this.updateAndNotify = (v, render = true) => {\n      this.prev = this.current;\n      this.current = v;\n      const { delta, timestamp } = getFrameData();\n      if (this.lastUpdated !== timestamp) {\n        this.timeDelta = delta;\n        this.lastUpdated = timestamp;\n        es_default.postRender(this.scheduleVelocityCheck);\n      }\n      if (this.prev !== this.current) {\n        this.updateSubscribers.notify(this.current);\n      }\n      if (this.velocityUpdateSubscribers.getSize()) {\n        this.velocityUpdateSubscribers.notify(this.getVelocity());\n      }\n      if (render) {\n        this.renderSubscribers.notify(this.current);\n      }\n    };\n    this.scheduleVelocityCheck = () => es_default.postRender(this.velocityCheck);\n    this.velocityCheck = ({ timestamp }) => {\n      if (timestamp !== this.lastUpdated) {\n        this.prev = this.current;\n        this.velocityUpdateSubscribers.notify(this.getVelocity());\n      }\n    };\n    this.hasAnimated = false;\n    this.prev = this.current = init;\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  onChange(subscription) {\n    return this.updateSubscribers.add(subscription);\n  }\n  clearListeners() {\n    this.updateSubscribers.clear();\n  }\n  onRenderRequest(subscription) {\n    subscription(this.get());\n    return this.renderSubscribers.add(subscription);\n  }\n  attach(passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  }\n  set(v, render = true) {\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  }\n  get() {\n    return this.current;\n  }\n  getPrevious() {\n    return this.prev;\n  }\n  getVelocity() {\n    return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  }\n  start(animation) {\n    this.stop();\n    return new Promise((resolve) => {\n      this.hasAnimated = true;\n      this.stopAnimation = animation(resolve);\n    }).then(() => this.clearAnimation());\n  }\n  stop() {\n    if (this.stopAnimation)\n      this.stopAnimation();\n    this.clearAnimation();\n  }\n  isAnimating() {\n    return !!this.stopAnimation;\n  }\n  clearAnimation() {\n    this.stopAnimation = null;\n  }\n  destroy() {\n    this.updateSubscribers.clear();\n    this.renderSubscribers.clear();\n    this.stop();\n  }\n};\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs\nvar testValueType = (v) => (type) => type.test(v);\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs\nvar auto = {\n  test: (v) => v === \"auto\",\n  parse: (v) => v\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\nvar findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs\nvar valueTypes = [...dimensionValueTypes, color, complex];\nvar findValueType = (v) => valueTypes.find(testValueType(v));\n\n// ../../node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs\nfunction getCurrent(visualElement) {\n  const current = {};\n  visualElement.values.forEach((value, key) => current[key] = value.get());\n  return current;\n}\nfunction getVelocity(visualElement) {\n  const velocity = {};\n  visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());\n  return velocity;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n  const props = visualElement.getProps();\n  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/setters.mjs\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\nfunction setTarget(visualElement, definition) {\n  const resolved = resolveVariant(visualElement, definition);\n  let _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {}, { transitionEnd = {}, transition = {} } = _a, target = __objRest(_a, [\"transitionEnd\", \"transition\"]);\n  target = __spreadValues(__spreadValues({}, target), transitionEnd);\n  for (const key in target) {\n    const value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b;\n  const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));\n  const numNewValues = newValueKeys.length;\n  if (!numNewValues)\n    return;\n  for (let i2 = 0; i2 < numNewValues; i2++) {\n    const key = newValueKeys[i2];\n    const targetValue = target[key];\n    let value = null;\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    if (value === void 0 || value === null)\n      continue;\n    if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone2(key, targetValue);\n    }\n    visualElement.addValue(key, motionValue(value));\n    if (origin[key] === void 0) {\n      origin[key] = value;\n    }\n    if (value !== null)\n      visualElement.setBaseTarget(key, value);\n  }\n}\nfunction getOriginFromTransition(key, transition) {\n  if (!transition)\n    return;\n  const valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n  var _a;\n  const origin = {};\n  for (const key in target) {\n    const transitionOrigin = getOriginFromTransition(key, transition);\n    origin[key] = transitionOrigin !== void 0 ? transitionOrigin : (_a = visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.get();\n  }\n  return origin;\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-will-change/is.mjs\nfunction isWillChangeMotionValue(value) {\n  return Boolean(isMotionValue(value) && value.add);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/animation.mjs\nfunction animateVisualElement(visualElement, definition, options = {}) {\n  visualElement.notify(\"AnimationStart\", definition);\n  let animation;\n  if (Array.isArray(definition)) {\n    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));\n    animation = Promise.all(animations2);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    const resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n  return animation.then(() => visualElement.notify(\"AnimationComplete\", definition));\n}\nfunction animateVariant(visualElement, variant, options = {}) {\n  var _a;\n  const resolved = resolveVariant(visualElement, variant, options.custom);\n  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  const getAnimation2 = resolved ? () => animateTarget(visualElement, resolved, options) : () => Promise.resolve();\n  const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? (forwardDelay = 0) => {\n    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  const { when } = transition;\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2];\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);\n  }\n}\nfunction animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {\n  var _a;\n  let _a2 = visualElement.makeTargetAnimatable(definition), { transition = visualElement.getDefaultTransition(), transitionEnd } = _a2, target = __objRest(_a2, [\"transition\", \"transitionEnd\"]);\n  const willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride)\n    transition = transitionOverride;\n  const animations2 = [];\n  const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n  for (const key in target) {\n    const value = visualElement.getValue(key);\n    const valueTarget = target[key];\n    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n    let valueTransition = __spreadValues({ delay: delay2 }, transition);\n    if (visualElement.shouldReduceMotion && transformProps.has(key)) {\n      valueTransition = __spreadProps(__spreadValues({}, valueTransition), {\n        type: false,\n        delay: 0\n      });\n    }\n    let animation = startAnimation(key, value, valueTarget, valueTransition);\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation = animation.then(() => willChange.remove(key));\n    }\n    animations2.push(animation);\n  }\n  return Promise.all(animations2).then(() => {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n  const animations2 = [];\n  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {\n    animations2.push(animateVariant(child, variant, __spreadProps(__spreadValues({}, options), {\n      delay: delayChildren + generateStaggerDuration(i2)\n    })).then(() => child.notify(\"AnimationComplete\", variant)));\n  });\n  return Promise.all(animations2);\n}\nfunction sortByTreeOrder(a2, b2) {\n  return a2.sortNodePosition(b2);\n}\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs\nvar variantPriorityOrder = [\n  AnimationType.Animate,\n  AnimationType.InView,\n  AnimationType.Focus,\n  AnimationType.Hover,\n  AnimationType.Tap,\n  AnimationType.Drag,\n  AnimationType.Exit\n];\nvar reversePriorityOrder = [...variantPriorityOrder].reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n  let animate3 = animateList(visualElement);\n  const state = createState();\n  let isInitialRender = true;\n  const buildResolvedTypeValues = (acc, definition) => {\n    const resolved = resolveVariant(visualElement, definition);\n    if (resolved) {\n      const _a = resolved, { transition, transitionEnd } = _a, target = __objRest(_a, [\"transition\", \"transitionEnd\"]);\n      acc = __spreadValues(__spreadValues(__spreadValues({}, acc), target), transitionEnd);\n    }\n    return acc;\n  };\n  function setAnimateFunction(makeAnimator) {\n    animate3 = makeAnimator(visualElement);\n  }\n  function animateChanges(options, changedActiveType) {\n    var _a;\n    const props = visualElement.getProps();\n    const context = visualElement.getVariantContext(true) || {};\n    const animations2 = [];\n    const removedKeys = /* @__PURE__ */ new Set();\n    let encounteredKeys = {};\n    let removedVariantIndex = Infinity;\n    for (let i2 = 0; i2 < numAnimationTypes; i2++) {\n      const type = reversePriorityOrder[i2];\n      const typeState = state[type];\n      const prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      const propIsVariant = isVariantLabel(prop);\n      const activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false)\n        removedVariantIndex = i2;\n      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      typeState.protectedKeys = __spreadValues({}, encounteredKeys);\n      if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop === \"boolean\") {\n        continue;\n      }\n      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n      let shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i2 > removedVariantIndex && propIsVariant;\n      const definitionList = Array.isArray(prop) ? prop : [prop];\n      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false)\n        resolvedValues = {};\n      const { prevResolvedValues = {} } = typeState;\n      const allKeys = __spreadValues(__spreadValues({}, prevResolvedValues), resolvedValues);\n      const markToAnimate = (key) => {\n        shouldAnimateType = true;\n        removedKeys.delete(key);\n        typeState.needsAnimating[key] = true;\n      };\n      for (const key in allKeys) {\n        const next = resolvedValues[key];\n        const prev = prevResolvedValues[key];\n        if (encounteredKeys.hasOwnProperty(key))\n          continue;\n        if (next !== prev) {\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev) || variantDidChange) {\n              markToAnimate(key);\n            } else {\n              typeState.protectedKeys[key] = true;\n            }\n          } else if (next !== void 0) {\n            markToAnimate(key);\n          } else {\n            removedKeys.add(key);\n          }\n        } else if (next !== void 0 && removedKeys.has(key)) {\n          markToAnimate(key);\n        } else {\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      if (typeState.isActive) {\n        encounteredKeys = __spreadValues(__spreadValues({}, encounteredKeys), resolvedValues);\n      }\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      if (shouldAnimateType && !isInherited) {\n        animations2.push(...definitionList.map((animation) => ({\n          animation,\n          options: __spreadValues({ type }, options)\n        })));\n      }\n    }\n    if (removedKeys.size) {\n      const fallbackAnimation = {};\n      removedKeys.forEach((key) => {\n        const fallbackTarget = visualElement.getBaseTarget(key);\n        if (fallbackTarget !== void 0) {\n          fallbackAnimation[key] = fallbackTarget;\n        }\n      });\n      animations2.push({ animation: fallbackAnimation });\n    }\n    let shouldAnimate = Boolean(animations2.length);\n    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n    isInitialRender = false;\n    return shouldAnimate ? animate3(animations2) : Promise.resolve();\n  }\n  function setActive(type, isActive, options) {\n    var _a;\n    if (state[type].isActive === isActive)\n      return Promise.resolve();\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\n      var _a2;\n      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    const animations2 = animateChanges(options, type);\n    for (const key in state) {\n      state[key].protectedKeys = {};\n    }\n    return animations2;\n  }\n  return {\n    animateChanges,\n    setActive,\n    setAnimateFunction,\n    getState: () => state\n  };\n}\nfunction checkVariantsDidChange(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (Array.isArray(next)) {\n    return !shallowCompare(next, prev);\n  }\n  return false;\n}\nfunction createTypeState(isActive = false) {\n  return {\n    isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction createState() {\n  return {\n    [AnimationType.Animate]: createTypeState(true),\n    [AnimationType.InView]: createTypeState(),\n    [AnimationType.Hover]: createTypeState(),\n    [AnimationType.Tap]: createTypeState(),\n    [AnimationType.Drag]: createTypeState(),\n    [AnimationType.Focus]: createTypeState(),\n    [AnimationType.Exit]: createTypeState()\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/animations.mjs\nvar animations = {\n  animation: makeRenderlessComponent(({ visualElement, animate: animate3 }) => {\n    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n    if (isAnimationControls(animate3)) {\n      (0, import_react23.useEffect)(() => animate3.subscribe(visualElement), [animate3]);\n    }\n  }),\n  exit: makeRenderlessComponent((props) => {\n    const { custom, visualElement } = props;\n    const [isPresent, safeToRemove] = usePresence();\n    const presenceContext = (0, import_react23.useContext)(PresenceContext);\n    (0, import_react23.useEffect)(() => {\n      visualElement.isPresent = isPresent;\n      const animation = visualElement.animationState && visualElement.animationState.setActive(AnimationType.Exit, !isPresent, {\n        custom: presenceContext && presenceContext.custom || custom\n      });\n      if (animation && !isPresent) {\n        animation.then(safeToRemove);\n      }\n    }, [isPresent]);\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs\nvar import_react24 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/gestures/PanSession.mjs\nvar PanSession = class {\n  constructor(event, handlers, { transformPagePoint } = {}) {\n    this.startEvent = null;\n    this.lastMoveEvent = null;\n    this.lastMoveEventInfo = null;\n    this.handlers = {};\n    this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n        return;\n      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      const isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold)\n        return;\n      const { point: point3 } = info2;\n      const { timestamp: timestamp2 } = getFrameData();\n      this.history.push(__spreadProps(__spreadValues({}, point3), { timestamp: timestamp2 }));\n      const { onStart, onMove } = this.handlers;\n      if (!isPanStarted) {\n        onStart && onStart(this.lastMoveEvent, info2);\n        this.startEvent = this.lastMoveEvent;\n      }\n      onMove && onMove(this.lastMoveEvent, info2);\n    };\n    this.handlePointerMove = (event2, info2) => {\n      this.lastMoveEvent = event2;\n      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);\n      if (isMouseEvent(event2) && event2.buttons === 0) {\n        this.handlePointerUp(event2, info2);\n        return;\n      }\n      es_default.update(this.updatePoint, true);\n    };\n    this.handlePointerUp = (event2, info2) => {\n      this.end();\n      const { onEnd, onSessionEnd } = this.handlers;\n      const panInfo = getPanInfo(transformPoint(info2, this.transformPagePoint), this.history);\n      if (this.startEvent && onEnd) {\n        onEnd(event2, panInfo);\n      }\n      onSessionEnd && onSessionEnd(event2, panInfo);\n    };\n    if (isTouchEvent(event) && event.touches.length > 1)\n      return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    const info = extractEventInfo(event);\n    const initialInfo = transformPoint(info, this.transformPagePoint);\n    const { point: point2 } = initialInfo;\n    const { timestamp } = getFrameData();\n    this.history = [__spreadProps(__spreadValues({}, point2), { timestamp })];\n    const { onSessionStart } = handlers;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n  }\n};\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a2, b2) {\n  return { x: a2.x - b2.x, y: a2.y - b2.y };\n}\nfunction getPanInfo({ point: point2 }, history) {\n  return {\n    point: point2,\n    delta: subtractPoint(point2, lastDevicePoint(history)),\n    offset: subtractPoint(point2, startDevicePoint(history)),\n    velocity: getVelocity2(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity2(history, timeDelta) {\n  if (history.length < 2) {\n    return { x: 0, y: 0 };\n  }\n  let i2 = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n  while (i2 >= 0) {\n    timestampedPoint = history[i2];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n    i2--;\n  }\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 };\n  }\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n  if (time === 0) {\n    return { x: 0, y: 0 };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\nfunction isNear(value, target = 0, maxDistance = 0.01) {\n  return distance(value, target) < maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n  delta.origin = origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))\n    delta.scale = 1;\n  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate) || isNaN(delta.translate))\n    delta.translate = 0;\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);\n  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n  calcRelativeAxis(target.x, relative.x, parent.x);\n  calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n  target.min = layout.min - parent.min;\n  target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n  calcRelativeAxisPosition(target.x, layout.x, parent.x);\n  calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs\nfunction applyConstraints(point2, { min, max }, elastic) {\n  if (min !== void 0 && point2 < min) {\n    point2 = elastic ? mix(min, point2, elastic.min) : Math.max(point2, min);\n  } else if (max !== void 0 && point2 > max) {\n    point2 = elastic ? mix(max, point2, elastic.max) : Math.min(point2, max);\n  }\n  return point2;\n}\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== void 0 ? axis.min + min : void 0,\n    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0\n  };\n}\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  let min = constraintsAxis.min - layoutAxis.min;\n  let max = constraintsAxis.max - layoutAxis.max;\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    [min, max] = [max, min];\n  }\n  return { min, max };\n}\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\nfunction calcOrigin2(source, target) {\n  let origin = 0.5;\n  const sourceLength = calcLength(source);\n  const targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n  return clamp2(0, 1, origin);\n}\nfunction rebaseAxisConstraints(layout, constraints) {\n  const relativeConstraints = {};\n  if (constraints.min !== void 0) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n  if (constraints.max !== void 0) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n  return relativeConstraints;\n}\nvar defaultElastic = 0.35;\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\nfunction resolvePointElastic(dragElastic, label) {\n  var _a;\n  return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/models.mjs\nvar createAxisDelta = () => ({\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n});\nvar createDelta = () => ({\n  x: createAxisDelta(),\n  y: createAxisDelta()\n});\nvar createAxis = () => ({ min: 0, max: 0 });\nvar createBox = () => ({\n  x: createAxis(),\n  y: createAxis()\n});\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs\nfunction eachAxis(callback) {\n  return [callback(\"x\"), callback(\"y\")];\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs\nfunction convertBoundingBoxToBox({ top, left, right, bottom }) {\n  return {\n    x: { min: left, max: right },\n    y: { min: top, max: bottom }\n  };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n  return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\nfunction transformBoxPoints(point2, transformPoint2) {\n  if (!transformPoint2)\n    return point2;\n  const topLeft = transformPoint2({ x: point2.left, y: point2.top });\n  const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs\nfunction isIdentityScale(scale2) {\n  return scale2 === void 0 || scale2 === 1;\n}\nfunction hasScale({ scale: scale2, scaleX, scaleY }) {\n  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);\n}\nfunction hasTransform(values) {\n  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;\n}\nfunction has2DTranslate(values) {\n  return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n  return value && value !== \"0%\";\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs\nfunction scalePoint(point2, scale2, originPoint) {\n  const distanceFromOrigin = point2 - originPoint;\n  const scaled = scale2 * distanceFromOrigin;\n  return originPoint + scaled;\n}\nfunction applyPointDelta(point2, translate, scale2, originPoint, boxScale) {\n  if (boxScale !== void 0) {\n    point2 = scalePoint(point2, boxScale, originPoint);\n  }\n  return scalePoint(point2, scale2, originPoint) + translate;\n}\nfunction applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {\n  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction applyBoxDelta(box, { x, y }) {\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n  var _a, _b;\n  const treeLength = treePath.length;\n  if (!treeLength)\n    return;\n  treeScale.x = treeScale.y = 1;\n  let node;\n  let delta;\n  for (let i2 = 0; i2 < treeLength; i2++) {\n    node = treePath[i2];\n    delta = node.projectionDelta;\n    if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === \"contents\")\n      continue;\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });\n    }\n    if (delta) {\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale;\n      applyBoxDelta(box, delta);\n    }\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n}\nfunction translateAxis(axis, distance2) {\n  axis.min = axis.min + distance2;\n  axis.max = axis.max + distance2;\n}\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\n  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;\n  const originPoint = mix(axis.min, axis.max, axisOrigin);\n  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform, xKeys);\n  transformAxis(box.y, transform, yKeys);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/measure.mjs\nfunction measureViewportBox(instance, transformPoint2) {\n  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));\n}\nfunction measurePageBox(element, rootProjectionNode2, transformPagePoint) {\n  const viewportBox = measureViewportBox(element, transformPagePoint);\n  const { scroll: scroll2 } = rootProjectionNode2;\n  if (scroll2) {\n    translateAxis(viewportBox.x, scroll2.x);\n    translateAxis(viewportBox.y, scroll2.y);\n  }\n  return viewportBox;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs\nvar elementDragControls = /* @__PURE__ */ new WeakMap();\nvar VisualElementDragControls = class {\n  constructor(visualElement) {\n    this.openGlobalLock = null;\n    this.isDragging = false;\n    this.currentDirection = null;\n    this.originPoint = { x: 0, y: 0 };\n    this.constraints = false;\n    this.hasMutatedConstraints = false;\n    this.elastic = createBox();\n    this.visualElement = visualElement;\n  }\n  start(originEvent, { snapToCursor = false } = {}) {\n    if (this.visualElement.isPresent === false)\n      return;\n    const onSessionStart = (event) => {\n      this.stopAnimation();\n      if (snapToCursor) {\n        this.snapToCursor(extractEventInfo(event, \"page\").point);\n      }\n    };\n    const onStart = (event, info) => {\n      var _a;\n      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();\n      if (drag2 && !dragPropagation) {\n        if (this.openGlobalLock)\n          this.openGlobalLock();\n        this.openGlobalLock = getGlobalLock(drag2);\n        if (!this.openGlobalLock)\n          return;\n      }\n      this.isDragging = true;\n      this.currentDirection = null;\n      this.resolveConstraints();\n      if (this.visualElement.projection) {\n        this.visualElement.projection.isAnimationBlocked = true;\n        this.visualElement.projection.target = void 0;\n      }\n      eachAxis((axis) => {\n        var _a2, _b;\n        let current = this.getAxisMotionValue(axis).get() || 0;\n        if (percent.test(current)) {\n          const measuredAxis = (_b = (_a2 = this.visualElement.projection) === null || _a2 === void 0 ? void 0 : _a2.layout) === null || _b === void 0 ? void 0 : _b.layoutBox[axis];\n          if (measuredAxis) {\n            const length = calcLength(measuredAxis);\n            current = length * (parseFloat(current) / 100);\n          }\n        }\n        this.originPoint[axis] = current;\n      });\n      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);\n      (_a = this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Drag, true);\n    };\n    const onMove = (event, info) => {\n      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();\n      if (!dragPropagation && !this.openGlobalLock)\n        return;\n      const { offset } = info;\n      if (dragDirectionLock && this.currentDirection === null) {\n        this.currentDirection = getCurrentDirection(offset);\n        if (this.currentDirection !== null) {\n          onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(this.currentDirection);\n        }\n        return;\n      }\n      this.updateAxis(\"x\", info.point, offset);\n      this.updateAxis(\"y\", info.point, offset);\n      this.visualElement.render();\n      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);\n    };\n    const onSessionEnd = (event, info) => this.stop(event, info);\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart,\n      onStart,\n      onMove,\n      onSessionEnd\n    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });\n  }\n  stop(event, info) {\n    const isDragging = this.isDragging;\n    this.cancel();\n    if (!isDragging)\n      return;\n    const { velocity } = info;\n    this.startAnimation(velocity);\n    const { onDragEnd } = this.getProps();\n    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n  }\n  cancel() {\n    var _a, _b;\n    this.isDragging = false;\n    if (this.visualElement.projection) {\n      this.visualElement.projection.isAnimationBlocked = false;\n    }\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = void 0;\n    const { dragPropagation } = this.getProps();\n    if (!dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n  }\n  updateAxis(axis, _point, offset) {\n    const { drag: drag2 } = this.getProps();\n    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))\n      return;\n    const axisValue = this.getAxisMotionValue(axis);\n    let next = this.originPoint[axis] + offset[axis];\n    if (this.constraints && this.constraints[axis]) {\n      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n    }\n    axisValue.set(next);\n  }\n  resolveConstraints() {\n    const { dragConstraints, dragElastic } = this.getProps();\n    const { layout } = this.visualElement.projection || {};\n    const prevConstraints = this.constraints;\n    if (dragConstraints && isRefObject(dragConstraints)) {\n      if (!this.constraints) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    } else {\n      if (dragConstraints && layout) {\n        this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n      } else {\n        this.constraints = false;\n      }\n    }\n    this.elastic = resolveDragElastic(dragElastic);\n    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {\n      eachAxis((axis) => {\n        if (this.getAxisMotionValue(axis)) {\n          this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n        }\n      });\n    }\n  }\n  resolveRefConstraints() {\n    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n    if (!constraints || !isRefObject(constraints))\n      return false;\n    const constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    const { projection } = this.visualElement;\n    if (!projection || !projection.layout)\n      return false;\n    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n    if (onMeasureDragConstraints) {\n      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n      this.hasMutatedConstraints = !!userConstraints;\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToBox(userConstraints);\n      }\n    }\n    return measuredConstraints;\n  }\n  startAnimation(velocity) {\n    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();\n    const constraints = this.constraints || {};\n    const momentumAnimations = eachAxis((axis) => {\n      var _a;\n      if (!shouldDrag(axis, drag2, this.currentDirection)) {\n        return;\n      }\n      let transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n      if (dragSnapToOrigin)\n        transition = { min: 0, max: 0 };\n      const bounceStiffness = dragElastic ? 200 : 1e6;\n      const bounceDamping = dragElastic ? 40 : 1e7;\n      const inertia2 = __spreadValues(__spreadValues({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness,\n        bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition);\n      return this.startAxisValueAnimation(axis, inertia2);\n    });\n    return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n  }\n  startAxisValueAnimation(axis, transition) {\n    const axisValue = this.getAxisMotionValue(axis);\n    return startAnimation(axis, axisValue, 0, transition);\n  }\n  stopAnimation() {\n    eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n  }\n  getAxisMotionValue(axis) {\n    var _a, _b;\n    const dragKey = \"_drag\" + axis.toUpperCase();\n    const externalMotionValue = this.visualElement.getProps()[dragKey];\n    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);\n  }\n  snapToCursor(point2) {\n    eachAxis((axis) => {\n      const { drag: drag2 } = this.getProps();\n      if (!shouldDrag(axis, drag2, this.currentDirection))\n        return;\n      const { projection } = this.visualElement;\n      const axisValue = this.getAxisMotionValue(axis);\n      if (projection && projection.layout) {\n        const { min, max } = projection.layout.layoutBox[axis];\n        axisValue.set(point2[axis] - mix(min, max, 0.5));\n      }\n    });\n  }\n  scalePositionWithinConstraints() {\n    var _a;\n    if (!this.visualElement.current)\n      return;\n    const { drag: drag2, dragConstraints } = this.getProps();\n    const { projection } = this.visualElement;\n    if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n      return;\n    this.stopAnimation();\n    const boxProgress = { x: 0, y: 0 };\n    eachAxis((axis) => {\n      const axisValue = this.getAxisMotionValue(axis);\n      if (axisValue) {\n        const latest = axisValue.get();\n        boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);\n      }\n    });\n    const { transformTemplate } = this.visualElement.getProps();\n    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n    (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n    projection.updateLayout();\n    this.resolveConstraints();\n    eachAxis((axis) => {\n      if (!shouldDrag(axis, drag2, null))\n        return;\n      const axisValue = this.getAxisMotionValue(axis);\n      const { min, max } = this.constraints[axis];\n      axisValue.set(mix(min, max, boxProgress[axis]));\n    });\n  }\n  addListeners() {\n    var _a;\n    if (!this.visualElement.current)\n      return;\n    elementDragControls.set(this.visualElement, this);\n    const element = this.visualElement.current;\n    const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\n      const { drag: drag2, dragListener = true } = this.getProps();\n      drag2 && dragListener && this.start(event);\n    });\n    const measureDragConstraints = () => {\n      const { dragConstraints } = this.getProps();\n      if (isRefObject(dragConstraints)) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    };\n    const { projection } = this.visualElement;\n    const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n    if (projection && !projection.layout) {\n      (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n      projection.updateLayout();\n    }\n    measureDragConstraints();\n    const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n    const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged }) => {\n      if (this.isDragging && hasLayoutChanged) {\n        eachAxis((axis) => {\n          const motionValue2 = this.getAxisMotionValue(axis);\n          if (!motionValue2)\n            return;\n          this.originPoint[axis] += delta[axis].translate;\n          motionValue2.set(motionValue2.get() + delta[axis].translate);\n        });\n        this.visualElement.render();\n      }\n    });\n    return () => {\n      stopResizeListener();\n      stopPointerListener();\n      stopMeasureLayoutListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n    };\n  }\n  getProps() {\n    const props = this.visualElement.getProps();\n    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;\n    return __spreadProps(__spreadValues({}, props), {\n      drag: drag2,\n      dragDirectionLock,\n      dragPropagation,\n      dragConstraints,\n      dragElastic,\n      dragMomentum\n    });\n  }\n};\nfunction shouldDrag(direction, drag2, currentDirection) {\n  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);\n}\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n  let direction = null;\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n  return direction;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs\nfunction useDrag(props) {\n  const { dragControls: groupDragControls, visualElement } = props;\n  const dragControls = useConstant(() => new VisualElementDragControls(visualElement));\n  (0, import_react24.useEffect)(() => groupDragControls && groupDragControls.subscribe(dragControls), [dragControls, groupDragControls]);\n  (0, import_react24.useEffect)(() => dragControls.addListeners(), [dragControls]);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-pan-gesture.mjs\nvar import_react25 = __webpack_require__(/*! react */ \"react\");\nfunction usePanGesture({ onPan, onPanStart, onPanEnd, onPanSessionStart, visualElement }) {\n  const hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  const panSession = (0, import_react25.useRef)(null);\n  const { transformPagePoint } = (0, import_react25.useContext)(MotionConfigContext);\n  const handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: (event, info) => {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  (0, import_react25.useEffect)(() => {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint\n    });\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(() => panSession.current && panSession.current.end());\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/drag.mjs\nvar drag = {\n  pan: makeRenderlessComponent(usePanGesture),\n  drag: makeRenderlessComponent(useDrag)\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs\nfunction isCSSVariable2(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n  const match = cssVariableRegex.exec(current);\n  if (!match)\n    return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n  const [token, fallback] = parseCSSVariable(current);\n  if (!token)\n    return;\n  const resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariable2(fallback)) {\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var target = __objRest(_a, []);\n  const element = visualElement.current;\n  if (!(element instanceof Element))\n    return { target, transitionEnd };\n  if (transitionEnd) {\n    transitionEnd = __spreadValues({}, transitionEnd);\n  }\n  visualElement.values.forEach((value) => {\n    const current = value.get();\n    if (!isCSSVariable2(current))\n      return;\n    const resolved = getVariableValue(current, element);\n    if (resolved)\n      value.set(resolved);\n  });\n  for (const key in target) {\n    const current = target[key];\n    if (!isCSSVariable2(current))\n      continue;\n    const resolved = getVariableValue(current, element);\n    if (!resolved)\n      continue;\n    target[key] = resolved;\n    if (transitionEnd && transitionEnd[key] === void 0) {\n      transitionEnd[key] = current;\n    }\n  }\n  return { target, transitionEnd };\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs\nvar positionalKeys = /* @__PURE__ */ new Set([\n  \"width\",\n  \"height\",\n  \"top\",\n  \"left\",\n  \"right\",\n  \"bottom\",\n  \"x\",\n  \"y\"\n]);\nvar isPositionalKey = (key) => positionalKeys.has(key);\nvar hasPositionalKey = (target) => {\n  return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = (value, to) => {\n  value.set(to, false);\n  value.set(to);\n};\nvar isNumOrPxType = (v) => v === number || v === px;\nvar BoundingBoxDimension;\n(function(BoundingBoxDimension2) {\n  BoundingBoxDimension2[\"width\"] = \"width\";\n  BoundingBoxDimension2[\"height\"] = \"height\";\n  BoundingBoxDimension2[\"left\"] = \"left\";\n  BoundingBoxDimension2[\"right\"] = \"right\";\n  BoundingBoxDimension2[\"top\"] = \"top\";\n  BoundingBoxDimension2[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nvar getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n  if (transform === \"none\" || !transform)\n    return 0;\n  const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n  if (matrix3d) {\n    return getPosFromMatrix(matrix3d[1], pos3);\n  } else {\n    const matrix = transform.match(/^matrix\\((.+)\\)$/);\n    if (matrix) {\n      return getPosFromMatrix(matrix[1], pos2);\n    } else {\n      return 0;\n    }\n  }\n};\nvar transformKeys = /* @__PURE__ */ new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n  const removedTransforms = [];\n  nonTranslationalTransformKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    if (value !== void 0) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  if (removedTransforms.length)\n    visualElement.render();\n  return removedTransforms;\n}\nvar positionalValues = {\n  width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n  height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n  top: (_bbox, { top }) => parseFloat(top),\n  left: (_bbox, { left }) => parseFloat(left),\n  bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n  right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\nvar convertChangedValueTypes = (target, visualElement, changedKeys) => {\n  const originBbox = visualElement.measureViewportBox();\n  const element = visualElement.current;\n  const elementComputedStyle = getComputedStyle(element);\n  const { display } = elementComputedStyle;\n  const origin = {};\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  changedKeys.forEach((key) => {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  });\n  visualElement.render();\n  const targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    setAndResetVelocity(value, origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\nvar checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\n  target = __spreadValues({}, target);\n  transitionEnd = __spreadValues({}, transitionEnd);\n  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n  let removedTransformValues = [];\n  let hasAttemptedToRemoveTransformValues = false;\n  const changedValueTypeKeys = [];\n  targetPositionalKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key))\n      return;\n    let from = origin[key];\n    let fromType = findDimensionValueType(from);\n    const to = target[key];\n    let toType;\n    if (isKeyframesTarget(to)) {\n      const numKeyframes = to.length;\n      const fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n      for (let i2 = fromIndex; i2 < numKeyframes; i2++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i2]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i2]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n    if (fromType !== toType) {\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        const current = value.get();\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n  if (changedValueTypeKeys.length) {\n    const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(([key, value]) => {\n        visualElement.getValue(key).set(value);\n      });\n    }\n    visualElement.render();\n    if (isBrowser && scrollY !== null) {\n      window.scrollTo({ top: scrollY });\n    }\n    return { target: convertedTarget, transitionEnd };\n  } else {\n    return { target, transitionEnd };\n  }\n};\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs\nvar parseDomVariant = (visualElement, target, origin, transitionEnd) => {\n  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\n// ../../node_modules/framer-motion/dist/es/render/VisualElement.mjs\nvar import_react26 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs\nvar prefersReducedMotion = { current: null };\nvar hasReducedMotionListener = { current: false };\n\n// ../../node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs\nfunction initPrefersReducedMotion() {\n  hasReducedMotionListener.current = true;\n  if (!isBrowser)\n    return;\n  if (window.matchMedia) {\n    const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;\n    motionMediaQuery.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.current = false;\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/motion-values.mjs\nfunction updateMotionValuesFromProps(element, next, prev) {\n  const { willChange } = next;\n  for (const key in next) {\n    const nextValue = next[key];\n    const prevValue = prev[key];\n    if (isMotionValue(nextValue)) {\n      element.addValue(key, nextValue);\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.add(key);\n      }\n      if (true) {\n        warnOnce(nextValue.version === \"7.6.7\", `Attempting to mix Framer Motion versions ${nextValue.version} with 7.6.7 may not work as expected.`);\n      }\n    } else if (isMotionValue(prevValue)) {\n      element.addValue(key, motionValue(nextValue));\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.remove(key);\n      }\n    } else if (prevValue !== nextValue) {\n      if (element.hasValue(key)) {\n        const existingValue = element.getValue(key);\n        !existingValue.hasAnimated && existingValue.set(nextValue);\n      } else {\n        const latestValue = element.getStaticValue(key);\n        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue));\n      }\n    }\n  }\n  for (const key in prev) {\n    if (next[key] === void 0)\n      element.removeValue(key);\n  }\n  return next;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/VisualElement.mjs\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\nvar propEventHandlers = [\n  \"AnimationStart\",\n  \"AnimationComplete\",\n  \"Update\",\n  \"Unmount\",\n  \"BeforeLayoutMeasure\",\n  \"LayoutMeasure\",\n  \"LayoutAnimationStart\",\n  \"LayoutAnimationComplete\"\n];\nvar VisualElement = class {\n  constructor({ parent, props, reducedMotionConfig, visualState }, options = {}) {\n    this.current = null;\n    this.children = /* @__PURE__ */ new Set();\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    this.shouldReduceMotion = null;\n    this.values = /* @__PURE__ */ new Map();\n    this.isPresent = true;\n    this.valueSubscriptions = /* @__PURE__ */ new Map();\n    this.prevMotionValues = {};\n    this.events = {};\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n    this.render = () => {\n      if (!this.current)\n        return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n    this.scheduleRender = () => es_default.render(this.render, false, true);\n    const { latestValues, renderState } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = __spreadValues({}, latestValues);\n    this.initialValues = props.initial ? __spreadValues({}, latestValues) : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.options = options;\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n    if (this.isVariantNode) {\n      this.variantChildren = /* @__PURE__ */ new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    const _a = this.scrapeMotionValuesFromProps(props), { willChange } = _a, initialMotionValues = __objRest(_a, [\"willChange\"]);\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n      if (latestValues[key] !== void 0 && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n        if (isWillChangeMotionValue(willChange)) {\n          willChange.add(key);\n        }\n      }\n    }\n  }\n  scrapeMotionValuesFromProps(_props) {\n    return {};\n  }\n  mount(instance) {\n    var _a;\n    this.current = instance;\n    if (this.projection) {\n      this.projection.mount(instance);\n    }\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.addVariantChild(this);\n    }\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    if (!hasReducedMotionListener.current) {\n      initPrefersReducedMotion();\n    }\n    this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? false : this.reducedMotionConfig === \"always\" ? true : prefersReducedMotion.current;\n    if (this.parent)\n      this.parent.children.add(this);\n    this.setProps(this.props);\n  }\n  unmount() {\n    var _a, _b, _c;\n    (_a = this.projection) === null || _a === void 0 ? void 0 : _a.unmount();\n    cancelSync.update(this.notifyUpdate);\n    cancelSync.render(this.render);\n    this.valueSubscriptions.forEach((remove) => remove());\n    (_b = this.removeFromVariantTree) === null || _b === void 0 ? void 0 : _b.call(this);\n    (_c = this.parent) === null || _c === void 0 ? void 0 : _c.children.delete(this);\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n    this.current = null;\n  }\n  bindToMotionValue(key, value) {\n    const removeOnChange = value.onChange((latestValue) => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && es_default.update(this.notifyUpdate, false, true);\n    });\n    const removeOnRenderRequest = value.onRenderRequest(this.scheduleRender);\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      removeOnRenderRequest();\n    });\n  }\n  sortNodePosition(other) {\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type)\n      return 0;\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n  loadFeatures(renderedProps, isStrict, preloadedFeatures, projectionId, ProjectionNodeConstructor, initialLayoutGroupConfig) {\n    const features = [];\n    if (env !== \"production\" && preloadedFeatures && isStrict) {\n      invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n    }\n    for (let i2 = 0; i2 < numFeatures; i2++) {\n      const name = featureNames[i2];\n      const { isEnabled, Component } = featureDefinitions[name];\n      if (isEnabled(renderedProps) && Component) {\n        features.push((0, import_react26.createElement)(Component, __spreadProps(__spreadValues({\n          key: name\n        }, renderedProps), {\n          visualElement: this\n        })));\n      }\n    }\n    if (!this.projection && ProjectionNodeConstructor) {\n      this.projection = new ProjectionNodeConstructor(projectionId, this.latestValues, this.parent && this.parent.projection);\n      const { layoutId, layout, drag: drag2, dragConstraints, layoutScroll } = renderedProps;\n      this.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),\n        visualElement: this,\n        scheduleRender: () => this.scheduleRender(),\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig: initialLayoutGroupConfig,\n        layoutScroll\n      });\n    }\n    return features;\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.options, this.props);\n  }\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  makeTargetAnimatable(target, canMutate = true) {\n    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);\n  }\n  setProps(props) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n    this.props = props;\n    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {\n      const key = propEventHandlers[i2];\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n      const listener = props[\"on\" + key];\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props), this.prevMotionValues);\n  }\n  getProps() {\n    return this.props;\n  }\n  getVariant(name) {\n    var _a;\n    return (_a = this.props.variants) === null || _a === void 0 ? void 0 : _a[name];\n  }\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    var _a;\n    return this.isVariantNode ? this : (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getClosestVariantNode();\n  }\n  getVariantContext(startAtParent = false) {\n    var _a, _b;\n    if (startAtParent)\n      return (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getVariantContext();\n    if (!this.isControllingVariants) {\n      const context2 = ((_b = this.parent) === null || _b === void 0 ? void 0 : _b.getVariantContext()) || {};\n      if (this.props.initial !== void 0) {\n        context2.initial = this.props.initial;\n      }\n      return context2;\n    }\n    const context = {};\n    for (let i2 = 0; i2 < numVariantProps; i2++) {\n      const name = variantProps2[i2];\n      const prop = this.props[name];\n      if (isVariantLabel(prop) || prop === false) {\n        context[name] = prop;\n      }\n    }\n    return context;\n  }\n  addVariantChild(child) {\n    var _a;\n    const closestVariantNode = this.getClosestVariantNode();\n    if (closestVariantNode) {\n      (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  addValue(key, value) {\n    if (this.hasValue(key))\n      this.removeValue(key);\n    this.values.set(key, value);\n    this.latestValues[key] = value.get();\n    this.bindToMotionValue(key, value);\n  }\n  removeValue(key) {\n    var _a;\n    this.values.delete(key);\n    (_a = this.valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n    this.valueSubscriptions.delete(key);\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  hasValue(key) {\n    return this.values.has(key);\n  }\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n    let value = this.values.get(key);\n    if (value === void 0 && defaultValue !== void 0) {\n      value = motionValue(defaultValue);\n      this.addValue(key, value);\n    }\n    return value;\n  }\n  readValue(key) {\n    return this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.readValueFromInstance(this.current, key, this.options);\n  }\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  getBaseTarget(key) {\n    var _a;\n    const { initial } = this.props;\n    const valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : void 0;\n    if (initial && valueFromInitial !== void 0) {\n      return valueFromInitial;\n    }\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== void 0 && !isMotionValue(target))\n      return target;\n    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    return this.events[eventName].add(callback);\n  }\n  notify(eventName, ...args) {\n    var _a;\n    (_a = this.events[eventName]) === null || _a === void 0 ? void 0 : _a.notify(...args);\n  }\n};\nvar variantProps2 = [\"initial\", ...variantPriorityOrder];\nvar numVariantProps = variantProps2.length;\n\n// ../../node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs\nvar DOMVisualElement = class extends VisualElement {\n  sortInstanceNodePosition(a2, b2) {\n    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;\n  }\n  getBaseTargetFromProps(props, key) {\n    var _a;\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  }\n  removeValueFromRenderState(key, { vars, style }) {\n    delete vars[key];\n    delete style[key];\n  }\n  makeTargetAnimatableFromInstance(_a, { transformValues }, isMounted) {\n    var _b = _a, { transition, transitionEnd } = _b, target = __objRest(_b, [\"transition\", \"transitionEnd\"]);\n    let origin = getOrigin(target, transition || {}, this);\n    if (transformValues) {\n      if (transitionEnd)\n        transitionEnd = transformValues(transitionEnd);\n      if (target)\n        target = transformValues(target);\n      if (origin)\n        origin = transformValues(origin);\n    }\n    if (isMounted) {\n      checkTargetForNewValues(this, target, origin);\n      const parsed = parseDomVariant(this, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n    return __spreadValues({\n      transition,\n      transitionEnd\n    }, target);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs\nfunction getComputedStyle2(element) {\n  return window.getComputedStyle(element);\n}\nvar HTMLVisualElement = class extends DOMVisualElement {\n  readValueFromInstance(instance, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle2(instance);\n      const value = (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  }\n  measureInstanceViewportBox(instance, { transformPagePoint }) {\n    return measureViewportBox(instance, transformPagePoint);\n  }\n  build(renderState, latestValues, options, props) {\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  }\n  scrapeMotionValuesFromProps(props) {\n    return scrapeMotionValuesFromProps(props);\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderHTML(instance, renderState, styleProp, projection);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs\nvar SVGVisualElement = class extends DOMVisualElement {\n  getBaseTargetFromProps(props, key) {\n    return props[key];\n  }\n  readValueFromInstance(instance, key) {\n    var _a;\n    if (transformProps.has(key)) {\n      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n    }\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return instance.getAttribute(key);\n  }\n  measureInstanceViewportBox() {\n    return createBox();\n  }\n  scrapeMotionValuesFromProps(props) {\n    return scrapeMotionValuesFromProps2(props);\n  }\n  build(renderState, latestValues, options, props) {\n    buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderSVG(instance, renderState, styleProp, projection);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs\nvar createDomVisualElement = (Component, options) => {\n  return isSVGComponent(Component) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\nvar import_react27 = __toESM(__webpack_require__(/*! react */ \"react\"), 1);\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs\nfunction pixelsToPercent(pixels, axis) {\n  if (axis.max === axis.min)\n    return 0;\n  return pixels / (axis.max - axis.min) * 100;\n}\nvar correctBorderRadius = {\n  correct: (latest, node) => {\n    if (!node.target)\n      return latest;\n    if (typeof latest === \"string\") {\n      if (px.test(latest)) {\n        latest = parseFloat(latest);\n      } else {\n        return latest;\n      }\n    }\n    const x = pixelsToPercent(latest, node.target.x);\n    const y = pixelsToPercent(latest, node.target.y);\n    return `${x}% ${y}%`;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs\nvar varToken = \"_$css\";\nvar correctBoxShadow = {\n  correct: (latest, { treeScale, projectionDelta }) => {\n    const original = latest;\n    const containsCSSVariables = latest.includes(\"var(\");\n    const cssVariables = [];\n    if (containsCSSVariables) {\n      latest = latest.replace(cssVariableRegex, (match) => {\n        cssVariables.push(match);\n        return varToken;\n      });\n    }\n    const shadow = complex.parse(latest);\n    if (shadow.length > 5)\n      return original;\n    const template = complex.createTransformer(latest);\n    const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    const xScale = projectionDelta.x.scale * treeScale.x;\n    const yScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    const averageScale = mix(xScale, yScale, 0.5);\n    if (typeof shadow[2 + offset] === \"number\")\n      shadow[2 + offset] /= averageScale;\n    if (typeof shadow[3 + offset] === \"number\")\n      shadow[3 + offset] /= averageScale;\n    let output = template(shadow);\n    if (containsCSSVariables) {\n      let i2 = 0;\n      output = output.replace(varToken, () => {\n        const cssVariable = cssVariables[i2];\n        i2++;\n        return cssVariable;\n      });\n    }\n    return output;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\nvar MeasureLayoutWithContext = class extends import_react27.default.Component {\n  componentDidMount() {\n    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n    const { projection } = visualElement;\n    addScaleCorrector(defaultScaleCorrectors);\n    if (projection) {\n      if (layoutGroup.group)\n        layoutGroup.group.add(projection);\n      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n      projection.root.didUpdate();\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions(__spreadProps(__spreadValues({}, projection.options), {\n        onExitComplete: () => this.safeToRemove()\n      }));\n    }\n    globalProjectionState.hasEverUpdated = true;\n  }\n  getSnapshotBeforeUpdate(prevProps) {\n    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;\n    const projection = visualElement.projection;\n    if (!projection)\n      return null;\n    projection.isPresent = isPresent;\n    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        es_default.postRender(() => {\n          var _a;\n          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n    return null;\n  }\n  componentDidUpdate() {\n    const { projection } = this.props.visualElement;\n    if (projection) {\n      projection.root.didUpdate();\n      if (!projection.currentAnimation && projection.isLead()) {\n        this.safeToRemove();\n      }\n    }\n  }\n  componentWillUnmount() {\n    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;\n    const { projection } = visualElement;\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\n        layoutGroup.group.remove(projection);\n      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)\n        promoteContext.deregister(projection);\n    }\n  }\n  safeToRemove() {\n    const { safeToRemove } = this.props;\n    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n  }\n  render() {\n    return null;\n  }\n};\nfunction MeasureLayout(props) {\n  const [isPresent, safeToRemove] = usePresence();\n  const layoutGroup = (0, import_react27.useContext)(LayoutGroupContext);\n  return import_react27.default.createElement(MeasureLayoutWithContext, __spreadProps(__spreadValues({}, props), { layoutGroup, switchLayoutGroup: (0, import_react27.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove }));\n}\nvar defaultScaleCorrectors = {\n  borderRadius: __spreadProps(__spreadValues({}, correctBorderRadius), {\n    applyTo: [\n      \"borderTopLeftRadius\",\n      \"borderTopRightRadius\",\n      \"borderBottomLeftRadius\",\n      \"borderBottomRightRadius\"\n    ]\n  }),\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/index.mjs\nvar layoutFeatures = {\n  measureLayout: MeasureLayout\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/animate.mjs\nfunction animate2(from, to, transition = {}) {\n  const value = isMotionValue(from) ? from : motionValue(from);\n  startAnimation(\"\", value, to, transition);\n  return {\n    stop: () => value.stop(),\n    isAnimating: () => value.isAnimating()\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nvar asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nvar isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress3, shouldCrossfadeOpacity, isOnlyMember) {\n  var _a, _b, _c, _d;\n  if (shouldCrossfadeOpacity) {\n    target.opacity = mix(\n      0,\n      (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1,\n      easeCrossfadeIn(progress3)\n    );\n    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress3));\n  } else if (isOnlyMember) {\n    target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress3);\n  }\n  for (let i2 = 0; i2 < numBorders; i2++) {\n    const borderLabel = `border${borders[i2]}Radius`;\n    let followRadius = getRadius(follow, borderLabel);\n    let leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === void 0 && leadRadius === void 0)\n      continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n    if (canMix) {\n      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress3), 0);\n      if (percent.test(leadRadius) || percent.test(followRadius)) {\n        target[borderLabel] += \"%\";\n      }\n    } else {\n      target[borderLabel] = leadRadius;\n    }\n  }\n  if (follow.rotate || lead.rotate) {\n    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress3);\n  }\n}\nfunction getRadius(values, radiusName) {\n  var _a;\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n  return (p2) => {\n    if (p2 < min)\n      return 0;\n    if (p2 > max)\n      return 1;\n    return easing(progress(min, max, p2));\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/copy.mjs\nfunction copyAxisInto(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\nfunction copyBoxInto(box, originBox) {\n  copyAxisInto(box.x, originBox.x);\n  copyAxisInto(box.y, originBox.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs\nfunction removePointDelta(point2, translate, scale2, originPoint, boxScale) {\n  point2 -= translate;\n  point2 = scalePoint(point2, 1 / scale2, originPoint);\n  if (boxScale !== void 0) {\n    point2 = scalePoint(point2, 1 / boxScale, originPoint);\n  }\n  return point2;\n}\nfunction removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n  if (percent.test(translate)) {\n    translate = parseFloat(translate);\n    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);\n    translate = relativeProgress - sourceAxis.min;\n  }\n  if (typeof translate !== \"number\")\n    return;\n  let originPoint = mix(originAxis.min, originAxis.max, origin);\n  if (axis === originAxis)\n    originPoint -= translate;\n  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\nvar xKeys2 = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys2 = [\"y\", \"scaleY\", \"originY\"];\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n  removeAxisTransforms(box.x, transforms, xKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);\n  removeAxisTransforms(box.y, transforms, yKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/utils.mjs\nfunction isAxisDeltaZero(delta) {\n  return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction boxEquals(a2, b2) {\n  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;\n}\nfunction aspectRatio(box) {\n  return calcLength(box.x) / calcLength(box.y);\n}\nfunction isCloseTo(a2, b2, max = 0.1) {\n  return distance(a2, b2) <= max;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/shared/stack.mjs\nvar NodeStack = class {\n  constructor() {\n    this.members = [];\n  }\n  add(node) {\n    addUniqueItem(this.members, node);\n    node.scheduleRender();\n  }\n  remove(node) {\n    removeItem(this.members, node);\n    if (node === this.prevLead) {\n      this.prevLead = void 0;\n    }\n    if (node === this.lead) {\n      const prevLead = this.members[this.members.length - 1];\n      if (prevLead) {\n        this.promote(prevLead);\n      }\n    }\n  }\n  relegate(node) {\n    const indexOfNode = this.members.findIndex((member) => node === member);\n    if (indexOfNode === 0)\n      return false;\n    let prevLead;\n    for (let i2 = indexOfNode; i2 >= 0; i2--) {\n      const member = this.members[i2];\n      if (member.isPresent !== false) {\n        prevLead = member;\n        break;\n      }\n    }\n    if (prevLead) {\n      this.promote(prevLead);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  promote(node, preserveFollowOpacity) {\n    var _a;\n    const prevLead = this.lead;\n    if (node === prevLead)\n      return;\n    this.prevLead = prevLead;\n    this.lead = node;\n    node.show();\n    if (prevLead) {\n      prevLead.instance && prevLead.scheduleRender();\n      node.scheduleRender();\n      node.resumeFrom = prevLead;\n      if (preserveFollowOpacity) {\n        node.resumeFrom.preserveOpacity = true;\n      }\n      if (prevLead.snapshot) {\n        node.snapshot = prevLead.snapshot;\n        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;\n        node.snapshot.isShared = true;\n      }\n      if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {\n        node.isLayoutDirty = true;\n      }\n      const { crossfade } = node.options;\n      if (crossfade === false) {\n        prevLead.hide();\n      }\n    }\n  }\n  exitAnimationComplete() {\n    this.members.forEach((node) => {\n      var _a, _b, _c, _d, _e;\n      (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n      (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);\n    });\n  }\n  scheduleRender() {\n    this.members.forEach((node) => {\n      node.instance && node.scheduleRender(false);\n    });\n  }\n  removeLeadSnapshot() {\n    if (this.lead && this.lead.snapshot) {\n      this.lead.snapshot = void 0;\n    }\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/transform.mjs\nvar identityProjection = \"translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)\";\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n  const xTranslate = delta.x.translate / treeScale.x;\n  const yTranslate = delta.y.translate / treeScale.y;\n  let transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;\n  transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n  if (latestTransform) {\n    const { rotate, rotateX, rotateY } = latestTransform;\n    if (rotate)\n      transform += `rotate(${rotate}deg) `;\n    if (rotateX)\n      transform += `rotateX(${rotateX}deg) `;\n    if (rotateY)\n      transform += `rotateY(${rotateY}deg) `;\n  }\n  const elementScaleX = delta.x.scale * treeScale.x;\n  const elementScaleY = delta.y.scale * treeScale.y;\n  transform += `scale(${elementScaleX}, ${elementScaleY})`;\n  return transform === identityProjection ? \"none\" : transform;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs\nvar compareByDepth = (a2, b2) => a2.depth - b2.depth;\n\n// ../../node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs\nvar FlatTree = class {\n  constructor() {\n    this.children = [];\n    this.isDirty = false;\n  }\n  add(child) {\n    addUniqueItem(this.children, child);\n    this.isDirty = true;\n  }\n  remove(child) {\n    removeItem(this.children, child);\n    this.isDirty = true;\n  }\n  forEach(callback) {\n    this.isDirty && this.children.sort(compareByDepth);\n    this.isDirty = false;\n    this.children.forEach(callback);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\nvar animationTarget = 1e3;\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {\n  return class ProjectionNode {\n    constructor(elementId, latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\n      this.children = /* @__PURE__ */ new Set();\n      this.options = {};\n      this.isTreeAnimating = false;\n      this.isAnimationBlocked = false;\n      this.isLayoutDirty = false;\n      this.updateManuallyBlocked = false;\n      this.updateBlockedByResize = false;\n      this.isUpdating = false;\n      this.isSVG = false;\n      this.needsReset = false;\n      this.shouldResetTransform = false;\n      this.treeScale = { x: 1, y: 1 };\n      this.eventHandlers = /* @__PURE__ */ new Map();\n      this.potentialNodes = /* @__PURE__ */ new Map();\n      this.checkUpdateFailed = () => {\n        if (this.isUpdating) {\n          this.isUpdating = false;\n          this.clearAllSnapshots();\n        }\n      };\n      this.updateProjection = () => {\n        this.nodes.forEach(resolveTargetDelta);\n        this.nodes.forEach(calcProjection);\n      };\n      this.hasProjected = false;\n      this.isVisible = true;\n      this.animationProgress = 0;\n      this.sharedNodes = /* @__PURE__ */ new Map();\n      this.elementId = elementId;\n      this.latestValues = latestValues;\n      this.root = parent ? parent.root || parent : this;\n      this.path = parent ? [...parent.path, parent] : [];\n      this.parent = parent;\n      this.depth = parent ? parent.depth + 1 : 0;\n      elementId && this.root.registerPotentialNode(elementId, this);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        this.path[i2].shouldResetTransform = true;\n      }\n      if (this.root === this)\n        this.nodes = new FlatTree();\n    }\n    addEventListener(name, handler) {\n      if (!this.eventHandlers.has(name)) {\n        this.eventHandlers.set(name, new SubscriptionManager());\n      }\n      return this.eventHandlers.get(name).add(handler);\n    }\n    notifyListeners(name, ...args) {\n      const subscriptionManager = this.eventHandlers.get(name);\n      subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify(...args);\n    }\n    hasListeners(name) {\n      return this.eventHandlers.has(name);\n    }\n    registerPotentialNode(id2, node) {\n      this.potentialNodes.set(id2, node);\n    }\n    mount(instance, isLayoutDirty = false) {\n      var _a;\n      if (this.instance)\n        return;\n      this.isSVG = instance instanceof SVGElement && instance.tagName !== \"svg\";\n      this.instance = instance;\n      const { layoutId, layout, visualElement } = this.options;\n      if (visualElement && !visualElement.current) {\n        visualElement.mount(instance);\n      }\n      this.root.nodes.add(this);\n      (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);\n      this.elementId && this.root.potentialNodes.delete(this.elementId);\n      if (isLayoutDirty && (layout || layoutId)) {\n        this.isLayoutDirty = true;\n      }\n      if (attachResizeListener) {\n        let cancelDelay;\n        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;\n        attachResizeListener(instance, () => {\n          this.root.updateBlockedByResize = true;\n          cancelDelay && cancelDelay();\n          cancelDelay = delay(resizeUnblockUpdate, 250);\n          if (globalProjectionState.hasAnimatedSinceResize) {\n            globalProjectionState.hasAnimatedSinceResize = false;\n            this.nodes.forEach(finishAnimation);\n          }\n        });\n      }\n      if (layoutId) {\n        this.root.registerSharedNode(layoutId, this);\n      }\n      if (this.options.animate !== false && visualElement && (layoutId || layout)) {\n        this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {\n          var _a2, _b, _c, _d, _e;\n          if (this.isTreeAnimationBlocked()) {\n            this.target = void 0;\n            this.relativeTarget = void 0;\n            return;\n          }\n          const layoutTransition = (_b = (_a2 = this.options.transition) !== null && _a2 !== void 0 ? _a2 : visualElement.getDefaultTransition()) !== null && _b !== void 0 ? _b : defaultLayoutTransition;\n          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();\n          const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;\n          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n          if (((_c = this.resumeFrom) === null || _c === void 0 ? void 0 : _c.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {\n            if (this.resumeFrom) {\n              this.resumingFrom = this.resumeFrom;\n              this.resumingFrom.resumingFrom = void 0;\n            }\n            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n            const animationOptions = __spreadProps(__spreadValues({}, getValueTransition(layoutTransition, \"layout\")), {\n              onPlay: onLayoutAnimationStart,\n              onComplete: onLayoutAnimationComplete\n            });\n            if (visualElement.shouldReduceMotion) {\n              animationOptions.delay = 0;\n              animationOptions.type = false;\n            }\n            this.startAnimation(animationOptions);\n          } else {\n            if (!hasLayoutChanged && this.animationProgress === 0) {\n              finishAnimation(this);\n            }\n            this.isLead() && ((_e = (_d = this.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d));\n          }\n          this.targetLayout = newLayout;\n        });\n      }\n    }\n    unmount() {\n      var _a, _b;\n      this.options.layoutId && this.willUpdate();\n      this.root.nodes.remove(this);\n      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);\n      (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);\n      this.instance = void 0;\n      cancelSync.preRender(this.updateProjection);\n    }\n    blockUpdate() {\n      this.updateManuallyBlocked = true;\n    }\n    unblockUpdate() {\n      this.updateManuallyBlocked = false;\n    }\n    isUpdateBlocked() {\n      return this.updateManuallyBlocked || this.updateBlockedByResize;\n    }\n    isTreeAnimationBlocked() {\n      var _a;\n      return this.isAnimationBlocked || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) || false;\n    }\n    startUpdate() {\n      var _a;\n      if (this.isUpdateBlocked())\n        return;\n      this.isUpdating = true;\n      (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);\n    }\n    willUpdate(shouldNotifyListeners = true) {\n      var _a, _b, _c;\n      if (this.root.isUpdateBlocked()) {\n        (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n        return;\n      }\n      !this.root.isUpdating && this.root.startUpdate();\n      if (this.isLayoutDirty)\n        return;\n      this.isLayoutDirty = true;\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        node.shouldResetTransform = true;\n        node.updateScroll();\n      }\n      const { layoutId, layout } = this.options;\n      if (layoutId === void 0 && !layout)\n        return;\n      const transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;\n      this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n      this.updateSnapshot();\n      shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n    }\n    didUpdate() {\n      const updateWasBlocked = this.isUpdateBlocked();\n      if (updateWasBlocked) {\n        this.unblockUpdate();\n        this.clearAllSnapshots();\n        this.nodes.forEach(clearMeasurements);\n        return;\n      }\n      if (!this.isUpdating)\n        return;\n      this.isUpdating = false;\n      if (this.potentialNodes.size) {\n        this.potentialNodes.forEach(mountNodeEarly);\n        this.potentialNodes.clear();\n      }\n      this.nodes.forEach(resetTransformStyle);\n      this.nodes.forEach(updateLayout);\n      this.nodes.forEach(notifyLayoutUpdate);\n      this.clearAllSnapshots();\n      flushSync.update();\n      flushSync.preRender();\n      flushSync.render();\n    }\n    clearAllSnapshots() {\n      this.nodes.forEach(clearSnapshot);\n      this.sharedNodes.forEach(removeLeadSnapshots);\n    }\n    scheduleUpdateProjection() {\n      es_default.preRender(this.updateProjection, false, true);\n    }\n    scheduleCheckAfterUnmount() {\n      es_default.postRender(() => {\n        if (this.isLayoutDirty) {\n          this.root.didUpdate();\n        } else {\n          this.root.checkUpdateFailed();\n        }\n      });\n    }\n    updateSnapshot() {\n      if (this.snapshot || !this.instance)\n        return;\n      this.snapshot = this.measure();\n    }\n    updateLayout() {\n      var _a;\n      if (!this.instance)\n        return;\n      this.updateScroll();\n      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {\n        return;\n      }\n      if (this.resumeFrom && !this.resumeFrom.instance) {\n        for (let i2 = 0; i2 < this.path.length; i2++) {\n          const node = this.path[i2];\n          node.updateScroll();\n        }\n      }\n      const prevLayout = this.layout;\n      this.layout = this.measure(false);\n      this.layoutCorrected = createBox();\n      this.isLayoutDirty = false;\n      this.projectionDelta = void 0;\n      this.notifyListeners(\"measure\", this.layout.layoutBox);\n      (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.layoutBox);\n    }\n    updateScroll() {\n      if (this.options.layoutScroll && this.instance) {\n        this.isScrollRoot = checkIsScrollRoot(this.instance);\n        this.scroll = measureScroll(this.instance);\n      }\n    }\n    resetTransform() {\n      var _a;\n      if (!resetTransform)\n        return;\n      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;\n      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n      const transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n      const transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {\n        resetTransform(this.instance, transformTemplateValue);\n        this.shouldResetTransform = false;\n        this.scheduleRender();\n      }\n    }\n    measure(removeTransform = true) {\n      const pageBox = this.measurePageBox();\n      let layoutBox = this.removeElementScroll(pageBox);\n      if (removeTransform) {\n        layoutBox = this.removeTransform(layoutBox);\n      }\n      roundBox(layoutBox);\n      return {\n        measuredBox: pageBox,\n        layoutBox,\n        latestValues: {}\n      };\n    }\n    measurePageBox() {\n      const { visualElement } = this.options;\n      if (!visualElement)\n        return createBox();\n      const box = visualElement.measureViewportBox();\n      const { scroll: scroll2 } = this.root;\n      if (scroll2) {\n        translateAxis(box.x, scroll2.x);\n        translateAxis(box.y, scroll2.y);\n      }\n      return box;\n    }\n    removeElementScroll(box) {\n      const boxWithoutScroll = createBox();\n      copyBoxInto(boxWithoutScroll, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        const { scroll: scroll2, options, isScrollRoot } = node;\n        if (node !== this.root && scroll2 && options.layoutScroll) {\n          if (isScrollRoot) {\n            copyBoxInto(boxWithoutScroll, box);\n            const { scroll: rootScroll } = this.root;\n            if (rootScroll) {\n              translateAxis(boxWithoutScroll.x, -rootScroll.x);\n              translateAxis(boxWithoutScroll.y, -rootScroll.y);\n            }\n          }\n          translateAxis(boxWithoutScroll.x, scroll2.x);\n          translateAxis(boxWithoutScroll.y, scroll2.y);\n        }\n      }\n      return boxWithoutScroll;\n    }\n    applyTransform(box, transformOnly = false) {\n      const withTransforms = createBox();\n      copyBoxInto(withTransforms, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {\n          transformBox(withTransforms, {\n            x: -node.scroll.x,\n            y: -node.scroll.y\n          });\n        }\n        if (!hasTransform(node.latestValues))\n          continue;\n        transformBox(withTransforms, node.latestValues);\n      }\n      if (hasTransform(this.latestValues)) {\n        transformBox(withTransforms, this.latestValues);\n      }\n      return withTransforms;\n    }\n    removeTransform(box) {\n      var _a;\n      const boxWithoutTransform = createBox();\n      copyBoxInto(boxWithoutTransform, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        if (!node.instance)\n          continue;\n        if (!hasTransform(node.latestValues))\n          continue;\n        hasScale(node.latestValues) && node.updateSnapshot();\n        const sourceBox = createBox();\n        const nodeBox = node.measurePageBox();\n        copyBoxInto(sourceBox, nodeBox);\n        removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layoutBox, sourceBox);\n      }\n      if (hasTransform(this.latestValues)) {\n        removeBoxTransforms(boxWithoutTransform, this.latestValues);\n      }\n      return boxWithoutTransform;\n    }\n    setTargetDelta(delta) {\n      this.targetDelta = delta;\n      this.root.scheduleUpdateProjection();\n    }\n    setOptions(options) {\n      this.options = __spreadProps(__spreadValues(__spreadValues({}, this.options), options), {\n        crossfade: options.crossfade !== void 0 ? options.crossfade : true\n      });\n    }\n    clearMeasurements() {\n      this.scroll = void 0;\n      this.layout = void 0;\n      this.snapshot = void 0;\n      this.prevTransformTemplateValue = void 0;\n      this.targetDelta = void 0;\n      this.target = void 0;\n      this.isLayoutDirty = false;\n    }\n    resolveTargetDelta() {\n      var _a;\n      const { layout, layoutId } = this.options;\n      if (!this.layout || !(layout || layoutId))\n        return;\n      if (!this.targetDelta && !this.relativeTarget) {\n        const relativeParent = this.getClosestProjectingParent();\n        if (relativeParent && relativeParent.layout) {\n          this.relativeParent = relativeParent;\n          this.relativeTarget = createBox();\n          this.relativeTargetOrigin = createBox();\n          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n        } else {\n          this.relativeParent = this.relativeTarget = void 0;\n        }\n      }\n      if (!this.relativeTarget && !this.targetDelta)\n        return;\n      if (!this.target) {\n        this.target = createBox();\n        this.targetWithTransforms = createBox();\n      }\n      if (this.relativeTarget && this.relativeTargetOrigin && ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {\n        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n      } else if (this.targetDelta) {\n        if (Boolean(this.resumingFrom)) {\n          this.target = this.applyTransform(this.layout.layoutBox);\n        } else {\n          copyBoxInto(this.target, this.layout.layoutBox);\n        }\n        applyBoxDelta(this.target, this.targetDelta);\n      } else {\n        copyBoxInto(this.target, this.layout.layoutBox);\n      }\n      if (this.attemptToResolveRelativeTarget) {\n        this.attemptToResolveRelativeTarget = false;\n        const relativeParent = this.getClosestProjectingParent();\n        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target) {\n          this.relativeParent = relativeParent;\n          this.relativeTarget = createBox();\n          this.relativeTargetOrigin = createBox();\n          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n        } else {\n          this.relativeParent = this.relativeTarget = void 0;\n        }\n      }\n    }\n    getClosestProjectingParent() {\n      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues))\n        return void 0;\n      if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {\n        return this.parent;\n      } else {\n        return this.parent.getClosestProjectingParent();\n      }\n    }\n    calcProjection() {\n      var _a;\n      const { layout, layoutId } = this.options;\n      this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);\n      if (!this.isTreeAnimating) {\n        this.targetDelta = this.relativeTarget = void 0;\n      }\n      if (!this.layout || !(layout || layoutId))\n        return;\n      const lead = this.getLead();\n      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);\n      const { target } = lead;\n      if (!target)\n        return;\n      if (!this.projectionDelta) {\n        this.projectionDelta = createDelta();\n        this.projectionDeltaWithTransform = createDelta();\n      }\n      const prevTreeScaleX = this.treeScale.x;\n      const prevTreeScaleY = this.treeScale.y;\n      const prevProjectionTransform = this.projectionTransform;\n      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);\n      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {\n        this.hasProjected = true;\n        this.scheduleRender();\n        this.notifyListeners(\"projectionUpdate\", target);\n      }\n    }\n    hide() {\n      this.isVisible = false;\n    }\n    show() {\n      this.isVisible = true;\n    }\n    scheduleRender(notifyAll2 = true) {\n      var _a, _b, _c;\n      (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);\n      notifyAll2 && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());\n      if (this.resumingFrom && !this.resumingFrom.instance) {\n        this.resumingFrom = void 0;\n      }\n    }\n    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n      var _a;\n      const snapshot = this.snapshot;\n      const snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};\n      const mixedValues = __spreadValues({}, this.latestValues);\n      const targetDelta = createDelta();\n      this.relativeTarget = this.relativeTargetOrigin = void 0;\n      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n      const relativeLayout = createBox();\n      const isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;\n      const isOnlyMember = (((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.members.length) || 0) <= 1;\n      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));\n      this.animationProgress = 0;\n      this.mixTargetDelta = (latest) => {\n        var _a2;\n        const progress3 = latest / 1e3;\n        mixAxisDelta(targetDelta.x, delta.x, progress3);\n        mixAxisDelta(targetDelta.y, delta.y, progress3);\n        this.setTargetDelta(targetDelta);\n        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && ((_a2 = this.relativeParent) === null || _a2 === void 0 ? void 0 : _a2.layout)) {\n          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress3);\n        }\n        if (isSharedLayoutAnimation) {\n          this.animationValues = mixedValues;\n          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress3, shouldCrossfadeOpacity, isOnlyMember);\n        }\n        this.root.scheduleUpdateProjection();\n        this.scheduleRender();\n        this.animationProgress = progress3;\n      };\n      this.mixTargetDelta(0);\n    }\n    startAnimation(options) {\n      var _a, _b;\n      this.notifyListeners(\"animationStart\");\n      (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n      if (this.resumingFrom) {\n        (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();\n      }\n      if (this.pendingAnimation) {\n        cancelSync.update(this.pendingAnimation);\n        this.pendingAnimation = void 0;\n      }\n      this.pendingAnimation = es_default.update(() => {\n        globalProjectionState.hasAnimatedSinceResize = true;\n        this.currentAnimation = animate2(0, animationTarget, __spreadProps(__spreadValues({}, options), {\n          onUpdate: (latest) => {\n            var _a2;\n            this.mixTargetDelta(latest);\n            (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, latest);\n          },\n          onComplete: () => {\n            var _a2;\n            (_a2 = options.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(options);\n            this.completeAnimation();\n          }\n        }));\n        if (this.resumingFrom) {\n          this.resumingFrom.currentAnimation = this.currentAnimation;\n        }\n        this.pendingAnimation = void 0;\n      });\n    }\n    completeAnimation() {\n      var _a;\n      if (this.resumingFrom) {\n        this.resumingFrom.currentAnimation = void 0;\n        this.resumingFrom.preserveOpacity = void 0;\n      }\n      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();\n      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;\n      this.notifyListeners(\"animationComplete\");\n    }\n    finishAnimation() {\n      var _a;\n      if (this.currentAnimation) {\n        (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);\n        this.currentAnimation.stop();\n      }\n      this.completeAnimation();\n    }\n    applyTransformsToTarget() {\n      const lead = this.getLead();\n      let { targetWithTransforms, target, layout, latestValues } = lead;\n      if (!targetWithTransforms || !target || !layout)\n        return;\n      if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n        target = this.target || createBox();\n        const xLength = calcLength(this.layout.layoutBox.x);\n        target.x.min = lead.target.x.min;\n        target.x.max = target.x.min + xLength;\n        const yLength = calcLength(this.layout.layoutBox.y);\n        target.y.min = lead.target.y.min;\n        target.y.max = target.y.min + yLength;\n      }\n      copyBoxInto(targetWithTransforms, target);\n      transformBox(targetWithTransforms, latestValues);\n      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n    }\n    registerSharedNode(layoutId, node) {\n      var _a, _b, _c;\n      if (!this.sharedNodes.has(layoutId)) {\n        this.sharedNodes.set(layoutId, new NodeStack());\n      }\n      const stack = this.sharedNodes.get(layoutId);\n      stack.add(node);\n      node.promote({\n        transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,\n        preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)\n      });\n    }\n    isLead() {\n      const stack = this.getStack();\n      return stack ? stack.lead === this : true;\n    }\n    getLead() {\n      var _a;\n      const { layoutId } = this.options;\n      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n    }\n    getPrevLead() {\n      var _a;\n      const { layoutId } = this.options;\n      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;\n    }\n    getStack() {\n      const { layoutId } = this.options;\n      if (layoutId)\n        return this.root.sharedNodes.get(layoutId);\n    }\n    promote({ needsReset, transition, preserveFollowOpacity } = {}) {\n      const stack = this.getStack();\n      if (stack)\n        stack.promote(this, preserveFollowOpacity);\n      if (needsReset) {\n        this.projectionDelta = void 0;\n        this.needsReset = true;\n      }\n      if (transition)\n        this.setOptions({ transition });\n    }\n    relegate() {\n      const stack = this.getStack();\n      if (stack) {\n        return stack.relegate(this);\n      } else {\n        return false;\n      }\n    }\n    resetRotation() {\n      const { visualElement } = this.options;\n      if (!visualElement)\n        return;\n      let hasRotate = false;\n      const resetValues = {};\n      for (let i2 = 0; i2 < transformAxes.length; i2++) {\n        const axis = transformAxes[i2];\n        const key = \"rotate\" + axis;\n        if (!visualElement.getStaticValue(key)) {\n          continue;\n        }\n        hasRotate = true;\n        resetValues[key] = visualElement.getStaticValue(key);\n        visualElement.setStaticValue(key, 0);\n      }\n      if (!hasRotate)\n        return;\n      visualElement === null || visualElement === void 0 ? void 0 : visualElement.render();\n      for (const key in resetValues) {\n        visualElement.setStaticValue(key, resetValues[key]);\n      }\n      visualElement.scheduleRender();\n    }\n    getProjectionStyles(styleProp = {}) {\n      var _a, _b, _c;\n      const styles = {};\n      if (!this.instance || this.isSVG)\n        return styles;\n      if (!this.isVisible) {\n        return { visibility: \"hidden\" };\n      } else {\n        styles.visibility = \"\";\n      }\n      const transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n      if (this.needsReset) {\n        this.needsReset = false;\n        styles.opacity = \"\";\n        styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n        styles.transform = transformTemplate ? transformTemplate(this.latestValues, \"\") : \"none\";\n        return styles;\n      }\n      const lead = this.getLead();\n      if (!this.projectionDelta || !this.layout || !lead.target) {\n        const emptyStyles = {};\n        if (this.options.layoutId) {\n          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;\n          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n        }\n        if (this.hasProjected && !hasTransform(this.latestValues)) {\n          emptyStyles.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n          this.hasProjected = false;\n        }\n        return emptyStyles;\n      }\n      const valuesToRender = lead.animationValues || lead.latestValues;\n      this.applyTransformsToTarget();\n      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n      if (transformTemplate) {\n        styles.transform = transformTemplate(valuesToRender, styles.transform);\n      }\n      const { x, y } = this.projectionDelta;\n      styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n      if (lead.animationValues) {\n        styles.opacity = lead === this ? (_c = (_b = valuesToRender.opacity) !== null && _b !== void 0 ? _b : this.latestValues.opacity) !== null && _c !== void 0 ? _c : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;\n      } else {\n        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : \"\" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;\n      }\n      for (const key in scaleCorrectors) {\n        if (valuesToRender[key] === void 0)\n          continue;\n        const { correct, applyTo } = scaleCorrectors[key];\n        const corrected = correct(valuesToRender[key], lead);\n        if (applyTo) {\n          const num = applyTo.length;\n          for (let i2 = 0; i2 < num; i2++) {\n            styles[applyTo[i2]] = corrected;\n          }\n        } else {\n          styles[key] = corrected;\n        }\n      }\n      if (this.options.layoutId) {\n        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || \"\" : \"none\";\n      }\n      return styles;\n    }\n    clearSnapshot() {\n      this.resumeFrom = this.snapshot = void 0;\n    }\n    resetTree() {\n      this.root.nodes.forEach((node) => {\n        var _a;\n        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n      });\n      this.root.nodes.forEach(clearMeasurements);\n      this.root.sharedNodes.clear();\n    }\n  };\n}\nfunction updateLayout(node) {\n  node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n  var _a, _b, _c;\n  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\n  if (node.isLead() && node.layout && snapshot && node.hasListeners(\"didUpdate\")) {\n    const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\n    const { animationType } = node.options;\n    if (animationType === \"size\") {\n      eachAxis((axis) => {\n        const axisSnapshot = snapshot.isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n        const length = calcLength(axisSnapshot);\n        axisSnapshot.min = layout[axis].min;\n        axisSnapshot.max = axisSnapshot.min + length;\n      });\n    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\n      eachAxis((axis) => {\n        const axisSnapshot = snapshot.isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n        const length = calcLength(layout[axis]);\n        axisSnapshot.max = axisSnapshot.min + length;\n      });\n    }\n    const layoutDelta = createDelta();\n    calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\n    const visualDelta = createDelta();\n    if (snapshot.isShared) {\n      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n    } else {\n      calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n    }\n    const hasLayoutChanged = !isDeltaZero(layoutDelta);\n    let hasRelativeTargetChanged = false;\n    if (!node.resumeFrom) {\n      const relativeParent = node.getClosestProjectingParent();\n      if (relativeParent && !relativeParent.resumeFrom) {\n        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n        if (parentSnapshot && parentLayout) {\n          const relativeSnapshot = createBox();\n          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n          const relativeLayout = createBox();\n          calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n          if (!boxEquals(relativeSnapshot, relativeLayout)) {\n            hasRelativeTargetChanged = true;\n          }\n        }\n      }\n    }\n    node.notifyListeners(\"didUpdate\", {\n      layout,\n      snapshot,\n      delta: visualDelta,\n      layoutDelta,\n      hasLayoutChanged,\n      hasRelativeTargetChanged\n    });\n  } else if (node.isLead()) {\n    (_c = (_b = node.options).onExitComplete) === null || _c === void 0 ? void 0 : _c.call(_b);\n  }\n  node.options.transition = void 0;\n}\nfunction clearSnapshot(node) {\n  node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n  node.clearMeasurements();\n}\nfunction resetTransformStyle(node) {\n  const { visualElement } = node.options;\n  if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {\n    visualElement.notify(\"BeforeLayoutMeasure\");\n  }\n  node.resetTransform();\n}\nfunction finishAnimation(node) {\n  node.finishAnimation();\n  node.targetDelta = node.relativeTarget = node.target = void 0;\n}\nfunction resolveTargetDelta(node) {\n  node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n  node.calcProjection();\n}\nfunction resetRotation(node) {\n  node.resetRotation();\n}\nfunction removeLeadSnapshots(stack) {\n  stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p2) {\n  output.translate = mix(delta.translate, 0, p2);\n  output.scale = mix(delta.scale, 1, p2);\n  output.origin = delta.origin;\n  output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p2) {\n  output.min = mix(from.min, to.min, p2);\n  output.max = mix(from.max, to.max, p2);\n}\nfunction mixBox(output, from, to, p2) {\n  mixAxis(output.x, from.x, to.x, p2);\n  mixAxis(output.y, from.y, to.y, p2);\n}\nfunction hasOpacityCrossfade(node) {\n  return node.animationValues && node.animationValues.opacityExit !== void 0;\n}\nvar defaultLayoutTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\nfunction mountNodeEarly(node, id2) {\n  let searchNode = node.root;\n  for (let i2 = node.path.length - 1; i2 >= 0; i2--) {\n    if (Boolean(node.path[i2].instance)) {\n      searchNode = node.path[i2];\n      break;\n    }\n  }\n  const searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;\n  const element = searchElement.querySelector(`[data-projection-id=\"${id2}\"]`);\n  if (element)\n    node.mount(element, true);\n}\nfunction roundAxis(axis) {\n  axis.min = Math.round(axis.min);\n  axis.max = Math.round(axis.max);\n}\nfunction roundBox(box) {\n  roundAxis(box.x);\n  roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\n  return animationType === \"position\" || animationType === \"preserve-aspect\" && !isCloseTo(aspectRatio(snapshot), aspectRatio(layout), 0.2);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs\nvar DocumentProjectionNode = createProjectionNode({\n  attachResizeListener: (ref, notify) => addDomEvent(ref, \"resize\", notify),\n  measureScroll: () => ({\n    x: document.documentElement.scrollLeft || document.body.scrollLeft,\n    y: document.documentElement.scrollTop || document.body.scrollTop\n  }),\n  checkIsScrollRoot: () => true\n});\n\n// ../../node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs\nvar rootProjectionNode = {\n  current: void 0\n};\nvar HTMLProjectionNode = createProjectionNode({\n  measureScroll: (instance) => ({\n    x: instance.scrollLeft,\n    y: instance.scrollTop\n  }),\n  defaultParent: () => {\n    if (!rootProjectionNode.current) {\n      const documentNode = new DocumentProjectionNode(0, {});\n      documentNode.mount(window);\n      documentNode.setOptions({ layoutScroll: true });\n      rootProjectionNode.current = documentNode;\n    }\n    return rootProjectionNode.current;\n  },\n  resetTransform: (instance, value) => {\n    instance.style.transform = value !== void 0 ? value : \"none\";\n  },\n  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \"fixed\")\n});\n\n// ../../node_modules/framer-motion/dist/es/render/dom/motion.mjs\nvar featureBundle = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, animations), gestureAnimations), drag), layoutFeatures);\nvar motion = /* @__PURE__ */ createMotionProxy((Component, config) => createDomMotionConfig(Component, config, featureBundle, createDomVisualElement, HTMLProjectionNode));\n\n// ../../node_modules/@motionone/utils/dist/clamp.es.js\nvar clamp3 = (min, max, v) => Math.min(Math.max(v, min), max);\n\n// ../../node_modules/@motionone/utils/dist/is-number.es.js\nvar isNumber = (value) => typeof value === \"number\";\n\n// ../../node_modules/@motionone/utils/dist/is-easing-list.es.js\nvar isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\n\n// ../../node_modules/@motionone/utils/dist/wrap.es.js\nvar wrap = (min, max, v) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\n// ../../node_modules/@motionone/utils/dist/easing.es.js\nfunction getEasingForSegment(easing, i2) {\n  return isEasingList(easing) ? easing[wrap(0, easing.length, i2)] : easing;\n}\n\n// ../../node_modules/@motionone/utils/dist/mix.es.js\nvar mix2 = (min, max, progress3) => -progress3 * min + progress3 * max + min;\n\n// ../../node_modules/@motionone/utils/dist/noop.es.js\nvar noopReturn = (v) => v;\n\n// ../../node_modules/@motionone/utils/dist/progress.es.js\nvar progress2 = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\n// ../../node_modules/@motionone/utils/dist/offset.es.js\nfunction fillOffset(offset, remaining) {\n  const min = offset[offset.length - 1];\n  for (let i2 = 1; i2 <= remaining; i2++) {\n    const offsetProgress = progress2(0, remaining, i2);\n    offset.push(mix2(min, 1, offsetProgress));\n  }\n}\nfunction defaultOffset2(length) {\n  const offset = [0];\n  fillOffset(offset, length - 1);\n  return offset;\n}\n\n// ../../node_modules/@motionone/utils/dist/interpolate.es.js\nfunction interpolate2(output, input = defaultOffset2(output.length), easing = noopReturn) {\n  const length = output.length;\n  const remainder = length - input.length;\n  remainder > 0 && fillOffset(input, remainder);\n  return (t) => {\n    let i2 = 0;\n    for (; i2 < length - 2; i2++) {\n      if (t < input[i2 + 1])\n        break;\n    }\n    let progressInRange = clamp3(0, 1, progress2(input[i2], input[i2 + 1], t));\n    const segmentEasing = getEasingForSegment(easing, i2);\n    progressInRange = segmentEasing(progressInRange);\n    return mix2(output[i2], output[i2 + 1], progressInRange);\n  };\n}\n\n// ../../node_modules/@motionone/utils/dist/is-function.es.js\nvar isFunction = (value) => typeof value === \"function\";\n\n// ../../node_modules/@motionone/utils/dist/is-string.es.js\nvar isString2 = (value) => typeof value === \"string\";\n\n// ../../node_modules/@motionone/utils/dist/velocity.es.js\nfunction velocityPerSecond2(velocity, frameDuration) {\n  return frameDuration ? velocity * (1e3 / frameDuration) : 0;\n}\n\n// ../../node_modules/@motionone/dom/dist/utils/resolve-elements.es.js\nfunction resolveElements(elements, selectorCache) {\n  var _a;\n  if (typeof elements === \"string\") {\n    if (selectorCache) {\n      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = document.querySelectorAll(elements);\n      elements = selectorCache[elements];\n    } else {\n      elements = document.querySelectorAll(elements);\n    }\n  } else if (elements instanceof Element) {\n    elements = [elements];\n  }\n  return Array.from(elements || []);\n}\n\n// ../../node_modules/tslib/modules/index.js\nvar import_tslib4 = __toESM(require_tslib2(), 1);\nvar {\n  __extends: __extends2,\n  __assign: __assign2,\n  __rest: __rest2,\n  __decorate: __decorate2,\n  __param: __param2,\n  __metadata: __metadata2,\n  __awaiter: __awaiter2,\n  __generator: __generator2,\n  __exportStar: __exportStar2,\n  __createBinding: __createBinding2,\n  __values: __values2,\n  __read: __read2,\n  __spread: __spread2,\n  __spreadArrays: __spreadArrays2,\n  __spreadArray: __spreadArray2,\n  __await: __await2,\n  __asyncGenerator: __asyncGenerator2,\n  __asyncDelegator: __asyncDelegator2,\n  __asyncValues: __asyncValues2,\n  __makeTemplateObject: __makeTemplateObject2,\n  __importStar: __importStar2,\n  __importDefault: __importDefault2,\n  __classPrivateFieldGet: __classPrivateFieldGet2,\n  __classPrivateFieldSet: __classPrivateFieldSet2,\n  __classPrivateFieldIn: __classPrivateFieldIn2\n} = import_tslib4.default;\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/handle-element.es.js\nvar resizeHandlers = /* @__PURE__ */ new WeakMap();\nvar observer;\nfunction getElementSize(target, borderBoxSize) {\n  if (borderBoxSize) {\n    const { inlineSize, blockSize } = borderBoxSize[0];\n    return { width: inlineSize, height: blockSize };\n  } else if (target instanceof SVGElement && \"getBBox\" in target) {\n    return target.getBBox();\n  } else {\n    return {\n      width: target.offsetWidth,\n      height: target.offsetHeight\n    };\n  }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize }) {\n  var _a;\n  (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n    handler({\n      target,\n      contentSize: contentRect,\n      get size() {\n        return getElementSize(target, borderBoxSize);\n      }\n    });\n  });\n}\nfunction notifyAll(entries) {\n  entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n  if (typeof ResizeObserver === \"undefined\")\n    return;\n  observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n  if (!observer)\n    createResizeObserver();\n  const elements = resolveElements(target);\n  elements.forEach((element) => {\n    let elementHandlers = resizeHandlers.get(element);\n    if (!elementHandlers) {\n      elementHandlers = /* @__PURE__ */ new Set();\n      resizeHandlers.set(element, elementHandlers);\n    }\n    elementHandlers.add(handler);\n    observer === null || observer === void 0 ? void 0 : observer.observe(element);\n  });\n  return () => {\n    elements.forEach((element) => {\n      const elementHandlers = resizeHandlers.get(element);\n      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n        observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n      }\n    });\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/handle-window.es.js\nvar windowCallbacks = /* @__PURE__ */ new Set();\nvar windowResizeHandler;\nfunction createWindowResizeHandler() {\n  windowResizeHandler = () => {\n    const size = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n    const info = {\n      target: window,\n      size,\n      contentSize: size\n    };\n    windowCallbacks.forEach((callback) => callback(info));\n  };\n  window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n  windowCallbacks.add(callback);\n  if (!windowResizeHandler)\n    createWindowResizeHandler();\n  return () => {\n    windowCallbacks.delete(callback);\n    if (!windowCallbacks.size && windowResizeHandler) {\n      windowResizeHandler = void 0;\n    }\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/index.es.js\nfunction resize(a2, b2) {\n  return isFunction(a2) ? resizeWindow(a2) : resizeElement(a2, b2);\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/info.es.js\nvar maxElapsed2 = 50;\nvar createAxisInfo = () => ({\n  current: 0,\n  offset: [],\n  progress: 0,\n  scrollLength: 0,\n  targetOffset: 0,\n  targetLength: 0,\n  containerLength: 0,\n  velocity: 0\n});\nvar createScrollInfo = () => ({\n  time: 0,\n  x: createAxisInfo(),\n  y: createAxisInfo()\n});\nvar keys = {\n  x: {\n    length: \"Width\",\n    position: \"Left\"\n  },\n  y: {\n    length: \"Height\",\n    position: \"Top\"\n  }\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n  const axis = info[axisName];\n  const { length, position } = keys[axisName];\n  const prev = axis.current;\n  const prevTime = info.time;\n  axis.current = element[\"scroll\" + position];\n  axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n  axis.offset.length = 0;\n  axis.offset[0] = 0;\n  axis.offset[1] = axis.scrollLength;\n  axis.progress = progress2(0, axis.scrollLength, axis.current);\n  const elapsed = time - prevTime;\n  axis.velocity = elapsed > maxElapsed2 ? 0 : velocityPerSecond2(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n  updateAxisInfo(element, \"x\", info, time);\n  updateAxisInfo(element, \"y\", info, time);\n  info.time = time;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/inset.es.js\nfunction calcInset(element, container) {\n  let inset = { x: 0, y: 0 };\n  let current = element;\n  while (current && current !== container) {\n    if (current instanceof HTMLElement) {\n      inset.x += current.offsetLeft;\n      inset.y += current.offsetTop;\n      current = current.offsetParent;\n    } else if (current instanceof SVGGraphicsElement && \"getBBox\" in current) {\n      const { top, left } = current.getBBox();\n      inset.x += left;\n      inset.y += top;\n      while (current && current.tagName !== \"svg\") {\n        current = current.parentNode;\n      }\n    }\n  }\n  return inset;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/presets.es.js\nvar ScrollOffset = {\n  Enter: [\n    [0, 1],\n    [1, 1]\n  ],\n  Exit: [\n    [0, 0],\n    [1, 0]\n  ],\n  Any: [\n    [1, 0],\n    [0, 1]\n  ],\n  All: [\n    [0, 0],\n    [1, 1]\n  ]\n};\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/edge.es.js\nvar namedEdges = {\n  start: 0,\n  center: 0.5,\n  end: 1\n};\nfunction resolveEdge(edge, length, inset = 0) {\n  let delta = 0;\n  if (namedEdges[edge] !== void 0) {\n    edge = namedEdges[edge];\n  }\n  if (isString2(edge)) {\n    const asNumber2 = parseFloat(edge);\n    if (edge.endsWith(\"px\")) {\n      delta = asNumber2;\n    } else if (edge.endsWith(\"%\")) {\n      edge = asNumber2 / 100;\n    } else if (edge.endsWith(\"vw\")) {\n      delta = asNumber2 / 100 * document.documentElement.clientWidth;\n    } else if (edge.endsWith(\"vh\")) {\n      delta = asNumber2 / 100 * document.documentElement.clientHeight;\n    } else {\n      edge = asNumber2;\n    }\n  }\n  if (isNumber(edge)) {\n    delta = length * edge;\n  }\n  return inset + delta;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/offset.es.js\nvar defaultOffset3 = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset3;\n  let targetPoint = 0;\n  let containerPoint = 0;\n  if (isNumber(offset)) {\n    offsetDefinition = [offset, offset];\n  } else if (isString2(offset)) {\n    offset = offset.trim();\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n    }\n  }\n  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/index.es.js\nvar point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n  let { offset: offsetDefinition = ScrollOffset.All } = options;\n  const { target = container, axis = \"y\" } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset = target !== container ? calcInset(target, container) : point;\n  const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight } : { width: target.clientWidth, height: target.clientHeight };\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  info[axis].offset.length = 0;\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n  for (let i2 = 0; i2 < numOffsets; i2++) {\n    const offset = resolveOffset(offsetDefinition[i2], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i2]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i2] = offset;\n  }\n  if (hasChanged) {\n    info[axis].interpolate = interpolate2(defaultOffset2(numOffsets), info[axis].offset);\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/on-scroll-handler.es.js\nfunction measure(container, target = container, info) {\n  info.x.targetOffset = 0;\n  info.y.targetOffset = 0;\n  if (target !== container) {\n    let node = target;\n    while (node && node != container) {\n      info.x.targetOffset += node.offsetLeft;\n      info.y.targetOffset += node.offsetTop;\n      node = node.offsetParent;\n    }\n  }\n  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;\n  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;\n  info.x.containerLength = container.clientWidth;\n  info.y.containerLength = container.clientHeight;\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n  const axis = options.axis || \"y\";\n  return {\n    measure: () => measure(element, options.target, info),\n    update: (time) => {\n      updateScrollInfo(element, info, time);\n      if (options.offset || options.target) {\n        resolveOffsets(element, info, options);\n      }\n    },\n    notify: isFunction(onScroll) ? () => onScroll(info) : scrubAnimation(onScroll, info[axis])\n  };\n}\nfunction scrubAnimation(controls, axisInfo) {\n  controls.pause();\n  controls.forEachNative((animation, { easing }) => {\n    var _a, _b;\n    if (animation.updateDuration) {\n      if (!easing)\n        animation.easing = noopReturn;\n      animation.updateDuration(1);\n    } else {\n      const timingOptions = { duration: 1e3 };\n      if (!easing)\n        timingOptions.easing = \"linear\";\n      (_b = (_a = animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming) === null || _b === void 0 ? void 0 : _b.call(_a, timingOptions);\n    }\n  });\n  return () => {\n    controls.currentTime = axisInfo.progress;\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/index.es.js\nvar scrollListeners = /* @__PURE__ */ new WeakMap();\nvar resizeListeners = /* @__PURE__ */ new WeakMap();\nvar onScrollHandlers = /* @__PURE__ */ new WeakMap();\nvar getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction scroll(onScroll, _a = {}) {\n  var { container = document.documentElement } = _a, options = __rest2(_a, [\"container\"]);\n  let containerHandlers = onScrollHandlers.get(container);\n  if (!containerHandlers) {\n    containerHandlers = /* @__PURE__ */ new Set();\n    onScrollHandlers.set(container, containerHandlers);\n  }\n  const info = createScrollInfo();\n  const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n  containerHandlers.add(containerHandler);\n  if (!scrollListeners.has(container)) {\n    const listener2 = () => {\n      const time = performance.now();\n      for (const handler of containerHandlers)\n        handler.measure();\n      for (const handler of containerHandlers)\n        handler.update(time);\n      for (const handler of containerHandlers)\n        handler.notify();\n    };\n    scrollListeners.set(container, listener2);\n    const target = getEventTarget(container);\n    window.addEventListener(\"resize\", listener2, { passive: true });\n    if (container !== document.documentElement) {\n      resizeListeners.set(container, resize(container, listener2));\n    }\n    target.addEventListener(\"scroll\", listener2, { passive: true });\n  }\n  const listener = scrollListeners.get(container);\n  const onLoadProcesss = requestAnimationFrame(listener);\n  return () => {\n    var _a2;\n    if (typeof onScroll !== \"function\")\n      onScroll.stop();\n    cancelAnimationFrame(onLoadProcesss);\n    const containerHandlers2 = onScrollHandlers.get(container);\n    if (!containerHandlers2)\n      return;\n    containerHandlers2.delete(containerHandler);\n    if (containerHandlers2.size)\n      return;\n    const listener2 = scrollListeners.get(container);\n    scrollListeners.delete(container);\n    if (listener2) {\n      getEventTarget(container).removeEventListener(\"scroll\", listener2);\n      (_a2 = resizeListeners.get(container)) === null || _a2 === void 0 ? void 0 : _a2();\n      window.removeEventListener(\"resize\", listener2);\n    }\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-scroll.mjs\nvar import_react28 = __webpack_require__(/*! react */ \"react\");\nvar createScrollMotionValues = () => ({\n  scrollX: motionValue(0),\n  scrollY: motionValue(0),\n  scrollXProgress: motionValue(0),\n  scrollYProgress: motionValue(0)\n});\nfunction useScroll(_a = {}) {\n  var _b = _a, { container, target, layoutEffect = true } = _b, options = __objRest(_b, [\"container\", \"target\", \"layoutEffect\"]);\n  const values = useConstant(createScrollMotionValues);\n  const useLifecycleEffect = layoutEffect ? useIsomorphicLayoutEffect : import_react28.useEffect;\n  useLifecycleEffect(() => {\n    return scroll(({ x, y }) => {\n      values.scrollX.set(x.current);\n      values.scrollXProgress.set(x.progress);\n      values.scrollY.set(y.current);\n      values.scrollYProgress.set(y.progress);\n    }, __spreadProps(__spreadValues({}, options), {\n      container: (container === null || container === void 0 ? void 0 : container.current) || void 0,\n      target: (target === null || target === void 0 ? void 0 : target.current) || void 0\n    }));\n  }, []);\n  return values;\n}\n\n// src/Menu.tsx\nvar import_jsx_runtime2 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar Menu = () => {\n  const { scrollYProgress } = useScroll();\n  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(\"div\", {\n    className: \"hidden sm:block\",\n    children: [\n      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(motion.div, {\n        className: \"progress-bar\",\n        style: { scaleX: scrollYProgress }\n      }),\n      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(\"div\", {\n        className: \"flex flex-row items-center justify-between bg-gradient-to-r from-blue-400 to-blue-500\",\n        children: [\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n              href: \"/\",\n              children: \"Pylar\\u2122 AI\"\n            })\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n              href: \"/blog\",\n              children: \"Daily Work\"\n            })\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n              href: \"/what-is-pylar\",\n              children: \"About\"\n            })\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n              href: \"/pylar-license\",\n              children: \"The License\"\n            })\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n              href: \"https://pencil.domains\",\n              target: \"_blank\",\n              rel: \"noreferrer\",\n              children: \"Pencil Domains\"\n            })\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(\"div\", {\n            className: \"hidden py-2 px-4 font-bold text-white md:block\",\n            style: {\n              display: \"flex\",\n              justifyContent: \"center\",\n              alignItems: \"center\"\n            },\n            children: [\n              \" \",\n              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n                className: \"hidden py-2 px-4 font-bold text-white md:block\",\n                children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n                  href: \"http://twitter.com/superdatas\",\n                  target: \"_blank\",\n                  rel: \"noopener noreferrer\",\n                  children: \"Twitter\"\n                })\n              }),\n              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n                href: \"http://github.com/miguelgargallo/next13-gallery-image-turbo\",\n                target: \"_blank\",\n                rel: \"noopener noreferrer\",\n                className: \"hidden py-2 px-4 font-bold text-white md:block\",\n                children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"picture\", {\n                  children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"img\", {\n                    src: \"https://img.shields.io/github/stars/miguelgargallo/Next13-gallery-image-turbo?style=social\",\n                    alt: \"Landscape picture\",\n                    width: 100,\n                    height: 20\n                  })\n                })\n              }),\n              \" \",\n              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Version, {})\n            ]\n          })\n        ]\n      })\n    ]\n  });\n};\n\n// src/MenuPylar.tsx\nvar import_jsx_runtime3 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar MenuPylar = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"div\", {\n    className: \"flex hidden flex-row items-center justify-between bg-gradient-to-r from-blue-400 to-blue-500 sm:block\",\n    children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(\"div\", {\n      className: \"flex flex-row\",\n      children: [\n        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"a\", {\n            href: \"/blog\",\n            children: \"Our Daily Work\"\n          })\n        }),\n        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"a\", {\n            href: \"/what-is-pylar\",\n            children: \"What is Pylar AI\"\n          })\n        }),\n        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"a\", {\n            href: \"/pylar-license\",\n            children: \"License\"\n          })\n        })\n      ]\n    })\n  });\n};\n\n// src/TitlePylar.tsx\nvar import_jsx_runtime4 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar TitlePylar = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(\"div\", {\n    children: [\n      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(\"h1\", {\n        className: \"py-8 text-center text-5xl font-bold\",\n        children: [\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.5, duration: 1.5 },\n            children: \"P\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.6, duration: 1.5 },\n            children: \"y\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.7, duration: 1.5 },\n            children: \"l\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.8, duration: 1.5 },\n            children: \"a\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.9, duration: 1.5 },\n            children: \"r\\u2122\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1, duration: 1.5 },\n            children: \"\\xA0\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1.1, duration: 1.5 },\n            children: \"A\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1.2, duration: 1.5 },\n            children: \"I\"\n          })\n        ]\n      }),\n      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(motion.h2, {\n        className: \"py-8 text-center text-4xl font-bold\",\n        initial: { opacity: 0 },\n        animate: { opacity: 1 },\n        transition: { delay: 1.4, duration: 1.5 },\n        children: [\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"Py\"\n          }),\n          \"thon\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"L\"\n          }),\n          \"earning\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"A\"\n          }),\n          \"rtificial\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"R\"\n          }),\n          \"esearch\\u2122\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-black\",\n            children: \" \"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"A\"\n          }),\n          \"rtificial\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"I\"\n          }),\n          \"ntelligence\",\n          \" \"\n        ]\n      })\n    ]\n  });\n};\n\n// src/ListPylar.tsx\nvar import_jsx_runtime5 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar ListPylar = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"div\", {\n    className: \"mt-8 flex flex-row justify-center\",\n    children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(\"div\", {\n      className: \"flex w-3/4 flex-col\",\n      children: [\n        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"h2\", {\n          className: \"text-2xl font-bold\",\n          children: \"Welcome to the Pylar AI Blog\"\n        }),\n        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(\"p\", {\n          className: \"mt-4 text-lg\",\n          children: [\n            \"Pylar AI is:\",\n            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(\"ul\", {\n              className: \"list-inside list-disc\",\n              children: [\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"li\", {\n                  children: \"Generative art results\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"a\", {\n                  children: \"What is generative art? Generative art is a form of art that uses a computer to create art. The computer is programmed to create art based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"li\", {\n                  children: \"Promt Engineering design\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"a\", {\n                  children: \"Promt Engineering is a form of engineering that uses a computer to create engineering. The computer is programmed to create engineering based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"li\", {\n                  children: \"StableDiffusion 2.0 modified\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"a\", {\n                  children: \"StableDiffusion 2.0 is a computer program that is used to create art based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                })\n              ]\n            })\n          ]\n        })\n      ]\n    })\n  });\n};\n\n// src/Footer.tsx\nvar import_jsx_runtime6 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar Footer = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(\"footer\", {\n    className: \"bg-white py-8 text-center\",\n    children: [\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"div\", {\n        children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(\"a\", {\n          children: [\n            \"Made with \\u2764\\uFE0F by\",\n            \" \",\n            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"a\", {\n              href: \"https://twitter.com/miguelgargallo\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hover:text-blue text-indigo-600\",\n              children: \"Miguel Gargallo\"\n            }),\n            \".\"\n          ]\n        })\n      }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"div\", {\n        children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(\"a\", {\n          children: [\n            \"2022 \\xA9\",\n            \" \",\n            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"a\", {\n              href: \"https://huggingface.co/spaces/superdatas/LICENSE\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hover:text-blue text-indigo-600\",\n              children: \"Pylar\\u2122 AI creative ML license\"\n            }),\n            \".\"\n          ]\n        })\n      }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"div\", {\n        className: \"hidden sm:block\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"div\", {\n          className: \"flex w-full items-center justify-center\",\n          children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"a\", {\n            href: \"https://huggingface.co/spaces/superdatas/LICENSE\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            className: \"hidden p-2 md:block\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"picture\", {\n              children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"img\", {\n                src: \"https://huggingface.co/front/assets/huggingface_logo.svg\",\n                alt: \"Landscape picture\",\n                width: 40,\n                height: 20\n              })\n            })\n          })\n        })\n      }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"p\", {\n        children: \"Thanks for your time.\"\n      })\n    ]\n  });\n};\n\n// src/Scrollable.tsx\nvar import_jsx_runtime7 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar Scrollable = () => {\n  const { scrollYProgress } = useScroll();\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(motion.div, {\n    className: \"progress-bar\",\n    style: { scaleX: scrollYProgress }\n  });\n};\n\n// src/BlogPylar/blog.tsx\nvar import_jsx_runtime8 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar ELEMENTS2 = 5;\nvar blog = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(\"div\", {\n    children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: \"95\",\n      height: \"95\",\n      stroke: \"#FFF\",\n      \"stroke-width\": \"0\",\n      viewBox: \"0 0 95 95\",\n      className: \"m-2 rounded-xl py-2 shadow-md hover:shadow-xl\",\n      style: k(ELEMENTS2),\n      children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(\"path\", {\n        d: \"M32.816,12.95,30.349,8.568h4.78a.439.439,0,0,1,.346.2l.931,1.534c.558.92,1.225,2.02,1.607,2.648ZM23.975,39.495a.339.339,0,0,1-.315.207H18.772l7.595-13.635a.731.731,0,0,0-.636-1.087h0L12.787,25l-2.574-4.456H29.076c.011,0,.02,0,.031,0a.677.677,0,0,0,.217-.045l.047-.02a.722.722,0,0,0,.346-.313l3.108-5.745h5.13Zm-6.468-.518-.613-1.009c-.785-1.3-1.791-2.955-1.9-3.137a.385.385,0,0,1,.024-.355l4.457-8.027,5.019-.006ZM8.948,30.444,6.453,26.011,8.968,21.3l2.522,4.367C10.706,27.14,9.483,29.442,8.948,30.444Zm-3.348.69H2.881a.443.443,0,0,1-.343-.2L1.726,29.6C1.147,28.641.409,27.425,0,26.752H5.2l2.466,4.383ZM14.037.208A.338.338,0,0,1,14.351,0h4.91L11.646,13.636c-.006.011-.01.023-.016.035s-.021.046-.03.07-.015.046-.021.069-.011.044-.014.066a.648.648,0,0,0-.008.081c0,.012,0,.023,0,.036s0,.018,0,.027a.591.591,0,0,0,.008.079.538.538,0,0,0,.012.066c.006.023.013.045.021.068s.016.045.025.066.021.041.033.062.023.04.037.059a.644.644,0,0,0,.045.055c.016.017.031.035.048.051s.035.029.053.043a.634.634,0,0,0,.063.045l.023.016c.008,0,.018.006.027.011a.729.729,0,0,0,.119.048c.015,0,.029.01.044.013a.7.7,0,0,0,.164.021h.33l12.619-.017c.334.58.957,1.673,1.489,2.6q.612,1.072,1.01,1.768H8.949c-.008,0-.016,0-.024,0a.725.725,0,0,0-.631.382L5.185,25.29H.059Zm6.479.534.456.75c.8,1.321,1.932,3.185,2.052,3.379A.383.383,0,0,1,23,5.227l-4.457,8.027-5.017.006Zm8.546,8.511,2.5,4.435-2.545,4.7c-.3-.529-.68-1.189-1.034-1.808-.7-1.224-1.208-2.115-1.495-2.613C27.028,12.977,28.462,10.349,29.062,9.253Z\",\n        id: \"Fill-1\",\n        className: \"fill-yellow-500\"\n      })\n    })\n  });\n};\n\n// src/BlogPylar/post12032022.tsx\nvar import_jsx_runtime9 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar ELEMENTS3 = 5;\nvar post12032022 = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\"div\", {\n    children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: \"95\",\n      height: \"95\",\n      stroke: \"#FFF\",\n      \"stroke-width\": \"0\",\n      viewBox: \"0 0 95 95\",\n      className: \"m-2 rounded-xl py-2 shadow-md hover:shadow-xl\",\n      style: k(ELEMENTS3),\n      children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\"path\", {\n        d: \"M32.816,12.95,30.349,8.568h4.78a.439.439,0,0,1,.346.2l.931,1.534c.558.92,1.225,2.02,1.607,2.648ZM23.975,39.495a.339.339,0,0,1-.315.207H18.772l7.595-13.635a.731.731,0,0,0-.636-1.087h0L12.787,25l-2.574-4.456H29.076c.011,0,.02,0,.031,0a.677.677,0,0,0,.217-.045l.047-.02a.722.722,0,0,0,.346-.313l3.108-5.745h5.13Zm-6.468-.518-.613-1.009c-.785-1.3-1.791-2.955-1.9-3.137a.385.385,0,0,1,.024-.355l4.457-8.027,5.019-.006ZM8.948,30.444,6.453,26.011,8.968,21.3l2.522,4.367C10.706,27.14,9.483,29.442,8.948,30.444Zm-3.348.69H2.881a.443.443,0,0,1-.343-.2L1.726,29.6C1.147,28.641.409,27.425,0,26.752H5.2l2.466,4.383ZM14.037.208A.338.338,0,0,1,14.351,0h4.91L11.646,13.636c-.006.011-.01.023-.016.035s-.021.046-.03.07-.015.046-.021.069-.011.044-.014.066a.648.648,0,0,0-.008.081c0,.012,0,.023,0,.036s0,.018,0,.027a.591.591,0,0,0,.008.079.538.538,0,0,0,.012.066c.006.023.013.045.021.068s.016.045.025.066.021.041.033.062.023.04.037.059a.644.644,0,0,0,.045.055c.016.017.031.035.048.051s.035.029.053.043a.634.634,0,0,0,.063.045l.023.016c.008,0,.018.006.027.011a.729.729,0,0,0,.119.048c.015,0,.029.01.044.013a.7.7,0,0,0,.164.021h.33l12.619-.017c.334.58.957,1.673,1.489,2.6q.612,1.072,1.01,1.768H8.949c-.008,0-.016,0-.024,0a.725.725,0,0,0-.631.382L5.185,25.29H.059Zm6.479.534.456.75c.8,1.321,1.932,3.185,2.052,3.379A.383.383,0,0,1,23,5.227l-4.457,8.027-5.017.006Zm8.546,8.511,2.5,4.435-2.545,4.7c-.3-.529-.68-1.189-1.034-1.808-.7-1.224-1.208-2.115-1.495-2.613C27.028,12.977,28.462,10.349,29.062,9.253Z\",\n        id: \"Fill-1\",\n        className: \"fill-yellow-500\"\n      })\n    })\n  });\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzS0FBc0s7QUFDOUssUUFBUSxLQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQSxjQUFjLCtEQUErRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtB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TTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsTUFBTSxXQUFXO0FBQzdELHdCQUF3QixnQkFBZ0IsSUFBSSxnQkFBZ0I7QUFDNUQ7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYyxJQUFJLGNBQWM7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVGQUF1RjtBQUN2SDtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0NBQWtDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzRUFBc0U7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQW9EO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFxRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnREFBZ0QsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixrQ0FBa0MsZUFBZSxJQUFJLGVBQWU7QUFDcEU7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlEQUFpRDtBQUM3RCxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGtGQUFrRjtBQUNsRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyw0Q0FBbUI7QUFDckQ7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLDRDQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsNENBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sQ0FVTCIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9wYWNrYWdlcy91aS9kaXN0L2luZGV4LmpzP2JlNTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYTIsIGIyKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYjIgfHwgKGIyID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiMiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYTIsIHByb3AsIGIyW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIyKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIyLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEyLCBwcm9wLCBiMltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTI7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYTIsIGIyKSA9PiBfX2RlZlByb3BzKGEyLCBfX2dldE93blByb3BEZXNjcyhiMikpO1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX19lc20gPSAoZm4sIHJlcykgPT4gZnVuY3Rpb24gX19pbml0KCkge1xuICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltfX2dldE93blByb3BOYW1lcyhmbilbMF1dKShmbiA9IDApKSwgcmVzO1xufTtcbnZhciBfX2NvbW1vbkpTID0gKGNiMiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiMltfX2dldE93blByb3BOYW1lcyhjYjIpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL21lbW9pemUvZGlzdC9tZW1vaXplLmVzbS5qc1xuZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIGlmIChjYWNoZVthcmddID09PSB2b2lkIDApXG4gICAgICBjYWNoZVthcmddID0gZm4oYXJnKTtcbiAgICByZXR1cm4gY2FjaGVbYXJnXTtcbiAgfTtcbn1cbnZhciBtZW1vaXplX2VzbV9kZWZhdWx0O1xudmFyIGluaXRfbWVtb2l6ZV9lc20gPSBfX2VzbSh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL21lbW9pemUvZGlzdC9tZW1vaXplLmVzbS5qc1wiKCkge1xuICAgIG1lbW9pemVfZXNtX2RlZmF1bHQgPSBtZW1vaXplO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL2lzLXByb3AtdmFsaWQvZGlzdC9pcy1wcm9wLXZhbGlkLmVzbS5qc1xudmFyIGlzX3Byb3BfdmFsaWRfZXNtX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGlzX3Byb3BfdmFsaWRfZXNtX2V4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gaXNfcHJvcF92YWxpZF9lc21fZGVmYXVsdFxufSk7XG52YXIgcmVhY3RQcm9wc1JlZ2V4LCBpbmRleCwgaXNfcHJvcF92YWxpZF9lc21fZGVmYXVsdDtcbnZhciBpbml0X2lzX3Byb3BfdmFsaWRfZXNtID0gX19lc20oe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9pcy1wcm9wLXZhbGlkL2Rpc3QvaXMtcHJvcC12YWxpZC5lc20uanNcIigpIHtcbiAgICBpbml0X21lbW9pemVfZXNtKCk7XG4gICAgcmVhY3RQcm9wc1JlZ2V4ID0gL14oKGNoaWxkcmVufGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MfGtleXxyZWZ8YXV0b0ZvY3VzfGRlZmF1bHRWYWx1ZXxkZWZhdWx0Q2hlY2tlZHxpbm5lckhUTUx8c3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nfHN1cHByZXNzSHlkcmF0aW9uV2FybmluZ3x2YWx1ZUxpbmt8YWNjZXB0fGFjY2VwdENoYXJzZXR8YWNjZXNzS2V5fGFjdGlvbnxhbGxvd3xhbGxvd1VzZXJNZWRpYXxhbGxvd1BheW1lbnRSZXF1ZXN0fGFsbG93RnVsbFNjcmVlbnxhbGxvd1RyYW5zcGFyZW5jeXxhbHR8YXN5bmN8YXV0b0NvbXBsZXRlfGF1dG9QbGF5fGNhcHR1cmV8Y2VsbFBhZGRpbmd8Y2VsbFNwYWNpbmd8Y2hhbGxlbmdlfGNoYXJTZXR8Y2hlY2tlZHxjaXRlfGNsYXNzSUR8Y2xhc3NOYW1lfGNvbHN8Y29sU3Bhbnxjb250ZW50fGNvbnRlbnRFZGl0YWJsZXxjb250ZXh0TWVudXxjb250cm9sc3xjb250cm9sc0xpc3R8Y29vcmRzfGNyb3NzT3JpZ2lufGRhdGF8ZGF0ZVRpbWV8ZGVjb2Rpbmd8ZGVmYXVsdHxkZWZlcnxkaXJ8ZGlzYWJsZWR8ZGlzYWJsZVBpY3R1cmVJblBpY3R1cmV8ZG93bmxvYWR8ZHJhZ2dhYmxlfGVuY1R5cGV8Zm9ybXxmb3JtQWN0aW9ufGZvcm1FbmNUeXBlfGZvcm1NZXRob2R8Zm9ybU5vVmFsaWRhdGV8Zm9ybVRhcmdldHxmcmFtZUJvcmRlcnxoZWFkZXJzfGhlaWdodHxoaWRkZW58aGlnaHxocmVmfGhyZWZMYW5nfGh0bWxGb3J8aHR0cEVxdWl2fGlkfGlucHV0TW9kZXxpbnRlZ3JpdHl8aXN8a2V5UGFyYW1zfGtleVR5cGV8a2luZHxsYWJlbHxsYW5nfGxpc3R8bG9hZGluZ3xsb29wfGxvd3xtYXJnaW5IZWlnaHR8bWFyZ2luV2lkdGh8bWF4fG1heExlbmd0aHxtZWRpYXxtZWRpYUdyb3VwfG1ldGhvZHxtaW58bWluTGVuZ3RofG11bHRpcGxlfG11dGVkfG5hbWV8bm9uY2V8bm9WYWxpZGF0ZXxvcGVufG9wdGltdW18cGF0dGVybnxwbGFjZWhvbGRlcnxwbGF5c0lubGluZXxwb3N0ZXJ8cHJlbG9hZHxwcm9maWxlfHJhZGlvR3JvdXB8cmVhZE9ubHl8cmVmZXJyZXJQb2xpY3l8cmVsfHJlcXVpcmVkfHJldmVyc2VkfHJvbGV8cm93c3xyb3dTcGFufHNhbmRib3h8c2NvcGV8c2NvcGVkfHNjcm9sbGluZ3xzZWFtbGVzc3xzZWxlY3RlZHxzaGFwZXxzaXplfHNpemVzfHNsb3R8c3BhbnxzcGVsbENoZWNrfHNyY3xzcmNEb2N8c3JjTGFuZ3xzcmNTZXR8c3RhcnR8c3RlcHxzdHlsZXxzdW1tYXJ5fHRhYkluZGV4fHRhcmdldHx0aXRsZXx0eXBlfHVzZU1hcHx2YWx1ZXx3aWR0aHx3bW9kZXx3cmFwfGFib3V0fGRhdGF0eXBlfGlubGlzdHxwcmVmaXh8cHJvcGVydHl8cmVzb3VyY2V8dHlwZW9mfHZvY2FifGF1dG9DYXBpdGFsaXplfGF1dG9Db3JyZWN0fGF1dG9TYXZlfGNvbG9yfGluZXJ0fGl0ZW1Qcm9wfGl0ZW1TY29wZXxpdGVtVHlwZXxpdGVtSUR8aXRlbVJlZnxvbnxyZXN1bHRzfHNlY3VyaXR5fHVuc2VsZWN0YWJsZXxhY2NlbnRIZWlnaHR8YWNjdW11bGF0ZXxhZGRpdGl2ZXxhbGlnbm1lbnRCYXNlbGluZXxhbGxvd1Jlb3JkZXJ8YWxwaGFiZXRpY3xhbXBsaXR1ZGV8YXJhYmljRm9ybXxhc2NlbnR8YXR0cmlidXRlTmFtZXxhdHRyaWJ1dGVUeXBlfGF1dG9SZXZlcnNlfGF6aW11dGh8YmFzZUZyZXF1ZW5jeXxiYXNlbGluZVNoaWZ0fGJhc2VQcm9maWxlfGJib3h8YmVnaW58Ymlhc3xieXxjYWxjTW9kZXxjYXBIZWlnaHR8Y2xpcHxjbGlwUGF0aFVuaXRzfGNsaXBQYXRofGNsaXBSdWxlfGNvbG9ySW50ZXJwb2xhdGlvbnxjb2xvckludGVycG9sYXRpb25GaWx0ZXJzfGNvbG9yUHJvZmlsZXxjb2xvclJlbmRlcmluZ3xjb250ZW50U2NyaXB0VHlwZXxjb250ZW50U3R5bGVUeXBlfGN1cnNvcnxjeHxjeXxkfGRlY2VsZXJhdGV8ZGVzY2VudHxkaWZmdXNlQ29uc3RhbnR8ZGlyZWN0aW9ufGRpc3BsYXl8ZGl2aXNvcnxkb21pbmFudEJhc2VsaW5lfGR1cnxkeHxkeXxlZGdlTW9kZXxlbGV2YXRpb258ZW5hYmxlQmFja2dyb3VuZHxlbmR8ZXhwb25lbnR8ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHxmaWxsfGZpbGxPcGFjaXR5fGZpbGxSdWxlfGZpbHRlcnxmaWx0ZXJSZXN8ZmlsdGVyVW5pdHN8Zmxvb2RDb2xvcnxmbG9vZE9wYWNpdHl8Zm9jdXNhYmxlfGZvbnRGYW1pbHl8Zm9udFNpemV8Zm9udFNpemVBZGp1c3R8Zm9udFN0cmV0Y2h8Zm9udFN0eWxlfGZvbnRWYXJpYW50fGZvbnRXZWlnaHR8Zm9ybWF0fGZyb218ZnJ8Znh8Znl8ZzF8ZzJ8Z2x5cGhOYW1lfGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsfGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbHxnbHlwaFJlZnxncmFkaWVudFRyYW5zZm9ybXxncmFkaWVudFVuaXRzfGhhbmdpbmd8aG9yaXpBZHZYfGhvcml6T3JpZ2luWHxpZGVvZ3JhcGhpY3xpbWFnZVJlbmRlcmluZ3xpbnxpbjJ8aW50ZXJjZXB0fGt8azF8azJ8azN8azR8a2VybmVsTWF0cml4fGtlcm5lbFVuaXRMZW5ndGh8a2VybmluZ3xrZXlQb2ludHN8a2V5U3BsaW5lc3xrZXlUaW1lc3xsZW5ndGhBZGp1c3R8bGV0dGVyU3BhY2luZ3xsaWdodGluZ0NvbG9yfGxpbWl0aW5nQ29uZUFuZ2xlfGxvY2FsfG1hcmtlckVuZHxtYXJrZXJNaWR8bWFya2VyU3RhcnR8bWFya2VySGVpZ2h0fG1hcmtlclVuaXRzfG1hcmtlcldpZHRofG1hc2t8bWFza0NvbnRlbnRVbml0c3xtYXNrVW5pdHN8bWF0aGVtYXRpY2FsfG1vZGV8bnVtT2N0YXZlc3xvZmZzZXR8b3BhY2l0eXxvcGVyYXRvcnxvcmRlcnxvcmllbnR8b3JpZW50YXRpb258b3JpZ2lufG92ZXJmbG93fG92ZXJsaW5lUG9zaXRpb258b3ZlcmxpbmVUaGlja25lc3N8cGFub3NlMXxwYWludE9yZGVyfHBhdGhMZW5ndGh8cGF0dGVybkNvbnRlbnRVbml0c3xwYXR0ZXJuVHJhbnNmb3JtfHBhdHRlcm5Vbml0c3xwb2ludGVyRXZlbnRzfHBvaW50c3xwb2ludHNBdFh8cG9pbnRzQXRZfHBvaW50c0F0WnxwcmVzZXJ2ZUFscGhhfHByZXNlcnZlQXNwZWN0UmF0aW98cHJpbWl0aXZlVW5pdHN8cnxyYWRpdXN8cmVmWHxyZWZZfHJlbmRlcmluZ0ludGVudHxyZXBlYXRDb3VudHxyZXBlYXREdXJ8cmVxdWlyZWRFeHRlbnNpb25zfHJlcXVpcmVkRmVhdHVyZXN8cmVzdGFydHxyZXN1bHR8cm90YXRlfHJ4fHJ5fHNjYWxlfHNlZWR8c2hhcGVSZW5kZXJpbmd8c2xvcGV8c3BhY2luZ3xzcGVjdWxhckNvbnN0YW50fHNwZWN1bGFyRXhwb25lbnR8c3BlZWR8c3ByZWFkTWV0aG9kfHN0YXJ0T2Zmc2V0fHN0ZERldmlhdGlvbnxzdGVtaHxzdGVtdnxzdGl0Y2hUaWxlc3xzdG9wQ29sb3J8c3RvcE9wYWNpdHl8c3RyaWtldGhyb3VnaFBvc2l0aW9ufHN0cmlrZXRocm91Z2hUaGlja25lc3N8c3RyaW5nfHN0cm9rZXxzdHJva2VEYXNoYXJyYXl8c3Ryb2tlRGFzaG9mZnNldHxzdHJva2VMaW5lY2FwfHN0cm9rZUxpbmVqb2lufHN0cm9rZU1pdGVybGltaXR8c3Ryb2tlT3BhY2l0eXxzdHJva2VXaWR0aHxzdXJmYWNlU2NhbGV8c3lzdGVtTGFuZ3VhZ2V8dGFibGVWYWx1ZXN8dGFyZ2V0WHx0YXJnZXRZfHRleHRBbmNob3J8dGV4dERlY29yYXRpb258dGV4dFJlbmRlcmluZ3x0ZXh0TGVuZ3RofHRvfHRyYW5zZm9ybXx1MXx1Mnx1bmRlcmxpbmVQb3NpdGlvbnx1bmRlcmxpbmVUaGlja25lc3N8dW5pY29kZXx1bmljb2RlQmlkaXx1bmljb2RlUmFuZ2V8dW5pdHNQZXJFbXx2QWxwaGFiZXRpY3x2SGFuZ2luZ3x2SWRlb2dyYXBoaWN8dk1hdGhlbWF0aWNhbHx2YWx1ZXN8dmVjdG9yRWZmZWN0fHZlcnNpb258dmVydEFkdll8dmVydE9yaWdpblh8dmVydE9yaWdpbll8dmlld0JveHx2aWV3VGFyZ2V0fHZpc2liaWxpdHl8d2lkdGhzfHdvcmRTcGFjaW5nfHdyaXRpbmdNb2RlfHh8eEhlaWdodHx4MXx4Mnx4Q2hhbm5lbFNlbGVjdG9yfHhsaW5rQWN0dWF0ZXx4bGlua0FyY3JvbGV8eGxpbmtIcmVmfHhsaW5rUm9sZXx4bGlua1Nob3d8eGxpbmtUaXRsZXx4bGlua1R5cGV8eG1sQmFzZXx4bWxuc3x4bWxuc1hsaW5rfHhtbExhbmd8eG1sU3BhY2V8eXx5MXx5Mnx5Q2hhbm5lbFNlbGVjdG9yfHp8em9vbUFuZFBhbnxmb3J8Y2xhc3N8YXV0b2ZvY3VzKXwoKFtEZF1bQWFdW1R0XVtBYV18W0FhXVtScl1bSWldW0FhXXx4KS0uKikpJC87XG4gICAgaW5kZXggPSBtZW1vaXplX2VzbV9kZWZhdWx0KFxuICAgICAgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gcmVhY3RQcm9wc1JlZ2V4LnRlc3QocHJvcCkgfHwgcHJvcC5jaGFyQ29kZUF0KDApID09PSAxMTEgJiYgcHJvcC5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgcHJvcC5jaGFyQ29kZUF0KDIpIDwgOTE7XG4gICAgICB9XG4gICAgKTtcbiAgICBpc19wcm9wX3ZhbGlkX2VzbV9kZWZhdWx0ID0gaW5kZXg7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5qc1xudmFyIHJlcXVpcmVfdHNsaWIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgX19leHRlbmRzMztcbiAgICB2YXIgX19hc3NpZ24zO1xuICAgIHZhciBfX3Jlc3QzO1xuICAgIHZhciBfX2RlY29yYXRlMztcbiAgICB2YXIgX19wYXJhbTM7XG4gICAgdmFyIF9fbWV0YWRhdGEzO1xuICAgIHZhciBfX2F3YWl0ZXIzO1xuICAgIHZhciBfX2dlbmVyYXRvcjM7XG4gICAgdmFyIF9fZXhwb3J0U3RhcjM7XG4gICAgdmFyIF9fdmFsdWVzMztcbiAgICB2YXIgX19yZWFkMztcbiAgICB2YXIgX19zcHJlYWQzO1xuICAgIHZhciBfX3NwcmVhZEFycmF5czM7XG4gICAgdmFyIF9fc3ByZWFkQXJyYXkzO1xuICAgIHZhciBfX2F3YWl0MztcbiAgICB2YXIgX19hc3luY0dlbmVyYXRvcjM7XG4gICAgdmFyIF9fYXN5bmNEZWxlZ2F0b3IzO1xuICAgIHZhciBfX2FzeW5jVmFsdWVzMztcbiAgICB2YXIgX19tYWtlVGVtcGxhdGVPYmplY3QzO1xuICAgIHZhciBfX2ltcG9ydFN0YXIzO1xuICAgIHZhciBfX2ltcG9ydERlZmF1bHQzO1xuICAgIHZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MztcbiAgICB2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDM7XG4gICAgdmFyIF9fY2xhc3NQcml2YXRlRmllbGRJbjM7XG4gICAgdmFyIF9fY3JlYXRlQmluZGluZzM7XG4gICAgKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xuICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uKGV4cG9ydHMyKSB7XG4gICAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzMikpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUyLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihtb2R1bGUyLmV4cG9ydHMpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMyLCBwcmV2aW91cykge1xuICAgICAgICBpZiAoZXhwb3J0czIgIT09IHJvb3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwb3J0czIuX19lc01vZHVsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpZDIsIHYpIHtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0czJbaWQyXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQyLCB2KSA6IHY7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSkoZnVuY3Rpb24oZXhwb3J0ZXIpIHtcbiAgICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgIGQyLl9fcHJvdG9fXyA9IGIyO1xuICAgICAgfSB8fCBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gYjIpXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiMiwgcDIpKVxuICAgICAgICAgICAgZDJbcDJdID0gYjJbcDJdO1xuICAgICAgfTtcbiAgICAgIF9fZXh0ZW5kczMgPSBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiMiAhPT0gXCJmdW5jdGlvblwiICYmIGIyICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIyKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZDIsIGIyKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQyO1xuICAgICAgICB9XG4gICAgICAgIGQyLnByb3RvdHlwZSA9IGIyID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiMikgOiAoX18ucHJvdG90eXBlID0gYjIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgICB9O1xuICAgICAgX19hc3NpZ24zID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkyID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkyIDwgbjsgaTIrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaTJdO1xuICAgICAgICAgIGZvciAodmFyIHAyIGluIHMpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHAyKSlcbiAgICAgICAgICAgICAgdFtwMl0gPSBzW3AyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH07XG4gICAgICBfX3Jlc3QzID0gZnVuY3Rpb24ocywgZSkge1xuICAgICAgICB2YXIgdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBzKVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcDIpICYmIGUuaW5kZXhPZihwMikgPCAwKVxuICAgICAgICAgICAgdFtwMl0gPSBzW3AyXTtcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIGZvciAodmFyIGkyID0gMCwgcDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpMiA8IHAyLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwMltpMl0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcDJbaTJdKSlcbiAgICAgICAgICAgICAgdFtwMltpMl1dID0gc1twMltpMl1dO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9O1xuICAgICAgX19kZWNvcmF0ZTMgPSBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgICAgICB2YXIgYzMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYzMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQyO1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSlcbiAgICAgICAgICAgIGlmIChkMiA9IGRlY29yYXRvcnNbaTJdKVxuICAgICAgICAgICAgICByID0gKGMzIDwgMyA/IGQyKHIpIDogYzMgPiAzID8gZDIodGFyZ2V0LCBrZXksIHIpIDogZDIodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgICAgICByZXR1cm4gYzMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgICAgIH07XG4gICAgICBfX3BhcmFtMyA9IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIF9fbWV0YWRhdGEzID0gZnVuY3Rpb24obWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xuICAgICAgfTtcbiAgICAgIF9fYXdhaXRlcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIF9fZ2VuZXJhdG9yMyA9IGZ1bmN0aW9uKHRoaXNBcmcsIGJvZHkpIHtcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodFswXSAmIDEpXG4gICAgICAgICAgICB0aHJvdyB0WzFdO1xuICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmMiwgeSwgdCwgZzI7XG4gICAgICAgIHJldHVybiBnMiA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZzJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KSwgZzI7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICAgIGlmIChmMilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICAgIHdoaWxlIChfKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGYyID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpXG4gICAgICAgICAgICAgICAgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodFsyXSlcbiAgICAgICAgICAgICAgICAgICAgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgb3AgPSBbNiwgZV07XG4gICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgZjIgPSB0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BbMF0gJiA1KVxuICAgICAgICAgICAgdGhyb3cgb3BbMV07XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fZXhwb3J0U3RhcjMgPSBmdW5jdGlvbihtLCBvKSB7XG4gICAgICAgIGZvciAodmFyIHAyIGluIG0pXG4gICAgICAgICAgaWYgKHAyICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHAyKSlcbiAgICAgICAgICAgIF9fY3JlYXRlQmluZGluZzMobywgbSwgcDIpO1xuICAgICAgfTtcbiAgICAgIF9fY3JlYXRlQmluZGluZzMgPSBPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24obywgbSwgazIsIGsyMikge1xuICAgICAgICBpZiAoazIyID09PSB2b2lkIDApXG4gICAgICAgICAgazIyID0gazI7XG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrMik7XG4gICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtW2syXTtcbiAgICAgICAgICB9IH07XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyMiwgZGVzYyk7XG4gICAgICB9IDogZnVuY3Rpb24obywgbSwgazIsIGsyMikge1xuICAgICAgICBpZiAoazIyID09PSB2b2lkIDApXG4gICAgICAgICAgazIyID0gazI7XG4gICAgICAgIG9bazIyXSA9IG1bazJdO1xuICAgICAgfTtcbiAgICAgIF9fdmFsdWVzMyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpMiA9IDA7XG4gICAgICAgIGlmIChtKVxuICAgICAgICAgIHJldHVybiBtLmNhbGwobyk7XG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChvICYmIGkyID49IG8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baTIrK10sIGRvbmU6ICFvIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgfTtcbiAgICAgIF9fcmVhZDMgPSBmdW5jdGlvbihvLCBuKSB7XG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB2YXIgaTIgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaTIubmV4dCgpKS5kb25lKVxuICAgICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBlID0geyBlcnJvciB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaTJbXCJyZXR1cm5cIl0pKVxuICAgICAgICAgICAgICBtLmNhbGwoaTIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgICAgdGhyb3cgZS5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgfTtcbiAgICAgIF9fc3ByZWFkMyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpMiA9IDA7IGkyIDwgYXJndW1lbnRzLmxlbmd0aDsgaTIrKylcbiAgICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQzKGFyZ3VtZW50c1tpMl0pKTtcbiAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgfTtcbiAgICAgIF9fc3ByZWFkQXJyYXlzMyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBzID0gMCwgaTIgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkyIDwgaWw7IGkyKyspXG4gICAgICAgICAgcyArPSBhcmd1bWVudHNbaTJdLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrMiA9IDAsIGkyID0gMDsgaTIgPCBpbDsgaTIrKylcbiAgICAgICAgICBmb3IgKHZhciBhMiA9IGFyZ3VtZW50c1tpMl0sIGogPSAwLCBqbCA9IGEyLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsyKyspXG4gICAgICAgICAgICByW2syXSA9IGEyW2pdO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH07XG4gICAgICBfX3NwcmVhZEFycmF5MyA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpMiA8IGw7IGkyKyspIHtcbiAgICAgICAgICAgIGlmIChhciB8fCAhKGkyIGluIGZyb20pKSB7XG4gICAgICAgICAgICAgIGlmICghYXIpXG4gICAgICAgICAgICAgICAgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpMik7XG4gICAgICAgICAgICAgIGFyW2kyXSA9IGZyb21baTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG4gICAgICB9O1xuICAgICAgX19hd2FpdDMgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdDMgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdDModik7XG4gICAgICB9O1xuICAgICAgX19hc3luY0dlbmVyYXRvcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICB2YXIgZzIgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGkyLCBxID0gW107XG4gICAgICAgIHJldHVybiBpMiA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpMltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgaTI7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICAgIGlmIChnMltuXSlcbiAgICAgICAgICAgIGkyW25dID0gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oYTIsIGIyKSB7XG4gICAgICAgICAgICAgICAgcS5wdXNoKFtuLCB2LCBhMiwgYjJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RlcChnMltuXSh2KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgc2V0dGxlKHFbMF1bM10sIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHtcbiAgICAgICAgICByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdDMgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VtZShcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VtZShcInRocm93XCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZjIsIHYpIHtcbiAgICAgICAgICBpZiAoZjIodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpXG4gICAgICAgICAgICByZXN1bWUocVswXVswXSwgcVswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX2FzeW5jRGVsZWdhdG9yMyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdmFyIGkyLCBwMjtcbiAgICAgICAgcmV0dXJuIGkyID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpMltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGkyO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYyKSB7XG4gICAgICAgICAgaTJbbl0gPSBvW25dID8gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIChwMiA9ICFwMikgPyB7IHZhbHVlOiBfX2F3YWl0MyhvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZjIgPyBmMih2KSA6IHY7XG4gICAgICAgICAgfSA6IGYyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19hc3luY1ZhbHVlczMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTI7XG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlczMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaTIgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaTJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGkyKTtcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgICAgaTJbbl0gPSBvW25dICYmIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQyLCB2KSB7XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odjIpIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyB2YWx1ZTogdjIsIGRvbmU6IGQyIH0pO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX21ha2VUZW1wbGF0ZU9iamVjdDMgPSBmdW5jdGlvbihjb29rZWQsIHJhdykge1xuICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvb2tlZC5yYXcgPSByYXc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcbiAgICAgIH07XG4gICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xuICAgICAgfSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgfTtcbiAgICAgIF9faW1wb3J0U3RhcjMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAodmFyIGsyIGluIG1vZClcbiAgICAgICAgICAgIGlmIChrMiAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgazIpKVxuICAgICAgICAgICAgICBfX2NyZWF0ZUJpbmRpbmczKHJlc3VsdCwgbW9kLCBrMik7XG4gICAgICAgIH1cbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfX2ltcG9ydERlZmF1bHQzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbiAgICAgIH07XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MyA9IGZ1bmN0aW9uKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZjIpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmMilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYyIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZjIgOiBraW5kID09PSBcImFcIiA/IGYyLmNhbGwocmVjZWl2ZXIpIDogZjIgPyBmMi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG4gICAgICB9O1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldDMgPSBmdW5jdGlvbihyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmMikge1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJtXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmMilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYyIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgICAgICByZXR1cm4ga2luZCA9PT0gXCJhXCIgPyBmMi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmMiA/IGYyLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSwgdmFsdWU7XG4gICAgICB9O1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEluMyA9IGZ1bmN0aW9uKHN0YXRlLCByZWNlaXZlcikge1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgdHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcbiAgICAgIH07XG4gICAgICBleHBvcnRlcihcIl9fZXh0ZW5kc1wiLCBfX2V4dGVuZHMzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24zKTtcbiAgICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2RlY29yYXRlXCIsIF9fZGVjb3JhdGUzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtMyk7XG4gICAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YTMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2F3YWl0ZXJcIiwgX19hd2FpdGVyMyk7XG4gICAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yMyk7XG4gICAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19jcmVhdGVCaW5kaW5nXCIsIF9fY3JlYXRlQmluZGluZzMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlczMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkMyk7XG4gICAgICBleHBvcnRlcihcIl9fc3ByZWFkXCIsIF9fc3ByZWFkMyk7XG4gICAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzMyk7XG4gICAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlcIiwgX19zcHJlYWRBcnJheTMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2F3YWl0XCIsIF9fYXdhaXQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yMyk7XG4gICAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2FzeW5jVmFsdWVzXCIsIF9fYXN5bmNWYWx1ZXMzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19pbXBvcnRTdGFyXCIsIF9faW1wb3J0U3RhcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2ltcG9ydERlZmF1bHRcIiwgX19pbXBvcnREZWZhdWx0Myk7XG4gICAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZEluXCIsIF9fY2xhc3NQcml2YXRlRmllbGRJbjMpO1xuICAgIH0pO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzXG52YXIgcmVxdWlyZV90c2xpYjIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIF9fZXh0ZW5kczM7XG4gICAgdmFyIF9fYXNzaWduMztcbiAgICB2YXIgX19yZXN0MztcbiAgICB2YXIgX19kZWNvcmF0ZTM7XG4gICAgdmFyIF9fcGFyYW0zO1xuICAgIHZhciBfX21ldGFkYXRhMztcbiAgICB2YXIgX19hd2FpdGVyMztcbiAgICB2YXIgX19nZW5lcmF0b3IzO1xuICAgIHZhciBfX2V4cG9ydFN0YXIzO1xuICAgIHZhciBfX3ZhbHVlczM7XG4gICAgdmFyIF9fcmVhZDM7XG4gICAgdmFyIF9fc3ByZWFkMztcbiAgICB2YXIgX19zcHJlYWRBcnJheXMzO1xuICAgIHZhciBfX3NwcmVhZEFycmF5MztcbiAgICB2YXIgX19hd2FpdDM7XG4gICAgdmFyIF9fYXN5bmNHZW5lcmF0b3IzO1xuICAgIHZhciBfX2FzeW5jRGVsZWdhdG9yMztcbiAgICB2YXIgX19hc3luY1ZhbHVlczM7XG4gICAgdmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0MztcbiAgICB2YXIgX19pbXBvcnRTdGFyMztcbiAgICB2YXIgX19pbXBvcnREZWZhdWx0MztcbiAgICB2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldDM7XG4gICAgdmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQzO1xuICAgIHZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4zO1xuICAgIHZhciBfX2NyZWF0ZUJpbmRpbmczO1xuICAgIChmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcbiAgICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbihleHBvcnRzMikge1xuICAgICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0czIpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlMi5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlMi5leHBvcnRzKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzMiwgcHJldmlvdXMpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMyICE9PSByb290KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydHMyLl9fZXNNb2R1bGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaWQyLCB2KSB7XG4gICAgICAgICAgcmV0dXJuIGV4cG9ydHMyW2lkMl0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkMiwgdikgOiB2O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pKGZ1bmN0aW9uKGV4cG9ydGVyKSB7XG4gICAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGQyLCBiMikge1xuICAgICAgICBkMi5fX3Byb3RvX18gPSBiMjtcbiAgICAgIH0gfHwgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgIGZvciAodmFyIHAyIGluIGIyKVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYjIsIHAyKSlcbiAgICAgICAgICAgIGQyW3AyXSA9IGIyW3AyXTtcbiAgICAgIH07XG4gICAgICBfX2V4dGVuZHMzID0gZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYjIgIT09IFwiZnVuY3Rpb25cIiAmJiBiMiAhPT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiMikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQyLCBiMik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkMjtcbiAgICAgICAgfVxuICAgICAgICBkMi5wcm90b3R5cGUgPSBiMiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYjIpIDogKF9fLnByb3RvdHlwZSA9IGIyLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgICAgfTtcbiAgICAgIF9fYXNzaWduMyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpMiA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpMiA8IG47IGkyKyspIHtcbiAgICAgICAgICBzID0gYXJndW1lbnRzW2kyXTtcbiAgICAgICAgICBmb3IgKHZhciBwMiBpbiBzKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwMikpXG4gICAgICAgICAgICAgIHRbcDJdID0gc1twMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9O1xuICAgICAgX19yZXN0MyA9IGZ1bmN0aW9uKHMsIGUpIHtcbiAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gcylcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHAyKSAmJiBlLmluZGV4T2YocDIpIDwgMClcbiAgICAgICAgICAgIHRbcDJdID0gc1twMl07XG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDAsIHAyID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaTIgPCBwMi5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocDJbaTJdKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHAyW2kyXSkpXG4gICAgICAgICAgICAgIHRbcDJbaTJdXSA9IHNbcDJbaTJdXTtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfTtcbiAgICAgIF9fZGVjb3JhdGUzID0gZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICAgICAgdmFyIGMzID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMzIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkMjtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICh2YXIgaTIgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pXG4gICAgICAgICAgICBpZiAoZDIgPSBkZWNvcmF0b3JzW2kyXSlcbiAgICAgICAgICAgICAgciA9IChjMyA8IDMgPyBkMihyKSA6IGMzID4gMyA/IGQyKHRhcmdldCwga2V5LCByKSA6IGQyKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICAgICAgcmV0dXJuIGMzID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gICAgICB9O1xuICAgICAgX19wYXJhbTMgPSBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBfX21ldGFkYXRhMyA9IGZ1bmN0aW9uKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcbiAgICAgIH07XG4gICAgICBfX2F3YWl0ZXIzID0gZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBfX2dlbmVyYXRvcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBib2R5KSB7XG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRbMF0gJiAxKVxuICAgICAgICAgICAgdGhyb3cgdFsxXTtcbiAgICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgICAgfSwgdHJ5czogW10sIG9wczogW10gfSwgZjIsIHksIHQsIGcyO1xuICAgICAgICByZXR1cm4gZzIgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGcyW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSksIGcyO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgICBpZiAoZjIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgICB3aGlsZSAoZzIgJiYgKGcyID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoZjIgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgIGlmICh5ID0gMCwgdClcbiAgICAgICAgICAgICAgICBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICBvcCA9IFswXTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKVxuICAgICAgICAgICAgICAgICAgICBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBvcCA9IFs2LCBlXTtcbiAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBmMiA9IHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcFswXSAmIDUpXG4gICAgICAgICAgICB0aHJvdyBvcFsxXTtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19leHBvcnRTdGFyMyA9IGZ1bmN0aW9uKG0sIG8pIHtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gbSlcbiAgICAgICAgICBpZiAocDIgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcDIpKVxuICAgICAgICAgICAgX19jcmVhdGVCaW5kaW5nMyhvLCBtLCBwMik7XG4gICAgICB9O1xuICAgICAgX19jcmVhdGVCaW5kaW5nMyA9IE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbihvLCBtLCBrMiwgazIyKSB7XG4gICAgICAgIGlmIChrMjIgPT09IHZvaWQgMClcbiAgICAgICAgICBrMjIgPSBrMjtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGsyKTtcbiAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1bazJdO1xuICAgICAgICAgIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIyLCBkZXNjKTtcbiAgICAgIH0gOiBmdW5jdGlvbihvLCBtLCBrMiwgazIyKSB7XG4gICAgICAgIGlmIChrMjIgPT09IHZvaWQgMClcbiAgICAgICAgICBrMjIgPSBrMjtcbiAgICAgICAgb1trMjJdID0gbVtrMl07XG4gICAgICB9O1xuICAgICAgX192YWx1ZXMzID0gZnVuY3Rpb24obykge1xuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkyID0gMDtcbiAgICAgICAgaWYgKG0pXG4gICAgICAgICAgcmV0dXJuIG0uY2FsbChvKTtcbiAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKG8gJiYgaTIgPj0gby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpMisrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICB9O1xuICAgICAgX19yZWFkMyA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIHZhciBpMiA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpMi5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGUgPSB7IGVycm9yIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpMltcInJldHVyblwiXSkpXG4gICAgICAgICAgICAgIG0uY2FsbChpMik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXI7XG4gICAgICB9O1xuICAgICAgX19zcHJlYWQzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGFyID0gW10sIGkyID0gMDsgaTIgPCBhcmd1bWVudHMubGVuZ3RoOyBpMisrKVxuICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZDMoYXJndW1lbnRzW2kyXSkpO1xuICAgICAgICByZXR1cm4gYXI7XG4gICAgICB9O1xuICAgICAgX19zcHJlYWRBcnJheXMzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBpMiA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaTIgPCBpbDsgaTIrKylcbiAgICAgICAgICBzICs9IGFyZ3VtZW50c1tpMl0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsyID0gMCwgaTIgPSAwOyBpMiA8IGlsOyBpMisrKVxuICAgICAgICAgIGZvciAodmFyIGEyID0gYXJndW1lbnRzW2kyXSwgaiA9IDAsIGpsID0gYTIubGVuZ3RoOyBqIDwgamw7IGorKywgazIrKylcbiAgICAgICAgICAgIHJbazJdID0gYTJbal07XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICAgIF9fc3ByZWFkQXJyYXkzID0gZnVuY3Rpb24odG8sIGZyb20sIHBhY2spIHtcbiAgICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkyIDwgbDsgaTIrKykge1xuICAgICAgICAgICAgaWYgKGFyIHx8ICEoaTIgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFhcilcbiAgICAgICAgICAgICAgICBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkyKTtcbiAgICAgICAgICAgICAgYXJbaTJdID0gZnJvbVtpMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbiAgICAgIH07XG4gICAgICBfX2F3YWl0MyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0MyA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0Myh2KTtcbiAgICAgIH07XG4gICAgICBfX2FzeW5jR2VuZXJhdG9yMyA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIHZhciBnMiA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaTIsIHEgPSBbXTtcbiAgICAgICAgcmV0dXJuIGkyID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGkyW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBpMjtcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgICAgaWYgKGcyW25dKVxuICAgICAgICAgICAgaTJbbl0gPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihhMiwgYjIpIHtcbiAgICAgICAgICAgICAgICBxLnB1c2goW24sIHYsIGEyLCBiMl0pID4gMSB8fCByZXN1bWUobiwgdik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwKGcyW25dKHYpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZXR0bGUocVswXVszXSwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikge1xuICAgICAgICAgIHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0MyA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmMiwgdikge1xuICAgICAgICAgIGlmIChmMih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aClcbiAgICAgICAgICAgIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fYXN5bmNEZWxlZ2F0b3IzID0gZnVuY3Rpb24obykge1xuICAgICAgICB2YXIgaTIsIHAyO1xuICAgICAgICByZXR1cm4gaTIgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSksIHZlcmIoXCJyZXR1cm5cIiksIGkyW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgaTI7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZjIpIHtcbiAgICAgICAgICBpMltuXSA9IG9bbl0gPyBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gKHAyID0gIXAyKSA/IHsgdmFsdWU6IF9fYXdhaXQzKG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmMiA/IGYyKHYpIDogdjtcbiAgICAgICAgICB9IDogZjI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX2FzeW5jVmFsdWVzMyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpMjtcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlczMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzMyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpMiA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpMltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgaTIpO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICBpMltuXSA9IG9bbl0gJiYgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZDIsIHYpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2Mikge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB2MiwgZG9uZTogZDIgfSk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0MyA9IGZ1bmN0aW9uKGNvb2tlZCwgcmF3KSB7XG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29va2VkLnJhdyA9IHJhdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29va2VkO1xuICAgICAgfTtcbiAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24obywgdikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG4gICAgICB9IDogZnVuY3Rpb24obywgdikge1xuICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICB9O1xuICAgICAgX19pbXBvcnRTdGFyMyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgazIgaW4gbW9kKVxuICAgICAgICAgICAgaWYgKGsyICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrMikpXG4gICAgICAgICAgICAgIF9fY3JlYXRlQmluZGluZzMocmVzdWx0LCBtb2QsIGsyKTtcbiAgICAgICAgfVxuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9faW1wb3J0RGVmYXVsdDMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xuICAgICAgfTtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQzID0gZnVuY3Rpb24ocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmMikge1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYyKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZjIgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgICAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmMiA6IGtpbmQgPT09IFwiYVwiID8gZjIuY2FsbChyZWNlaXZlcikgOiBmMiA/IGYyLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbiAgICAgIH07XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MyA9IGZ1bmN0aW9uKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYyKSB7XG4gICAgICAgIGlmIChraW5kID09PSBcIm1cIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYyKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZjIgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgICAgIHJldHVybiBraW5kID09PSBcImFcIiA/IGYyLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYyID8gZjIudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpLCB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4zID0gZnVuY3Rpb24oc3RhdGUsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCB0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xuICAgICAgfTtcbiAgICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kczMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2Fzc2lnblwiLCBfX2Fzc2lnbjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0Myk7XG4gICAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZTMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3BhcmFtXCIsIF9fcGFyYW0zKTtcbiAgICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhMyk7XG4gICAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19nZW5lcmF0b3JcIiwgX19nZW5lcmF0b3IzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3RhcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NyZWF0ZUJpbmRpbmdcIiwgX19jcmVhdGVCaW5kaW5nMyk7XG4gICAgICBleHBvcnRlcihcIl9fdmFsdWVzXCIsIF9fdmFsdWVzMyk7XG4gICAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheXNcIiwgX19zcHJlYWRBcnJheXMzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5Myk7XG4gICAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIF9fYXN5bmNHZW5lcmF0b3IzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yMyk7XG4gICAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlczMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBfX21ha2VUZW1wbGF0ZU9iamVjdDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyMyk7XG4gICAgICBleHBvcnRlcihcIl9faW1wb3J0RGVmYXVsdFwiLCBfX2ltcG9ydERlZmF1bHQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZEdldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0Myk7XG4gICAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkSW5cIiwgX19jbGFzc1ByaXZhdGVGaWVsZEluMyk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHN4XG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIEZvb3RlcjogKCkgPT4gRm9vdGVyLFxuICBMaXN0UHlsYXI6ICgpID0+IExpc3RQeWxhcixcbiAgTWVudTogKCkgPT4gTWVudSxcbiAgTWVudVB5bGFyOiAoKSA9PiBNZW51UHlsYXIsXG4gIFNjcm9sbGFibGU6ICgpID0+IFNjcm9sbGFibGUsXG4gIFRpdGxlUHlsYXI6ICgpID0+IFRpdGxlUHlsYXIsXG4gIFZlcnNpb246ICgpID0+IFZlcnNpb24sXG4gIGJsb2c6ICgpID0+IGJsb2csXG4gIHBvc3QxMjAzMjAyMjogKCkgPT4gcG9zdDEyMDMyMDIyXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL21lc2hncmFkL2Rpc3QvaW5kZXgubWpzXG52YXIgaSA9ICgpID0+IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDM2MCk7XG52YXIgYyA9IChuKSA9PiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAobiAqIDEwMCkgJSAxMDApO1xudmFyIGcgPSAobiwgdCwgZSkgPT4gTWF0aC5yb3VuZCh0IC8gZSAqIChuICogMTAwKSAlIDEwMCk7XG52YXIgZCA9IChuKSA9PiB7XG4gIGlmICghIW4pIHtcbiAgICBuID0gbi5yZXBsYWNlKC8jL2csIFwiXCIpLCBuLmxlbmd0aCA9PT0gMyAmJiAobiA9IG4uc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uKGIyKSB7XG4gICAgICByZXR1cm4gYjIgKyBiMjtcbiAgICB9KS5qb2luKFwiXCIpKTtcbiAgICB2YXIgdCA9IC9eKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pW1xcZGEtel17MCwwfSQvaS5leGVjKG4pO1xuICAgIGlmICghIXQpIHtcbiAgICAgIHZhciBlID0gcGFyc2VJbnQodFsxXSwgMTYpLCByID0gcGFyc2VJbnQodFsyXSwgMTYpLCBhMiA9IHBhcnNlSW50KHRbM10sIDE2KTtcbiAgICAgIGUgLz0gMjU1LCByIC89IDI1NSwgYTIgLz0gMjU1O1xuICAgICAgdmFyIG8gPSBNYXRoLm1heChlLCByLCBhMiksIHMgPSBNYXRoLm1pbihlLCByLCBhMiksIHUgPSAobyArIHMpIC8gMjtcbiAgICAgIGlmIChvID09IHMpXG4gICAgICAgIHUgPSAwO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBtID0gbyAtIHM7XG4gICAgICAgIHN3aXRjaCAobykge1xuICAgICAgICAgIGNhc2UgZTpcbiAgICAgICAgICAgIHUgPSAociAtIGEyKSAvIG0gKyAociA8IGEyID8gNiA6IDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgdSA9IChhMiAtIGUpIC8gbSArIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGEyOlxuICAgICAgICAgICAgdSA9IChlIC0gcikgLyBtICsgNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHUgLz0gNjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1ID0gTWF0aC5yb3VuZCgzNjAgKiB1KSwgdTtcbiAgICB9XG4gIH1cbn07XG52YXIgcCA9IChuLCB0KSA9PiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sIChlLCByKSA9PiByID09PSAwID8gYGhzbCgke3R9LCAxMDAlLCA4MCUpYCA6IHIgPCBuIC8gMS40ID8gYGhzbCgke3QgLSAzMCAqICgxIC0gMiAqIChyICUgMikpICogKHIgPiAyID8gciAvIDIgOiByKX0sIDEwMCUsICR7NzYgLSByICogKDEgLSAyICogKHIgJSAyKSkgKiAxLjc1fSUpYCA6IGBoc2woJHt0IC0gMTUwICogKDEgLSAyICogKHIgJSAyKSl9LCAxMDAlLCAkezc2IC0gciAqICgxIC0gMiAqIChyICUgMikpICogMS4yNX0lKWApO1xudmFyIE0gPSAobiwgdCwgZSkgPT4gQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAociwgYTIpID0+IGByYWRpYWwtZ3JhZGllbnQoYXQgJHtlID8gZyhhMiwgZSwgbikgOiBjKGEyKX0lICR7ZSA/IGcoYTIgKiAxMCwgZSwgbikgOiBjKGEyICogMTApfSUsICR7dFthMl19IDBweCwgdHJhbnNwYXJlbnQgNTAlKVxuYCk7XG52YXIgZiA9IChuLCB0LCBlKSA9PiB7XG4gIGxldCByID0gcChuLCB0IHx8IGkoKSksIGEyID0gTShuLCByLCBlIHx8IHZvaWQgMCk7XG4gIHJldHVybiBbclswXSwgYTIuam9pbihcIixcIildO1xufTtcbnZhciBrID0gKG4sIHQsIGUpID0+IHtcbiAgbGV0IFtyLCBhMl0gPSBmKG4sIGQodCkgPyBkKHQpIDogdm9pZCAwLCBlIHx8IHZvaWQgMCk7XG4gIHJldHVybiB7IGJhY2tncm91bmRDb2xvcjogciwgYmFja2dyb3VuZEltYWdlOiBhMiB9O1xufTtcblxuLy8gc3JjL1ZlcnNpb24udHN4XG52YXIgaW1wb3J0X2pzeF9ydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIEVMRU1FTlRTID0gODtcbnZhciBWZXJzaW9uID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUuanN4KShcImJ1dHRvblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm0tMiBoaWRkZW4gcm91bmRlZC1mdWxsIHB5LTIgcHgtNCB0ZXh0LXhzIGZvbnQtYm9sZCB0ZXh0LWJsYWNrIHNoYWRvdy1tZCBob3ZlcjpzaGFkb3cteGwgbWQ6YmxvY2tcIixcbiAgICBzdHlsZTogayhFTEVNRU5UUyksXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lLmpzeCkoXCJhXCIsIHtcbiAgICAgIGhyZWY6IFwiaHR0cDovL2dpdGh1Yi5jb20vbWlndWVsZ2FyZ2FsbG8vbmV4dDEzLWdhbGxlcnktaW1hZ2UtdHVyYm9cIixcbiAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsXG4gICAgICBjaGlsZHJlbjogXCJ2MS4wLjJcIlxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vaW5kZXgubWpzXG52YXIgUmVhY3QgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSwgMSk7XG52YXIgaW1wb3J0X3JlYWN0MTMgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db25maWdDb250ZXh0Lm1qc1xudmFyIGltcG9ydF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBNb3Rpb25Db25maWdDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdC5jcmVhdGVDb250ZXh0KSh7XG4gIHRyYW5zZm9ybVBhZ2VQb2ludDogKHAyKSA9PiBwMixcbiAgaXNTdGF0aWM6IGZhbHNlLFxuICByZWR1Y2VkTW90aW9uOiBcIm5ldmVyXCJcbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29udGV4dC9pbmRleC5tanNcbnZhciBpbXBvcnRfcmVhY3QyID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIE1vdGlvbkNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0Mi5jcmVhdGVDb250ZXh0KSh7fSk7XG5mdW5jdGlvbiB1c2VWaXN1YWxFbGVtZW50Q29udGV4dCgpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfcmVhY3QyLnVzZUNvbnRleHQpKE1vdGlvbkNvbnRleHQpLnZpc3VhbEVsZW1lbnQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3VzZS12aXN1YWwtZWxlbWVudC5tanNcbnZhciBpbXBvcnRfcmVhY3Q2ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvUHJlc2VuY2VDb250ZXh0Lm1qc1xudmFyIGltcG9ydF9yZWFjdDMgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgUHJlc2VuY2VDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDMuY3JlYXRlQ29udGV4dCkobnVsbCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWlzb21vcnBoaWMtZWZmZWN0Lm1qc1xudmFyIGltcG9ydF9yZWFjdDQgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtYnJvd3Nlci5tanNcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWlzb21vcnBoaWMtZWZmZWN0Lm1qc1xudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBpc0Jyb3dzZXIgPyBpbXBvcnRfcmVhY3Q0LnVzZUxheW91dEVmZmVjdCA6IGltcG9ydF9yZWFjdDQudXNlRWZmZWN0O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTGF6eUNvbnRleHQubWpzXG52YXIgaW1wb3J0X3JlYWN0NSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBMYXp5Q29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3Q1LmNyZWF0ZUNvbnRleHQpKHsgc3RyaWN0OiBmYWxzZSB9KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1lbGVtZW50Lm1qc1xuZnVuY3Rpb24gdXNlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHZpc3VhbFN0YXRlLCBwcm9wcywgY3JlYXRlVmlzdWFsRWxlbWVudCkge1xuICBjb25zdCBwYXJlbnQgPSB1c2VWaXN1YWxFbGVtZW50Q29udGV4dCgpO1xuICBjb25zdCBsYXp5Q29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3Q2LnVzZUNvbnRleHQpKExhenlDb250ZXh0KTtcbiAgY29uc3QgcHJlc2VuY2VDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDYudXNlQ29udGV4dCkoUHJlc2VuY2VDb250ZXh0KTtcbiAgY29uc3QgcmVkdWNlZE1vdGlvbkNvbmZpZyA9ICgwLCBpbXBvcnRfcmVhY3Q2LnVzZUNvbnRleHQpKE1vdGlvbkNvbmZpZ0NvbnRleHQpLnJlZHVjZWRNb3Rpb247XG4gIGNvbnN0IHZpc3VhbEVsZW1lbnRSZWYgPSAoMCwgaW1wb3J0X3JlYWN0Ni51c2VSZWYpKCk7XG4gIGNyZWF0ZVZpc3VhbEVsZW1lbnQgPSBjcmVhdGVWaXN1YWxFbGVtZW50IHx8IGxhenlDb250ZXh0LnJlbmRlcmVyO1xuICBpZiAoIXZpc3VhbEVsZW1lbnRSZWYuY3VycmVudCAmJiBjcmVhdGVWaXN1YWxFbGVtZW50KSB7XG4gICAgdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50ID0gY3JlYXRlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgIHZpc3VhbFN0YXRlLFxuICAgICAgcGFyZW50LFxuICAgICAgcHJvcHMsXG4gICAgICBwcmVzZW5jZUlkOiBwcmVzZW5jZUNvbnRleHQgPyBwcmVzZW5jZUNvbnRleHQuaWQgOiB2b2lkIDAsXG4gICAgICBibG9ja0luaXRpYWxBbmltYXRpb246IHByZXNlbmNlQ29udGV4dCA/IHByZXNlbmNlQ29udGV4dC5pbml0aWFsID09PSBmYWxzZSA6IGZhbHNlLFxuICAgICAgcmVkdWNlZE1vdGlvbkNvbmZpZ1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHZpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQ7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZpc3VhbEVsZW1lbnQgJiYgdmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgfSk7XG4gICgwLCBpbXBvcnRfcmVhY3Q2LnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGlmICh2aXN1YWxFbGVtZW50ICYmIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuYW5pbWF0ZUNoYW5nZXMoKTtcbiAgICB9XG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+ICgpID0+IHZpc3VhbEVsZW1lbnQgJiYgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJVbm1vdW50XCIpLCBbXSk7XG4gIHJldHVybiB2aXN1YWxFbGVtZW50O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtbW90aW9uLXJlZi5tanNcbnZhciBpbXBvcnRfcmVhY3Q3ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLXJlZi1vYmplY3QubWpzXG5mdW5jdGlvbiBpc1JlZk9iamVjdChyZWYpIHtcbiAgcmV0dXJuIHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZiwgXCJjdXJyZW50XCIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtbW90aW9uLXJlZi5tanNcbmZ1bmN0aW9uIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgdmlzdWFsRWxlbWVudCwgZXh0ZXJuYWxSZWYpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfcmVhY3Q3LnVzZUNhbGxiYWNrKShcbiAgICAoaW5zdGFuY2UpID0+IHtcbiAgICAgIGluc3RhbmNlICYmIHZpc3VhbFN0YXRlLm1vdW50ICYmIHZpc3VhbFN0YXRlLm1vdW50KGluc3RhbmNlKTtcbiAgICAgIGlmICh2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgIGluc3RhbmNlID8gdmlzdWFsRWxlbWVudC5tb3VudChpbnN0YW5jZSkgOiB2aXN1YWxFbGVtZW50LnVubW91bnQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRlcm5hbFJlZikge1xuICAgICAgICBpZiAodHlwZW9mIGV4dGVybmFsUmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBleHRlcm5hbFJlZihpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWZPYmplY3QoZXh0ZXJuYWxSZWYpKSB7XG4gICAgICAgICAgZXh0ZXJuYWxSZWYuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbdmlzdWFsRWxlbWVudF1cbiAgKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbnRleHQvY3JlYXRlLm1qc1xudmFyIGltcG9ydF9yZWFjdDggPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2lzLXZhcmlhbnQtbGFiZWwubWpzXG5mdW5jdGlvbiBpc1ZhcmlhbnRMYWJlbCh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KHYpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRpb24tY29udHJvbHMubWpzXG5mdW5jdGlvbiBpc0FuaW1hdGlvbkNvbnRyb2xzKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2LnN0YXJ0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2lzLWNvbnRyb2xsaW5nLXZhcmlhbnRzLm1qc1xudmFyIHZhcmlhbnRQcm9wcyA9IFtcbiAgXCJpbml0aWFsXCIsXG4gIFwiYW5pbWF0ZVwiLFxuICBcImV4aXRcIixcbiAgXCJ3aGlsZUhvdmVyXCIsXG4gIFwid2hpbGVEcmFnXCIsXG4gIFwid2hpbGVUYXBcIixcbiAgXCJ3aGlsZUZvY3VzXCIsXG4gIFwid2hpbGVJblZpZXdcIlxuXTtcbmZ1bmN0aW9uIGlzQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcykge1xuICByZXR1cm4gaXNBbmltYXRpb25Db250cm9scyhwcm9wcy5hbmltYXRlKSB8fCB2YXJpYW50UHJvcHMuc29tZSgobmFtZSkgPT4gaXNWYXJpYW50TGFiZWwocHJvcHNbbmFtZV0pKTtcbn1cbmZ1bmN0aW9uIGlzVmFyaWFudE5vZGUocHJvcHMpIHtcbiAgcmV0dXJuIEJvb2xlYW4oaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSB8fCBwcm9wcy52YXJpYW50cyk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db250ZXh0L3V0aWxzLm1qc1xuZnVuY3Rpb24gZ2V0Q3VycmVudFRyZWVWYXJpYW50cyhwcm9wcywgY29udGV4dCkge1xuICBpZiAoaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSkge1xuICAgIGNvbnN0IHsgaW5pdGlhbCwgYW5pbWF0ZTogYW5pbWF0ZTMgfSA9IHByb3BzO1xuICAgIHJldHVybiB7XG4gICAgICBpbml0aWFsOiBpbml0aWFsID09PSBmYWxzZSB8fCBpc1ZhcmlhbnRMYWJlbChpbml0aWFsKSA/IGluaXRpYWwgOiB2b2lkIDAsXG4gICAgICBhbmltYXRlOiBpc1ZhcmlhbnRMYWJlbChhbmltYXRlMykgPyBhbmltYXRlMyA6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHByb3BzLmluaGVyaXQgIT09IGZhbHNlID8gY29udGV4dCA6IHt9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29udGV4dC9jcmVhdGUubWpzXG5mdW5jdGlvbiB1c2VDcmVhdGVNb3Rpb25Db250ZXh0KHByb3BzKSB7XG4gIGNvbnN0IHsgaW5pdGlhbCwgYW5pbWF0ZTogYW5pbWF0ZTMgfSA9IGdldEN1cnJlbnRUcmVlVmFyaWFudHMocHJvcHMsICgwLCBpbXBvcnRfcmVhY3Q4LnVzZUNvbnRleHQpKE1vdGlvbkNvbnRleHQpKTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfcmVhY3Q4LnVzZU1lbW8pKCgpID0+ICh7IGluaXRpYWwsIGFuaW1hdGU6IGFuaW1hdGUzIH0pLCBbdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShpbml0aWFsKSwgdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShhbmltYXRlMyldKTtcbn1cbmZ1bmN0aW9uIHZhcmlhbnRMYWJlbHNBc0RlcGVuZGVuY3kocHJvcCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShwcm9wKSA/IHByb3Auam9pbihcIiBcIikgOiBwcm9wO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9kZWZpbml0aW9ucy5tanNcbnZhciBjcmVhdGVEZWZpbml0aW9uID0gKHByb3BOYW1lcykgPT4gKHtcbiAgaXNFbmFibGVkOiAocHJvcHMpID0+IHByb3BOYW1lcy5zb21lKChuYW1lKSA9PiAhIXByb3BzW25hbWVdKVxufSk7XG52YXIgZmVhdHVyZURlZmluaXRpb25zID0ge1xuICBtZWFzdXJlTGF5b3V0OiBjcmVhdGVEZWZpbml0aW9uKFtcImxheW91dFwiLCBcImxheW91dElkXCIsIFwiZHJhZ1wiXSksXG4gIGFuaW1hdGlvbjogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJleGl0XCIsXG4gICAgXCJ2YXJpYW50c1wiLFxuICAgIFwid2hpbGVIb3ZlclwiLFxuICAgIFwid2hpbGVUYXBcIixcbiAgICBcIndoaWxlRm9jdXNcIixcbiAgICBcIndoaWxlRHJhZ1wiLFxuICAgIFwid2hpbGVJblZpZXdcIlxuICBdKSxcbiAgZXhpdDogY3JlYXRlRGVmaW5pdGlvbihbXCJleGl0XCJdKSxcbiAgZHJhZzogY3JlYXRlRGVmaW5pdGlvbihbXCJkcmFnXCIsIFwiZHJhZ0NvbnRyb2xzXCJdKSxcbiAgZm9jdXM6IGNyZWF0ZURlZmluaXRpb24oW1wid2hpbGVGb2N1c1wiXSksXG4gIGhvdmVyOiBjcmVhdGVEZWZpbml0aW9uKFtcIndoaWxlSG92ZXJcIiwgXCJvbkhvdmVyU3RhcnRcIiwgXCJvbkhvdmVyRW5kXCJdKSxcbiAgdGFwOiBjcmVhdGVEZWZpbml0aW9uKFtcIndoaWxlVGFwXCIsIFwib25UYXBcIiwgXCJvblRhcFN0YXJ0XCIsIFwib25UYXBDYW5jZWxcIl0pLFxuICBwYW46IGNyZWF0ZURlZmluaXRpb24oW1xuICAgIFwib25QYW5cIixcbiAgICBcIm9uUGFuU3RhcnRcIixcbiAgICBcIm9uUGFuU2Vzc2lvblN0YXJ0XCIsXG4gICAgXCJvblBhbkVuZFwiXG4gIF0pLFxuICBpblZpZXc6IGNyZWF0ZURlZmluaXRpb24oW1xuICAgIFwid2hpbGVJblZpZXdcIixcbiAgICBcIm9uVmlld3BvcnRFbnRlclwiLFxuICAgIFwib25WaWV3cG9ydExlYXZlXCJcbiAgXSlcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xvYWQtZmVhdHVyZXMubWpzXG5mdW5jdGlvbiBsb2FkRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gZmVhdHVyZXMpIHtcbiAgICBpZiAoa2V5ID09PSBcInByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3JcIikge1xuICAgICAgZmVhdHVyZURlZmluaXRpb25zLnByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IgPSBmZWF0dXJlc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBmZWF0dXJlRGVmaW5pdGlvbnNba2V5XS5Db21wb25lbnQgPSBmZWF0dXJlc1trZXldO1xuICAgIH1cbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1jb25zdGFudC5tanNcbnZhciBpbXBvcnRfcmVhY3Q5ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gdXNlQ29uc3RhbnQoaW5pdCkge1xuICBjb25zdCByZWYgPSAoMCwgaW1wb3J0X3JlYWN0OS51c2VSZWYpKG51bGwpO1xuICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICByZWYuY3VycmVudCA9IGluaXQoKTtcbiAgfVxuICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL3N0YXRlLm1qc1xudmFyIGdsb2JhbFByb2plY3Rpb25TdGF0ZSA9IHtcbiAgaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZTogdHJ1ZSxcbiAgaGFzRXZlclVwZGF0ZWQ6IGZhbHNlXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9pZC5tanNcbnZhciBpZCA9IDE7XG5mdW5jdGlvbiB1c2VQcm9qZWN0aW9uSWQoKSB7XG4gIHJldHVybiB1c2VDb25zdGFudCgoKSA9PiB7XG4gICAgaWYgKGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNFdmVyVXBkYXRlZCkge1xuICAgICAgcmV0dXJuIGlkKys7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L0xheW91dEdyb3VwQ29udGV4dC5tanNcbnZhciBpbXBvcnRfcmVhY3QxMCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBMYXlvdXRHcm91cENvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MTAuY3JlYXRlQ29udGV4dCkoe30pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9WaXN1YWxFbGVtZW50SGFuZGxlci5tanNcbnZhciBpbXBvcnRfcmVhY3QxMSA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpLCAxKTtcbnZhciBWaXN1YWxFbGVtZW50SGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X3JlYWN0MTEuZGVmYXVsdC5Db21wb25lbnQge1xuICBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHtcbiAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQsIHByb3BzIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICh2aXN1YWxFbGVtZW50KVxuICAgICAgdmlzdWFsRWxlbWVudC5zZXRQcm9wcyhwcm9wcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L1N3aXRjaExheW91dEdyb3VwQ29udGV4dC5tanNcbnZhciBpbXBvcnRfcmVhY3QxMiA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MTIuY3JlYXRlQ29udGV4dCkoe30pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9zeW1ib2wubWpzXG52YXIgbW90aW9uQ29tcG9uZW50U3ltYm9sID0gU3ltYm9sLmZvcihcIm1vdGlvbkNvbXBvbmVudFN5bWJvbFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vaW5kZXgubWpzXG5mdW5jdGlvbiBjcmVhdGVNb3Rpb25Db21wb25lbnQoeyBwcmVsb2FkZWRGZWF0dXJlcywgY3JlYXRlVmlzdWFsRWxlbWVudCwgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciwgdXNlUmVuZGVyLCB1c2VWaXN1YWxTdGF0ZSwgQ29tcG9uZW50IH0pIHtcbiAgcHJlbG9hZGVkRmVhdHVyZXMgJiYgbG9hZEZlYXR1cmVzKHByZWxvYWRlZEZlYXR1cmVzKTtcbiAgZnVuY3Rpb24gTW90aW9uQ29tcG9uZW50KHByb3BzLCBleHRlcm5hbFJlZikge1xuICAgIGNvbnN0IGNvbmZpZ0FuZFByb3BzID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgKDAsIGltcG9ydF9yZWFjdDEzLnVzZUNvbnRleHQpKE1vdGlvbkNvbmZpZ0NvbnRleHQpKSwgcHJvcHMpLCB7XG4gICAgICBsYXlvdXRJZDogdXNlTGF5b3V0SWQocHJvcHMpXG4gICAgfSk7XG4gICAgY29uc3QgeyBpc1N0YXRpYyB9ID0gY29uZmlnQW5kUHJvcHM7XG4gICAgbGV0IGZlYXR1cmVzID0gbnVsbDtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ3JlYXRlTW90aW9uQ29udGV4dChwcm9wcyk7XG4gICAgY29uc3QgcHJvamVjdGlvbklkID0gaXNTdGF0aWMgPyB2b2lkIDAgOiB1c2VQcm9qZWN0aW9uSWQoKTtcbiAgICBjb25zdCB2aXN1YWxTdGF0ZSA9IHVzZVZpc3VhbFN0YXRlKHByb3BzLCBpc1N0YXRpYyk7XG4gICAgaWYgKCFpc1N0YXRpYyAmJiBpc0Jyb3dzZXIpIHtcbiAgICAgIGNvbnRleHQudmlzdWFsRWxlbWVudCA9IHVzZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50LCB2aXN1YWxTdGF0ZSwgY29uZmlnQW5kUHJvcHMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQpO1xuICAgICAgY29uc3QgbGF6eVN0cmljdE1vZGUgPSAoMCwgaW1wb3J0X3JlYWN0MTMudXNlQ29udGV4dCkoTGF6eUNvbnRleHQpLnN0cmljdDtcbiAgICAgIGNvbnN0IGluaXRpYWxMYXlvdXRHcm91cENvbmZpZyA9ICgwLCBpbXBvcnRfcmVhY3QxMy51c2VDb250ZXh0KShTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQpO1xuICAgICAgaWYgKGNvbnRleHQudmlzdWFsRWxlbWVudCkge1xuICAgICAgICBmZWF0dXJlcyA9IGNvbnRleHQudmlzdWFsRWxlbWVudC5sb2FkRmVhdHVyZXMoXG4gICAgICAgICAgY29uZmlnQW5kUHJvcHMsXG4gICAgICAgICAgbGF6eVN0cmljdE1vZGUsXG4gICAgICAgICAgcHJlbG9hZGVkRmVhdHVyZXMsXG4gICAgICAgICAgcHJvamVjdGlvbklkLFxuICAgICAgICAgIHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IgfHwgZmVhdHVyZURlZmluaXRpb25zLnByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsXG4gICAgICAgICAgaW5pdGlhbExheW91dEdyb3VwQ29uZmlnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgVmlzdWFsRWxlbWVudEhhbmRsZXIsXG4gICAgICB7IHZpc3VhbEVsZW1lbnQ6IGNvbnRleHQudmlzdWFsRWxlbWVudCwgcHJvcHM6IGNvbmZpZ0FuZFByb3BzIH0sXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW90aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCB1c2VSZW5kZXIoQ29tcG9uZW50LCBwcm9wcywgcHJvamVjdGlvbklkLCB1c2VNb3Rpb25SZWYodmlzdWFsU3RhdGUsIGNvbnRleHQudmlzdWFsRWxlbWVudCwgZXh0ZXJuYWxSZWYpLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMsIGNvbnRleHQudmlzdWFsRWxlbWVudCkpXG4gICAgKTtcbiAgfVxuICBjb25zdCBGb3J3YXJkUmVmQ29tcG9uZW50ID0gKDAsIGltcG9ydF9yZWFjdDEzLmZvcndhcmRSZWYpKE1vdGlvbkNvbXBvbmVudCk7XG4gIEZvcndhcmRSZWZDb21wb25lbnRbbW90aW9uQ29tcG9uZW50U3ltYm9sXSA9IENvbXBvbmVudDtcbiAgcmV0dXJuIEZvcndhcmRSZWZDb21wb25lbnQ7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRJZCh7IGxheW91dElkIH0pIHtcbiAgY29uc3QgbGF5b3V0R3JvdXBJZCA9ICgwLCBpbXBvcnRfcmVhY3QxMy51c2VDb250ZXh0KShMYXlvdXRHcm91cENvbnRleHQpLmlkO1xuICByZXR1cm4gbGF5b3V0R3JvdXBJZCAmJiBsYXlvdXRJZCAhPT0gdm9pZCAwID8gbGF5b3V0R3JvdXBJZCArIFwiLVwiICsgbGF5b3V0SWQgOiBsYXlvdXRJZDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL21vdGlvbi1wcm94eS5tanNcbmZ1bmN0aW9uIGNyZWF0ZU1vdGlvblByb3h5KGNyZWF0ZUNvbmZpZykge1xuICBmdW5jdGlvbiBjdXN0b20oQ29tcG9uZW50LCBjdXN0b21Nb3Rpb25Db21wb25lbnRDb25maWcgPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVNb3Rpb25Db21wb25lbnQoY3JlYXRlQ29uZmlnKENvbXBvbmVudCwgY3VzdG9tTW90aW9uQ29tcG9uZW50Q29uZmlnKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBjdXN0b207XG4gIH1cbiAgY29uc3QgY29tcG9uZW50Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gbmV3IFByb3h5KGN1c3RvbSwge1xuICAgIGdldDogKF90YXJnZXQsIGtleSkgPT4ge1xuICAgICAgaWYgKCFjb21wb25lbnRDYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICBjb21wb25lbnRDYWNoZS5zZXQoa2V5LCBjdXN0b20oa2V5KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcG9uZW50Q2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL2xvd2VyY2FzZS1lbGVtZW50cy5tanNcbnZhciBsb3dlcmNhc2VTVkdFbGVtZW50cyA9IFtcbiAgXCJhbmltYXRlXCIsXG4gIFwiY2lyY2xlXCIsXG4gIFwiZGVmc1wiLFxuICBcImRlc2NcIixcbiAgXCJlbGxpcHNlXCIsXG4gIFwiZ1wiLFxuICBcImltYWdlXCIsXG4gIFwibGluZVwiLFxuICBcImZpbHRlclwiLFxuICBcIm1hcmtlclwiLFxuICBcIm1hc2tcIixcbiAgXCJtZXRhZGF0YVwiLFxuICBcInBhdGhcIixcbiAgXCJwYXR0ZXJuXCIsXG4gIFwicG9seWdvblwiLFxuICBcInBvbHlsaW5lXCIsXG4gIFwicmVjdFwiLFxuICBcInN0b3BcIixcbiAgXCJzdmdcIixcbiAgXCJzd2l0Y2hcIixcbiAgXCJzeW1ib2xcIixcbiAgXCJ0ZXh0XCIsXG4gIFwidHNwYW5cIixcbiAgXCJ1c2VcIixcbiAgXCJ2aWV3XCJcbl07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9pcy1zdmctY29tcG9uZW50Lm1qc1xuZnVuY3Rpb24gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2YgQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiIHx8IENvbXBvbmVudC5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAobG93ZXJjYXNlU1ZHRWxlbWVudHMuaW5kZXhPZihDb21wb25lbnQpID4gLTEgfHwgL1tBLVpdLy50ZXN0KENvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91c2UtcmVuZGVyLm1qc1xudmFyIGltcG9ydF9yZWFjdDE2ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3VzZS1wcm9wcy5tanNcbnZhciBpbXBvcnRfcmVhY3QxNCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1jb3JyZWN0aW9uLm1qc1xudmFyIHNjYWxlQ29ycmVjdG9ycyA9IHt9O1xuZnVuY3Rpb24gYWRkU2NhbGVDb3JyZWN0b3IoY29ycmVjdG9ycykge1xuICBPYmplY3QuYXNzaWduKHNjYWxlQ29ycmVjdG9ycywgY29ycmVjdG9ycyk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvdHJhbnNmb3JtLm1qc1xudmFyIHRyYW5zZm9ybVByb3BPcmRlciA9IFtcbiAgXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLFxuICBcInhcIixcbiAgXCJ5XCIsXG4gIFwielwiLFxuICBcInRyYW5zbGF0ZVhcIixcbiAgXCJ0cmFuc2xhdGVZXCIsXG4gIFwidHJhbnNsYXRlWlwiLFxuICBcInNjYWxlXCIsXG4gIFwic2NhbGVYXCIsXG4gIFwic2NhbGVZXCIsXG4gIFwicm90YXRlXCIsXG4gIFwicm90YXRlWFwiLFxuICBcInJvdGF0ZVlcIixcbiAgXCJyb3RhdGVaXCIsXG4gIFwic2tld1wiLFxuICBcInNrZXdYXCIsXG4gIFwic2tld1lcIlxuXTtcbnZhciB0cmFuc2Zvcm1Qcm9wcyA9IG5ldyBTZXQodHJhbnNmb3JtUHJvcE9yZGVyKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvaXMtZm9yY2VkLW1vdGlvbi12YWx1ZS5tanNcbmZ1bmN0aW9uIGlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCB7IGxheW91dCwgbGF5b3V0SWQgfSkge1xuICByZXR1cm4gdHJhbnNmb3JtUHJvcHMuaGFzKGtleSkgfHwga2V5LnN0YXJ0c1dpdGgoXCJvcmlnaW5cIikgfHwgKGxheW91dCB8fCBsYXlvdXRJZCAhPT0gdm9pZCAwKSAmJiAoISFzY2FsZUNvcnJlY3RvcnNba2V5XSB8fCBrZXkgPT09IFwib3BhY2l0eVwiKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzXG52YXIgaXNNb3Rpb25WYWx1ZSA9ICh2YWx1ZSkgPT4gISEodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmdldFZlbG9jaXR5KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9idWlsZC10cmFuc2Zvcm0ubWpzXG52YXIgdHJhbnNsYXRlQWxpYXMgPSB7XG4gIHg6IFwidHJhbnNsYXRlWFwiLFxuICB5OiBcInRyYW5zbGF0ZVlcIixcbiAgejogXCJ0cmFuc2xhdGVaXCIsXG4gIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBcInBlcnNwZWN0aXZlXCJcbn07XG52YXIgc29ydFRyYW5zZm9ybVByb3BzID0gKGEyLCBiMikgPT4gdHJhbnNmb3JtUHJvcE9yZGVyLmluZGV4T2YoYTIpIC0gdHJhbnNmb3JtUHJvcE9yZGVyLmluZGV4T2YoYjIpO1xuZnVuY3Rpb24gYnVpbGRUcmFuc2Zvcm0oeyB0cmFuc2Zvcm0sIHRyYW5zZm9ybUtleXM6IHRyYW5zZm9ybUtleXMyIH0sIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24gPSB0cnVlLCBhbGxvd1RyYW5zZm9ybU5vbmUgPSB0cnVlIH0sIHRyYW5zZm9ybUlzRGVmYXVsdCwgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgbGV0IHRyYW5zZm9ybVN0cmluZyA9IFwiXCI7XG4gIHRyYW5zZm9ybUtleXMyLnNvcnQoc29ydFRyYW5zZm9ybVByb3BzKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgdHJhbnNmb3JtS2V5czIpIHtcbiAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gYCR7dHJhbnNsYXRlQWxpYXNba2V5XSB8fCBrZXl9KCR7dHJhbnNmb3JtW2tleV19KSBgO1xuICB9XG4gIGlmIChlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbiAmJiAhdHJhbnNmb3JtLnopIHtcbiAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gXCJ0cmFuc2xhdGVaKDApXCI7XG4gIH1cbiAgdHJhbnNmb3JtU3RyaW5nID0gdHJhbnNmb3JtU3RyaW5nLnRyaW0oKTtcbiAgaWYgKHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgdHJhbnNmb3JtU3RyaW5nID0gdHJhbnNmb3JtVGVtcGxhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm1Jc0RlZmF1bHQgPyBcIlwiIDogdHJhbnNmb3JtU3RyaW5nKTtcbiAgfSBlbHNlIGlmIChhbGxvd1RyYW5zZm9ybU5vbmUgJiYgdHJhbnNmb3JtSXNEZWZhdWx0KSB7XG4gICAgdHJhbnNmb3JtU3RyaW5nID0gXCJub25lXCI7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybVN0cmluZztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2lzLWNzcy12YXJpYWJsZS5tanNcbmZ1bmN0aW9uIGlzQ1NTVmFyaWFibGUoa2V5KSB7XG4gIHJldHVybiBrZXkuc3RhcnRzV2l0aChcIi0tXCIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZ2V0LWFzLXR5cGUubWpzXG52YXIgZ2V0VmFsdWVBc1R5cGUgPSAodmFsdWUsIHR5cGUpID0+IHtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdHlwZS50cmFuc2Zvcm0odmFsdWUpIDogdmFsdWU7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy91dGlscy5tanNcbnZhciBjbGFtcCA9IChtaW4sIG1heCkgPT4gKHYpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIG1heCksIG1pbik7XG52YXIgc2FuaXRpemUgPSAodikgPT4gdiAlIDEgPyBOdW1iZXIodi50b0ZpeGVkKDUpKSA6IHY7XG52YXIgZmxvYXRSZWdleCA9IC8oLSk/KFtcXGRdKlxcLj9bXFxkXSkrL2c7XG52YXIgY29sb3JSZWdleCA9IC8oI1swLTlhLWZdezZ9fCNbMC05YS1mXXszfXwjKD86WzAtOWEtZl17Mn0pezIsNH18KHJnYnxoc2wpYT9cXCgoLT9bXFxkXFwuXSslP1ssXFxzXSspezJ9KC0/W1xcZFxcLl0rJT8pXFxzKltcXCxcXC9dP1xccypbXFxkXFwuXSolP1xcKSkvZ2k7XG52YXIgc2luZ2xlQ29sb3JSZWdleCA9IC9eKCNbMC05YS1mXXszfXwjKD86WzAtOWEtZl17Mn0pezIsNH18KHJnYnxoc2wpYT9cXCgoLT9bXFxkXFwuXSslP1ssXFxzXSspezJ9KC0/W1xcZFxcLl0rJT8pXFxzKltcXCxcXC9dP1xccypbXFxkXFwuXSolP1xcKSkkL2k7XG5mdW5jdGlvbiBpc1N0cmluZyh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvbnVtYmVycy9pbmRleC5tanNcbnZhciBudW1iZXIgPSB7XG4gIHRlc3Q6ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIixcbiAgcGFyc2U6IHBhcnNlRmxvYXQsXG4gIHRyYW5zZm9ybTogKHYpID0+IHZcbn07XG52YXIgYWxwaGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG51bWJlciksIHsgdHJhbnNmb3JtOiBjbGFtcCgwLCAxKSB9KTtcbnZhciBzY2FsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyKSwgeyBkZWZhdWx0OiAxIH0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9udW1iZXJzL3VuaXRzLm1qc1xudmFyIGNyZWF0ZVVuaXRUeXBlID0gKHVuaXQpID0+ICh7XG4gIHRlc3Q6ICh2KSA9PiBpc1N0cmluZyh2KSAmJiB2LmVuZHNXaXRoKHVuaXQpICYmIHYuc3BsaXQoXCIgXCIpLmxlbmd0aCA9PT0gMSxcbiAgcGFyc2U6IHBhcnNlRmxvYXQsXG4gIHRyYW5zZm9ybTogKHYpID0+IGAke3Z9JHt1bml0fWBcbn0pO1xudmFyIGRlZ3JlZXMgPSBjcmVhdGVVbml0VHlwZShcImRlZ1wiKTtcbnZhciBwZXJjZW50ID0gY3JlYXRlVW5pdFR5cGUoXCIlXCIpO1xudmFyIHB4ID0gY3JlYXRlVW5pdFR5cGUoXCJweFwiKTtcbnZhciB2aCA9IGNyZWF0ZVVuaXRUeXBlKFwidmhcIik7XG52YXIgdncgPSBjcmVhdGVVbml0VHlwZShcInZ3XCIpO1xudmFyIHByb2dyZXNzUGVyY2VudGFnZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGVyY2VudCksIHsgcGFyc2U6ICh2KSA9PiBwZXJjZW50LnBhcnNlKHYpIC8gMTAwLCB0cmFuc2Zvcm06ICh2KSA9PiBwZXJjZW50LnRyYW5zZm9ybSh2ICogMTAwKSB9KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvY29sb3IvdXRpbHMubWpzXG52YXIgaXNDb2xvclN0cmluZyA9ICh0eXBlLCB0ZXN0UHJvcCkgPT4gKHYpID0+IHtcbiAgcmV0dXJuIEJvb2xlYW4oaXNTdHJpbmcodikgJiYgc2luZ2xlQ29sb3JSZWdleC50ZXN0KHYpICYmIHYuc3RhcnRzV2l0aCh0eXBlKSB8fCB0ZXN0UHJvcCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodiwgdGVzdFByb3ApKTtcbn07XG52YXIgc3BsaXRDb2xvciA9IChhTmFtZSwgYk5hbWUsIGNOYW1lKSA9PiAodikgPT4ge1xuICBpZiAoIWlzU3RyaW5nKHYpKVxuICAgIHJldHVybiB2O1xuICBjb25zdCBbYTIsIGIyLCBjMywgYWxwaGEyXSA9IHYubWF0Y2goZmxvYXRSZWdleCk7XG4gIHJldHVybiB7XG4gICAgW2FOYW1lXTogcGFyc2VGbG9hdChhMiksXG4gICAgW2JOYW1lXTogcGFyc2VGbG9hdChiMiksXG4gICAgW2NOYW1lXTogcGFyc2VGbG9hdChjMyksXG4gICAgYWxwaGE6IGFscGhhMiAhPT0gdm9pZCAwID8gcGFyc2VGbG9hdChhbHBoYTIpIDogMVxuICB9O1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvY29sb3IvaHNsYS5tanNcbnZhciBoc2xhID0ge1xuICB0ZXN0OiBpc0NvbG9yU3RyaW5nKFwiaHNsXCIsIFwiaHVlXCIpLFxuICBwYXJzZTogc3BsaXRDb2xvcihcImh1ZVwiLCBcInNhdHVyYXRpb25cIiwgXCJsaWdodG5lc3NcIiksXG4gIHRyYW5zZm9ybTogKHsgaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhOiBhbHBoYSQxID0gMSB9KSA9PiB7XG4gICAgcmV0dXJuIFwiaHNsYShcIiArIE1hdGgucm91bmQoaHVlKSArIFwiLCBcIiArIHBlcmNlbnQudHJhbnNmb3JtKHNhbml0aXplKHNhdHVyYXRpb24pKSArIFwiLCBcIiArIHBlcmNlbnQudHJhbnNmb3JtKHNhbml0aXplKGxpZ2h0bmVzcykpICsgXCIsIFwiICsgc2FuaXRpemUoYWxwaGEudHJhbnNmb3JtKGFscGhhJDEpKSArIFwiKVwiO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9yZ2JhLm1qc1xudmFyIGNsYW1wUmdiVW5pdCA9IGNsYW1wKDAsIDI1NSk7XG52YXIgcmdiVW5pdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyKSwgeyB0cmFuc2Zvcm06ICh2KSA9PiBNYXRoLnJvdW5kKGNsYW1wUmdiVW5pdCh2KSkgfSk7XG52YXIgcmdiYSA9IHtcbiAgdGVzdDogaXNDb2xvclN0cmluZyhcInJnYlwiLCBcInJlZFwiKSxcbiAgcGFyc2U6IHNwbGl0Q29sb3IoXCJyZWRcIiwgXCJncmVlblwiLCBcImJsdWVcIiksXG4gIHRyYW5zZm9ybTogKHsgcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGE6IGFscGhhJDEgPSAxIH0pID0+IFwicmdiYShcIiArIHJnYlVuaXQudHJhbnNmb3JtKHJlZCkgKyBcIiwgXCIgKyByZ2JVbml0LnRyYW5zZm9ybShncmVlbikgKyBcIiwgXCIgKyByZ2JVbml0LnRyYW5zZm9ybShibHVlKSArIFwiLCBcIiArIHNhbml0aXplKGFscGhhLnRyYW5zZm9ybShhbHBoYSQxKSkgKyBcIilcIlxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvY29sb3IvaGV4Lm1qc1xuZnVuY3Rpb24gcGFyc2VIZXgodikge1xuICBsZXQgciA9IFwiXCI7XG4gIGxldCBnMiA9IFwiXCI7XG4gIGxldCBiMiA9IFwiXCI7XG4gIGxldCBhMiA9IFwiXCI7XG4gIGlmICh2Lmxlbmd0aCA+IDUpIHtcbiAgICByID0gdi5zdWJzdHIoMSwgMik7XG4gICAgZzIgPSB2LnN1YnN0cigzLCAyKTtcbiAgICBiMiA9IHYuc3Vic3RyKDUsIDIpO1xuICAgIGEyID0gdi5zdWJzdHIoNywgMik7XG4gIH0gZWxzZSB7XG4gICAgciA9IHYuc3Vic3RyKDEsIDEpO1xuICAgIGcyID0gdi5zdWJzdHIoMiwgMSk7XG4gICAgYjIgPSB2LnN1YnN0cigzLCAxKTtcbiAgICBhMiA9IHYuc3Vic3RyKDQsIDEpO1xuICAgIHIgKz0gcjtcbiAgICBnMiArPSBnMjtcbiAgICBiMiArPSBiMjtcbiAgICBhMiArPSBhMjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlZDogcGFyc2VJbnQociwgMTYpLFxuICAgIGdyZWVuOiBwYXJzZUludChnMiwgMTYpLFxuICAgIGJsdWU6IHBhcnNlSW50KGIyLCAxNiksXG4gICAgYWxwaGE6IGEyID8gcGFyc2VJbnQoYTIsIDE2KSAvIDI1NSA6IDFcbiAgfTtcbn1cbnZhciBoZXggPSB7XG4gIHRlc3Q6IGlzQ29sb3JTdHJpbmcoXCIjXCIpLFxuICBwYXJzZTogcGFyc2VIZXgsXG4gIHRyYW5zZm9ybTogcmdiYS50cmFuc2Zvcm1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbG9yL2luZGV4Lm1qc1xudmFyIGNvbG9yID0ge1xuICB0ZXN0OiAodikgPT4gcmdiYS50ZXN0KHYpIHx8IGhleC50ZXN0KHYpIHx8IGhzbGEudGVzdCh2KSxcbiAgcGFyc2U6ICh2KSA9PiB7XG4gICAgaWYgKHJnYmEudGVzdCh2KSkge1xuICAgICAgcmV0dXJuIHJnYmEucGFyc2Uodik7XG4gICAgfSBlbHNlIGlmIChoc2xhLnRlc3QodikpIHtcbiAgICAgIHJldHVybiBoc2xhLnBhcnNlKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaGV4LnBhcnNlKHYpO1xuICAgIH1cbiAgfSxcbiAgdHJhbnNmb3JtOiAodikgPT4ge1xuICAgIHJldHVybiBpc1N0cmluZyh2KSA/IHYgOiB2Lmhhc093blByb3BlcnR5KFwicmVkXCIpID8gcmdiYS50cmFuc2Zvcm0odikgOiBoc2xhLnRyYW5zZm9ybSh2KTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvY29tcGxleC9pbmRleC5tanNcbnZhciBjb2xvclRva2VuID0gXCIke2N9XCI7XG52YXIgbnVtYmVyVG9rZW4gPSBcIiR7bn1cIjtcbmZ1bmN0aW9uIHRlc3Qodikge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIHJldHVybiBpc05hTih2KSAmJiBpc1N0cmluZyh2KSAmJiAoKF9iID0gKF9hID0gdi5tYXRjaChmbG9hdFJlZ2V4KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgKyAoKF9kID0gKF9jID0gdi5tYXRjaChjb2xvclJlZ2V4KSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCkgPiAwO1xufVxuZnVuY3Rpb24gYW5hbHlzZSh2KSB7XG4gIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIilcbiAgICB2ID0gYCR7dn1gO1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgbGV0IG51bUNvbG9ycyA9IDA7XG4gIGNvbnN0IGNvbG9ycyA9IHYubWF0Y2goY29sb3JSZWdleCk7XG4gIGlmIChjb2xvcnMpIHtcbiAgICBudW1Db2xvcnMgPSBjb2xvcnMubGVuZ3RoO1xuICAgIHYgPSB2LnJlcGxhY2UoY29sb3JSZWdleCwgY29sb3JUb2tlbik7XG4gICAgdmFsdWVzLnB1c2goLi4uY29sb3JzLm1hcChjb2xvci5wYXJzZSkpO1xuICB9XG4gIGNvbnN0IG51bWJlcnMgPSB2Lm1hdGNoKGZsb2F0UmVnZXgpO1xuICBpZiAobnVtYmVycykge1xuICAgIHYgPSB2LnJlcGxhY2UoZmxvYXRSZWdleCwgbnVtYmVyVG9rZW4pO1xuICAgIHZhbHVlcy5wdXNoKC4uLm51bWJlcnMubWFwKG51bWJlci5wYXJzZSkpO1xuICB9XG4gIHJldHVybiB7IHZhbHVlcywgbnVtQ29sb3JzLCB0b2tlbmlzZWQ6IHYgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlKHYpIHtcbiAgcmV0dXJuIGFuYWx5c2UodikudmFsdWVzO1xufVxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtZXIodikge1xuICBjb25zdCB7IHZhbHVlcywgbnVtQ29sb3JzLCB0b2tlbmlzZWQgfSA9IGFuYWx5c2Uodik7XG4gIGNvbnN0IG51bVZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiAodjIpID0+IHtcbiAgICBsZXQgb3V0cHV0ID0gdG9rZW5pc2VkO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1WYWx1ZXM7IGkyKyspIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKGkyIDwgbnVtQ29sb3JzID8gY29sb3JUb2tlbiA6IG51bWJlclRva2VuLCBpMiA8IG51bUNvbG9ycyA/IGNvbG9yLnRyYW5zZm9ybSh2MltpMl0pIDogc2FuaXRpemUodjJbaTJdKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG52YXIgY29udmVydE51bWJlcnNUb1plcm8gPSAodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgPyAwIDogdjtcbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVOb25lKHYpIHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2Uodik7XG4gIGNvbnN0IHRyYW5zZm9ybWVyID0gY3JlYXRlVHJhbnNmb3JtZXIodik7XG4gIHJldHVybiB0cmFuc2Zvcm1lcihwYXJzZWQubWFwKGNvbnZlcnROdW1iZXJzVG9aZXJvKSk7XG59XG52YXIgY29tcGxleCA9IHsgdGVzdCwgcGFyc2UsIGNyZWF0ZVRyYW5zZm9ybWVyLCBnZXRBbmltYXRhYmxlTm9uZSB9O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb21wbGV4L2ZpbHRlci5tanNcbnZhciBtYXhEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImJyaWdodG5lc3NcIiwgXCJjb250cmFzdFwiLCBcInNhdHVyYXRlXCIsIFwib3BhY2l0eVwiXSk7XG5mdW5jdGlvbiBhcHBseURlZmF1bHRGaWx0ZXIodikge1xuICBsZXQgW25hbWUsIHZhbHVlXSA9IHYuc2xpY2UoMCwgLTEpLnNwbGl0KFwiKFwiKTtcbiAgaWYgKG5hbWUgPT09IFwiZHJvcC1zaGFkb3dcIilcbiAgICByZXR1cm4gdjtcbiAgY29uc3QgW251bWJlcjJdID0gdmFsdWUubWF0Y2goZmxvYXRSZWdleCkgfHwgW107XG4gIGlmICghbnVtYmVyMilcbiAgICByZXR1cm4gdjtcbiAgY29uc3QgdW5pdCA9IHZhbHVlLnJlcGxhY2UobnVtYmVyMiwgXCJcIik7XG4gIGxldCBkZWZhdWx0VmFsdWUgPSBtYXhEZWZhdWx0cy5oYXMobmFtZSkgPyAxIDogMDtcbiAgaWYgKG51bWJlcjIgIT09IHZhbHVlKVxuICAgIGRlZmF1bHRWYWx1ZSAqPSAxMDA7XG4gIHJldHVybiBuYW1lICsgXCIoXCIgKyBkZWZhdWx0VmFsdWUgKyB1bml0ICsgXCIpXCI7XG59XG52YXIgZnVuY3Rpb25SZWdleCA9IC8oW2Etei1dKilcXCguKj9cXCkvZztcbnZhciBmaWx0ZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbXBsZXgpLCB7IGdldEFuaW1hdGFibGVOb25lOiAodikgPT4ge1xuICBjb25zdCBmdW5jdGlvbnMgPSB2Lm1hdGNoKGZ1bmN0aW9uUmVnZXgpO1xuICByZXR1cm4gZnVuY3Rpb25zID8gZnVuY3Rpb25zLm1hcChhcHBseURlZmF1bHRGaWx0ZXIpLmpvaW4oXCIgXCIpIDogdjtcbn0gfSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy90eXBlLWludC5tanNcbnZhciBpbnQgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBudW1iZXIpLCB7XG4gIHRyYW5zZm9ybTogTWF0aC5yb3VuZFxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9udW1iZXIubWpzXG52YXIgbnVtYmVyVmFsdWVUeXBlcyA9IHtcbiAgYm9yZGVyV2lkdGg6IHB4LFxuICBib3JkZXJUb3BXaWR0aDogcHgsXG4gIGJvcmRlclJpZ2h0V2lkdGg6IHB4LFxuICBib3JkZXJCb3R0b21XaWR0aDogcHgsXG4gIGJvcmRlckxlZnRXaWR0aDogcHgsXG4gIGJvcmRlclJhZGl1czogcHgsXG4gIHJhZGl1czogcHgsXG4gIGJvcmRlclRvcExlZnRSYWRpdXM6IHB4LFxuICBib3JkZXJUb3BSaWdodFJhZGl1czogcHgsXG4gIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiBweCxcbiAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogcHgsXG4gIHdpZHRoOiBweCxcbiAgbWF4V2lkdGg6IHB4LFxuICBoZWlnaHQ6IHB4LFxuICBtYXhIZWlnaHQ6IHB4LFxuICBzaXplOiBweCxcbiAgdG9wOiBweCxcbiAgcmlnaHQ6IHB4LFxuICBib3R0b206IHB4LFxuICBsZWZ0OiBweCxcbiAgcGFkZGluZzogcHgsXG4gIHBhZGRpbmdUb3A6IHB4LFxuICBwYWRkaW5nUmlnaHQ6IHB4LFxuICBwYWRkaW5nQm90dG9tOiBweCxcbiAgcGFkZGluZ0xlZnQ6IHB4LFxuICBtYXJnaW46IHB4LFxuICBtYXJnaW5Ub3A6IHB4LFxuICBtYXJnaW5SaWdodDogcHgsXG4gIG1hcmdpbkJvdHRvbTogcHgsXG4gIG1hcmdpbkxlZnQ6IHB4LFxuICByb3RhdGU6IGRlZ3JlZXMsXG4gIHJvdGF0ZVg6IGRlZ3JlZXMsXG4gIHJvdGF0ZVk6IGRlZ3JlZXMsXG4gIHJvdGF0ZVo6IGRlZ3JlZXMsXG4gIHNjYWxlLFxuICBzY2FsZVg6IHNjYWxlLFxuICBzY2FsZVk6IHNjYWxlLFxuICBzY2FsZVo6IHNjYWxlLFxuICBza2V3OiBkZWdyZWVzLFxuICBza2V3WDogZGVncmVlcyxcbiAgc2tld1k6IGRlZ3JlZXMsXG4gIGRpc3RhbmNlOiBweCxcbiAgdHJhbnNsYXRlWDogcHgsXG4gIHRyYW5zbGF0ZVk6IHB4LFxuICB0cmFuc2xhdGVaOiBweCxcbiAgeDogcHgsXG4gIHk6IHB4LFxuICB6OiBweCxcbiAgcGVyc3BlY3RpdmU6IHB4LFxuICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogcHgsXG4gIG9wYWNpdHk6IGFscGhhLFxuICBvcmlnaW5YOiBwcm9ncmVzc1BlcmNlbnRhZ2UsXG4gIG9yaWdpblk6IHByb2dyZXNzUGVyY2VudGFnZSxcbiAgb3JpZ2luWjogcHgsXG4gIHpJbmRleDogaW50LFxuICBmaWxsT3BhY2l0eTogYWxwaGEsXG4gIHN0cm9rZU9wYWNpdHk6IGFscGhhLFxuICBudW1PY3RhdmVzOiBpbnRcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvYnVpbGQtc3R5bGVzLm1qc1xuZnVuY3Rpb24gYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gIGNvbnN0IHsgc3R5bGUsIHZhcnMsIHRyYW5zZm9ybSwgdHJhbnNmb3JtS2V5czogdHJhbnNmb3JtS2V5czIsIHRyYW5zZm9ybU9yaWdpbiB9ID0gc3RhdGU7XG4gIHRyYW5zZm9ybUtleXMyLmxlbmd0aCA9IDA7XG4gIGxldCBoYXNUcmFuc2Zvcm0yID0gZmFsc2U7XG4gIGxldCBoYXNUcmFuc2Zvcm1PcmlnaW4gPSBmYWxzZTtcbiAgbGV0IHRyYW5zZm9ybUlzTm9uZSA9IHRydWU7XG4gIGZvciAoY29uc3Qga2V5IGluIGxhdGVzdFZhbHVlcykge1xuICAgIGNvbnN0IHZhbHVlID0gbGF0ZXN0VmFsdWVzW2tleV07XG4gICAgaWYgKGlzQ1NTVmFyaWFibGUoa2V5KSkge1xuICAgICAgdmFyc1trZXldID0gdmFsdWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVUeXBlID0gbnVtYmVyVmFsdWVUeXBlc1trZXldO1xuICAgIGNvbnN0IHZhbHVlQXNUeXBlID0gZ2V0VmFsdWVBc1R5cGUodmFsdWUsIHZhbHVlVHlwZSk7XG4gICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICBoYXNUcmFuc2Zvcm0yID0gdHJ1ZTtcbiAgICAgIHRyYW5zZm9ybVtrZXldID0gdmFsdWVBc1R5cGU7XG4gICAgICB0cmFuc2Zvcm1LZXlzMi5wdXNoKGtleSk7XG4gICAgICBpZiAoIXRyYW5zZm9ybUlzTm9uZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAodmFsdWUgIT09ICh2YWx1ZVR5cGUuZGVmYXVsdCB8fCAwKSlcbiAgICAgICAgdHJhbnNmb3JtSXNOb25lID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChrZXkuc3RhcnRzV2l0aChcIm9yaWdpblwiKSkge1xuICAgICAgaGFzVHJhbnNmb3JtT3JpZ2luID0gdHJ1ZTtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbltrZXldID0gdmFsdWVBc1R5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFsYXRlc3RWYWx1ZXMudHJhbnNmb3JtKSB7XG4gICAgaWYgKGhhc1RyYW5zZm9ybTIgfHwgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGJ1aWxkVHJhbnNmb3JtKHN0YXRlLCBvcHRpb25zLCB0cmFuc2Zvcm1Jc05vbmUsIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLnRyYW5zZm9ybSkge1xuICAgICAgc3R5bGUudHJhbnNmb3JtID0gXCJub25lXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNUcmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBjb25zdCB7IG9yaWdpblggPSBcIjUwJVwiLCBvcmlnaW5ZID0gXCI1MCVcIiwgb3JpZ2luWiA9IDAgfSA9IHRyYW5zZm9ybU9yaWdpbjtcbiAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBgJHtvcmlnaW5YfSAke29yaWdpbll9ICR7b3JpZ2luWn1gO1xuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanNcbnZhciBjcmVhdGVIdG1sUmVuZGVyU3RhdGUgPSAoKSA9PiAoe1xuICBzdHlsZToge30sXG4gIHRyYW5zZm9ybToge30sXG4gIHRyYW5zZm9ybUtleXM6IFtdLFxuICB0cmFuc2Zvcm1PcmlnaW46IHt9LFxuICB2YXJzOiB7fVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXNlLXByb3BzLm1qc1xuZnVuY3Rpb24gY29weVJhd1ZhbHVlc09ubHkodGFyZ2V0LCBzb3VyY2UsIHByb3BzKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgIGlmICghaXNNb3Rpb25WYWx1ZShzb3VyY2Vba2V5XSkgJiYgIWlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1c2VJbml0aWFsTW90aW9uVmFsdWVzKHsgdHJhbnNmb3JtVGVtcGxhdGUgfSwgdmlzdWFsU3RhdGUsIGlzU3RhdGljKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X3JlYWN0MTQudXNlTWVtbykoKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlSHRtbFJlbmRlclN0YXRlKCk7XG4gICAgYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCB2aXN1YWxTdGF0ZSwgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogIWlzU3RhdGljIH0sIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUudmFycywgc3RhdGUuc3R5bGUpO1xuICB9LCBbdmlzdWFsU3RhdGVdKTtcbn1cbmZ1bmN0aW9uIHVzZVN0eWxlKHByb3BzLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpIHtcbiAgY29uc3Qgc3R5bGVQcm9wID0gcHJvcHMuc3R5bGUgfHwge307XG4gIGNvbnN0IHN0eWxlID0ge307XG4gIGNvcHlSYXdWYWx1ZXNPbmx5KHN0eWxlLCBzdHlsZVByb3AsIHByb3BzKTtcbiAgT2JqZWN0LmFzc2lnbihzdHlsZSwgdXNlSW5pdGlhbE1vdGlvblZhbHVlcyhwcm9wcywgdmlzdWFsU3RhdGUsIGlzU3RhdGljKSk7XG4gIHJldHVybiBwcm9wcy50cmFuc2Zvcm1WYWx1ZXMgPyBwcm9wcy50cmFuc2Zvcm1WYWx1ZXMoc3R5bGUpIDogc3R5bGU7XG59XG5mdW5jdGlvbiB1c2VIVE1MUHJvcHMocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykge1xuICBjb25zdCBodG1sUHJvcHMgPSB7fTtcbiAgY29uc3Qgc3R5bGUgPSB1c2VTdHlsZShwcm9wcywgdmlzdWFsU3RhdGUsIGlzU3RhdGljKTtcbiAgaWYgKHByb3BzLmRyYWcgJiYgcHJvcHMuZHJhZ0xpc3RlbmVyICE9PSBmYWxzZSkge1xuICAgIGh0bWxQcm9wcy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICBzdHlsZS51c2VyU2VsZWN0ID0gc3R5bGUuV2Via2l0VXNlclNlbGVjdCA9IHN0eWxlLldlYmtpdFRvdWNoQ2FsbG91dCA9IFwibm9uZVwiO1xuICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gcHJvcHMuZHJhZyA9PT0gdHJ1ZSA/IFwibm9uZVwiIDogYHBhbi0ke3Byb3BzLmRyYWcgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIn1gO1xuICB9XG4gIGh0bWxQcm9wcy5zdHlsZSA9IHN0eWxlO1xuICByZXR1cm4gaHRtbFByb3BzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy92YWxpZC1wcm9wLm1qc1xudmFyIGFuaW1hdGlvblByb3BzID0gW1xuICBcImFuaW1hdGVcIixcbiAgXCJleGl0XCIsXG4gIFwidmFyaWFudHNcIixcbiAgXCJ3aGlsZUhvdmVyXCIsXG4gIFwid2hpbGVUYXBcIixcbiAgXCJ3aGlsZUZvY3VzXCIsXG4gIFwid2hpbGVEcmFnXCIsXG4gIFwid2hpbGVJblZpZXdcIlxuXTtcbnZhciB0YXBQcm9wcyA9IFtcIndoaWxlVGFwXCIsIFwib25UYXBcIiwgXCJvblRhcFN0YXJ0XCIsIFwib25UYXBDYW5jZWxcIl07XG52YXIgcGFuUHJvcHMgPSBbXCJvblBhblwiLCBcIm9uUGFuU3RhcnRcIiwgXCJvblBhblNlc3Npb25TdGFydFwiLCBcIm9uUGFuRW5kXCJdO1xudmFyIGluVmlld1Byb3BzID0gW1xuICBcIndoaWxlSW5WaWV3XCIsXG4gIFwib25WaWV3cG9ydEVudGVyXCIsXG4gIFwib25WaWV3cG9ydExlYXZlXCIsXG4gIFwidmlld3BvcnRcIlxuXTtcbnZhciB2YWxpZE1vdGlvblByb3BzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImluaXRpYWxcIixcbiAgXCJzdHlsZVwiLFxuICBcInZhbHVlc1wiLFxuICBcInZhcmlhbnRzXCIsXG4gIFwidHJhbnNpdGlvblwiLFxuICBcInRyYW5zZm9ybVRlbXBsYXRlXCIsXG4gIFwidHJhbnNmb3JtVmFsdWVzXCIsXG4gIFwiY3VzdG9tXCIsXG4gIFwiaW5oZXJpdFwiLFxuICBcImxheW91dFwiLFxuICBcImxheW91dElkXCIsXG4gIFwibGF5b3V0RGVwZW5kZW5jeVwiLFxuICBcIm9uTGF5b3V0QW5pbWF0aW9uU3RhcnRcIixcbiAgXCJvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gIFwib25MYXlvdXRNZWFzdXJlXCIsXG4gIFwib25CZWZvcmVMYXlvdXRNZWFzdXJlXCIsXG4gIFwib25BbmltYXRpb25TdGFydFwiLFxuICBcIm9uQW5pbWF0aW9uQ29tcGxldGVcIixcbiAgXCJvblVwZGF0ZVwiLFxuICBcIm9uRHJhZ1N0YXJ0XCIsXG4gIFwib25EcmFnXCIsXG4gIFwib25EcmFnRW5kXCIsXG4gIFwib25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzXCIsXG4gIFwib25EaXJlY3Rpb25Mb2NrXCIsXG4gIFwib25EcmFnVHJhbnNpdGlvbkVuZFwiLFxuICBcImRyYWdcIixcbiAgXCJkcmFnQ29udHJvbHNcIixcbiAgXCJkcmFnTGlzdGVuZXJcIixcbiAgXCJkcmFnQ29uc3RyYWludHNcIixcbiAgXCJkcmFnRGlyZWN0aW9uTG9ja1wiLFxuICBcImRyYWdTbmFwVG9PcmlnaW5cIixcbiAgXCJfZHJhZ1hcIixcbiAgXCJfZHJhZ1lcIixcbiAgXCJkcmFnRWxhc3RpY1wiLFxuICBcImRyYWdNb21lbnR1bVwiLFxuICBcImRyYWdQcm9wYWdhdGlvblwiLFxuICBcImRyYWdUcmFuc2l0aW9uXCIsXG4gIFwib25Ib3ZlclN0YXJ0XCIsXG4gIFwib25Ib3ZlckVuZFwiLFxuICBcImxheW91dFNjcm9sbFwiLFxuICAuLi5pblZpZXdQcm9wcyxcbiAgLi4udGFwUHJvcHMsXG4gIC4uLmFuaW1hdGlvblByb3BzLFxuICAuLi5wYW5Qcm9wc1xuXSk7XG5mdW5jdGlvbiBpc1ZhbGlkTW90aW9uUHJvcChrZXkpIHtcbiAgcmV0dXJuIHZhbGlkTW90aW9uUHJvcHMuaGFzKGtleSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9maWx0ZXItcHJvcHMubWpzXG52YXIgc2hvdWxkRm9yd2FyZCA9IChrZXkpID0+ICFpc1ZhbGlkTW90aW9uUHJvcChrZXkpO1xuZnVuY3Rpb24gbG9hZEV4dGVybmFsSXNWYWxpZFByb3AoaXNWYWxpZFByb3ApIHtcbiAgaWYgKCFpc1ZhbGlkUHJvcClcbiAgICByZXR1cm47XG4gIHNob3VsZEZvcndhcmQgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uXCIpID8gIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSkgOiBpc1ZhbGlkUHJvcChrZXkpO1xufVxudHJ5IHtcbiAgbG9hZEV4dGVybmFsSXNWYWxpZFByb3AoKGluaXRfaXNfcHJvcF92YWxpZF9lc20oKSwgX190b0NvbW1vbkpTKGlzX3Byb3BfdmFsaWRfZXNtX2V4cG9ydHMpKS5kZWZhdWx0KTtcbn0gY2F0Y2ggKF9hKSB7XG59XG5mdW5jdGlvbiBmaWx0ZXJQcm9wcyhwcm9wcywgaXNEb20sIGZvcndhcmRNb3Rpb25Qcm9wcykge1xuICBjb25zdCBmaWx0ZXJlZFByb3BzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgaWYgKHNob3VsZEZvcndhcmQoa2V5KSB8fCBmb3J3YXJkTW90aW9uUHJvcHMgPT09IHRydWUgJiYgaXNWYWxpZE1vdGlvblByb3Aoa2V5KSB8fCAhaXNEb20gJiYgIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSkgfHwgcHJvcHNbXCJkcmFnZ2FibGVcIl0gJiYga2V5LnN0YXJ0c1dpdGgoXCJvbkRyYWdcIikpIHtcbiAgICAgIGZpbHRlcmVkUHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWx0ZXJlZFByb3BzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXNlLXByb3BzLm1qc1xudmFyIGltcG9ydF9yZWFjdDE1ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvdHJhbnNmb3JtLW9yaWdpbi5tanNcbmZ1bmN0aW9uIGNhbGNPcmlnaW4ob3JpZ2luLCBvZmZzZXQsIHNpemUpIHtcbiAgcmV0dXJuIHR5cGVvZiBvcmlnaW4gPT09IFwic3RyaW5nXCIgPyBvcmlnaW4gOiBweC50cmFuc2Zvcm0ob2Zmc2V0ICsgc2l6ZSAqIG9yaWdpbik7XG59XG5mdW5jdGlvbiBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luKGRpbWVuc2lvbnMsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgY29uc3QgcHhPcmlnaW5YID0gY2FsY09yaWdpbihvcmlnaW5YLCBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMud2lkdGgpO1xuICBjb25zdCBweE9yaWdpblkgPSBjYWxjT3JpZ2luKG9yaWdpblksIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy5oZWlnaHQpO1xuICByZXR1cm4gYCR7cHhPcmlnaW5YfSAke3B4T3JpZ2luWX1gO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvcGF0aC5tanNcbnZhciBkYXNoS2V5cyA9IHtcbiAgb2Zmc2V0OiBcInN0cm9rZS1kYXNob2Zmc2V0XCIsXG4gIGFycmF5OiBcInN0cm9rZS1kYXNoYXJyYXlcIlxufTtcbnZhciBjYW1lbEtleXMgPSB7XG4gIG9mZnNldDogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gIGFycmF5OiBcInN0cm9rZURhc2hhcnJheVwiXG59O1xuZnVuY3Rpb24gYnVpbGRTVkdQYXRoKGF0dHJzLCBsZW5ndGgsIHNwYWNpbmcgPSAxLCBvZmZzZXQgPSAwLCB1c2VEYXNoQ2FzZSA9IHRydWUpIHtcbiAgYXR0cnMucGF0aExlbmd0aCA9IDE7XG4gIGNvbnN0IGtleXMyID0gdXNlRGFzaENhc2UgPyBkYXNoS2V5cyA6IGNhbWVsS2V5cztcbiAgYXR0cnNba2V5czIub2Zmc2V0XSA9IHB4LnRyYW5zZm9ybSgtb2Zmc2V0KTtcbiAgY29uc3QgcGF0aExlbmd0aCA9IHB4LnRyYW5zZm9ybShsZW5ndGgpO1xuICBjb25zdCBwYXRoU3BhY2luZyA9IHB4LnRyYW5zZm9ybShzcGFjaW5nKTtcbiAgYXR0cnNba2V5czIuYXJyYXldID0gYCR7cGF0aExlbmd0aH0gJHtwYXRoU3BhY2luZ31gO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvYnVpbGQtYXR0cnMubWpzXG5mdW5jdGlvbiBidWlsZFNWR0F0dHJzKHN0YXRlLCBfYSwgb3B0aW9ucywgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgdmFyIF9iID0gX2EsIHtcbiAgICBhdHRyWCxcbiAgICBhdHRyWSxcbiAgICBvcmlnaW5YLFxuICAgIG9yaWdpblksXG4gICAgcGF0aExlbmd0aCxcbiAgICBwYXRoU3BhY2luZyA9IDEsXG4gICAgcGF0aE9mZnNldCA9IDBcbiAgfSA9IF9iLCBsYXRlc3QgPSBfX29ialJlc3QoX2IsIFtcbiAgICBcImF0dHJYXCIsXG4gICAgXCJhdHRyWVwiLFxuICAgIFwib3JpZ2luWFwiLFxuICAgIFwib3JpZ2luWVwiLFxuICAgIFwicGF0aExlbmd0aFwiLFxuICAgIFwicGF0aFNwYWNpbmdcIixcbiAgICBcInBhdGhPZmZzZXRcIlxuICBdKTtcbiAgYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCBsYXRlc3QsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgc3RhdGUuYXR0cnMgPSBzdGF0ZS5zdHlsZTtcbiAgc3RhdGUuc3R5bGUgPSB7fTtcbiAgY29uc3QgeyBhdHRycywgc3R5bGUsIGRpbWVuc2lvbnMgfSA9IHN0YXRlO1xuICBpZiAoYXR0cnMudHJhbnNmb3JtKSB7XG4gICAgaWYgKGRpbWVuc2lvbnMpXG4gICAgICBzdHlsZS50cmFuc2Zvcm0gPSBhdHRycy50cmFuc2Zvcm07XG4gICAgZGVsZXRlIGF0dHJzLnRyYW5zZm9ybTtcbiAgfVxuICBpZiAoZGltZW5zaW9ucyAmJiAob3JpZ2luWCAhPT0gdm9pZCAwIHx8IG9yaWdpblkgIT09IHZvaWQgMCB8fCBzdHlsZS50cmFuc2Zvcm0pKSB7XG4gICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2FsY1NWR1RyYW5zZm9ybU9yaWdpbihkaW1lbnNpb25zLCBvcmlnaW5YICE9PSB2b2lkIDAgPyBvcmlnaW5YIDogMC41LCBvcmlnaW5ZICE9PSB2b2lkIDAgPyBvcmlnaW5ZIDogMC41KTtcbiAgfVxuICBpZiAoYXR0clggIT09IHZvaWQgMClcbiAgICBhdHRycy54ID0gYXR0clg7XG4gIGlmIChhdHRyWSAhPT0gdm9pZCAwKVxuICAgIGF0dHJzLnkgPSBhdHRyWTtcbiAgaWYgKHBhdGhMZW5ndGggIT09IHZvaWQgMCkge1xuICAgIGJ1aWxkU1ZHUGF0aChhdHRycywgcGF0aExlbmd0aCwgcGF0aFNwYWNpbmcsIHBhdGhPZmZzZXQsIGZhbHNlKTtcbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanNcbnZhciBjcmVhdGVTdmdSZW5kZXJTdGF0ZSA9ICgpID0+IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSgpKSwge1xuICBhdHRyczoge31cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXNlLXByb3BzLm1qc1xuZnVuY3Rpb24gdXNlU1ZHUHJvcHMocHJvcHMsIHZpc3VhbFN0YXRlKSB7XG4gIGNvbnN0IHZpc3VhbFByb3BzID0gKDAsIGltcG9ydF9yZWFjdDE1LnVzZU1lbW8pKCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZVN2Z1JlbmRlclN0YXRlKCk7XG4gICAgYnVpbGRTVkdBdHRycyhzdGF0ZSwgdmlzdWFsU3RhdGUsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IGZhbHNlIH0sIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgc3RhdGUuYXR0cnMpLCB7XG4gICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoe30sIHN0YXRlLnN0eWxlKVxuICAgIH0pO1xuICB9LCBbdmlzdWFsU3RhdGVdKTtcbiAgaWYgKHByb3BzLnN0eWxlKSB7XG4gICAgY29uc3QgcmF3U3R5bGVzID0ge307XG4gICAgY29weVJhd1ZhbHVlc09ubHkocmF3U3R5bGVzLCBwcm9wcy5zdHlsZSwgcHJvcHMpO1xuICAgIHZpc3VhbFByb3BzLnN0eWxlID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHJhd1N0eWxlcyksIHZpc3VhbFByb3BzLnN0eWxlKTtcbiAgfVxuICByZXR1cm4gdmlzdWFsUHJvcHM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91c2UtcmVuZGVyLm1qc1xuZnVuY3Rpb24gY3JlYXRlVXNlUmVuZGVyKGZvcndhcmRNb3Rpb25Qcm9wcyA9IGZhbHNlKSB7XG4gIGNvbnN0IHVzZVJlbmRlciA9IChDb21wb25lbnQsIHByb3BzLCBwcm9qZWN0aW9uSWQsIHJlZiwgeyBsYXRlc3RWYWx1ZXMgfSwgaXNTdGF0aWMpID0+IHtcbiAgICBjb25zdCB1c2VWaXN1YWxQcm9wcyA9IGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudCkgPyB1c2VTVkdQcm9wcyA6IHVzZUhUTUxQcm9wcztcbiAgICBjb25zdCB2aXN1YWxQcm9wcyA9IHVzZVZpc3VhbFByb3BzKHByb3BzLCBsYXRlc3RWYWx1ZXMsIGlzU3RhdGljKTtcbiAgICBjb25zdCBmaWx0ZXJlZFByb3BzID0gZmlsdGVyUHJvcHMocHJvcHMsIHR5cGVvZiBDb21wb25lbnQgPT09IFwic3RyaW5nXCIsIGZvcndhcmRNb3Rpb25Qcm9wcyk7XG4gICAgY29uc3QgZWxlbWVudFByb3BzID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZmlsdGVyZWRQcm9wcyksIHZpc3VhbFByb3BzKSwge1xuICAgICAgcmVmXG4gICAgfSk7XG4gICAgaWYgKHByb2plY3Rpb25JZCkge1xuICAgICAgZWxlbWVudFByb3BzW1wiZGF0YS1wcm9qZWN0aW9uLWlkXCJdID0gcHJvamVjdGlvbklkO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGltcG9ydF9yZWFjdDE2LmNyZWF0ZUVsZW1lbnQpKENvbXBvbmVudCwgZWxlbWVudFByb3BzKTtcbiAgfTtcbiAgcmV0dXJuIHVzZVJlbmRlcjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2NhbWVsLXRvLWRhc2gubWpzXG52YXIgY2FtZWxUb0Rhc2ggPSAoc3RyKSA9PiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL3JlbmRlci5tanNcbmZ1bmN0aW9uIHJlbmRlckhUTUwoZWxlbWVudCwgeyBzdHlsZSwgdmFycyB9LCBzdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSwgcHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLmdldFByb2plY3Rpb25TdHlsZXMoc3R5bGVQcm9wKSk7XG4gIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcbiAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFyc1trZXldKTtcbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvY2FtZWwtY2FzZS1hdHRycy5tanNcbnZhciBjYW1lbENhc2VBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImJhc2VGcmVxdWVuY3lcIixcbiAgXCJkaWZmdXNlQ29uc3RhbnRcIixcbiAgXCJrZXJuZWxNYXRyaXhcIixcbiAgXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gIFwia2V5U3BsaW5lc1wiLFxuICBcImtleVRpbWVzXCIsXG4gIFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgXCJtYXJrZXJIZWlnaHRcIixcbiAgXCJtYXJrZXJXaWR0aFwiLFxuICBcIm51bU9jdGF2ZXNcIixcbiAgXCJ0YXJnZXRYXCIsXG4gIFwidGFyZ2V0WVwiLFxuICBcInN1cmZhY2VTY2FsZVwiLFxuICBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gIFwic3RkRGV2aWF0aW9uXCIsXG4gIFwidGFibGVWYWx1ZXNcIixcbiAgXCJ2aWV3Qm94XCIsXG4gIFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgXCJwYXRoTGVuZ3RoXCJcbl0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvcmVuZGVyLm1qc1xuZnVuY3Rpb24gcmVuZGVyU1ZHKGVsZW1lbnQsIHJlbmRlclN0YXRlLCBfc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gIHJlbmRlckhUTUwoZWxlbWVudCwgcmVuZGVyU3RhdGUsIHZvaWQgMCwgcHJvamVjdGlvbik7XG4gIGZvciAoY29uc3Qga2V5IGluIHJlbmRlclN0YXRlLmF0dHJzKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoIWNhbWVsQ2FzZUF0dHJpYnV0ZXMuaGFzKGtleSkgPyBjYW1lbFRvRGFzaChrZXkpIDoga2V5LCByZW5kZXJTdGF0ZS5hdHRyc1trZXldKTtcbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qc1xuZnVuY3Rpb24gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKSB7XG4gIGNvbnN0IHsgc3R5bGUgfSA9IHByb3BzO1xuICBjb25zdCBuZXdWYWx1ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGUpIHtcbiAgICBpZiAoaXNNb3Rpb25WYWx1ZShzdHlsZVtrZXldKSB8fCBpc0ZvcmNlZE1vdGlvblZhbHVlKGtleSwgcHJvcHMpKSB7XG4gICAgICBuZXdWYWx1ZXNba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdWYWx1ZXM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanNcbmZ1bmN0aW9uIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczIocHJvcHMpIHtcbiAgY29uc3QgbmV3VmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaXNNb3Rpb25WYWx1ZShwcm9wc1trZXldKSkge1xuICAgICAgY29uc3QgdGFyZ2V0S2V5ID0ga2V5ID09PSBcInhcIiB8fCBrZXkgPT09IFwieVwiID8gXCJhdHRyXCIgKyBrZXkudG9VcHBlckNhc2UoKSA6IGtleTtcbiAgICAgIG5ld1ZhbHVlc1t0YXJnZXRLZXldID0gcHJvcHNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1ZhbHVlcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1zdGF0ZS5tanNcbnZhciBpbXBvcnRfcmVhY3QxNyA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvcmVzb2x2ZS12YXJpYW50cy5tanNcbmZ1bmN0aW9uIHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uLCBjdXN0b20sIGN1cnJlbnRWYWx1ZXMgPSB7fSwgY3VycmVudFZlbG9jaXR5ID0ge30pIHtcbiAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbihjdXN0b20gIT09IHZvaWQgMCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgY3VycmVudFZhbHVlcywgY3VycmVudFZlbG9jaXR5KTtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICBkZWZpbml0aW9uID0gcHJvcHMudmFyaWFudHMgJiYgcHJvcHMudmFyaWFudHNbZGVmaW5pdGlvbl07XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbihjdXN0b20gIT09IHZvaWQgMCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgY3VycmVudFZhbHVlcywgY3VycmVudFZlbG9jaXR5KTtcbiAgfVxuICByZXR1cm4gZGVmaW5pdGlvbjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvaXMta2V5ZnJhbWVzLXRhcmdldC5tanNcbnZhciBpc0tleWZyYW1lc1RhcmdldCA9ICh2KSA9PiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHYpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9yZXNvbHZlLXZhbHVlLm1qc1xudmFyIGlzQ3VzdG9tVmFsdWUgPSAodikgPT4ge1xuICByZXR1cm4gQm9vbGVhbih2ICYmIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYubWl4ICYmIHYudG9WYWx1ZSk7XG59O1xudmFyIHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMgPSAodikgPT4ge1xuICByZXR1cm4gaXNLZXlmcmFtZXNUYXJnZXQodikgPyB2W3YubGVuZ3RoIC0gMV0gfHwgMCA6IHY7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3V0aWxzL3Jlc29sdmUtbW90aW9uLXZhbHVlLm1qc1xuZnVuY3Rpb24gcmVzb2x2ZU1vdGlvblZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IHVud3JhcHBlZFZhbHVlID0gaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZS5nZXQoKSA6IHZhbHVlO1xuICByZXR1cm4gaXNDdXN0b21WYWx1ZSh1bndyYXBwZWRWYWx1ZSkgPyB1bndyYXBwZWRWYWx1ZS50b1ZhbHVlKCkgOiB1bndyYXBwZWRWYWx1ZTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1zdGF0ZS5tanNcbmZ1bmN0aW9uIG1ha2VTdGF0ZSh7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMywgY3JlYXRlUmVuZGVyU3RhdGUsIG9uTW91bnQgfSwgcHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBsYXRlc3RWYWx1ZXM6IG1ha2VMYXRlc3RWYWx1ZXMocHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMyksXG4gICAgcmVuZGVyU3RhdGU6IGNyZWF0ZVJlbmRlclN0YXRlKClcbiAgfTtcbiAgaWYgKG9uTW91bnQpIHtcbiAgICBzdGF0ZS5tb3VudCA9IChpbnN0YW5jZSkgPT4gb25Nb3VudChwcm9wcywgaW5zdGFuY2UsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG52YXIgbWFrZVVzZVZpc3VhbFN0YXRlID0gKGNvbmZpZykgPT4gKHByb3BzLCBpc1N0YXRpYykgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZUNvbnRleHQpKE1vdGlvbkNvbnRleHQpO1xuICBjb25zdCBwcmVzZW5jZUNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MTcudXNlQ29udGV4dCkoUHJlc2VuY2VDb250ZXh0KTtcbiAgY29uc3QgbWFrZSA9ICgpID0+IG1ha2VTdGF0ZShjb25maWcsIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpO1xuICByZXR1cm4gaXNTdGF0aWMgPyBtYWtlKCkgOiB1c2VDb25zdGFudChtYWtlKTtcbn07XG5mdW5jdGlvbiBtYWtlTGF0ZXN0VmFsdWVzKHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQsIHNjcmFwZU1vdGlvblZhbHVlcykge1xuICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgY29uc3QgbW90aW9uVmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzKHByb3BzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbW90aW9uVmFsdWVzKSB7XG4gICAgdmFsdWVzW2tleV0gPSByZXNvbHZlTW90aW9uVmFsdWUobW90aW9uVmFsdWVzW2tleV0pO1xuICB9XG4gIGxldCB7IGluaXRpYWwsIGFuaW1hdGU6IGFuaW1hdGUzIH0gPSBwcm9wcztcbiAgY29uc3QgaXNDb250cm9sbGluZ1ZhcmlhbnRzJDEgPSBpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpO1xuICBjb25zdCBpc1ZhcmlhbnROb2RlJDEgPSBpc1ZhcmlhbnROb2RlKHByb3BzKTtcbiAgaWYgKGNvbnRleHQgJiYgaXNWYXJpYW50Tm9kZSQxICYmICFpc0NvbnRyb2xsaW5nVmFyaWFudHMkMSAmJiBwcm9wcy5pbmhlcml0ICE9PSBmYWxzZSkge1xuICAgIGlmIChpbml0aWFsID09PSB2b2lkIDApXG4gICAgICBpbml0aWFsID0gY29udGV4dC5pbml0aWFsO1xuICAgIGlmIChhbmltYXRlMyA9PT0gdm9pZCAwKVxuICAgICAgYW5pbWF0ZTMgPSBjb250ZXh0LmFuaW1hdGU7XG4gIH1cbiAgbGV0IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPSBwcmVzZW5jZUNvbnRleHQgPyBwcmVzZW5jZUNvbnRleHQuaW5pdGlhbCA9PT0gZmFsc2UgOiBmYWxzZTtcbiAgaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZCA9IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgfHwgaW5pdGlhbCA9PT0gZmFsc2U7XG4gIGNvbnN0IHZhcmlhbnRUb1NldCA9IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPyBhbmltYXRlMyA6IGluaXRpYWw7XG4gIGlmICh2YXJpYW50VG9TZXQgJiYgdHlwZW9mIHZhcmlhbnRUb1NldCAhPT0gXCJib29sZWFuXCIgJiYgIWlzQW5pbWF0aW9uQ29udHJvbHModmFyaWFudFRvU2V0KSkge1xuICAgIGNvbnN0IGxpc3QgPSBBcnJheS5pc0FycmF5KHZhcmlhbnRUb1NldCkgPyB2YXJpYW50VG9TZXQgOiBbdmFyaWFudFRvU2V0XTtcbiAgICBsaXN0LmZvckVhY2goKGRlZmluaXRpb24pID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24pO1xuICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgX2EgPSByZXNvbHZlZCwgeyB0cmFuc2l0aW9uRW5kLCB0cmFuc2l0aW9uIH0gPSBfYSwgdGFyZ2V0ID0gX19vYmpSZXN0KF9hLCBbXCJ0cmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvblwiXSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgbGV0IHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlVGFyZ2V0KSkge1xuICAgICAgICAgIGNvbnN0IGluZGV4MiA9IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPyB2YWx1ZVRhcmdldC5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICB2YWx1ZVRhcmdldCA9IHZhbHVlVGFyZ2V0W2luZGV4Ml07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZVRhcmdldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHJhbnNpdGlvbkVuZClcbiAgICAgICAgdmFsdWVzW2tleV0gPSB0cmFuc2l0aW9uRW5kW2tleV07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL2NvbmZpZy1tb3Rpb24ubWpzXG52YXIgc3ZnTW90aW9uQ29uZmlnID0ge1xuICB1c2VWaXN1YWxTdGF0ZTogbWFrZVVzZVZpc3VhbFN0YXRlKHtcbiAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczIsXG4gICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZVN2Z1JlbmRlclN0YXRlLFxuICAgIG9uTW91bnQ6IChwcm9wcywgaW5zdGFuY2UsIHsgcmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcyB9KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZW5kZXJTdGF0ZS5kaW1lbnNpb25zID0gdHlwZW9mIGluc3RhbmNlLmdldEJCb3ggPT09IFwiZnVuY3Rpb25cIiA/IGluc3RhbmNlLmdldEJCb3goKSA6IGluc3RhbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZW5kZXJTdGF0ZS5kaW1lbnNpb25zID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGJ1aWxkU1ZHQXR0cnMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogZmFsc2UgfSwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgcmVuZGVyU1ZHKGluc3RhbmNlLCByZW5kZXJTdGF0ZSk7XG4gICAgfVxuICB9KVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC9jb25maWctbW90aW9uLm1qc1xudmFyIGh0bWxNb3Rpb25Db25maWcgPSB7XG4gIHVzZVZpc3VhbFN0YXRlOiBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyxcbiAgICBjcmVhdGVSZW5kZXJTdGF0ZTogY3JlYXRlSHRtbFJlbmRlclN0YXRlXG4gIH0pXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvY3JlYXRlLWNvbmZpZy5tanNcbmZ1bmN0aW9uIGNyZWF0ZURvbU1vdGlvbkNvbmZpZyhDb21wb25lbnQsIHsgZm9yd2FyZE1vdGlvblByb3BzID0gZmFsc2UgfSwgcHJlbG9hZGVkRmVhdHVyZXMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQsIHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IpIHtcbiAgY29uc3QgYmFzZUNvbmZpZyA9IGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudCkgPyBzdmdNb3Rpb25Db25maWcgOiBodG1sTW90aW9uQ29uZmlnO1xuICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYmFzZUNvbmZpZyksIHtcbiAgICBwcmVsb2FkZWRGZWF0dXJlcyxcbiAgICB1c2VSZW5kZXI6IGNyZWF0ZVVzZVJlbmRlcihmb3J3YXJkTW90aW9uUHJvcHMpLFxuICAgIGNyZWF0ZVZpc3VhbEVsZW1lbnQsXG4gICAgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvcixcbiAgICBDb21wb25lbnRcbiAgfSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL3R5cGVzLm1qc1xudmFyIEFuaW1hdGlvblR5cGU7XG4oZnVuY3Rpb24oQW5pbWF0aW9uVHlwZTIpIHtcbiAgQW5pbWF0aW9uVHlwZTJbXCJBbmltYXRlXCJdID0gXCJhbmltYXRlXCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiSG92ZXJcIl0gPSBcIndoaWxlSG92ZXJcIjtcbiAgQW5pbWF0aW9uVHlwZTJbXCJUYXBcIl0gPSBcIndoaWxlVGFwXCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiRHJhZ1wiXSA9IFwid2hpbGVEcmFnXCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiRm9jdXNcIl0gPSBcIndoaWxlRm9jdXNcIjtcbiAgQW5pbWF0aW9uVHlwZTJbXCJJblZpZXdcIl0gPSBcIndoaWxlSW5WaWV3XCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiRXhpdFwiXSA9IFwiZXhpdFwiO1xufSkoQW5pbWF0aW9uVHlwZSB8fCAoQW5pbWF0aW9uVHlwZSA9IHt9KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL3VzZS1kb20tZXZlbnQubWpzXG52YXIgaW1wb3J0X3JlYWN0MTggPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiBhZGREb21FdmVudCh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9KSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xufVxuZnVuY3Rpb24gdXNlRG9tRXZlbnQocmVmLCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgKDAsIGltcG9ydF9yZWFjdDE4LnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSByZWYuY3VycmVudDtcbiAgICBpZiAoaGFuZGxlciAmJiBlbGVtZW50KSB7XG4gICAgICByZXR1cm4gYWRkRG9tRXZlbnQoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIFtyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9uc10pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS1mb2N1cy1nZXN0dXJlLm1qc1xuZnVuY3Rpb24gdXNlRm9jdXNHZXN0dXJlKHsgd2hpbGVGb2N1cywgdmlzdWFsRWxlbWVudCB9KSB7XG4gIGNvbnN0IHsgYW5pbWF0aW9uU3RhdGUgfSA9IHZpc3VhbEVsZW1lbnQ7XG4gIGNvbnN0IG9uRm9jdXMgPSAoKSA9PiB7XG4gICAgYW5pbWF0aW9uU3RhdGUgJiYgYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuRm9jdXMsIHRydWUpO1xuICB9O1xuICBjb25zdCBvbkJsdXIgPSAoKSA9PiB7XG4gICAgYW5pbWF0aW9uU3RhdGUgJiYgYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuRm9jdXMsIGZhbHNlKTtcbiAgfTtcbiAgdXNlRG9tRXZlbnQodmlzdWFsRWxlbWVudCwgXCJmb2N1c1wiLCB3aGlsZUZvY3VzID8gb25Gb2N1cyA6IHZvaWQgMCk7XG4gIHVzZURvbUV2ZW50KHZpc3VhbEVsZW1lbnQsIFwiYmx1clwiLCB3aGlsZUZvY3VzID8gb25CbHVyIDogdm9pZCAwKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy91dGlscy9ldmVudC10eXBlLm1qc1xuZnVuY3Rpb24gaXNNb3VzZUV2ZW50KGV2ZW50KSB7XG4gIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGV2ZW50IGluc3RhbmNlb2YgUG9pbnRlckV2ZW50KSB7XG4gICAgcmV0dXJuICEhKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpO1xuICB9XG4gIHJldHVybiBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQ7XG59XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgaGFzVG91Y2hlcyA9ICEhZXZlbnQudG91Y2hlcztcbiAgcmV0dXJuIGhhc1RvdWNoZXM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL2V2ZW50LWluZm8ubWpzXG5mdW5jdGlvbiBmaWx0ZXJQcmltYXJ5UG9pbnRlcihldmVudEhhbmRsZXIpIHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGNvbnN0IGlzTW91c2VFdmVudDIgPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQ7XG4gICAgY29uc3QgaXNQcmltYXJ5UG9pbnRlciA9ICFpc01vdXNlRXZlbnQyIHx8IGlzTW91c2VFdmVudDIgJiYgZXZlbnQuYnV0dG9uID09PSAwO1xuICAgIGlmIChpc1ByaW1hcnlQb2ludGVyKSB7XG4gICAgICBldmVudEhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBkZWZhdWx0UGFnZVBvaW50ID0geyBwYWdlWDogMCwgcGFnZVk6IDAgfTtcbmZ1bmN0aW9uIHBvaW50RnJvbVRvdWNoKGUsIHBvaW50VHlwZSA9IFwicGFnZVwiKSB7XG4gIGNvbnN0IHByaW1hcnlUb3VjaCA9IGUudG91Y2hlc1swXSB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICBjb25zdCBwb2ludDIgPSBwcmltYXJ5VG91Y2ggfHwgZGVmYXVsdFBhZ2VQb2ludDtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludDJbcG9pbnRUeXBlICsgXCJYXCJdLFxuICAgIHk6IHBvaW50Mltwb2ludFR5cGUgKyBcIllcIl1cbiAgfTtcbn1cbmZ1bmN0aW9uIHBvaW50RnJvbU1vdXNlKHBvaW50MiwgcG9pbnRUeXBlID0gXCJwYWdlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludDJbcG9pbnRUeXBlICsgXCJYXCJdLFxuICAgIHk6IHBvaW50Mltwb2ludFR5cGUgKyBcIllcIl1cbiAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudEluZm8oZXZlbnQsIHBvaW50VHlwZSA9IFwicGFnZVwiKSB7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IGlzVG91Y2hFdmVudChldmVudCkgPyBwb2ludEZyb21Ub3VjaChldmVudCwgcG9pbnRUeXBlKSA6IHBvaW50RnJvbU1vdXNlKGV2ZW50LCBwb2ludFR5cGUpXG4gIH07XG59XG52YXIgd3JhcEhhbmRsZXIgPSAoaGFuZGxlciwgc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBsaXN0ZW5lciA9IChldmVudCkgPT4gaGFuZGxlcihldmVudCwgZXh0cmFjdEV2ZW50SW5mbyhldmVudCkpO1xuICByZXR1cm4gc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIgPyBmaWx0ZXJQcmltYXJ5UG9pbnRlcihsaXN0ZW5lcikgOiBsaXN0ZW5lcjtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL3V0aWxzLm1qc1xudmFyIHN1cHBvcnRzUG9pbnRlckV2ZW50cyA9ICgpID0+IGlzQnJvd3NlciAmJiB3aW5kb3cub25wb2ludGVyZG93biA9PT0gbnVsbDtcbnZhciBzdXBwb3J0c1RvdWNoRXZlbnRzID0gKCkgPT4gaXNCcm93c2VyICYmIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09IG51bGw7XG52YXIgc3VwcG9ydHNNb3VzZUV2ZW50cyA9ICgpID0+IGlzQnJvd3NlciAmJiB3aW5kb3cub25tb3VzZWRvd24gPT09IG51bGw7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL3VzZS1wb2ludGVyLWV2ZW50Lm1qc1xudmFyIG1vdXNlRXZlbnROYW1lcyA9IHtcbiAgcG9pbnRlcmRvd246IFwibW91c2Vkb3duXCIsXG4gIHBvaW50ZXJtb3ZlOiBcIm1vdXNlbW92ZVwiLFxuICBwb2ludGVydXA6IFwibW91c2V1cFwiLFxuICBwb2ludGVyY2FuY2VsOiBcIm1vdXNlY2FuY2VsXCIsXG4gIHBvaW50ZXJvdmVyOiBcIm1vdXNlb3ZlclwiLFxuICBwb2ludGVyb3V0OiBcIm1vdXNlb3V0XCIsXG4gIHBvaW50ZXJlbnRlcjogXCJtb3VzZWVudGVyXCIsXG4gIHBvaW50ZXJsZWF2ZTogXCJtb3VzZWxlYXZlXCJcbn07XG52YXIgdG91Y2hFdmVudE5hbWVzID0ge1xuICBwb2ludGVyZG93bjogXCJ0b3VjaHN0YXJ0XCIsXG4gIHBvaW50ZXJtb3ZlOiBcInRvdWNobW92ZVwiLFxuICBwb2ludGVydXA6IFwidG91Y2hlbmRcIixcbiAgcG9pbnRlcmNhbmNlbDogXCJ0b3VjaGNhbmNlbFwiXG59O1xuZnVuY3Rpb24gZ2V0UG9pbnRlckV2ZW50TmFtZShuYW1lKSB7XG4gIGlmIChzdXBwb3J0c1BvaW50ZXJFdmVudHMoKSkge1xuICAgIHJldHVybiBuYW1lO1xuICB9IGVsc2UgaWYgKHN1cHBvcnRzVG91Y2hFdmVudHMoKSkge1xuICAgIHJldHVybiB0b3VjaEV2ZW50TmFtZXNbbmFtZV07XG4gIH0gZWxzZSBpZiAoc3VwcG9ydHNNb3VzZUV2ZW50cygpKSB7XG4gICAgcmV0dXJuIG1vdXNlRXZlbnROYW1lc1tuYW1lXTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGFkZFBvaW50ZXJFdmVudCh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICByZXR1cm4gYWRkRG9tRXZlbnQodGFyZ2V0LCBnZXRQb2ludGVyRXZlbnROYW1lKGV2ZW50TmFtZSksIHdyYXBIYW5kbGVyKGhhbmRsZXIsIGV2ZW50TmFtZSA9PT0gXCJwb2ludGVyZG93blwiKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB1c2VQb2ludGVyRXZlbnQocmVmLCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVzZURvbUV2ZW50KHJlZiwgZ2V0UG9pbnRlckV2ZW50TmFtZShldmVudE5hbWUpLCBoYW5kbGVyICYmIHdyYXBIYW5kbGVyKGhhbmRsZXIsIGV2ZW50TmFtZSA9PT0gXCJwb2ludGVyZG93blwiKSwgb3B0aW9ucyk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91dGlscy9sb2NrLm1qc1xuZnVuY3Rpb24gY3JlYXRlTG9jayhuYW1lKSB7XG4gIGxldCBsb2NrID0gbnVsbDtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBvcGVuTG9jayA9ICgpID0+IHtcbiAgICAgIGxvY2sgPSBudWxsO1xuICAgIH07XG4gICAgaWYgKGxvY2sgPT09IG51bGwpIHtcbiAgICAgIGxvY2sgPSBuYW1lO1xuICAgICAgcmV0dXJuIG9wZW5Mb2NrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG52YXIgZ2xvYmFsSG9yaXpvbnRhbExvY2sgPSBjcmVhdGVMb2NrKFwiZHJhZ0hvcml6b250YWxcIik7XG52YXIgZ2xvYmFsVmVydGljYWxMb2NrID0gY3JlYXRlTG9jayhcImRyYWdWZXJ0aWNhbFwiKTtcbmZ1bmN0aW9uIGdldEdsb2JhbExvY2soZHJhZzIpIHtcbiAgbGV0IGxvY2sgPSBmYWxzZTtcbiAgaWYgKGRyYWcyID09PSBcInlcIikge1xuICAgIGxvY2sgPSBnbG9iYWxWZXJ0aWNhbExvY2soKTtcbiAgfSBlbHNlIGlmIChkcmFnMiA9PT0gXCJ4XCIpIHtcbiAgICBsb2NrID0gZ2xvYmFsSG9yaXpvbnRhbExvY2soKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvcGVuSG9yaXpvbnRhbCA9IGdsb2JhbEhvcml6b250YWxMb2NrKCk7XG4gICAgY29uc3Qgb3BlblZlcnRpY2FsID0gZ2xvYmFsVmVydGljYWxMb2NrKCk7XG4gICAgaWYgKG9wZW5Ib3Jpem9udGFsICYmIG9wZW5WZXJ0aWNhbCkge1xuICAgICAgbG9jayA9ICgpID0+IHtcbiAgICAgICAgb3Blbkhvcml6b250YWwoKTtcbiAgICAgICAgb3BlblZlcnRpY2FsKCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3Blbkhvcml6b250YWwpXG4gICAgICAgIG9wZW5Ib3Jpem9udGFsKCk7XG4gICAgICBpZiAob3BlblZlcnRpY2FsKVxuICAgICAgICBvcGVuVmVydGljYWwoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvY2s7XG59XG5mdW5jdGlvbiBpc0RyYWdBY3RpdmUoKSB7XG4gIGNvbnN0IG9wZW5HZXN0dXJlTG9jayA9IGdldEdsb2JhbExvY2sodHJ1ZSk7XG4gIGlmICghb3Blbkdlc3R1cmVMb2NrKVxuICAgIHJldHVybiB0cnVlO1xuICBvcGVuR2VzdHVyZUxvY2soKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS1ob3Zlci1nZXN0dXJlLm1qc1xuZnVuY3Rpb24gY3JlYXRlSG92ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBpc0FjdGl2ZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIChldmVudCwgaW5mbykgPT4ge1xuICAgIGlmICghaXNNb3VzZUV2ZW50KGV2ZW50KSB8fCBpc0RyYWdBY3RpdmUoKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkge1xuICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5Ib3ZlciwgaXNBY3RpdmUpO1xuICAgIH1cbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhldmVudCwgaW5mbyk7XG4gIH07XG59XG5mdW5jdGlvbiB1c2VIb3Zlckdlc3R1cmUoeyBvbkhvdmVyU3RhcnQsIG9uSG92ZXJFbmQsIHdoaWxlSG92ZXIsIHZpc3VhbEVsZW1lbnQgfSkge1xuICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudCwgXCJwb2ludGVyZW50ZXJcIiwgb25Ib3ZlclN0YXJ0IHx8IHdoaWxlSG92ZXIgPyBjcmVhdGVIb3ZlckV2ZW50KHZpc3VhbEVsZW1lbnQsIHRydWUsIG9uSG92ZXJTdGFydCkgOiB2b2lkIDAsIHsgcGFzc2l2ZTogIW9uSG92ZXJTdGFydCB9KTtcbiAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmxlYXZlXCIsIG9uSG92ZXJFbmQgfHwgd2hpbGVIb3ZlciA/IGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudCwgZmFsc2UsIG9uSG92ZXJFbmQpIDogdm9pZCAwLCB7IHBhc3NpdmU6ICFvbkhvdmVyRW5kIH0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS10YXAtZ2VzdHVyZS5tanNcbnZhciBpbXBvcnRfcmVhY3QyMCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy91dGlscy9pcy1ub2RlLW9yLWNoaWxkLm1qc1xudmFyIGlzTm9kZU9yQ2hpbGQgPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICBpZiAoIWNoaWxkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKHBhcmVudCA9PT0gY2hpbGQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXNOb2RlT3JDaGlsZChwYXJlbnQsIGNoaWxkLnBhcmVudEVsZW1lbnQpO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS11bm1vdW50LWVmZmVjdC5tanNcbnZhciBpbXBvcnRfcmVhY3QxOSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIHVzZVVubW91bnRFZmZlY3QoY2FsbGJhY2spIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfcmVhY3QxOS51c2VFZmZlY3QpKCgpID0+ICgpID0+IGNhbGxiYWNrKCksIFtdKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9ub2RlX21vZHVsZXMvdHNsaWIvbW9kdWxlcy9pbmRleC5qc1xudmFyIGltcG9ydF90c2xpYiA9IF9fdG9FU00ocmVxdWlyZV90c2xpYigpLCAxKTtcbnZhciB7XG4gIF9fZXh0ZW5kcyxcbiAgX19hc3NpZ24sXG4gIF9fcmVzdCxcbiAgX19kZWNvcmF0ZSxcbiAgX19wYXJhbSxcbiAgX19tZXRhZGF0YSxcbiAgX19hd2FpdGVyLFxuICBfX2dlbmVyYXRvcixcbiAgX19leHBvcnRTdGFyLFxuICBfX2NyZWF0ZUJpbmRpbmcsXG4gIF9fdmFsdWVzLFxuICBfX3JlYWQsXG4gIF9fc3ByZWFkLFxuICBfX3NwcmVhZEFycmF5cyxcbiAgX19zcHJlYWRBcnJheSxcbiAgX19hd2FpdCxcbiAgX19hc3luY0dlbmVyYXRvcixcbiAgX19hc3luY0RlbGVnYXRvcixcbiAgX19hc3luY1ZhbHVlcyxcbiAgX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gIF9faW1wb3J0U3RhcixcbiAgX19pbXBvcnREZWZhdWx0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW5cbn0gPSBpbXBvcnRfdHNsaWIuZGVmYXVsdDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2hleS1saXN0ZW4vZGlzdC9oZXktbGlzdGVuLmVzLmpzXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge1xufTtcbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbigpIHtcbn07XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjaGVjaywgbWVzc2FnZSkge1xuICAgIGlmICghY2hlY2sgJiYgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIGludmFyaWFudCA9IGZ1bmN0aW9uKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2NsYW1wLm1qc1xudmFyIGNsYW1wMiA9IChtaW4sIG1heCwgdikgPT4gTWF0aC5taW4oTWF0aC5tYXgodiwgbWluKSwgbWF4KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvdXRpbHMvZmluZC1zcHJpbmcubWpzXG52YXIgc2FmZU1pbiA9IDFlLTM7XG52YXIgbWluRHVyYXRpb24gPSAwLjAxO1xudmFyIG1heER1cmF0aW9uID0gMTA7XG52YXIgbWluRGFtcGluZyA9IDAuMDU7XG52YXIgbWF4RGFtcGluZyA9IDE7XG5mdW5jdGlvbiBmaW5kU3ByaW5nKHsgZHVyYXRpb24gPSA4MDAsIGJvdW5jZSA9IDAuMjUsIHZlbG9jaXR5ID0gMCwgbWFzcyA9IDEgfSkge1xuICBsZXQgZW52ZWxvcGU7XG4gIGxldCBkZXJpdmF0aXZlO1xuICB3YXJuaW5nKGR1cmF0aW9uIDw9IG1heER1cmF0aW9uICogMWUzLCBcIlNwcmluZyBkdXJhdGlvbiBtdXN0IGJlIDEwIHNlY29uZHMgb3IgbGVzc1wiKTtcbiAgbGV0IGRhbXBpbmdSYXRpbyA9IDEgLSBib3VuY2U7XG4gIGRhbXBpbmdSYXRpbyA9IGNsYW1wMihtaW5EYW1waW5nLCBtYXhEYW1waW5nLCBkYW1waW5nUmF0aW8pO1xuICBkdXJhdGlvbiA9IGNsYW1wMihtaW5EdXJhdGlvbiwgbWF4RHVyYXRpb24sIGR1cmF0aW9uIC8gMWUzKTtcbiAgaWYgKGRhbXBpbmdSYXRpbyA8IDEpIHtcbiAgICBlbnZlbG9wZSA9ICh1bmRhbXBlZEZyZXEyKSA9PiB7XG4gICAgICBjb25zdCBleHBvbmVudGlhbERlY2F5ID0gdW5kYW1wZWRGcmVxMiAqIGRhbXBpbmdSYXRpbztcbiAgICAgIGNvbnN0IGRlbHRhID0gZXhwb25lbnRpYWxEZWNheSAqIGR1cmF0aW9uO1xuICAgICAgY29uc3QgYTIgPSBleHBvbmVudGlhbERlY2F5IC0gdmVsb2NpdHk7XG4gICAgICBjb25zdCBiMiA9IGNhbGNBbmd1bGFyRnJlcSh1bmRhbXBlZEZyZXEyLCBkYW1waW5nUmF0aW8pO1xuICAgICAgY29uc3QgYzMgPSBNYXRoLmV4cCgtZGVsdGEpO1xuICAgICAgcmV0dXJuIHNhZmVNaW4gLSBhMiAvIGIyICogYzM7XG4gICAgfTtcbiAgICBkZXJpdmF0aXZlID0gKHVuZGFtcGVkRnJlcTIpID0+IHtcbiAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVjYXkgPSB1bmRhbXBlZEZyZXEyICogZGFtcGluZ1JhdGlvO1xuICAgICAgY29uc3QgZGVsdGEgPSBleHBvbmVudGlhbERlY2F5ICogZHVyYXRpb247XG4gICAgICBjb25zdCBkMiA9IGRlbHRhICogdmVsb2NpdHkgKyB2ZWxvY2l0eTtcbiAgICAgIGNvbnN0IGUgPSBNYXRoLnBvdyhkYW1waW5nUmF0aW8sIDIpICogTWF0aC5wb3codW5kYW1wZWRGcmVxMiwgMikgKiBkdXJhdGlvbjtcbiAgICAgIGNvbnN0IGYyID0gTWF0aC5leHAoLWRlbHRhKTtcbiAgICAgIGNvbnN0IGcyID0gY2FsY0FuZ3VsYXJGcmVxKE1hdGgucG93KHVuZGFtcGVkRnJlcTIsIDIpLCBkYW1waW5nUmF0aW8pO1xuICAgICAgY29uc3QgZmFjdG9yID0gLWVudmVsb3BlKHVuZGFtcGVkRnJlcTIpICsgc2FmZU1pbiA+IDAgPyAtMSA6IDE7XG4gICAgICByZXR1cm4gZmFjdG9yICogKChkMiAtIGUpICogZjIpIC8gZzI7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBlbnZlbG9wZSA9ICh1bmRhbXBlZEZyZXEyKSA9PiB7XG4gICAgICBjb25zdCBhMiA9IE1hdGguZXhwKC11bmRhbXBlZEZyZXEyICogZHVyYXRpb24pO1xuICAgICAgY29uc3QgYjIgPSAodW5kYW1wZWRGcmVxMiAtIHZlbG9jaXR5KSAqIGR1cmF0aW9uICsgMTtcbiAgICAgIHJldHVybiAtc2FmZU1pbiArIGEyICogYjI7XG4gICAgfTtcbiAgICBkZXJpdmF0aXZlID0gKHVuZGFtcGVkRnJlcTIpID0+IHtcbiAgICAgIGNvbnN0IGEyID0gTWF0aC5leHAoLXVuZGFtcGVkRnJlcTIgKiBkdXJhdGlvbik7XG4gICAgICBjb25zdCBiMiA9ICh2ZWxvY2l0eSAtIHVuZGFtcGVkRnJlcTIpICogKGR1cmF0aW9uICogZHVyYXRpb24pO1xuICAgICAgcmV0dXJuIGEyICogYjI7XG4gICAgfTtcbiAgfVxuICBjb25zdCBpbml0aWFsR3Vlc3MgPSA1IC8gZHVyYXRpb247XG4gIGNvbnN0IHVuZGFtcGVkRnJlcSA9IGFwcHJveGltYXRlUm9vdChlbnZlbG9wZSwgZGVyaXZhdGl2ZSwgaW5pdGlhbEd1ZXNzKTtcbiAgZHVyYXRpb24gPSBkdXJhdGlvbiAqIDFlMztcbiAgaWYgKGlzTmFOKHVuZGFtcGVkRnJlcSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RpZmZuZXNzOiAxMDAsXG4gICAgICBkYW1waW5nOiAxMCxcbiAgICAgIGR1cmF0aW9uXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdGlmZm5lc3MgPSBNYXRoLnBvdyh1bmRhbXBlZEZyZXEsIDIpICogbWFzcztcbiAgICByZXR1cm4ge1xuICAgICAgc3RpZmZuZXNzLFxuICAgICAgZGFtcGluZzogZGFtcGluZ1JhdGlvICogMiAqIE1hdGguc3FydChtYXNzICogc3RpZmZuZXNzKSxcbiAgICAgIGR1cmF0aW9uXG4gICAgfTtcbiAgfVxufVxudmFyIHJvb3RJdGVyYXRpb25zID0gMTI7XG5mdW5jdGlvbiBhcHByb3hpbWF0ZVJvb3QoZW52ZWxvcGUsIGRlcml2YXRpdmUsIGluaXRpYWxHdWVzcykge1xuICBsZXQgcmVzdWx0ID0gaW5pdGlhbEd1ZXNzO1xuICBmb3IgKGxldCBpMiA9IDE7IGkyIDwgcm9vdEl0ZXJhdGlvbnM7IGkyKyspIHtcbiAgICByZXN1bHQgPSByZXN1bHQgLSBlbnZlbG9wZShyZXN1bHQpIC8gZGVyaXZhdGl2ZShyZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRGcmVxLCBkYW1waW5nUmF0aW8pIHtcbiAgcmV0dXJuIHVuZGFtcGVkRnJlcSAqIE1hdGguc3FydCgxIC0gZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvZ2VuZXJhdG9ycy9zcHJpbmcubWpzXG52YXIgZHVyYXRpb25LZXlzID0gW1wiZHVyYXRpb25cIiwgXCJib3VuY2VcIl07XG52YXIgcGh5c2ljc0tleXMgPSBbXCJzdGlmZm5lc3NcIiwgXCJkYW1waW5nXCIsIFwibWFzc1wiXTtcbmZ1bmN0aW9uIGlzU3ByaW5nVHlwZShvcHRpb25zLCBrZXlzMikge1xuICByZXR1cm4ga2V5czIuc29tZSgoa2V5KSA9PiBvcHRpb25zW2tleV0gIT09IHZvaWQgMCk7XG59XG5mdW5jdGlvbiBnZXRTcHJpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgbGV0IHNwcmluZ09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgdmVsb2NpdHk6IDAsIHN0aWZmbmVzczogMTAwLCBkYW1waW5nOiAxMCwgbWFzczogMSwgaXNSZXNvbHZlZEZyb21EdXJhdGlvbjogZmFsc2UgfSwgb3B0aW9ucyk7XG4gIGlmICghaXNTcHJpbmdUeXBlKG9wdGlvbnMsIHBoeXNpY3NLZXlzKSAmJiBpc1NwcmluZ1R5cGUob3B0aW9ucywgZHVyYXRpb25LZXlzKSkge1xuICAgIGNvbnN0IGRlcml2ZWQgPSBmaW5kU3ByaW5nKG9wdGlvbnMpO1xuICAgIHNwcmluZ09wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3ByaW5nT3B0aW9ucyksIGRlcml2ZWQpLCB7IHZlbG9jaXR5OiAwLCBtYXNzOiAxIH0pO1xuICAgIHNwcmluZ09wdGlvbnMuaXNSZXNvbHZlZEZyb21EdXJhdGlvbiA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHNwcmluZ09wdGlvbnM7XG59XG5mdW5jdGlvbiBzcHJpbmcoX2EpIHtcbiAgdmFyIHsgZnJvbSA9IDAsIHRvID0gMSwgcmVzdFNwZWVkID0gMiwgcmVzdERlbHRhIH0gPSBfYSwgb3B0aW9ucyA9IF9fcmVzdChfYSwgW1wiZnJvbVwiLCBcInRvXCIsIFwicmVzdFNwZWVkXCIsIFwicmVzdERlbHRhXCJdKTtcbiAgY29uc3Qgc3RhdGUgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogZnJvbSB9O1xuICBsZXQgeyBzdGlmZm5lc3MsIGRhbXBpbmcsIG1hc3MsIHZlbG9jaXR5LCBkdXJhdGlvbiwgaXNSZXNvbHZlZEZyb21EdXJhdGlvbiB9ID0gZ2V0U3ByaW5nT3B0aW9ucyhvcHRpb25zKTtcbiAgbGV0IHJlc29sdmVTcHJpbmcgPSB6ZXJvO1xuICBsZXQgcmVzb2x2ZVZlbG9jaXR5ID0gemVybztcbiAgZnVuY3Rpb24gY3JlYXRlU3ByaW5nKCkge1xuICAgIGNvbnN0IGluaXRpYWxWZWxvY2l0eSA9IHZlbG9jaXR5ID8gLSh2ZWxvY2l0eSAvIDFlMykgOiAwO1xuICAgIGNvbnN0IGluaXRpYWxEZWx0YSA9IHRvIC0gZnJvbTtcbiAgICBjb25zdCBkYW1waW5nUmF0aW8gPSBkYW1waW5nIC8gKDIgKiBNYXRoLnNxcnQoc3RpZmZuZXNzICogbWFzcykpO1xuICAgIGNvbnN0IHVuZGFtcGVkQW5ndWxhckZyZXEgPSBNYXRoLnNxcnQoc3RpZmZuZXNzIC8gbWFzcykgLyAxZTM7XG4gICAgaWYgKHJlc3REZWx0YSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXN0RGVsdGEgPSBNYXRoLm1pbihNYXRoLmFicyh0byAtIGZyb20pIC8gMTAwLCAwLjQpO1xuICAgIH1cbiAgICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgICAgY29uc3QgYW5ndWxhckZyZXEgPSBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRBbmd1bGFyRnJlcSwgZGFtcGluZ1JhdGlvKTtcbiAgICAgIHJlc29sdmVTcHJpbmcgPSAodCkgPT4ge1xuICAgICAgICBjb25zdCBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgIHJldHVybiB0byAtIGVudmVsb3BlICogKChpbml0aWFsVmVsb2NpdHkgKyBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAvIGFuZ3VsYXJGcmVxICogTWF0aC5zaW4oYW5ndWxhckZyZXEgKiB0KSArIGluaXRpYWxEZWx0YSAqIE1hdGguY29zKGFuZ3VsYXJGcmVxICogdCkpO1xuICAgICAgfTtcbiAgICAgIHJlc29sdmVWZWxvY2l0eSA9ICh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgcmV0dXJuIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBlbnZlbG9wZSAqIChNYXRoLnNpbihhbmd1bGFyRnJlcSAqIHQpICogKGluaXRpYWxWZWxvY2l0eSArIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpIC8gYW5ndWxhckZyZXEgKyBpbml0aWFsRGVsdGEgKiBNYXRoLmNvcyhhbmd1bGFyRnJlcSAqIHQpKSAtIGVudmVsb3BlICogKE1hdGguY29zKGFuZ3VsYXJGcmVxICogdCkgKiAoaW5pdGlhbFZlbG9jaXR5ICsgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgLSBhbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSAqIE1hdGguc2luKGFuZ3VsYXJGcmVxICogdCkpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRhbXBpbmdSYXRpbyA9PT0gMSkge1xuICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB0byAtIE1hdGguZXhwKC11bmRhbXBlZEFuZ3VsYXJGcmVxICogdCkgKiAoaW5pdGlhbERlbHRhICsgKGluaXRpYWxWZWxvY2l0eSArIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpICogdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRhbXBlZEFuZ3VsYXJGcmVxID0gdW5kYW1wZWRBbmd1bGFyRnJlcSAqIE1hdGguc3FydChkYW1waW5nUmF0aW8gKiBkYW1waW5nUmF0aW8gLSAxKTtcbiAgICAgIHJlc29sdmVTcHJpbmcgPSAodCkgPT4ge1xuICAgICAgICBjb25zdCBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgIGNvbnN0IGZyZXFGb3JUID0gTWF0aC5taW4oZGFtcGVkQW5ndWxhckZyZXEgKiB0LCAzMDApO1xuICAgICAgICByZXR1cm4gdG8gLSBlbnZlbG9wZSAqICgoaW5pdGlhbFZlbG9jaXR5ICsgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgKiBNYXRoLnNpbmgoZnJlcUZvclQpICsgZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEgKiBNYXRoLmNvc2goZnJlcUZvclQpKSAvIGRhbXBlZEFuZ3VsYXJGcmVxO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlU3ByaW5nKCk7XG4gIHJldHVybiB7XG4gICAgbmV4dDogKHQpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSByZXNvbHZlU3ByaW5nKHQpO1xuICAgICAgaWYgKCFpc1Jlc29sdmVkRnJvbUR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWZWxvY2l0eSA9IHJlc29sdmVWZWxvY2l0eSh0KSAqIDFlMztcbiAgICAgICAgY29uc3QgaXNCZWxvd1ZlbG9jaXR5VGhyZXNob2xkID0gTWF0aC5hYnMoY3VycmVudFZlbG9jaXR5KSA8PSByZXN0U3BlZWQ7XG4gICAgICAgIGNvbnN0IGlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQgPSBNYXRoLmFicyh0byAtIGN1cnJlbnQpIDw9IHJlc3REZWx0YTtcbiAgICAgICAgc3RhdGUuZG9uZSA9IGlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCAmJiBpc0JlbG93RGlzcGxhY2VtZW50VGhyZXNob2xkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuZG9uZSA9IHQgPj0gZHVyYXRpb247XG4gICAgICB9XG4gICAgICBzdGF0ZS52YWx1ZSA9IHN0YXRlLmRvbmUgPyB0byA6IGN1cnJlbnQ7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBmbGlwVGFyZ2V0OiAoKSA9PiB7XG4gICAgICB2ZWxvY2l0eSA9IC12ZWxvY2l0eTtcbiAgICAgIFtmcm9tLCB0b10gPSBbdG8sIGZyb21dO1xuICAgICAgY3JlYXRlU3ByaW5nKCk7XG4gICAgfVxuICB9O1xufVxuc3ByaW5nLm5lZWRzSW50ZXJwb2xhdGlvbiA9IChhMiwgYjIpID0+IHR5cGVvZiBhMiA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYjIgPT09IFwic3RyaW5nXCI7XG52YXIgemVybyA9IChfdCkgPT4gMDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL3Byb2dyZXNzLm1qc1xudmFyIHByb2dyZXNzID0gKGZyb20sIHRvLCB2YWx1ZSkgPT4ge1xuICBjb25zdCB0b0Zyb21EaWZmZXJlbmNlID0gdG8gLSBmcm9tO1xuICByZXR1cm4gdG9Gcm9tRGlmZmVyZW5jZSA9PT0gMCA/IDEgOiAodmFsdWUgLSBmcm9tKSAvIHRvRnJvbURpZmZlcmVuY2U7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvbWl4Lm1qc1xudmFyIG1peCA9IChmcm9tLCB0bywgcHJvZ3Jlc3MzKSA9PiAtcHJvZ3Jlc3MzICogZnJvbSArIHByb2dyZXNzMyAqIHRvICsgZnJvbTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2hzbGEtdG8tcmdiYS5tanNcbmZ1bmN0aW9uIGh1ZVRvUmdiKHAyLCBxLCB0KSB7XG4gIGlmICh0IDwgMClcbiAgICB0ICs9IDE7XG4gIGlmICh0ID4gMSlcbiAgICB0IC09IDE7XG4gIGlmICh0IDwgMSAvIDYpXG4gICAgcmV0dXJuIHAyICsgKHEgLSBwMikgKiA2ICogdDtcbiAgaWYgKHQgPCAxIC8gMilcbiAgICByZXR1cm4gcTtcbiAgaWYgKHQgPCAyIC8gMylcbiAgICByZXR1cm4gcDIgKyAocSAtIHAyKSAqICgyIC8gMyAtIHQpICogNjtcbiAgcmV0dXJuIHAyO1xufVxuZnVuY3Rpb24gaHNsYVRvUmdiYSh7IGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYTogYWxwaGEyIH0pIHtcbiAgaHVlIC89IDM2MDtcbiAgc2F0dXJhdGlvbiAvPSAxMDA7XG4gIGxpZ2h0bmVzcyAvPSAxMDA7XG4gIGxldCByZWQgPSAwO1xuICBsZXQgZ3JlZW4gPSAwO1xuICBsZXQgYmx1ZSA9IDA7XG4gIGlmICghc2F0dXJhdGlvbikge1xuICAgIHJlZCA9IGdyZWVuID0gYmx1ZSA9IGxpZ2h0bmVzcztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBxID0gbGlnaHRuZXNzIDwgMC41ID8gbGlnaHRuZXNzICogKDEgKyBzYXR1cmF0aW9uKSA6IGxpZ2h0bmVzcyArIHNhdHVyYXRpb24gLSBsaWdodG5lc3MgKiBzYXR1cmF0aW9uO1xuICAgIGNvbnN0IHAyID0gMiAqIGxpZ2h0bmVzcyAtIHE7XG4gICAgcmVkID0gaHVlVG9SZ2IocDIsIHEsIGh1ZSArIDEgLyAzKTtcbiAgICBncmVlbiA9IGh1ZVRvUmdiKHAyLCBxLCBodWUpO1xuICAgIGJsdWUgPSBodWVUb1JnYihwMiwgcSwgaHVlIC0gMSAvIDMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVkOiBNYXRoLnJvdW5kKHJlZCAqIDI1NSksXG4gICAgZ3JlZW46IE1hdGgucm91bmQoZ3JlZW4gKiAyNTUpLFxuICAgIGJsdWU6IE1hdGgucm91bmQoYmx1ZSAqIDI1NSksXG4gICAgYWxwaGE6IGFscGhhMlxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvbWl4LWNvbG9yLm1qc1xudmFyIG1peExpbmVhckNvbG9yID0gKGZyb20sIHRvLCB2KSA9PiB7XG4gIGNvbnN0IGZyb21FeHBvID0gZnJvbSAqIGZyb207XG4gIGNvbnN0IHRvRXhwbyA9IHRvICogdG87XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgdiAqICh0b0V4cG8gLSBmcm9tRXhwbykgKyBmcm9tRXhwbykpO1xufTtcbnZhciBjb2xvclR5cGVzID0gW2hleCwgcmdiYSwgaHNsYV07XG52YXIgZ2V0Q29sb3JUeXBlID0gKHYpID0+IGNvbG9yVHlwZXMuZmluZCgodHlwZSkgPT4gdHlwZS50ZXN0KHYpKTtcbnZhciBub3RBbmltYXRhYmxlID0gKGNvbG9yMikgPT4gYCcke2NvbG9yMn0nIGlzIG5vdCBhbiBhbmltYXRhYmxlIGNvbG9yLiBVc2UgdGhlIGVxdWl2YWxlbnQgY29sb3IgY29kZSBpbnN0ZWFkLmA7XG52YXIgbWl4Q29sb3IgPSAoZnJvbSwgdG8pID0+IHtcbiAgbGV0IGZyb21Db2xvclR5cGUgPSBnZXRDb2xvclR5cGUoZnJvbSk7XG4gIGxldCB0b0NvbG9yVHlwZSA9IGdldENvbG9yVHlwZSh0byk7XG4gIGludmFyaWFudCghIWZyb21Db2xvclR5cGUsIG5vdEFuaW1hdGFibGUoZnJvbSkpO1xuICBpbnZhcmlhbnQoISF0b0NvbG9yVHlwZSwgbm90QW5pbWF0YWJsZSh0bykpO1xuICBsZXQgZnJvbUNvbG9yID0gZnJvbUNvbG9yVHlwZS5wYXJzZShmcm9tKTtcbiAgbGV0IHRvQ29sb3IgPSB0b0NvbG9yVHlwZS5wYXJzZSh0byk7XG4gIGlmIChmcm9tQ29sb3JUeXBlID09PSBoc2xhKSB7XG4gICAgZnJvbUNvbG9yID0gaHNsYVRvUmdiYShmcm9tQ29sb3IpO1xuICAgIGZyb21Db2xvclR5cGUgPSByZ2JhO1xuICB9XG4gIGlmICh0b0NvbG9yVHlwZSA9PT0gaHNsYSkge1xuICAgIHRvQ29sb3IgPSBoc2xhVG9SZ2JhKHRvQ29sb3IpO1xuICAgIHRvQ29sb3JUeXBlID0gcmdiYTtcbiAgfVxuICBjb25zdCBibGVuZGVkID0gT2JqZWN0LmFzc2lnbih7fSwgZnJvbUNvbG9yKTtcbiAgcmV0dXJuICh2KSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYmxlbmRlZCkge1xuICAgICAgaWYgKGtleSAhPT0gXCJhbHBoYVwiKSB7XG4gICAgICAgIGJsZW5kZWRba2V5XSA9IG1peExpbmVhckNvbG9yKGZyb21Db2xvcltrZXldLCB0b0NvbG9yW2tleV0sIHYpO1xuICAgICAgfVxuICAgIH1cbiAgICBibGVuZGVkLmFscGhhID0gbWl4KGZyb21Db2xvci5hbHBoYSwgdG9Db2xvci5hbHBoYSwgdik7XG4gICAgcmV0dXJuIGZyb21Db2xvclR5cGUudHJhbnNmb3JtKGJsZW5kZWQpO1xuICB9O1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2luYy5tanNcbnZhciBpc051bSA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL3BpcGUubWpzXG52YXIgY29tYmluZUZ1bmN0aW9ucyA9IChhMiwgYjIpID0+ICh2KSA9PiBiMihhMih2KSk7XG52YXIgcGlwZSA9ICguLi50cmFuc2Zvcm1lcnMpID0+IHRyYW5zZm9ybWVycy5yZWR1Y2UoY29tYmluZUZ1bmN0aW9ucyk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9taXgtY29tcGxleC5tanNcbmZ1bmN0aW9uIGdldE1peGVyKG9yaWdpbiwgdGFyZ2V0KSB7XG4gIGlmIChpc051bShvcmlnaW4pKSB7XG4gICAgcmV0dXJuICh2KSA9PiBtaXgob3JpZ2luLCB0YXJnZXQsIHYpO1xuICB9IGVsc2UgaWYgKGNvbG9yLnRlc3Qob3JpZ2luKSkge1xuICAgIHJldHVybiBtaXhDb2xvcihvcmlnaW4sIHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1peENvbXBsZXgob3JpZ2luLCB0YXJnZXQpO1xuICB9XG59XG52YXIgbWl4QXJyYXkgPSAoZnJvbSwgdG8pID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gWy4uLmZyb21dO1xuICBjb25zdCBudW1WYWx1ZXMgPSBvdXRwdXQubGVuZ3RoO1xuICBjb25zdCBibGVuZFZhbHVlID0gZnJvbS5tYXAoKGZyb21UaGlzLCBpMikgPT4gZ2V0TWl4ZXIoZnJvbVRoaXMsIHRvW2kyXSkpO1xuICByZXR1cm4gKHYpID0+IHtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtVmFsdWVzOyBpMisrKSB7XG4gICAgICBvdXRwdXRbaTJdID0gYmxlbmRWYWx1ZVtpMl0odik7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59O1xudmFyIG1peE9iamVjdCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICBjb25zdCBvdXRwdXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbiksIHRhcmdldCk7XG4gIGNvbnN0IGJsZW5kVmFsdWUgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb3V0cHV0KSB7XG4gICAgaWYgKG9yaWdpbltrZXldICE9PSB2b2lkIDAgJiYgdGFyZ2V0W2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgYmxlbmRWYWx1ZVtrZXldID0gZ2V0TWl4ZXIob3JpZ2luW2tleV0sIHRhcmdldFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICh2KSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYmxlbmRWYWx1ZSkge1xuICAgICAgb3V0cHV0W2tleV0gPSBibGVuZFZhbHVlW2tleV0odik7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59O1xuZnVuY3Rpb24gYW5hbHlzZTIodmFsdWUpIHtcbiAgY29uc3QgcGFyc2VkID0gY29tcGxleC5wYXJzZSh2YWx1ZSk7XG4gIGNvbnN0IG51bVZhbHVlcyA9IHBhcnNlZC5sZW5ndGg7XG4gIGxldCBudW1OdW1iZXJzID0gMDtcbiAgbGV0IG51bVJHQiA9IDA7XG4gIGxldCBudW1IU0wgPSAwO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtVmFsdWVzOyBpMisrKSB7XG4gICAgaWYgKG51bU51bWJlcnMgfHwgdHlwZW9mIHBhcnNlZFtpMl0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG51bU51bWJlcnMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhcnNlZFtpMl0uaHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgbnVtSFNMKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1SR0IrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgcGFyc2VkLCBudW1OdW1iZXJzLCBudW1SR0IsIG51bUhTTCB9O1xufVxudmFyIG1peENvbXBsZXggPSAob3JpZ2luLCB0YXJnZXQpID0+IHtcbiAgY29uc3QgdGVtcGxhdGUgPSBjb21wbGV4LmNyZWF0ZVRyYW5zZm9ybWVyKHRhcmdldCk7XG4gIGNvbnN0IG9yaWdpblN0YXRzID0gYW5hbHlzZTIob3JpZ2luKTtcbiAgY29uc3QgdGFyZ2V0U3RhdHMgPSBhbmFseXNlMih0YXJnZXQpO1xuICBjb25zdCBjYW5JbnRlcnBvbGF0ZSA9IG9yaWdpblN0YXRzLm51bUhTTCA9PT0gdGFyZ2V0U3RhdHMubnVtSFNMICYmIG9yaWdpblN0YXRzLm51bVJHQiA9PT0gdGFyZ2V0U3RhdHMubnVtUkdCICYmIG9yaWdpblN0YXRzLm51bU51bWJlcnMgPj0gdGFyZ2V0U3RhdHMubnVtTnVtYmVycztcbiAgaWYgKGNhbkludGVycG9sYXRlKSB7XG4gICAgcmV0dXJuIHBpcGUobWl4QXJyYXkob3JpZ2luU3RhdHMucGFyc2VkLCB0YXJnZXRTdGF0cy5wYXJzZWQpLCB0ZW1wbGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgd2FybmluZyh0cnVlLCBgQ29tcGxleCB2YWx1ZXMgJyR7b3JpZ2lufScgYW5kICcke3RhcmdldH0nIHRvbyBkaWZmZXJlbnQgdG8gbWl4LiBFbnN1cmUgYWxsIGNvbG9ycyBhcmUgb2YgdGhlIHNhbWUgdHlwZSwgYW5kIHRoYXQgZWFjaCBjb250YWlucyB0aGUgc2FtZSBxdWFudGl0eSBvZiBudW1iZXIgYW5kIGNvbG9yIHZhbHVlcy4gRmFsbGluZyBiYWNrIHRvIGluc3RhbnQgdHJhbnNpdGlvbi5gKTtcbiAgICByZXR1cm4gKHAyKSA9PiBgJHtwMiA+IDAgPyB0YXJnZXQgOiBvcmlnaW59YDtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2ludGVycG9sYXRlLm1qc1xudmFyIG1peE51bWJlciA9IChmcm9tLCB0bykgPT4gKHAyKSA9PiBtaXgoZnJvbSwgdG8sIHAyKTtcbmZ1bmN0aW9uIGRldGVjdE1peGVyRmFjdG9yeSh2KSB7XG4gIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBtaXhOdW1iZXI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoY29sb3IudGVzdCh2KSkge1xuICAgICAgcmV0dXJuIG1peENvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWl4Q29tcGxleDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiBtaXhBcnJheTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBtaXhPYmplY3Q7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU1peGVycyhvdXRwdXQsIGVhc2UsIGN1c3RvbU1peGVyKSB7XG4gIGNvbnN0IG1peGVycyA9IFtdO1xuICBjb25zdCBtaXhlckZhY3RvcnkgPSBjdXN0b21NaXhlciB8fCBkZXRlY3RNaXhlckZhY3Rvcnkob3V0cHV0WzBdKTtcbiAgY29uc3QgbnVtTWl4ZXJzID0gb3V0cHV0Lmxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1NaXhlcnM7IGkyKyspIHtcbiAgICBsZXQgbWl4ZXIgPSBtaXhlckZhY3Rvcnkob3V0cHV0W2kyXSwgb3V0cHV0W2kyICsgMV0pO1xuICAgIGlmIChlYXNlKSB7XG4gICAgICBjb25zdCBlYXNpbmdGdW5jdGlvbiA9IEFycmF5LmlzQXJyYXkoZWFzZSkgPyBlYXNlW2kyXSA6IGVhc2U7XG4gICAgICBtaXhlciA9IHBpcGUoZWFzaW5nRnVuY3Rpb24sIG1peGVyKTtcbiAgICB9XG4gICAgbWl4ZXJzLnB1c2gobWl4ZXIpO1xuICB9XG4gIHJldHVybiBtaXhlcnM7XG59XG5mdW5jdGlvbiBmYXN0SW50ZXJwb2xhdGUoW2Zyb20sIHRvXSwgW21peGVyXSkge1xuICByZXR1cm4gKHYpID0+IG1peGVyKHByb2dyZXNzKGZyb20sIHRvLCB2KSk7XG59XG5mdW5jdGlvbiBzbG93SW50ZXJwb2xhdGUoaW5wdXQsIG1peGVycykge1xuICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgY29uc3QgbGFzdElucHV0SW5kZXggPSBpbnB1dExlbmd0aCAtIDE7XG4gIHJldHVybiAodikgPT4ge1xuICAgIGxldCBtaXhlckluZGV4ID0gMDtcbiAgICBsZXQgZm91bmRNaXhlckluZGV4ID0gZmFsc2U7XG4gICAgaWYgKHYgPD0gaW5wdXRbMF0pIHtcbiAgICAgIGZvdW5kTWl4ZXJJbmRleCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh2ID49IGlucHV0W2xhc3RJbnB1dEluZGV4XSkge1xuICAgICAgbWl4ZXJJbmRleCA9IGxhc3RJbnB1dEluZGV4IC0gMTtcbiAgICAgIGZvdW5kTWl4ZXJJbmRleCA9IHRydWU7XG4gICAgfVxuICAgIGlmICghZm91bmRNaXhlckluZGV4KSB7XG4gICAgICBsZXQgaTIgPSAxO1xuICAgICAgZm9yICg7IGkyIDwgaW5wdXRMZW5ndGg7IGkyKyspIHtcbiAgICAgICAgaWYgKGlucHV0W2kyXSA+IHYgfHwgaTIgPT09IGxhc3RJbnB1dEluZGV4KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1peGVySW5kZXggPSBpMiAtIDE7XG4gICAgfVxuICAgIGNvbnN0IHByb2dyZXNzSW5SYW5nZSA9IHByb2dyZXNzKGlucHV0W21peGVySW5kZXhdLCBpbnB1dFttaXhlckluZGV4ICsgMV0sIHYpO1xuICAgIHJldHVybiBtaXhlcnNbbWl4ZXJJbmRleF0ocHJvZ3Jlc3NJblJhbmdlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBvdXRwdXQsIHsgY2xhbXA6IGlzQ2xhbXAgPSB0cnVlLCBlYXNlLCBtaXhlciB9ID0ge30pIHtcbiAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIGludmFyaWFudChpbnB1dExlbmd0aCA9PT0gb3V0cHV0Lmxlbmd0aCwgXCJCb3RoIGlucHV0IGFuZCBvdXRwdXQgcmFuZ2VzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICBpbnZhcmlhbnQoIWVhc2UgfHwgIUFycmF5LmlzQXJyYXkoZWFzZSkgfHwgZWFzZS5sZW5ndGggPT09IGlucHV0TGVuZ3RoIC0gMSwgXCJBcnJheSBvZiBlYXNpbmcgZnVuY3Rpb25zIG11c3QgYmUgb2YgbGVuZ3RoIGBpbnB1dC5sZW5ndGggLSAxYCwgYXMgaXQgYXBwbGllcyB0byB0aGUgdHJhbnNpdGlvbnMgKipiZXR3ZWVuKiogdGhlIGRlZmluZWQgdmFsdWVzLlwiKTtcbiAgaWYgKGlucHV0WzBdID4gaW5wdXRbaW5wdXRMZW5ndGggLSAxXSkge1xuICAgIGlucHV0ID0gW10uY29uY2F0KGlucHV0KTtcbiAgICBvdXRwdXQgPSBbXS5jb25jYXQob3V0cHV0KTtcbiAgICBpbnB1dC5yZXZlcnNlKCk7XG4gICAgb3V0cHV0LnJldmVyc2UoKTtcbiAgfVxuICBjb25zdCBtaXhlcnMgPSBjcmVhdGVNaXhlcnMob3V0cHV0LCBlYXNlLCBtaXhlcik7XG4gIGNvbnN0IGludGVycG9sYXRvciA9IGlucHV0TGVuZ3RoID09PSAyID8gZmFzdEludGVycG9sYXRlKGlucHV0LCBtaXhlcnMpIDogc2xvd0ludGVycG9sYXRlKGlucHV0LCBtaXhlcnMpO1xuICByZXR1cm4gaXNDbGFtcCA/ICh2KSA9PiBpbnRlcnBvbGF0b3IoY2xhbXAyKGlucHV0WzBdLCBpbnB1dFtpbnB1dExlbmd0aCAtIDFdLCB2KSkgOiBpbnRlcnBvbGF0b3I7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9lYXNpbmcvdXRpbHMubWpzXG52YXIgcmV2ZXJzZUVhc2luZyA9IChlYXNpbmcpID0+IChwMikgPT4gMSAtIGVhc2luZygxIC0gcDIpO1xudmFyIG1pcnJvckVhc2luZyA9IChlYXNpbmcpID0+IChwMikgPT4gcDIgPD0gMC41ID8gZWFzaW5nKDIgKiBwMikgLyAyIDogKDIgLSBlYXNpbmcoMiAqICgxIC0gcDIpKSkgLyAyO1xudmFyIGNyZWF0ZUV4cG9JbiA9IChwb3dlcikgPT4gKHAyKSA9PiBNYXRoLnBvdyhwMiwgcG93ZXIpO1xudmFyIGNyZWF0ZUJhY2tJbiA9IChwb3dlcikgPT4gKHAyKSA9PiBwMiAqIHAyICogKChwb3dlciArIDEpICogcDIgLSBwb3dlcik7XG52YXIgY3JlYXRlQW50aWNpcGF0ZSA9IChwb3dlcikgPT4ge1xuICBjb25zdCBiYWNrRWFzaW5nID0gY3JlYXRlQmFja0luKHBvd2VyKTtcbiAgcmV0dXJuIChwMikgPT4gKHAyICo9IDIpIDwgMSA/IDAuNSAqIGJhY2tFYXNpbmcocDIpIDogMC41ICogKDIgLSBNYXRoLnBvdygyLCAtMTAgKiAocDIgLSAxKSkpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2Vhc2luZy9pbmRleC5tanNcbnZhciBERUZBVUxUX09WRVJTSE9PVF9TVFJFTkdUSCA9IDEuNTI1O1xudmFyIEJPVU5DRV9GSVJTVF9USFJFU0hPTEQgPSA0IC8gMTE7XG52YXIgQk9VTkNFX1NFQ09ORF9USFJFU0hPTEQgPSA4IC8gMTE7XG52YXIgQk9VTkNFX1RISVJEX1RIUkVTSE9MRCA9IDkgLyAxMDtcbnZhciBsaW5lYXIgPSAocDIpID0+IHAyO1xudmFyIGVhc2VJbiA9IGNyZWF0ZUV4cG9JbigyKTtcbnZhciBlYXNlT3V0ID0gcmV2ZXJzZUVhc2luZyhlYXNlSW4pO1xudmFyIGVhc2VJbk91dCA9IG1pcnJvckVhc2luZyhlYXNlSW4pO1xudmFyIGNpcmNJbiA9IChwMikgPT4gMSAtIE1hdGguc2luKE1hdGguYWNvcyhwMikpO1xudmFyIGNpcmNPdXQgPSByZXZlcnNlRWFzaW5nKGNpcmNJbik7XG52YXIgY2lyY0luT3V0ID0gbWlycm9yRWFzaW5nKGNpcmNPdXQpO1xudmFyIGJhY2tJbiA9IGNyZWF0ZUJhY2tJbihERUZBVUxUX09WRVJTSE9PVF9TVFJFTkdUSCk7XG52YXIgYmFja091dCA9IHJldmVyc2VFYXNpbmcoYmFja0luKTtcbnZhciBiYWNrSW5PdXQgPSBtaXJyb3JFYXNpbmcoYmFja0luKTtcbnZhciBhbnRpY2lwYXRlID0gY3JlYXRlQW50aWNpcGF0ZShERUZBVUxUX09WRVJTSE9PVF9TVFJFTkdUSCk7XG52YXIgY2EgPSA0MzU2IC8gMzYxO1xudmFyIGNiID0gMzU0NDIgLyAxODA1O1xudmFyIGNjID0gMTYwNjEgLyAxODA1O1xudmFyIGJvdW5jZU91dCA9IChwMikgPT4ge1xuICBpZiAocDIgPT09IDEgfHwgcDIgPT09IDApXG4gICAgcmV0dXJuIHAyO1xuICBjb25zdCBwMjIgPSBwMiAqIHAyO1xuICByZXR1cm4gcDIgPCBCT1VOQ0VfRklSU1RfVEhSRVNIT0xEID8gNy41NjI1ICogcDIyIDogcDIgPCBCT1VOQ0VfU0VDT05EX1RIUkVTSE9MRCA/IDkuMDc1ICogcDIyIC0gOS45ICogcDIgKyAzLjQgOiBwMiA8IEJPVU5DRV9USElSRF9USFJFU0hPTEQgPyBjYSAqIHAyMiAtIGNiICogcDIgKyBjYyA6IDEwLjggKiBwMiAqIHAyIC0gMjAuNTIgKiBwMiArIDEwLjcyO1xufTtcbnZhciBib3VuY2VJbiA9IHJldmVyc2VFYXNpbmcoYm91bmNlT3V0KTtcbnZhciBib3VuY2VJbk91dCA9IChwMikgPT4gcDIgPCAwLjUgPyAwLjUgKiAoMSAtIGJvdW5jZU91dCgxIC0gcDIgKiAyKSkgOiAwLjUgKiBib3VuY2VPdXQocDIgKiAyIC0gMSkgKyAwLjU7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL2dlbmVyYXRvcnMva2V5ZnJhbWVzLm1qc1xuZnVuY3Rpb24gZGVmYXVsdEVhc2luZyh2YWx1ZXMsIGVhc2luZykge1xuICByZXR1cm4gdmFsdWVzLm1hcCgoKSA9PiBlYXNpbmcgfHwgZWFzZUluT3V0KS5zcGxpY2UoMCwgdmFsdWVzLmxlbmd0aCAtIDEpO1xufVxuZnVuY3Rpb24gZGVmYXVsdE9mZnNldCh2YWx1ZXMpIHtcbiAgY29uc3QgbnVtVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIHZhbHVlcy5tYXAoKF92YWx1ZSwgaTIpID0+IGkyICE9PSAwID8gaTIgLyAobnVtVmFsdWVzIC0gMSkgOiAwKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRUb1RpbWVzKG9mZnNldCwgZHVyYXRpb24pIHtcbiAgcmV0dXJuIG9mZnNldC5tYXAoKG8pID0+IG8gKiBkdXJhdGlvbik7XG59XG5mdW5jdGlvbiBrZXlmcmFtZXMoeyBmcm9tID0gMCwgdG8gPSAxLCBlYXNlLCBvZmZzZXQsIGR1cmF0aW9uID0gMzAwIH0pIHtcbiAgY29uc3Qgc3RhdGUgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogZnJvbSB9O1xuICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHRvKSA/IHRvIDogW2Zyb20sIHRvXTtcbiAgY29uc3QgdGltZXMgPSBjb252ZXJ0T2Zmc2V0VG9UaW1lcyhvZmZzZXQgJiYgb2Zmc2V0Lmxlbmd0aCA9PT0gdmFsdWVzLmxlbmd0aCA/IG9mZnNldCA6IGRlZmF1bHRPZmZzZXQodmFsdWVzKSwgZHVyYXRpb24pO1xuICBmdW5jdGlvbiBjcmVhdGVJbnRlcnBvbGF0b3IoKSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKHRpbWVzLCB2YWx1ZXMsIHtcbiAgICAgIGVhc2U6IEFycmF5LmlzQXJyYXkoZWFzZSkgPyBlYXNlIDogZGVmYXVsdEVhc2luZyh2YWx1ZXMsIGVhc2UpXG4gICAgfSk7XG4gIH1cbiAgbGV0IGludGVycG9sYXRvciA9IGNyZWF0ZUludGVycG9sYXRvcigpO1xuICByZXR1cm4ge1xuICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICBzdGF0ZS52YWx1ZSA9IGludGVycG9sYXRvcih0KTtcbiAgICAgIHN0YXRlLmRvbmUgPSB0ID49IGR1cmF0aW9uO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZmxpcFRhcmdldDogKCkgPT4ge1xuICAgICAgdmFsdWVzLnJldmVyc2UoKTtcbiAgICAgIGludGVycG9sYXRvciA9IGNyZWF0ZUludGVycG9sYXRvcigpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvZ2VuZXJhdG9ycy9kZWNheS5tanNcbmZ1bmN0aW9uIGRlY2F5KHsgdmVsb2NpdHkgPSAwLCBmcm9tID0gMCwgcG93ZXIgPSAwLjgsIHRpbWVDb25zdGFudCA9IDM1MCwgcmVzdERlbHRhID0gMC41LCBtb2RpZnlUYXJnZXQgfSkge1xuICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmcm9tIH07XG4gIGxldCBhbXBsaXR1ZGUgPSBwb3dlciAqIHZlbG9jaXR5O1xuICBjb25zdCBpZGVhbCA9IGZyb20gKyBhbXBsaXR1ZGU7XG4gIGNvbnN0IHRhcmdldCA9IG1vZGlmeVRhcmdldCA9PT0gdm9pZCAwID8gaWRlYWwgOiBtb2RpZnlUYXJnZXQoaWRlYWwpO1xuICBpZiAodGFyZ2V0ICE9PSBpZGVhbClcbiAgICBhbXBsaXR1ZGUgPSB0YXJnZXQgLSBmcm9tO1xuICByZXR1cm4ge1xuICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICBjb25zdCBkZWx0YSA9IC1hbXBsaXR1ZGUgKiBNYXRoLmV4cCgtdCAvIHRpbWVDb25zdGFudCk7XG4gICAgICBzdGF0ZS5kb25lID0gIShkZWx0YSA+IHJlc3REZWx0YSB8fCBkZWx0YSA8IC1yZXN0RGVsdGEpO1xuICAgICAgc3RhdGUudmFsdWUgPSBzdGF0ZS5kb25lID8gdGFyZ2V0IDogdGFyZ2V0ICsgZGVsdGE7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBmbGlwVGFyZ2V0OiAoKSA9PiB7XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy91dGlscy9kZXRlY3QtYW5pbWF0aW9uLWZyb20tb3B0aW9ucy5tanNcbnZhciB0eXBlcyA9IHsga2V5ZnJhbWVzLCBzcHJpbmcsIGRlY2F5IH07XG5mdW5jdGlvbiBkZXRlY3RBbmltYXRpb25Gcm9tT3B0aW9ucyhjb25maWcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnRvKSkge1xuICAgIHJldHVybiBrZXlmcmFtZXM7XG4gIH0gZWxzZSBpZiAodHlwZXNbY29uZmlnLnR5cGVdKSB7XG4gICAgcmV0dXJuIHR5cGVzW2NvbmZpZy50eXBlXTtcbiAgfVxuICBjb25zdCBrZXlzMiA9IG5ldyBTZXQoT2JqZWN0LmtleXMoY29uZmlnKSk7XG4gIGlmIChrZXlzMi5oYXMoXCJlYXNlXCIpIHx8IGtleXMyLmhhcyhcImR1cmF0aW9uXCIpICYmICFrZXlzMi5oYXMoXCJkYW1waW5nUmF0aW9cIikpIHtcbiAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICB9IGVsc2UgaWYgKGtleXMyLmhhcyhcImRhbXBpbmdSYXRpb1wiKSB8fCBrZXlzMi5oYXMoXCJzdGlmZm5lc3NcIikgfHwga2V5czIuaGFzKFwibWFzc1wiKSB8fCBrZXlzMi5oYXMoXCJkYW1waW5nXCIpIHx8IGtleXMyLmhhcyhcInJlc3RTcGVlZFwiKSB8fCBrZXlzMi5oYXMoXCJyZXN0RGVsdGFcIikpIHtcbiAgICByZXR1cm4gc3ByaW5nO1xuICB9XG4gIHJldHVybiBrZXlmcmFtZXM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXN5bmMvZGlzdC9lcy9vbi1uZXh0LWZyYW1lLm1qc1xudmFyIGRlZmF1bHRUaW1lc3RlcCA9IDEgLyA2MCAqIDFlMztcbnZhciBnZXRDdXJyZW50VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiA/ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpIDogKCkgPT4gRGF0ZS5ub3coKTtcbnZhciBvbk5leHRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyAoY2FsbGJhY2spID0+IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIDogKGNhbGxiYWNrKSA9PiBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKGdldEN1cnJlbnRUaW1lKCkpLCBkZWZhdWx0VGltZXN0ZXApO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVzeW5jL2Rpc3QvZXMvY3JlYXRlLXJlbmRlci1zdGVwLm1qc1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyU3RlcChydW5OZXh0RnJhbWUyKSB7XG4gIGxldCB0b1J1biA9IFtdO1xuICBsZXQgdG9SdW5OZXh0RnJhbWUgPSBbXTtcbiAgbGV0IG51bVRvUnVuID0gMDtcbiAgbGV0IGlzUHJvY2Vzc2luZzIgPSBmYWxzZTtcbiAgbGV0IGZsdXNoTmV4dEZyYW1lID0gZmFsc2U7XG4gIGNvbnN0IHRvS2VlcEFsaXZlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gIGNvbnN0IHN0ZXAgPSB7XG4gICAgc2NoZWR1bGU6IChjYWxsYmFjaywga2VlcEFsaXZlID0gZmFsc2UsIGltbWVkaWF0ZSA9IGZhbHNlKSA9PiB7XG4gICAgICBjb25zdCBhZGRUb0N1cnJlbnRGcmFtZSA9IGltbWVkaWF0ZSAmJiBpc1Byb2Nlc3NpbmcyO1xuICAgICAgY29uc3QgYnVmZmVyID0gYWRkVG9DdXJyZW50RnJhbWUgPyB0b1J1biA6IHRvUnVuTmV4dEZyYW1lO1xuICAgICAgaWYgKGtlZXBBbGl2ZSlcbiAgICAgICAgdG9LZWVwQWxpdmUuYWRkKGNhbGxiYWNrKTtcbiAgICAgIGlmIChidWZmZXIuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGFkZFRvQ3VycmVudEZyYW1lICYmIGlzUHJvY2Vzc2luZzIpXG4gICAgICAgICAgbnVtVG9SdW4gPSB0b1J1bi5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfSxcbiAgICBjYW5jZWw6IChjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgaW5kZXgyID0gdG9SdW5OZXh0RnJhbWUuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICBpZiAoaW5kZXgyICE9PSAtMSlcbiAgICAgICAgdG9SdW5OZXh0RnJhbWUuc3BsaWNlKGluZGV4MiwgMSk7XG4gICAgICB0b0tlZXBBbGl2ZS5kZWxldGUoY2FsbGJhY2spO1xuICAgIH0sXG4gICAgcHJvY2VzczogKGZyYW1lRGF0YSkgPT4ge1xuICAgICAgaWYgKGlzUHJvY2Vzc2luZzIpIHtcbiAgICAgICAgZmx1c2hOZXh0RnJhbWUgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpc1Byb2Nlc3NpbmcyID0gdHJ1ZTtcbiAgICAgIFt0b1J1biwgdG9SdW5OZXh0RnJhbWVdID0gW3RvUnVuTmV4dEZyYW1lLCB0b1J1bl07XG4gICAgICB0b1J1bk5leHRGcmFtZS5sZW5ndGggPSAwO1xuICAgICAgbnVtVG9SdW4gPSB0b1J1bi5sZW5ndGg7XG4gICAgICBpZiAobnVtVG9SdW4pIHtcbiAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bVRvUnVuOyBpMisrKSB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0b1J1bltpMl07XG4gICAgICAgICAgY2FsbGJhY2soZnJhbWVEYXRhKTtcbiAgICAgICAgICBpZiAodG9LZWVwQWxpdmUuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgc3RlcC5zY2hlZHVsZShjYWxsYmFjayk7XG4gICAgICAgICAgICBydW5OZXh0RnJhbWUyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc1Byb2Nlc3NpbmcyID0gZmFsc2U7XG4gICAgICBpZiAoZmx1c2hOZXh0RnJhbWUpIHtcbiAgICAgICAgZmx1c2hOZXh0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgc3RlcC5wcm9jZXNzKGZyYW1lRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gc3RlcDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lc3luYy9kaXN0L2VzL2luZGV4Lm1qc1xudmFyIG1heEVsYXBzZWQgPSA0MDtcbnZhciB1c2VEZWZhdWx0RWxhcHNlZCA9IHRydWU7XG52YXIgcnVuTmV4dEZyYW1lID0gZmFsc2U7XG52YXIgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG52YXIgZnJhbWUgPSB7XG4gIGRlbHRhOiAwLFxuICB0aW1lc3RhbXA6IDBcbn07XG52YXIgc3RlcHNPcmRlciA9IFtcbiAgXCJyZWFkXCIsXG4gIFwidXBkYXRlXCIsXG4gIFwicHJlUmVuZGVyXCIsXG4gIFwicmVuZGVyXCIsXG4gIFwicG9zdFJlbmRlclwiXG5dO1xudmFyIHN0ZXBzID0gc3RlcHNPcmRlci5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gIGFjY1trZXldID0gY3JlYXRlUmVuZGVyU3RlcCgoKSA9PiBydW5OZXh0RnJhbWUgPSB0cnVlKTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9KTtcbnZhciBzeW5jID0gc3RlcHNPcmRlci5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gIGNvbnN0IHN0ZXAgPSBzdGVwc1trZXldO1xuICBhY2Nba2V5XSA9IChwcm9jZXNzMiwga2VlcEFsaXZlID0gZmFsc2UsIGltbWVkaWF0ZSA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKCFydW5OZXh0RnJhbWUpXG4gICAgICBzdGFydExvb3AoKTtcbiAgICByZXR1cm4gc3RlcC5zY2hlZHVsZShwcm9jZXNzMiwga2VlcEFsaXZlLCBpbW1lZGlhdGUpO1xuICB9O1xuICByZXR1cm4gYWNjO1xufSwge30pO1xudmFyIGNhbmNlbFN5bmMgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgYWNjW2tleV0gPSBzdGVwc1trZXldLmNhbmNlbDtcbiAgcmV0dXJuIGFjYztcbn0sIHt9KTtcbnZhciBmbHVzaFN5bmMgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgYWNjW2tleV0gPSAoKSA9PiBzdGVwc1trZXldLnByb2Nlc3MoZnJhbWUpO1xuICByZXR1cm4gYWNjO1xufSwge30pO1xudmFyIHByb2Nlc3NTdGVwID0gKHN0ZXBJZCkgPT4gc3RlcHNbc3RlcElkXS5wcm9jZXNzKGZyYW1lKTtcbnZhciBwcm9jZXNzRnJhbWUgPSAodGltZXN0YW1wKSA9PiB7XG4gIHJ1bk5leHRGcmFtZSA9IGZhbHNlO1xuICBmcmFtZS5kZWx0YSA9IHVzZURlZmF1bHRFbGFwc2VkID8gZGVmYXVsdFRpbWVzdGVwIDogTWF0aC5tYXgoTWF0aC5taW4odGltZXN0YW1wIC0gZnJhbWUudGltZXN0YW1wLCBtYXhFbGFwc2VkKSwgMSk7XG4gIGZyYW1lLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgc3RlcHNPcmRlci5mb3JFYWNoKHByb2Nlc3NTdGVwKTtcbiAgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIGlmIChydW5OZXh0RnJhbWUpIHtcbiAgICB1c2VEZWZhdWx0RWxhcHNlZCA9IGZhbHNlO1xuICAgIG9uTmV4dEZyYW1lKHByb2Nlc3NGcmFtZSk7XG4gIH1cbn07XG52YXIgc3RhcnRMb29wID0gKCkgPT4ge1xuICBydW5OZXh0RnJhbWUgPSB0cnVlO1xuICB1c2VEZWZhdWx0RWxhcHNlZCA9IHRydWU7XG4gIGlmICghaXNQcm9jZXNzaW5nKVxuICAgIG9uTmV4dEZyYW1lKHByb2Nlc3NGcmFtZSk7XG59O1xudmFyIGdldEZyYW1lRGF0YSA9ICgpID0+IGZyYW1lO1xudmFyIGVzX2RlZmF1bHQgPSBzeW5jO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy91dGlscy9lbGFwc2VkLm1qc1xuZnVuY3Rpb24gbG9vcEVsYXBzZWQoZWxhcHNlZCwgZHVyYXRpb24sIGRlbGF5MiA9IDApIHtcbiAgcmV0dXJuIGVsYXBzZWQgLSBkdXJhdGlvbiAtIGRlbGF5Mjtcbn1cbmZ1bmN0aW9uIHJldmVyc2VFbGFwc2VkKGVsYXBzZWQsIGR1cmF0aW9uLCBkZWxheTIgPSAwLCBpc0ZvcndhcmRQbGF5YmFjayA9IHRydWUpIHtcbiAgcmV0dXJuIGlzRm9yd2FyZFBsYXliYWNrID8gbG9vcEVsYXBzZWQoZHVyYXRpb24gKyAtZWxhcHNlZCwgZHVyYXRpb24sIGRlbGF5MikgOiBkdXJhdGlvbiAtIChlbGFwc2VkIC0gZHVyYXRpb24pICsgZGVsYXkyO1xufVxuZnVuY3Rpb24gaGFzUmVwZWF0RGVsYXlFbGFwc2VkKGVsYXBzZWQsIGR1cmF0aW9uLCBkZWxheTIsIGlzRm9yd2FyZFBsYXliYWNrKSB7XG4gIHJldHVybiBpc0ZvcndhcmRQbGF5YmFjayA/IGVsYXBzZWQgPj0gZHVyYXRpb24gKyBkZWxheTIgOiBlbGFwc2VkIDw9IC1kZWxheTI7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL2luZGV4Lm1qc1xudmFyIGZyYW1lc3luYyA9ICh1cGRhdGUpID0+IHtcbiAgY29uc3QgcGFzc1RpbWVzdGFtcCA9ICh7IGRlbHRhIH0pID0+IHVwZGF0ZShkZWx0YSk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6ICgpID0+IGVzX2RlZmF1bHQudXBkYXRlKHBhc3NUaW1lc3RhbXAsIHRydWUpLFxuICAgIHN0b3A6ICgpID0+IGNhbmNlbFN5bmMudXBkYXRlKHBhc3NUaW1lc3RhbXApXG4gIH07XG59O1xuZnVuY3Rpb24gYW5pbWF0ZShfYSkge1xuICB2YXIgX2IsIF9jO1xuICB2YXIgeyBmcm9tLCBhdXRvcGxheSA9IHRydWUsIGRyaXZlciA9IGZyYW1lc3luYywgZWxhcHNlZCA9IDAsIHJlcGVhdDogcmVwZWF0TWF4ID0gMCwgcmVwZWF0VHlwZSA9IFwibG9vcFwiLCByZXBlYXREZWxheSA9IDAsIG9uUGxheSwgb25TdG9wLCBvbkNvbXBsZXRlLCBvblJlcGVhdCwgb25VcGRhdGUgfSA9IF9hLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJmcm9tXCIsIFwiYXV0b3BsYXlcIiwgXCJkcml2ZXJcIiwgXCJlbGFwc2VkXCIsIFwicmVwZWF0XCIsIFwicmVwZWF0VHlwZVwiLCBcInJlcGVhdERlbGF5XCIsIFwib25QbGF5XCIsIFwib25TdG9wXCIsIFwib25Db21wbGV0ZVwiLCBcIm9uUmVwZWF0XCIsIFwib25VcGRhdGVcIl0pO1xuICBsZXQgeyB0byB9ID0gb3B0aW9ucztcbiAgbGV0IGRyaXZlckNvbnRyb2xzO1xuICBsZXQgcmVwZWF0Q291bnQgPSAwO1xuICBsZXQgY29tcHV0ZWREdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG4gIGxldCBsYXRlc3Q7XG4gIGxldCBpc0NvbXBsZXRlID0gZmFsc2U7XG4gIGxldCBpc0ZvcndhcmRQbGF5YmFjayA9IHRydWU7XG4gIGxldCBpbnRlcnBvbGF0ZUZyb21OdW1iZXI7XG4gIGNvbnN0IGFuaW1hdG9yID0gZGV0ZWN0QW5pbWF0aW9uRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIGlmICgoX2MgPSAoX2IgPSBhbmltYXRvcikubmVlZHNJbnRlcnBvbGF0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgZnJvbSwgdG8pKSB7XG4gICAgaW50ZXJwb2xhdGVGcm9tTnVtYmVyID0gaW50ZXJwb2xhdGUoWzAsIDEwMF0sIFtmcm9tLCB0b10sIHtcbiAgICAgIGNsYW1wOiBmYWxzZVxuICAgIH0pO1xuICAgIGZyb20gPSAwO1xuICAgIHRvID0gMTAwO1xuICB9XG4gIGNvbnN0IGFuaW1hdGlvbiA9IGFuaW1hdG9yKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZnJvbSwgdG8gfSkpO1xuICBmdW5jdGlvbiByZXBlYXQoKSB7XG4gICAgcmVwZWF0Q291bnQrKztcbiAgICBpZiAocmVwZWF0VHlwZSA9PT0gXCJyZXZlcnNlXCIpIHtcbiAgICAgIGlzRm9yd2FyZFBsYXliYWNrID0gcmVwZWF0Q291bnQgJSAyID09PSAwO1xuICAgICAgZWxhcHNlZCA9IHJldmVyc2VFbGFwc2VkKGVsYXBzZWQsIGNvbXB1dGVkRHVyYXRpb24sIHJlcGVhdERlbGF5LCBpc0ZvcndhcmRQbGF5YmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsYXBzZWQgPSBsb29wRWxhcHNlZChlbGFwc2VkLCBjb21wdXRlZER1cmF0aW9uLCByZXBlYXREZWxheSk7XG4gICAgICBpZiAocmVwZWF0VHlwZSA9PT0gXCJtaXJyb3JcIilcbiAgICAgICAgYW5pbWF0aW9uLmZsaXBUYXJnZXQoKTtcbiAgICB9XG4gICAgaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIG9uUmVwZWF0ICYmIG9uUmVwZWF0KCk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgZHJpdmVyQ29udHJvbHMuc3RvcCgpO1xuICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZShkZWx0YSkge1xuICAgIGlmICghaXNGb3J3YXJkUGxheWJhY2spXG4gICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICBlbGFwc2VkICs9IGRlbHRhO1xuICAgIGlmICghaXNDb21wbGV0ZSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSBhbmltYXRpb24ubmV4dChNYXRoLm1heCgwLCBlbGFwc2VkKSk7XG4gICAgICBsYXRlc3QgPSBzdGF0ZS52YWx1ZTtcbiAgICAgIGlmIChpbnRlcnBvbGF0ZUZyb21OdW1iZXIpXG4gICAgICAgIGxhdGVzdCA9IGludGVycG9sYXRlRnJvbU51bWJlcihsYXRlc3QpO1xuICAgICAgaXNDb21wbGV0ZSA9IGlzRm9yd2FyZFBsYXliYWNrID8gc3RhdGUuZG9uZSA6IGVsYXBzZWQgPD0gMDtcbiAgICB9XG4gICAgb25VcGRhdGUgPT09IG51bGwgfHwgb25VcGRhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVXBkYXRlKGxhdGVzdCk7XG4gICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgIGlmIChyZXBlYXRDb3VudCA9PT0gMClcbiAgICAgICAgY29tcHV0ZWREdXJhdGlvbiAhPT0gbnVsbCAmJiBjb21wdXRlZER1cmF0aW9uICE9PSB2b2lkIDAgPyBjb21wdXRlZER1cmF0aW9uIDogY29tcHV0ZWREdXJhdGlvbiA9IGVsYXBzZWQ7XG4gICAgICBpZiAocmVwZWF0Q291bnQgPCByZXBlYXRNYXgpIHtcbiAgICAgICAgaGFzUmVwZWF0RGVsYXlFbGFwc2VkKGVsYXBzZWQsIGNvbXB1dGVkRHVyYXRpb24sIHJlcGVhdERlbGF5LCBpc0ZvcndhcmRQbGF5YmFjaykgJiYgcmVwZWF0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwbGF5KCkge1xuICAgIG9uUGxheSA9PT0gbnVsbCB8fCBvblBsYXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUGxheSgpO1xuICAgIGRyaXZlckNvbnRyb2xzID0gZHJpdmVyKHVwZGF0ZSk7XG4gICAgZHJpdmVyQ29udHJvbHMuc3RhcnQoKTtcbiAgfVxuICBhdXRvcGxheSAmJiBwbGF5KCk7XG4gIHJldHVybiB7XG4gICAgc3RvcDogKCkgPT4ge1xuICAgICAgb25TdG9wID09PSBudWxsIHx8IG9uU3RvcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25TdG9wKCk7XG4gICAgICBkcml2ZXJDb250cm9scy5zdG9wKCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvdmVsb2NpdHktcGVyLXNlY29uZC5tanNcbmZ1bmN0aW9uIHZlbG9jaXR5UGVyU2Vjb25kKHZlbG9jaXR5LCBmcmFtZUR1cmF0aW9uKSB7XG4gIHJldHVybiBmcmFtZUR1cmF0aW9uID8gdmVsb2NpdHkgKiAoMWUzIC8gZnJhbWVEdXJhdGlvbikgOiAwO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy9pbmVydGlhLm1qc1xuZnVuY3Rpb24gaW5lcnRpYSh7IGZyb20gPSAwLCB2ZWxvY2l0eSA9IDAsIG1pbiwgbWF4LCBwb3dlciA9IDAuOCwgdGltZUNvbnN0YW50ID0gNzUwLCBib3VuY2VTdGlmZm5lc3MgPSA1MDAsIGJvdW5jZURhbXBpbmcgPSAxMCwgcmVzdERlbHRhID0gMSwgbW9kaWZ5VGFyZ2V0LCBkcml2ZXIsIG9uVXBkYXRlLCBvbkNvbXBsZXRlLCBvblN0b3AgfSkge1xuICBsZXQgY3VycmVudEFuaW1hdGlvbjtcbiAgZnVuY3Rpb24gaXNPdXRPZkJvdW5kcyh2KSB7XG4gICAgcmV0dXJuIG1pbiAhPT0gdm9pZCAwICYmIHYgPCBtaW4gfHwgbWF4ICE9PSB2b2lkIDAgJiYgdiA+IG1heDtcbiAgfVxuICBmdW5jdGlvbiBib3VuZGFyeU5lYXJlc3Qodikge1xuICAgIGlmIChtaW4gPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBtYXg7XG4gICAgaWYgKG1heCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG1pbjtcbiAgICByZXR1cm4gTWF0aC5hYnMobWluIC0gdikgPCBNYXRoLmFicyhtYXggLSB2KSA/IG1pbiA6IG1heDtcbiAgfVxuICBmdW5jdGlvbiBzdGFydEFuaW1hdGlvbjIob3B0aW9ucykge1xuICAgIGN1cnJlbnRBbmltYXRpb24gPT09IG51bGwgfHwgY3VycmVudEFuaW1hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEFuaW1hdGlvbi5zdG9wKCk7XG4gICAgY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgZHJpdmVyLFxuICAgICAgb25VcGRhdGU6ICh2KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgb25VcGRhdGUgPT09IG51bGwgfHwgb25VcGRhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVXBkYXRlKHYpO1xuICAgICAgICAoX2EgPSBvcHRpb25zLm9uVXBkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCB2KTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlLFxuICAgICAgb25TdG9wXG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0U3ByaW5nKG9wdGlvbnMpIHtcbiAgICBzdGFydEFuaW1hdGlvbjIoT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwic3ByaW5nXCIsIHN0aWZmbmVzczogYm91bmNlU3RpZmZuZXNzLCBkYW1waW5nOiBib3VuY2VEYW1waW5nLCByZXN0RGVsdGEgfSwgb3B0aW9ucykpO1xuICB9XG4gIGlmIChpc091dE9mQm91bmRzKGZyb20pKSB7XG4gICAgc3RhcnRTcHJpbmcoeyBmcm9tLCB2ZWxvY2l0eSwgdG86IGJvdW5kYXJ5TmVhcmVzdChmcm9tKSB9KTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgdGFyZ2V0ID0gcG93ZXIgKiB2ZWxvY2l0eSArIGZyb207XG4gICAgaWYgKHR5cGVvZiBtb2RpZnlUYXJnZXQgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICB0YXJnZXQgPSBtb2RpZnlUYXJnZXQodGFyZ2V0KTtcbiAgICBjb25zdCBib3VuZGFyeSA9IGJvdW5kYXJ5TmVhcmVzdCh0YXJnZXQpO1xuICAgIGNvbnN0IGhlYWRpbmcgPSBib3VuZGFyeSA9PT0gbWluID8gLTEgOiAxO1xuICAgIGxldCBwcmV2O1xuICAgIGxldCBjdXJyZW50O1xuICAgIGNvbnN0IGNoZWNrQm91bmRhcnkgPSAodikgPT4ge1xuICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICBjdXJyZW50ID0gdjtcbiAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHlQZXJTZWNvbmQodiAtIHByZXYsIGdldEZyYW1lRGF0YSgpLmRlbHRhKTtcbiAgICAgIGlmIChoZWFkaW5nID09PSAxICYmIHYgPiBib3VuZGFyeSB8fCBoZWFkaW5nID09PSAtMSAmJiB2IDwgYm91bmRhcnkpIHtcbiAgICAgICAgc3RhcnRTcHJpbmcoeyBmcm9tOiB2LCB0bzogYm91bmRhcnksIHZlbG9jaXR5IH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgc3RhcnRBbmltYXRpb24yKHtcbiAgICAgIHR5cGU6IFwiZGVjYXlcIixcbiAgICAgIGZyb20sXG4gICAgICB2ZWxvY2l0eSxcbiAgICAgIHRpbWVDb25zdGFudCxcbiAgICAgIHBvd2VyLFxuICAgICAgcmVzdERlbHRhLFxuICAgICAgbW9kaWZ5VGFyZ2V0LFxuICAgICAgb25VcGRhdGU6IGlzT3V0T2ZCb3VuZHModGFyZ2V0KSA/IGNoZWNrQm91bmRhcnkgOiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0b3A6ICgpID0+IGN1cnJlbnRBbmltYXRpb24gPT09IG51bGwgfHwgY3VycmVudEFuaW1hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEFuaW1hdGlvbi5zdG9wKClcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLXBvaW50Lm1qc1xudmFyIGlzUG9pbnQgPSAocG9pbnQyKSA9PiBwb2ludDIuaGFzT3duUHJvcGVydHkoXCJ4XCIpICYmIHBvaW50Mi5oYXNPd25Qcm9wZXJ0eShcInlcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9pcy1wb2ludC0zZC5tanNcbnZhciBpc1BvaW50M0QgPSAocG9pbnQyKSA9PiBpc1BvaW50KHBvaW50MikgJiYgcG9pbnQyLmhhc093blByb3BlcnR5KFwielwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2Rpc3RhbmNlLm1qc1xudmFyIGRpc3RhbmNlMUQgPSAoYTIsIGIyKSA9PiBNYXRoLmFicyhhMiAtIGIyKTtcbmZ1bmN0aW9uIGRpc3RhbmNlKGEyLCBiMikge1xuICBpZiAoaXNOdW0oYTIpICYmIGlzTnVtKGIyKSkge1xuICAgIHJldHVybiBkaXN0YW5jZTFEKGEyLCBiMik7XG4gIH0gZWxzZSBpZiAoaXNQb2ludChhMikgJiYgaXNQb2ludChiMikpIHtcbiAgICBjb25zdCB4RGVsdGEgPSBkaXN0YW5jZTFEKGEyLngsIGIyLngpO1xuICAgIGNvbnN0IHlEZWx0YSA9IGRpc3RhbmNlMUQoYTIueSwgYjIueSk7XG4gICAgY29uc3QgekRlbHRhID0gaXNQb2ludDNEKGEyKSAmJiBpc1BvaW50M0QoYjIpID8gZGlzdGFuY2UxRChhMi56LCBiMi56KSA6IDA7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4RGVsdGEsIDIpICsgTWF0aC5wb3coeURlbHRhLCAyKSArIE1hdGgucG93KHpEZWx0YSwgMikpO1xuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9lYXNpbmcvY3ViaWMtYmV6aWVyLm1qc1xudmFyIGEgPSAoYTEsIGEyKSA9PiAxIC0gMyAqIGEyICsgMyAqIGExO1xudmFyIGIgPSAoYTEsIGEyKSA9PiAzICogYTIgLSA2ICogYTE7XG52YXIgYzIgPSAoYTEpID0+IDMgKiBhMTtcbnZhciBjYWxjQmV6aWVyID0gKHQsIGExLCBhMikgPT4gKChhKGExLCBhMikgKiB0ICsgYihhMSwgYTIpKSAqIHQgKyBjMihhMSkpICogdDtcbnZhciBnZXRTbG9wZSA9ICh0LCBhMSwgYTIpID0+IDMgKiBhKGExLCBhMikgKiB0ICogdCArIDIgKiBiKGExLCBhMikgKiB0ICsgYzIoYTEpO1xudmFyIHN1YmRpdmlzaW9uUHJlY2lzaW9uID0gMWUtNztcbnZhciBzdWJkaXZpc2lvbk1heEl0ZXJhdGlvbnMgPSAxMDtcbmZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xuICBsZXQgY3VycmVudFg7XG4gIGxldCBjdXJyZW50VDtcbiAgbGV0IGkyID0gMDtcbiAgZG8ge1xuICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyO1xuICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgaWYgKGN1cnJlbnRYID4gMCkge1xuICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICB9IGVsc2Uge1xuICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICB9XG4gIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IHN1YmRpdmlzaW9uUHJlY2lzaW9uICYmICsraTIgPCBzdWJkaXZpc2lvbk1heEl0ZXJhdGlvbnMpO1xuICByZXR1cm4gY3VycmVudFQ7XG59XG52YXIgbmV3dG9uSXRlcmF0aW9ucyA9IDg7XG52YXIgbmV3dG9uTWluU2xvcGUgPSAxZS0zO1xuZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGFHdWVzc1QsIG1YMSwgbVgyKSB7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBuZXd0b25JdGVyYXRpb25zOyArK2kyKSB7XG4gICAgY29uc3QgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDApIHtcbiAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgfVxuICByZXR1cm4gYUd1ZXNzVDtcbn1cbnZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG52YXIga1NhbXBsZVN0ZXBTaXplID0gMSAvIChrU3BsaW5lVGFibGVTaXplIC0gMSk7XG5mdW5jdGlvbiBjdWJpY0JlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKVxuICAgIHJldHVybiBsaW5lYXI7XG4gIGNvbnN0IHNhbXBsZVZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBrU3BsaW5lVGFibGVTaXplOyArK2kyKSB7XG4gICAgc2FtcGxlVmFsdWVzW2kyXSA9IGNhbGNCZXppZXIoaTIgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuICAgIGxldCBpbnRlcnZhbFN0YXJ0ID0gMDtcbiAgICBsZXQgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgY29uc3QgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICB9XG4gICAgLS1jdXJyZW50U2FtcGxlO1xuICAgIGNvbnN0IGRpc3QgPSAoYVggLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgIGNvbnN0IGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xuICAgIGNvbnN0IGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIGlmIChpbml0aWFsU2xvcGUgPj0gbmV3dG9uTWluU2xvcGUpIHtcbiAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDApIHtcbiAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICh0KSA9PiB0ID09PSAwIHx8IHQgPT09IDEgPyB0IDogY2FsY0JlemllcihnZXRURm9yWCh0KSwgbVkxLCBtWTIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS10YXAtZ2VzdHVyZS5tanNcbmZ1bmN0aW9uIHVzZVRhcEdlc3R1cmUoeyBvblRhcCwgb25UYXBTdGFydCwgb25UYXBDYW5jZWwsIHdoaWxlVGFwLCB2aXN1YWxFbGVtZW50IH0pIHtcbiAgY29uc3QgaGFzUHJlc3NMaXN0ZW5lcnMgPSBvblRhcCB8fCBvblRhcFN0YXJ0IHx8IG9uVGFwQ2FuY2VsIHx8IHdoaWxlVGFwO1xuICBjb25zdCBpc1ByZXNzaW5nID0gKDAsIGltcG9ydF9yZWFjdDIwLnVzZVJlZikoZmFsc2UpO1xuICBjb25zdCBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzID0gKDAsIGltcG9ydF9yZWFjdDIwLnVzZVJlZikobnVsbCk7XG4gIGNvbnN0IGV2ZW50T3B0aW9ucyA9IHtcbiAgICBwYXNzaXZlOiAhKG9uVGFwU3RhcnQgfHwgb25UYXAgfHwgb25UYXBDYW5jZWwgfHwgb25Qb2ludGVyRG93bilcbiAgfTtcbiAgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlckVuZExpc3RlbmVyKCkge1xuICAgIGNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMuY3VycmVudCAmJiBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzLmN1cnJlbnQoKTtcbiAgICBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzLmN1cnJlbnQgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrUG9pbnRlckVuZCgpIHtcbiAgICByZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIoKTtcbiAgICBpc1ByZXNzaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlICYmIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuVGFwLCBmYWxzZSk7XG4gICAgcmV0dXJuICFpc0RyYWdBY3RpdmUoKTtcbiAgfVxuICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCwgaW5mbykge1xuICAgIGlmICghY2hlY2tQb2ludGVyRW5kKCkpXG4gICAgICByZXR1cm47XG4gICAgIWlzTm9kZU9yQ2hpbGQodmlzdWFsRWxlbWVudC5jdXJyZW50LCBldmVudC50YXJnZXQpID8gb25UYXBDYW5jZWwgJiYgb25UYXBDYW5jZWwoZXZlbnQsIGluZm8pIDogb25UYXAgJiYgb25UYXAoZXZlbnQsIGluZm8pO1xuICB9XG4gIGZ1bmN0aW9uIG9uUG9pbnRlckNhbmNlbChldmVudCwgaW5mbykge1xuICAgIGlmICghY2hlY2tQb2ludGVyRW5kKCkpXG4gICAgICByZXR1cm47XG4gICAgb25UYXBDYW5jZWwgJiYgb25UYXBDYW5jZWwoZXZlbnQsIGluZm8pO1xuICB9XG4gIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQsIGluZm8pIHtcbiAgICByZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIoKTtcbiAgICBpZiAoaXNQcmVzc2luZy5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGlzUHJlc3NpbmcuY3VycmVudCA9IHRydWU7XG4gICAgY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50ID0gcGlwZShhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgZXZlbnRPcHRpb25zKSwgYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlckNhbmNlbCwgZXZlbnRPcHRpb25zKSk7XG4gICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSAmJiB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLlRhcCwgdHJ1ZSk7XG4gICAgb25UYXBTdGFydCAmJiBvblRhcFN0YXJ0KGV2ZW50LCBpbmZvKTtcbiAgfVxuICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudCwgXCJwb2ludGVyZG93blwiLCBoYXNQcmVzc0xpc3RlbmVycyA/IG9uUG9pbnRlckRvd24gOiB2b2lkIDAsIGV2ZW50T3B0aW9ucyk7XG4gIHVzZVVubW91bnRFZmZlY3QocmVtb3ZlUG9pbnRlckVuZExpc3RlbmVyKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9wcm9jZXNzLm1qc1xudmFyIGRlZmF1bHRFbnZpcm9ubWVudCA9IFwicHJvZHVjdGlvblwiO1xudmFyIGVudiA9IHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52ID09PSB2b2lkIDAgPyBkZWZhdWx0RW52aXJvbm1lbnQgOiBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCBkZWZhdWx0RW52aXJvbm1lbnQ7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL3ZpZXdwb3J0L3VzZS12aWV3cG9ydC5tanNcbnZhciBpbXBvcnRfcmVhY3QyMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy93YXJuLW9uY2UubWpzXG52YXIgd2FybmVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHdhcm5PbmNlKGNvbmRpdGlvbiwgbWVzc2FnZSwgZWxlbWVudCkge1xuICBpZiAoY29uZGl0aW9uIHx8IHdhcm5lZC5oYXMobWVzc2FnZSkpXG4gICAgcmV0dXJuO1xuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gIGlmIChlbGVtZW50KVxuICAgIGNvbnNvbGUud2FybihlbGVtZW50KTtcbiAgd2FybmVkLmFkZChtZXNzYWdlKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvdmlld3BvcnQvb2JzZXJ2ZXJzLm1qc1xudmFyIG9ic2VydmVyQ2FsbGJhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgb2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgZmlyZU9ic2VydmVyQ2FsbGJhY2sgPSAoZW50cnkpID0+IHtcbiAgY29uc3QgY2FsbGJhY2sgPSBvYnNlcnZlckNhbGxiYWNrcy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW50cnkpO1xufTtcbnZhciBmaXJlQWxsT2JzZXJ2ZXJDYWxsYmFja3MgPSAoZW50cmllcykgPT4ge1xuICBlbnRyaWVzLmZvckVhY2goZmlyZU9ic2VydmVyQ2FsbGJhY2spO1xufTtcbmZ1bmN0aW9uIGluaXRJbnRlcnNlY3Rpb25PYnNlcnZlcihfYSkge1xuICB2YXIgX2IgPSBfYSwgeyByb290IH0gPSBfYiwgb3B0aW9ucyA9IF9fb2JqUmVzdChfYiwgW1wicm9vdFwiXSk7XG4gIGNvbnN0IGxvb2t1cFJvb3QgPSByb290IHx8IGRvY3VtZW50O1xuICBpZiAoIW9ic2VydmVycy5oYXMobG9va3VwUm9vdCkpIHtcbiAgICBvYnNlcnZlcnMuc2V0KGxvb2t1cFJvb3QsIHt9KTtcbiAgfVxuICBjb25zdCByb290T2JzZXJ2ZXJzID0gb2JzZXJ2ZXJzLmdldChsb29rdXBSb290KTtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGlmICghcm9vdE9ic2VydmVyc1trZXldKSB7XG4gICAgcm9vdE9ic2VydmVyc1trZXldID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcywgX19zcHJlYWRWYWx1ZXMoeyByb290IH0sIG9wdGlvbnMpKTtcbiAgfVxuICByZXR1cm4gcm9vdE9ic2VydmVyc1trZXldO1xufVxuZnVuY3Rpb24gb2JzZXJ2ZUludGVyc2VjdGlvbihlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCByb290SW50ZXJlc2VjdGlvbk9ic2VydmVyID0gaW5pdEludGVyc2VjdGlvbk9ic2VydmVyKG9wdGlvbnMpO1xuICBvYnNlcnZlckNhbGxiYWNrcy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICByb290SW50ZXJlc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgb2JzZXJ2ZXJDYWxsYmFja3MuZGVsZXRlKGVsZW1lbnQpO1xuICAgIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy92aWV3cG9ydC91c2Utdmlld3BvcnQubWpzXG5mdW5jdGlvbiB1c2VWaWV3cG9ydCh7IHZpc3VhbEVsZW1lbnQsIHdoaWxlSW5WaWV3LCBvblZpZXdwb3J0RW50ZXIsIG9uVmlld3BvcnRMZWF2ZSwgdmlld3BvcnQgPSB7fSB9KSB7XG4gIGNvbnN0IHN0YXRlID0gKDAsIGltcG9ydF9yZWFjdDIxLnVzZVJlZikoe1xuICAgIGhhc0VudGVyZWRWaWV3OiBmYWxzZSxcbiAgICBpc0luVmlldzogZmFsc2VcbiAgfSk7XG4gIGxldCBzaG91bGRPYnNlcnZlID0gQm9vbGVhbih3aGlsZUluVmlldyB8fCBvblZpZXdwb3J0RW50ZXIgfHwgb25WaWV3cG9ydExlYXZlKTtcbiAgaWYgKHZpZXdwb3J0Lm9uY2UgJiYgc3RhdGUuY3VycmVudC5oYXNFbnRlcmVkVmlldylcbiAgICBzaG91bGRPYnNlcnZlID0gZmFsc2U7XG4gIGNvbnN0IHVzZU9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiID8gdXNlTWlzc2luZ0ludGVyc2VjdGlvbk9ic2VydmVyIDogdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gIHVzZU9ic2VydmVyKHNob3VsZE9ic2VydmUsIHN0YXRlLmN1cnJlbnQsIHZpc3VhbEVsZW1lbnQsIHZpZXdwb3J0KTtcbn1cbnZhciB0aHJlc2hvbGROYW1lcyA9IHtcbiAgc29tZTogMCxcbiAgYWxsOiAxXG59O1xuZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoc2hvdWxkT2JzZXJ2ZSwgc3RhdGUsIHZpc3VhbEVsZW1lbnQsIHsgcm9vdCwgbWFyZ2luOiByb290TWFyZ2luLCBhbW91bnQgPSBcInNvbWVcIiwgb25jZSB9KSB7XG4gICgwLCBpbXBvcnRfcmVhY3QyMS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBpZiAoIXNob3VsZE9ic2VydmUgfHwgIXZpc3VhbEVsZW1lbnQuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcm9vdDogcm9vdCA9PT0gbnVsbCB8fCByb290ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb290LmN1cnJlbnQsXG4gICAgICByb290TWFyZ2luLFxuICAgICAgdGhyZXNob2xkOiB0eXBlb2YgYW1vdW50ID09PSBcIm51bWJlclwiID8gYW1vdW50IDogdGhyZXNob2xkTmFtZXNbYW1vdW50XVxuICAgIH07XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uQ2FsbGJhY2sgPSAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IHsgaXNJbnRlcnNlY3RpbmcgfSA9IGVudHJ5O1xuICAgICAgaWYgKHN0YXRlLmlzSW5WaWV3ID09PSBpc0ludGVyc2VjdGluZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgc3RhdGUuaXNJblZpZXcgPSBpc0ludGVyc2VjdGluZztcbiAgICAgIGlmIChvbmNlICYmICFpc0ludGVyc2VjdGluZyAmJiBzdGF0ZS5oYXNFbnRlcmVkVmlldykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIHN0YXRlLmhhc0VudGVyZWRWaWV3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuSW5WaWV3LCBpc0ludGVyc2VjdGluZyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gaXNJbnRlcnNlY3RpbmcgPyBwcm9wcy5vblZpZXdwb3J0RW50ZXIgOiBwcm9wcy5vblZpZXdwb3J0TGVhdmU7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbnRyeSk7XG4gICAgfTtcbiAgICByZXR1cm4gb2JzZXJ2ZUludGVyc2VjdGlvbih2aXN1YWxFbGVtZW50LmN1cnJlbnQsIG9wdGlvbnMsIGludGVyc2VjdGlvbkNhbGxiYWNrKTtcbiAgfSwgW3Nob3VsZE9ic2VydmUsIHJvb3QsIHJvb3RNYXJnaW4sIGFtb3VudF0pO1xufVxuZnVuY3Rpb24gdXNlTWlzc2luZ0ludGVyc2VjdGlvbk9ic2VydmVyKHNob3VsZE9ic2VydmUsIHN0YXRlLCB2aXN1YWxFbGVtZW50LCB7IGZhbGxiYWNrID0gdHJ1ZSB9KSB7XG4gICgwLCBpbXBvcnRfcmVhY3QyMS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBpZiAoIXNob3VsZE9ic2VydmUgfHwgIWZhbGxiYWNrKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChlbnYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuT25jZShmYWxzZSwgXCJJbnRlcnNlY3Rpb25PYnNlcnZlciBub3QgYXZhaWxhYmxlIG9uIHRoaXMgZGV2aWNlLiB3aGlsZUluVmlldyBhbmltYXRpb25zIHdpbGwgdHJpZ2dlciBvbiBtb3VudC5cIik7XG4gICAgfVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBzdGF0ZS5oYXNFbnRlcmVkVmlldyA9IHRydWU7XG4gICAgICBjb25zdCB7IG9uVmlld3BvcnRFbnRlciB9ID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgb25WaWV3cG9ydEVudGVyICYmIG9uVmlld3BvcnRFbnRlcihudWxsKTtcbiAgICAgIGlmICh2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuSW5WaWV3LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3Nob3VsZE9ic2VydmVdKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvbWFrZS1yZW5kZXJsZXNzLWNvbXBvbmVudC5tanNcbnZhciBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCA9IChob29rKSA9PiAocHJvcHMpID0+IHtcbiAgaG9vayhwcm9wcyk7XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvZ2VzdHVyZXMubWpzXG52YXIgZ2VzdHVyZUFuaW1hdGlvbnMgPSB7XG4gIGluVmlldzogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlVmlld3BvcnQpLFxuICB0YXA6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZVRhcEdlc3R1cmUpLFxuICBmb2N1czogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlRm9jdXNHZXN0dXJlKSxcbiAgaG92ZXI6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZUhvdmVyR2VzdHVyZSlcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2FuaW1hdGlvbnMubWpzXG52YXIgaW1wb3J0X3JlYWN0MjMgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvdXNlLXByZXNlbmNlLm1qc1xudmFyIGltcG9ydF9yZWFjdDIyID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gdXNlUHJlc2VuY2UoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MjIudXNlQ29udGV4dCkoUHJlc2VuY2VDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpXG4gICAgcmV0dXJuIFt0cnVlLCBudWxsXTtcbiAgY29uc3QgeyBpc1ByZXNlbnQsIG9uRXhpdENvbXBsZXRlLCByZWdpc3RlciB9ID0gY29udGV4dDtcbiAgY29uc3QgaWQyID0gKDAsIGltcG9ydF9yZWFjdDIyLnVzZUlkKSgpO1xuICAoMCwgaW1wb3J0X3JlYWN0MjIudXNlRWZmZWN0KSgoKSA9PiByZWdpc3RlcihpZDIpLCBbXSk7XG4gIGNvbnN0IHNhZmVUb1JlbW92ZSA9ICgpID0+IG9uRXhpdENvbXBsZXRlICYmIG9uRXhpdENvbXBsZXRlKGlkMik7XG4gIHJldHVybiAhaXNQcmVzZW50ICYmIG9uRXhpdENvbXBsZXRlID8gW2ZhbHNlLCBzYWZlVG9SZW1vdmVdIDogW3RydWVdO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3NoYWxsb3ctY29tcGFyZS5tanNcbmZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByZXYpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJldkxlbmd0aCA9IHByZXYubGVuZ3RoO1xuICBpZiAocHJldkxlbmd0aCAhPT0gbmV4dC5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgcHJldkxlbmd0aDsgaTIrKykge1xuICAgIGlmIChwcmV2W2kyXSAhPT0gbmV4dFtpMl0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdGltZS1jb252ZXJzaW9uLm1qc1xudmFyIHNlY29uZHNUb01pbGxpc2Vjb25kcyA9IChzZWNvbmRzKSA9PiBzZWNvbmRzICogMWUzO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9lYXNpbmcubWpzXG52YXIgZWFzaW5nTG9va3VwID0ge1xuICBsaW5lYXIsXG4gIGVhc2VJbixcbiAgZWFzZUluT3V0LFxuICBlYXNlT3V0LFxuICBjaXJjSW4sXG4gIGNpcmNJbk91dCxcbiAgY2lyY091dCxcbiAgYmFja0luLFxuICBiYWNrSW5PdXQsXG4gIGJhY2tPdXQsXG4gIGFudGljaXBhdGUsXG4gIGJvdW5jZUluLFxuICBib3VuY2VJbk91dCxcbiAgYm91bmNlT3V0XG59O1xudmFyIGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uID0gKGRlZmluaXRpb24pID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICBpbnZhcmlhbnQoZGVmaW5pdGlvbi5sZW5ndGggPT09IDQsIGBDdWJpYyBiZXppZXIgYXJyYXlzIG11c3QgY29udGFpbiBmb3VyIG51bWVyaWNhbCB2YWx1ZXMuYCk7XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IGRlZmluaXRpb247XG4gICAgcmV0dXJuIGN1YmljQmV6aWVyKHgxLCB5MSwgeDIsIHkyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgIGludmFyaWFudChlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl0gIT09IHZvaWQgMCwgYEludmFsaWQgZWFzaW5nIHR5cGUgJyR7ZGVmaW5pdGlvbn0nYCk7XG4gICAgcmV0dXJuIGVhc2luZ0xvb2t1cFtkZWZpbml0aW9uXTtcbiAgfVxuICByZXR1cm4gZGVmaW5pdGlvbjtcbn07XG52YXIgaXNFYXNpbmdBcnJheSA9IChlYXNlKSA9PiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGVhc2UpICYmIHR5cGVvZiBlYXNlWzBdICE9PSBcIm51bWJlclwiO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvaXMtYW5pbWF0YWJsZS5tanNcbnZhciBpc0FuaW1hdGFibGUgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICBpZiAoa2V5ID09PSBcInpJbmRleFwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBjb21wbGV4LnRlc3QodmFsdWUpICYmICF2YWx1ZS5zdGFydHNXaXRoKFwidXJsKFwiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2RlZmF1bHQtdHJhbnNpdGlvbnMubWpzXG52YXIgdW5kZXJEYW1wZWRTcHJpbmcgPSAoKSA9PiAoe1xuICB0eXBlOiBcInNwcmluZ1wiLFxuICBzdGlmZm5lc3M6IDUwMCxcbiAgZGFtcGluZzogMjUsXG4gIHJlc3RTcGVlZDogMTBcbn0pO1xudmFyIGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcgPSAodG8pID0+ICh7XG4gIHR5cGU6IFwic3ByaW5nXCIsXG4gIHN0aWZmbmVzczogNTUwLFxuICBkYW1waW5nOiB0byA9PT0gMCA/IDIgKiBNYXRoLnNxcnQoNTUwKSA6IDMwLFxuICByZXN0U3BlZWQ6IDEwXG59KTtcbnZhciBsaW5lYXJUd2VlbiA9ICgpID0+ICh7XG4gIHR5cGU6IFwia2V5ZnJhbWVzXCIsXG4gIGVhc2U6IFwibGluZWFyXCIsXG4gIGR1cmF0aW9uOiAwLjNcbn0pO1xudmFyIGtleWZyYW1lczIgPSAodmFsdWVzKSA9PiAoe1xuICB0eXBlOiBcImtleWZyYW1lc1wiLFxuICBkdXJhdGlvbjogMC44LFxuICB2YWx1ZXNcbn0pO1xudmFyIGRlZmF1bHRUcmFuc2l0aW9ucyA9IHtcbiAgeDogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHk6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICB6OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgcm90YXRlOiB1bmRlckRhbXBlZFNwcmluZyxcbiAgcm90YXRlWDogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHJvdGF0ZVk6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICByb3RhdGVaOiB1bmRlckRhbXBlZFNwcmluZyxcbiAgc2NhbGVYOiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nLFxuICBzY2FsZVk6IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsXG4gIHNjYWxlOiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nLFxuICBvcGFjaXR5OiBsaW5lYXJUd2VlbixcbiAgYmFja2dyb3VuZENvbG9yOiBsaW5lYXJUd2VlbixcbiAgY29sb3I6IGxpbmVhclR3ZWVuLFxuICBkZWZhdWx0OiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nXG59O1xudmFyIGdldERlZmF1bHRUcmFuc2l0aW9uID0gKHZhbHVlS2V5LCB0bykgPT4ge1xuICBsZXQgdHJhbnNpdGlvbkZhY3Rvcnk7XG4gIGlmIChpc0tleWZyYW1lc1RhcmdldCh0bykpIHtcbiAgICB0cmFuc2l0aW9uRmFjdG9yeSA9IGtleWZyYW1lczI7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNpdGlvbkZhY3RvcnkgPSBkZWZhdWx0VHJhbnNpdGlvbnNbdmFsdWVLZXldIHx8IGRlZmF1bHRUcmFuc2l0aW9ucy5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7IHRvIH0sIHRyYW5zaXRpb25GYWN0b3J5KHRvKSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZGVmYXVsdHMubWpzXG52YXIgZGVmYXVsdFZhbHVlVHlwZXMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBudW1iZXJWYWx1ZVR5cGVzKSwge1xuICBjb2xvcixcbiAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgb3V0bGluZUNvbG9yOiBjb2xvcixcbiAgZmlsbDogY29sb3IsXG4gIHN0cm9rZTogY29sb3IsXG4gIGJvcmRlckNvbG9yOiBjb2xvcixcbiAgYm9yZGVyVG9wQ29sb3I6IGNvbG9yLFxuICBib3JkZXJSaWdodENvbG9yOiBjb2xvcixcbiAgYm9yZGVyQm90dG9tQ29sb3I6IGNvbG9yLFxuICBib3JkZXJMZWZ0Q29sb3I6IGNvbG9yLFxuICBmaWx0ZXIsXG4gIFdlYmtpdEZpbHRlcjogZmlsdGVyXG59KTtcbnZhciBnZXREZWZhdWx0VmFsdWVUeXBlID0gKGtleSkgPT4gZGVmYXVsdFZhbHVlVHlwZXNba2V5XTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL2FuaW1hdGFibGUtbm9uZS5tanNcbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVOb25lMihrZXksIHZhbHVlKSB7XG4gIHZhciBfYTtcbiAgbGV0IGRlZmF1bHRWYWx1ZVR5cGUgPSBnZXREZWZhdWx0VmFsdWVUeXBlKGtleSk7XG4gIGlmIChkZWZhdWx0VmFsdWVUeXBlICE9PSBmaWx0ZXIpXG4gICAgZGVmYXVsdFZhbHVlVHlwZSA9IGNvbXBsZXg7XG4gIHJldHVybiAoX2EgPSBkZWZhdWx0VmFsdWVUeXBlLmdldEFuaW1hdGFibGVOb25lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChkZWZhdWx0VmFsdWVUeXBlLCB2YWx1ZSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWluc3RhbnQtdHJhbnNpdGlvbi1zdGF0ZS5tanNcbnZhciBpbnN0YW50QW5pbWF0aW9uU3RhdGUgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2RlbGF5Lm1qc1xuZnVuY3Rpb24gZGVsYXkoY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgY29uc3QgY2hlY2tFbGFwc2VkID0gKHsgdGltZXN0YW1wIH0pID0+IHtcbiAgICBjb25zdCBlbGFwc2VkID0gdGltZXN0YW1wIC0gc3RhcnQ7XG4gICAgaWYgKGVsYXBzZWQgPj0gdGltZW91dCkge1xuICAgICAgY2FuY2VsU3luYy5yZWFkKGNoZWNrRWxhcHNlZCk7XG4gICAgICBjYWxsYmFjayhlbGFwc2VkIC0gdGltZW91dCk7XG4gICAgfVxuICB9O1xuICBlc19kZWZhdWx0LnJlYWQoY2hlY2tFbGFwc2VkLCB0cnVlKTtcbiAgcmV0dXJuICgpID0+IGNhbmNlbFN5bmMucmVhZChjaGVja0VsYXBzZWQpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy90cmFuc2l0aW9ucy5tanNcbmZ1bmN0aW9uIGlzVHJhbnNpdGlvbkRlZmluZWQoX2EpIHtcbiAgdmFyIF9iID0gX2EsIHsgd2hlbiwgZGVsYXk6IF9kZWxheSwgZGVsYXlDaGlsZHJlbiwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCByZXBlYXQsIHJlcGVhdFR5cGUsIHJlcGVhdERlbGF5LCBmcm9tIH0gPSBfYiwgdHJhbnNpdGlvbiA9IF9fb2JqUmVzdChfYiwgW1wid2hlblwiLCBcImRlbGF5XCIsIFwiZGVsYXlDaGlsZHJlblwiLCBcInN0YWdnZXJDaGlsZHJlblwiLCBcInN0YWdnZXJEaXJlY3Rpb25cIiwgXCJyZXBlYXRcIiwgXCJyZXBlYXRUeXBlXCIsIFwicmVwZWF0RGVsYXlcIiwgXCJmcm9tXCJdKTtcbiAgcmV0dXJuICEhT2JqZWN0LmtleXModHJhbnNpdGlvbikubGVuZ3RoO1xufVxudmFyIGxlZ2FjeVJlcGVhdFdhcm5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbnZlcnRUcmFuc2l0aW9uVG9BbmltYXRpb25PcHRpb25zKF9hKSB7XG4gIHZhciBfYiA9IF9hLCB7IGVhc2UsIHRpbWVzLCB5b3lvLCBmbGlwLCBsb29wIH0gPSBfYiwgdHJhbnNpdGlvbiA9IF9fb2JqUmVzdChfYiwgW1wiZWFzZVwiLCBcInRpbWVzXCIsIFwieW95b1wiLCBcImZsaXBcIiwgXCJsb29wXCJdKTtcbiAgY29uc3Qgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0cmFuc2l0aW9uKTtcbiAgaWYgKHRpbWVzKVxuICAgIG9wdGlvbnNbXCJvZmZzZXRcIl0gPSB0aW1lcztcbiAgaWYgKHRyYW5zaXRpb24uZHVyYXRpb24pXG4gICAgb3B0aW9uc1tcImR1cmF0aW9uXCJdID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRyYW5zaXRpb24uZHVyYXRpb24pO1xuICBpZiAodHJhbnNpdGlvbi5yZXBlYXREZWxheSlcbiAgICBvcHRpb25zLnJlcGVhdERlbGF5ID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRyYW5zaXRpb24ucmVwZWF0RGVsYXkpO1xuICBpZiAoZWFzZSkge1xuICAgIG9wdGlvbnNbXCJlYXNlXCJdID0gaXNFYXNpbmdBcnJheShlYXNlKSA/IGVhc2UubWFwKGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKSA6IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKGVhc2UpO1xuICB9XG4gIGlmICh0cmFuc2l0aW9uLnR5cGUgPT09IFwidHdlZW5cIilcbiAgICBvcHRpb25zLnR5cGUgPSBcImtleWZyYW1lc1wiO1xuICBpZiAoeW95byB8fCBsb29wIHx8IGZsaXApIHtcbiAgICB3YXJuaW5nKCFsZWdhY3lSZXBlYXRXYXJuaW5nLCBcInlveW8sIGxvb3AgYW5kIGZsaXAgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgQVBJLiBSZXBsYWNlIHdpdGggcmVwZWF0IGFuZCByZXBlYXRUeXBlIG9wdGlvbnMuXCIpO1xuICAgIGxlZ2FjeVJlcGVhdFdhcm5pbmcgPSB0cnVlO1xuICAgIGlmICh5b3lvKSB7XG4gICAgICBvcHRpb25zLnJlcGVhdFR5cGUgPSBcInJldmVyc2VcIjtcbiAgICB9IGVsc2UgaWYgKGxvb3ApIHtcbiAgICAgIG9wdGlvbnMucmVwZWF0VHlwZSA9IFwibG9vcFwiO1xuICAgIH0gZWxzZSBpZiAoZmxpcCkge1xuICAgICAgb3B0aW9ucy5yZXBlYXRUeXBlID0gXCJtaXJyb3JcIjtcbiAgICB9XG4gICAgb3B0aW9ucy5yZXBlYXQgPSBsb29wIHx8IHlveW8gfHwgZmxpcCB8fCB0cmFuc2l0aW9uLnJlcGVhdDtcbiAgfVxuICBpZiAodHJhbnNpdGlvbi50eXBlICE9PSBcInNwcmluZ1wiKVxuICAgIG9wdGlvbnMudHlwZSA9IFwia2V5ZnJhbWVzXCI7XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0RGVsYXlGcm9tVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdmFsdWVUcmFuc2l0aW9uID0gZ2V0VmFsdWVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleSkgfHwge307XG4gIHJldHVybiAoX2IgPSAoX2EgPSB2YWx1ZVRyYW5zaXRpb24uZGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRyYW5zaXRpb24uZGVsYXkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG59XG5mdW5jdGlvbiBoeWRyYXRlS2V5ZnJhbWVzKG9wdGlvbnMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy50bykgJiYgb3B0aW9ucy50b1swXSA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMudG8gPSBbLi4ub3B0aW9ucy50b107XG4gICAgb3B0aW9ucy50b1swXSA9IG9wdGlvbnMuZnJvbTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGdldFBvcG1vdGlvbkFuaW1hdGlvbk9wdGlvbnModHJhbnNpdGlvbiwgb3B0aW9ucywga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudG8pICYmIHRyYW5zaXRpb24uZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgIHRyYW5zaXRpb24uZHVyYXRpb24gPSAwLjg7XG4gIH1cbiAgaHlkcmF0ZUtleWZyYW1lcyhvcHRpb25zKTtcbiAgaWYgKCFpc1RyYW5zaXRpb25EZWZpbmVkKHRyYW5zaXRpb24pKSB7XG4gICAgdHJhbnNpdGlvbiA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0cmFuc2l0aW9uKSwgZ2V0RGVmYXVsdFRyYW5zaXRpb24oa2V5LCBvcHRpb25zLnRvKSk7XG4gIH1cbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgY29udmVydFRyYW5zaXRpb25Ub0FuaW1hdGlvbk9wdGlvbnModHJhbnNpdGlvbikpO1xufVxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbiwgb25Db21wbGV0ZSkge1xuICBjb25zdCB2YWx1ZVRyYW5zaXRpb24gPSBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB8fCB7fTtcbiAgbGV0IG9yaWdpbiA9IHZhbHVlVHJhbnNpdGlvbi5mcm9tICE9PSB2b2lkIDAgPyB2YWx1ZVRyYW5zaXRpb24uZnJvbSA6IHZhbHVlLmdldCgpO1xuICBjb25zdCBpc1RhcmdldEFuaW1hdGFibGUgPSBpc0FuaW1hdGFibGUoa2V5LCB0YXJnZXQpO1xuICBpZiAob3JpZ2luID09PSBcIm5vbmVcIiAmJiBpc1RhcmdldEFuaW1hdGFibGUgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG9yaWdpbiA9IGdldEFuaW1hdGFibGVOb25lMihrZXksIHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoaXNaZXJvKG9yaWdpbikgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG9yaWdpbiA9IGdldFplcm9Vbml0KHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1plcm8odGFyZ2V0KSAmJiB0eXBlb2Ygb3JpZ2luID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGFyZ2V0ID0gZ2V0WmVyb1VuaXQob3JpZ2luKTtcbiAgfVxuICBjb25zdCBpc09yaWdpbkFuaW1hdGFibGUgPSBpc0FuaW1hdGFibGUoa2V5LCBvcmlnaW4pO1xuICB3YXJuaW5nKGlzT3JpZ2luQW5pbWF0YWJsZSA9PT0gaXNUYXJnZXRBbmltYXRhYmxlLCBgWW91IGFyZSB0cnlpbmcgdG8gYW5pbWF0ZSAke2tleX0gZnJvbSBcIiR7b3JpZ2lufVwiIHRvIFwiJHt0YXJnZXR9XCIuICR7b3JpZ2lufSBpcyBub3QgYW4gYW5pbWF0YWJsZSB2YWx1ZSAtIHRvIGVuYWJsZSB0aGlzIGFuaW1hdGlvbiBzZXQgJHtvcmlnaW59IHRvIGEgdmFsdWUgYW5pbWF0YWJsZSB0byAke3RhcmdldH0gdmlhIHRoZSBcXGBzdHlsZVxcYCBwcm9wZXJ0eS5gKTtcbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGZyb206IG9yaWdpbixcbiAgICAgIHRvOiB0YXJnZXQsXG4gICAgICB2ZWxvY2l0eTogdmFsdWUuZ2V0VmVsb2NpdHkoKSxcbiAgICAgIG9uQ29tcGxldGUsXG4gICAgICBvblVwZGF0ZTogKHYpID0+IHZhbHVlLnNldCh2KVxuICAgIH07XG4gICAgcmV0dXJuIHZhbHVlVHJhbnNpdGlvbi50eXBlID09PSBcImluZXJ0aWFcIiB8fCB2YWx1ZVRyYW5zaXRpb24udHlwZSA9PT0gXCJkZWNheVwiID8gaW5lcnRpYShfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHZhbHVlVHJhbnNpdGlvbikpIDogYW5pbWF0ZShfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBnZXRQb3Btb3Rpb25BbmltYXRpb25PcHRpb25zKHZhbHVlVHJhbnNpdGlvbiwgb3B0aW9ucywga2V5KSksIHtcbiAgICAgIG9uVXBkYXRlOiAodikgPT4ge1xuICAgICAgICBvcHRpb25zLm9uVXBkYXRlKHYpO1xuICAgICAgICB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUgJiYgdmFsdWVUcmFuc2l0aW9uLm9uVXBkYXRlKHYpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICAgIHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlICYmIHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIHNldCgpIHtcbiAgICBjb25zdCBmaW5hbFRhcmdldCA9IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXModGFyZ2V0KTtcbiAgICB2YWx1ZS5zZXQoZmluYWxUYXJnZXQpO1xuICAgIG9uQ29tcGxldGUoKTtcbiAgICB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUgJiYgdmFsdWVUcmFuc2l0aW9uLm9uVXBkYXRlKGZpbmFsVGFyZ2V0KTtcbiAgICB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSAmJiB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSgpO1xuICAgIHJldHVybiB7IHN0b3A6ICgpID0+IHtcbiAgICB9IH07XG4gIH1cbiAgcmV0dXJuICFpc09yaWdpbkFuaW1hdGFibGUgfHwgIWlzVGFyZ2V0QW5pbWF0YWJsZSB8fCB2YWx1ZVRyYW5zaXRpb24udHlwZSA9PT0gZmFsc2UgPyBzZXQgOiBzdGFydDtcbn1cbmZ1bmN0aW9uIGlzWmVybyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IDAgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHBhcnNlRmxvYXQodmFsdWUpID09PSAwICYmIHZhbHVlLmluZGV4T2YoXCIgXCIpID09PSAtMTtcbn1cbmZ1bmN0aW9uIGdldFplcm9Vbml0KHBvdGVudGlhbFVuaXRUeXBlKSB7XG4gIHJldHVybiB0eXBlb2YgcG90ZW50aWFsVW5pdFR5cGUgPT09IFwibnVtYmVyXCIgPyAwIDogZ2V0QW5pbWF0YWJsZU5vbmUyKFwiXCIsIHBvdGVudGlhbFVuaXRUeXBlKTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHtcbiAgcmV0dXJuIHRyYW5zaXRpb25ba2V5XSB8fCB0cmFuc2l0aW9uW1wiZGVmYXVsdFwiXSB8fCB0cmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uID0ge30pIHtcbiAgaWYgKGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50KSB7XG4gICAgdHJhbnNpdGlvbiA9IHsgdHlwZTogZmFsc2UgfTtcbiAgfVxuICByZXR1cm4gdmFsdWUuc3RhcnQoKG9uQ29tcGxldGUpID0+IHtcbiAgICBsZXQgY29udHJvbHM7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gZ2V0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbiwgb25Db21wbGV0ZSk7XG4gICAgY29uc3QgZGVsYXlCeSA9IGdldERlbGF5RnJvbVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KTtcbiAgICBjb25zdCBzdGFydCA9ICgpID0+IGNvbnRyb2xzID0gYW5pbWF0aW9uKCk7XG4gICAgbGV0IGNhbmNlbERlbGF5O1xuICAgIGlmIChkZWxheUJ5KSB7XG4gICAgICBjYW5jZWxEZWxheSA9IGRlbGF5KHN0YXJ0LCBzZWNvbmRzVG9NaWxsaXNlY29uZHMoZGVsYXlCeSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCgpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsRGVsYXkgJiYgY2FuY2VsRGVsYXkoKTtcbiAgICAgIGNvbnRyb2xzICYmIGNvbnRyb2xzLnN0b3AoKTtcbiAgICB9O1xuICB9KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pcy1udW1lcmljYWwtc3RyaW5nLm1qc1xudmFyIGlzTnVtZXJpY2FsU3RyaW5nID0gKHYpID0+IC9eXFwtP1xcZCpcXC4/XFxkKyQvLnRlc3Qodik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtemVyby12YWx1ZS1zdHJpbmcubWpzXG52YXIgaXNaZXJvVmFsdWVTdHJpbmcgPSAodikgPT4gL14wW14uXFxzXSskLy50ZXN0KHYpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2FycmF5Lm1qc1xuZnVuY3Rpb24gYWRkVW5pcXVlSXRlbShhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5pbmRleE9mKGl0ZW0pID09PSAtMSlcbiAgICBhcnIucHVzaChpdGVtKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0oYXJyLCBpdGVtKSB7XG4gIGNvbnN0IGluZGV4MiA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaW5kZXgyID4gLTEpXG4gICAgYXJyLnNwbGljZShpbmRleDIsIDEpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3N1YnNjcmlwdGlvbi1tYW5hZ2VyLm1qc1xudmFyIFN1YnNjcmlwdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICB9XG4gIGFkZChoYW5kbGVyKSB7XG4gICAgYWRkVW5pcXVlSXRlbSh0aGlzLnN1YnNjcmlwdGlvbnMsIGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiByZW1vdmVJdGVtKHRoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7XG4gIH1cbiAgbm90aWZ5KGEyLCBiMiwgYzMpIHtcbiAgICBjb25zdCBudW1TdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICBpZiAoIW51bVN1YnNjcmlwdGlvbnMpXG4gICAgICByZXR1cm47XG4gICAgaWYgKG51bVN1YnNjcmlwdGlvbnMgPT09IDEpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1swXShhMiwgYjIsIGMzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bVN1YnNjcmlwdGlvbnM7IGkyKyspIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuc3Vic2NyaXB0aW9uc1tpMl07XG4gICAgICAgIGhhbmRsZXIgJiYgaGFuZGxlcihhMiwgYjIsIGMzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoID0gMDtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS9pbmRleC5tanNcbnZhciBpc0Zsb2F0ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufTtcbnZhciBNb3Rpb25WYWx1ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdCkge1xuICAgIHRoaXMudmVyc2lvbiA9IFwiNy42LjdcIjtcbiAgICB0aGlzLnRpbWVEZWx0YSA9IDA7XG4gICAgdGhpcy5sYXN0VXBkYXRlZCA9IDA7XG4gICAgdGhpcy51cGRhdGVTdWJzY3JpYmVycyA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgdGhpcy52ZWxvY2l0eVVwZGF0ZVN1YnNjcmliZXJzID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLnJlbmRlclN1YnNjcmliZXJzID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSA9ICh2LCByZW5kZXIgPSB0cnVlKSA9PiB7XG4gICAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB2O1xuICAgICAgY29uc3QgeyBkZWx0YSwgdGltZXN0YW1wIH0gPSBnZXRGcmFtZURhdGEoKTtcbiAgICAgIGlmICh0aGlzLmxhc3RVcGRhdGVkICE9PSB0aW1lc3RhbXApIHtcbiAgICAgICAgdGhpcy50aW1lRGVsdGEgPSBkZWx0YTtcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgZXNfZGVmYXVsdC5wb3N0UmVuZGVyKHRoaXMuc2NoZWR1bGVWZWxvY2l0eUNoZWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByZXYgIT09IHRoaXMuY3VycmVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzLm5vdGlmeSh0aGlzLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5nZXRTaXplKCkpIHtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVVwZGF0ZVN1YnNjcmliZXJzLm5vdGlmeSh0aGlzLmdldFZlbG9jaXR5KCkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICB0aGlzLnJlbmRlclN1YnNjcmliZXJzLm5vdGlmeSh0aGlzLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zY2hlZHVsZVZlbG9jaXR5Q2hlY2sgPSAoKSA9PiBlc19kZWZhdWx0LnBvc3RSZW5kZXIodGhpcy52ZWxvY2l0eUNoZWNrKTtcbiAgICB0aGlzLnZlbG9jaXR5Q2hlY2sgPSAoeyB0aW1lc3RhbXAgfSkgPT4ge1xuICAgICAgaWYgKHRpbWVzdGFtcCAhPT0gdGhpcy5sYXN0VXBkYXRlZCkge1xuICAgICAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIHRoaXMudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5ub3RpZnkodGhpcy5nZXRWZWxvY2l0eSgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnQgPSBpbml0O1xuICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IGlzRmxvYXQodGhpcy5jdXJyZW50KTtcbiAgfVxuICBvbkNoYW5nZShzdWJzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVTdWJzY3JpYmVycy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgfVxuICBjbGVhckxpc3RlbmVycygpIHtcbiAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzLmNsZWFyKCk7XG4gIH1cbiAgb25SZW5kZXJSZXF1ZXN0KHN1YnNjcmlwdGlvbikge1xuICAgIHN1YnNjcmlwdGlvbih0aGlzLmdldCgpKTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgfVxuICBhdHRhY2gocGFzc2l2ZUVmZmVjdCkge1xuICAgIHRoaXMucGFzc2l2ZUVmZmVjdCA9IHBhc3NpdmVFZmZlY3Q7XG4gIH1cbiAgc2V0KHYsIHJlbmRlciA9IHRydWUpIHtcbiAgICBpZiAoIXJlbmRlciB8fCAhdGhpcy5wYXNzaXZlRWZmZWN0KSB7XG4gICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSh2LCByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhc3NpdmVFZmZlY3QodiwgdGhpcy51cGRhdGVBbmROb3RpZnkpO1xuICAgIH1cbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgfVxuICBnZXRQcmV2aW91cygpIHtcbiAgICByZXR1cm4gdGhpcy5wcmV2O1xuICB9XG4gIGdldFZlbG9jaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPyB2ZWxvY2l0eVBlclNlY29uZChwYXJzZUZsb2F0KHRoaXMuY3VycmVudCkgLSBwYXJzZUZsb2F0KHRoaXMucHJldiksIHRoaXMudGltZURlbHRhKSA6IDA7XG4gIH1cbiAgc3RhcnQoYW5pbWF0aW9uKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmhhc0FuaW1hdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbiA9IGFuaW1hdGlvbihyZXNvbHZlKTtcbiAgICB9KS50aGVuKCgpID0+IHRoaXMuY2xlYXJBbmltYXRpb24oKSk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5zdG9wQW5pbWF0aW9uKVxuICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5jbGVhckFuaW1hdGlvbigpO1xuICB9XG4gIGlzQW5pbWF0aW5nKCkge1xuICAgIHJldHVybiAhIXRoaXMuc3RvcEFuaW1hdGlvbjtcbiAgfVxuICBjbGVhckFuaW1hdGlvbigpIHtcbiAgICB0aGlzLnN0b3BBbmltYXRpb24gPSBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51cGRhdGVTdWJzY3JpYmVycy5jbGVhcigpO1xuICAgIHRoaXMucmVuZGVyU3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICB0aGlzLnN0b3AoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1vdGlvblZhbHVlKGluaXQpIHtcbiAgcmV0dXJuIG5ldyBNb3Rpb25WYWx1ZShpbml0KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3Rlc3QubWpzXG52YXIgdGVzdFZhbHVlVHlwZSA9ICh2KSA9PiAodHlwZSkgPT4gdHlwZS50ZXN0KHYpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvdHlwZS1hdXRvLm1qc1xudmFyIGF1dG8gPSB7XG4gIHRlc3Q6ICh2KSA9PiB2ID09PSBcImF1dG9cIixcbiAgcGFyc2U6ICh2KSA9PiB2XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZGltZW5zaW9ucy5tanNcbnZhciBkaW1lbnNpb25WYWx1ZVR5cGVzID0gW251bWJlciwgcHgsIHBlcmNlbnQsIGRlZ3JlZXMsIHZ3LCB2aCwgYXV0b107XG52YXIgZmluZERpbWVuc2lvblZhbHVlVHlwZSA9ICh2KSA9PiBkaW1lbnNpb25WYWx1ZVR5cGVzLmZpbmQodGVzdFZhbHVlVHlwZSh2KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9maW5kLm1qc1xudmFyIHZhbHVlVHlwZXMgPSBbLi4uZGltZW5zaW9uVmFsdWVUeXBlcywgY29sb3IsIGNvbXBsZXhdO1xudmFyIGZpbmRWYWx1ZVR5cGUgPSAodikgPT4gdmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9yZXNvbHZlLWR5bmFtaWMtdmFyaWFudHMubWpzXG5mdW5jdGlvbiBnZXRDdXJyZW50KHZpc3VhbEVsZW1lbnQpIHtcbiAgY29uc3QgY3VycmVudCA9IHt9O1xuICB2aXN1YWxFbGVtZW50LnZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBjdXJyZW50W2tleV0gPSB2YWx1ZS5nZXQoKSk7XG4gIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gZ2V0VmVsb2NpdHkodmlzdWFsRWxlbWVudCkge1xuICBjb25zdCB2ZWxvY2l0eSA9IHt9O1xuICB2aXN1YWxFbGVtZW50LnZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB2ZWxvY2l0eVtrZXldID0gdmFsdWUuZ2V0VmVsb2NpdHkoKSk7XG4gIHJldHVybiB2ZWxvY2l0eTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIGN1c3RvbSkge1xuICBjb25zdCBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgcmV0dXJuIHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uLCBjdXN0b20gIT09IHZvaWQgMCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgZ2V0Q3VycmVudCh2aXN1YWxFbGVtZW50KSwgZ2V0VmVsb2NpdHkodmlzdWFsRWxlbWVudCkpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9zZXR0ZXJzLm1qc1xuZnVuY3Rpb24gc2V0TW90aW9uVmFsdWUodmlzdWFsRWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICBpZiAodmlzdWFsRWxlbWVudC5oYXNWYWx1ZShrZXkpKSB7XG4gICAgdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpLnNldCh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmlzdWFsRWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKHZhbHVlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRhcmdldCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKSB7XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gIGxldCBfYSA9IHJlc29sdmVkID8gdmlzdWFsRWxlbWVudC5tYWtlVGFyZ2V0QW5pbWF0YWJsZShyZXNvbHZlZCwgZmFsc2UpIDoge30sIHsgdHJhbnNpdGlvbkVuZCA9IHt9LCB0cmFuc2l0aW9uID0ge30gfSA9IF9hLCB0YXJnZXQgPSBfX29ialJlc3QoX2EsIFtcInRyYW5zaXRpb25FbmRcIiwgXCJ0cmFuc2l0aW9uXCJdKTtcbiAgdGFyZ2V0ID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRhcmdldCksIHRyYW5zaXRpb25FbmQpO1xuICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXModGFyZ2V0W2tleV0pO1xuICAgIHNldE1vdGlvblZhbHVlKHZpc3VhbEVsZW1lbnQsIGtleSwgdmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1RhcmdldEZvck5ld1ZhbHVlcyh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbikge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBuZXdWYWx1ZUtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpLmZpbHRlcigoa2V5KSA9PiAhdmlzdWFsRWxlbWVudC5oYXNWYWx1ZShrZXkpKTtcbiAgY29uc3QgbnVtTmV3VmFsdWVzID0gbmV3VmFsdWVLZXlzLmxlbmd0aDtcbiAgaWYgKCFudW1OZXdWYWx1ZXMpXG4gICAgcmV0dXJuO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtTmV3VmFsdWVzOyBpMisrKSB7XG4gICAgY29uc3Qga2V5ID0gbmV3VmFsdWVLZXlzW2kyXTtcbiAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0VmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHRhcmdldFZhbHVlWzBdO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gKF9iID0gKF9hID0gb3JpZ2luW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZpc3VhbEVsZW1lbnQucmVhZFZhbHVlKGtleSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRhcmdldFtrZXldO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgKGlzTnVtZXJpY2FsU3RyaW5nKHZhbHVlKSB8fCBpc1plcm9WYWx1ZVN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoIWZpbmRWYWx1ZVR5cGUodmFsdWUpICYmIGNvbXBsZXgudGVzdCh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gZ2V0QW5pbWF0YWJsZU5vbmUyKGtleSwgdGFyZ2V0VmFsdWUpO1xuICAgIH1cbiAgICB2aXN1YWxFbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUodmFsdWUpKTtcbiAgICBpZiAob3JpZ2luW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgb3JpZ2luW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKVxuICAgICAgdmlzdWFsRWxlbWVudC5zZXRCYXNlVGFyZ2V0KGtleSwgdmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcmlnaW5Gcm9tVHJhbnNpdGlvbihrZXksIHRyYW5zaXRpb24pIHtcbiAgaWYgKCF0cmFuc2l0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgdmFsdWVUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldIHx8IHRyYW5zaXRpb25bXCJkZWZhdWx0XCJdIHx8IHRyYW5zaXRpb247XG4gIHJldHVybiB2YWx1ZVRyYW5zaXRpb24uZnJvbTtcbn1cbmZ1bmN0aW9uIGdldE9yaWdpbih0YXJnZXQsIHRyYW5zaXRpb24sIHZpc3VhbEVsZW1lbnQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBvcmlnaW4gPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgY29uc3QgdHJhbnNpdGlvbk9yaWdpbiA9IGdldE9yaWdpbkZyb21UcmFuc2l0aW9uKGtleSwgdHJhbnNpdGlvbik7XG4gICAgb3JpZ2luW2tleV0gPSB0cmFuc2l0aW9uT3JpZ2luICE9PSB2b2lkIDAgPyB0cmFuc2l0aW9uT3JpZ2luIDogKF9hID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91c2Utd2lsbC1jaGFuZ2UvaXMubWpzXG5mdW5jdGlvbiBpc1dpbGxDaGFuZ2VNb3Rpb25WYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbihpc01vdGlvblZhbHVlKHZhbHVlKSAmJiB2YWx1ZS5hZGQpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9hbmltYXRpb24ubWpzXG5mdW5jdGlvbiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJBbmltYXRpb25TdGFydFwiLCBkZWZpbml0aW9uKTtcbiAgbGV0IGFuaW1hdGlvbjtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICBjb25zdCBhbmltYXRpb25zMiA9IGRlZmluaXRpb24ubWFwKCh2YXJpYW50KSA9PiBhbmltYXRlVmFyaWFudCh2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBvcHRpb25zKSk7XG4gICAgYW5pbWF0aW9uID0gUHJvbWlzZS5hbGwoYW5pbWF0aW9uczIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgYW5pbWF0aW9uID0gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVzb2x2ZWREZWZpbml0aW9uID0gdHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMuY3VzdG9tKSA6IGRlZmluaXRpb247XG4gICAgYW5pbWF0aW9uID0gYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCByZXNvbHZlZERlZmluaXRpb24sIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBhbmltYXRpb24udGhlbigoKSA9PiB2aXN1YWxFbGVtZW50Lm5vdGlmeShcIkFuaW1hdGlvbkNvbXBsZXRlXCIsIGRlZmluaXRpb24pKTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucy5jdXN0b20pO1xuICBsZXQgeyB0cmFuc2l0aW9uID0gdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpIHx8IHt9IH0gPSByZXNvbHZlZCB8fCB7fTtcbiAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbk92ZXJyaWRlKSB7XG4gICAgdHJhbnNpdGlvbiA9IG9wdGlvbnMudHJhbnNpdGlvbk92ZXJyaWRlO1xuICB9XG4gIGNvbnN0IGdldEFuaW1hdGlvbjIgPSByZXNvbHZlZCA/ICgpID0+IGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudCwgcmVzb2x2ZWQsIG9wdGlvbnMpIDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIGNvbnN0IGdldENoaWxkQW5pbWF0aW9ucyA9ICgoX2EgPSB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpemUpID8gKGZvcndhcmREZWxheSA9IDApID0+IHtcbiAgICBjb25zdCB7IGRlbGF5Q2hpbGRyZW4gPSAwLCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24gfSA9IHRyYW5zaXRpb247XG4gICAgcmV0dXJuIGFuaW1hdGVDaGlsZHJlbih2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBkZWxheUNoaWxkcmVuICsgZm9yd2FyZERlbGF5LCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24sIG9wdGlvbnMpO1xuICB9IDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIGNvbnN0IHsgd2hlbiB9ID0gdHJhbnNpdGlvbjtcbiAgaWYgKHdoZW4pIHtcbiAgICBjb25zdCBbZmlyc3QsIGxhc3RdID0gd2hlbiA9PT0gXCJiZWZvcmVDaGlsZHJlblwiID8gW2dldEFuaW1hdGlvbjIsIGdldENoaWxkQW5pbWF0aW9uc10gOiBbZ2V0Q2hpbGRBbmltYXRpb25zLCBnZXRBbmltYXRpb24yXTtcbiAgICByZXR1cm4gZmlyc3QoKS50aGVuKGxhc3QpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbZ2V0QW5pbWF0aW9uMigpLCBnZXRDaGlsZEFuaW1hdGlvbnMob3B0aW9ucy5kZWxheSldKTtcbiAgfVxufVxuZnVuY3Rpb24gYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCB7IGRlbGF5OiBkZWxheTIgPSAwLCB0cmFuc2l0aW9uT3ZlcnJpZGUsIHR5cGUgfSA9IHt9KSB7XG4gIHZhciBfYTtcbiAgbGV0IF9hMiA9IHZpc3VhbEVsZW1lbnQubWFrZVRhcmdldEFuaW1hdGFibGUoZGVmaW5pdGlvbiksIHsgdHJhbnNpdGlvbiA9IHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSwgdHJhbnNpdGlvbkVuZCB9ID0gX2EyLCB0YXJnZXQgPSBfX29ialJlc3QoX2EyLCBbXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbkVuZFwiXSk7XG4gIGNvbnN0IHdpbGxDaGFuZ2UgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKFwid2lsbENoYW5nZVwiKTtcbiAgaWYgKHRyYW5zaXRpb25PdmVycmlkZSlcbiAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbk92ZXJyaWRlO1xuICBjb25zdCBhbmltYXRpb25zMiA9IFtdO1xuICBjb25zdCBhbmltYXRpb25UeXBlU3RhdGUgPSB0eXBlICYmICgoX2EgPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdGUoKVt0eXBlXSk7XG4gIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgIGNvbnN0IHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgIGNvbnN0IHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZVRhcmdldCA9PT0gdm9pZCAwIHx8IGFuaW1hdGlvblR5cGVTdGF0ZSAmJiBzaG91bGRCbG9ja0FuaW1hdGlvbihhbmltYXRpb25UeXBlU3RhdGUsIGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgdmFsdWVUcmFuc2l0aW9uID0gX19zcHJlYWRWYWx1ZXMoeyBkZWxheTogZGVsYXkyIH0sIHRyYW5zaXRpb24pO1xuICAgIGlmICh2aXN1YWxFbGVtZW50LnNob3VsZFJlZHVjZU1vdGlvbiAmJiB0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSkge1xuICAgICAgdmFsdWVUcmFuc2l0aW9uID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgdmFsdWVUcmFuc2l0aW9uKSwge1xuICAgICAgICB0eXBlOiBmYWxzZSxcbiAgICAgICAgZGVsYXk6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgYW5pbWF0aW9uID0gc3RhcnRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdmFsdWVUYXJnZXQsIHZhbHVlVHJhbnNpdGlvbik7XG4gICAgaWYgKGlzV2lsbENoYW5nZU1vdGlvblZhbHVlKHdpbGxDaGFuZ2UpKSB7XG4gICAgICB3aWxsQ2hhbmdlLmFkZChrZXkpO1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnRoZW4oKCkgPT4gd2lsbENoYW5nZS5yZW1vdmUoa2V5KSk7XG4gICAgfVxuICAgIGFuaW1hdGlvbnMyLnB1c2goYW5pbWF0aW9uKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9uczIpLnRoZW4oKCkgPT4ge1xuICAgIHRyYW5zaXRpb25FbmQgJiYgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHRyYW5zaXRpb25FbmQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGVDaGlsZHJlbih2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBkZWxheUNoaWxkcmVuID0gMCwgc3RhZ2dlckNoaWxkcmVuID0gMCwgc3RhZ2dlckRpcmVjdGlvbiA9IDEsIG9wdGlvbnMpIHtcbiAgY29uc3QgYW5pbWF0aW9uczIgPSBbXTtcbiAgY29uc3QgbWF4U3RhZ2dlckR1cmF0aW9uID0gKHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuLnNpemUgLSAxKSAqIHN0YWdnZXJDaGlsZHJlbjtcbiAgY29uc3QgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24gPSBzdGFnZ2VyRGlyZWN0aW9uID09PSAxID8gKGkyID0gMCkgPT4gaTIgKiBzdGFnZ2VyQ2hpbGRyZW4gOiAoaTIgPSAwKSA9PiBtYXhTdGFnZ2VyRHVyYXRpb24gLSBpMiAqIHN0YWdnZXJDaGlsZHJlbjtcbiAgQXJyYXkuZnJvbSh2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikuc29ydChzb3J0QnlUcmVlT3JkZXIpLmZvckVhY2goKGNoaWxkLCBpMikgPT4ge1xuICAgIGFuaW1hdGlvbnMyLnB1c2goYW5pbWF0ZVZhcmlhbnQoY2hpbGQsIHZhcmlhbnQsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICBkZWxheTogZGVsYXlDaGlsZHJlbiArIGdlbmVyYXRlU3RhZ2dlckR1cmF0aW9uKGkyKVxuICAgIH0pKS50aGVuKCgpID0+IGNoaWxkLm5vdGlmeShcIkFuaW1hdGlvbkNvbXBsZXRlXCIsIHZhcmlhbnQpKSk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9uczIpO1xufVxuZnVuY3Rpb24gc29ydEJ5VHJlZU9yZGVyKGEyLCBiMikge1xuICByZXR1cm4gYTIuc29ydE5vZGVQb3NpdGlvbihiMik7XG59XG5mdW5jdGlvbiBzaG91bGRCbG9ja0FuaW1hdGlvbih7IHByb3RlY3RlZEtleXMsIG5lZWRzQW5pbWF0aW5nIH0sIGtleSkge1xuICBjb25zdCBzaG91bGRCbG9jayA9IHByb3RlY3RlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBuZWVkc0FuaW1hdGluZ1trZXldICE9PSB0cnVlO1xuICBuZWVkc0FuaW1hdGluZ1trZXldID0gZmFsc2U7XG4gIHJldHVybiBzaG91bGRCbG9jaztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvYW5pbWF0aW9uLXN0YXRlLm1qc1xudmFyIHZhcmlhbnRQcmlvcml0eU9yZGVyID0gW1xuICBBbmltYXRpb25UeXBlLkFuaW1hdGUsXG4gIEFuaW1hdGlvblR5cGUuSW5WaWV3LFxuICBBbmltYXRpb25UeXBlLkZvY3VzLFxuICBBbmltYXRpb25UeXBlLkhvdmVyLFxuICBBbmltYXRpb25UeXBlLlRhcCxcbiAgQW5pbWF0aW9uVHlwZS5EcmFnLFxuICBBbmltYXRpb25UeXBlLkV4aXRcbl07XG52YXIgcmV2ZXJzZVByaW9yaXR5T3JkZXIgPSBbLi4udmFyaWFudFByaW9yaXR5T3JkZXJdLnJldmVyc2UoKTtcbnZhciBudW1BbmltYXRpb25UeXBlcyA9IHZhcmlhbnRQcmlvcml0eU9yZGVyLmxlbmd0aDtcbmZ1bmN0aW9uIGFuaW1hdGVMaXN0KHZpc3VhbEVsZW1lbnQpIHtcbiAgcmV0dXJuIChhbmltYXRpb25zMikgPT4gUHJvbWlzZS5hbGwoYW5pbWF0aW9uczIubWFwKCh7IGFuaW1hdGlvbiwgb3B0aW9ucyB9KSA9PiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBhbmltYXRpb24sIG9wdGlvbnMpKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBbmltYXRpb25TdGF0ZSh2aXN1YWxFbGVtZW50KSB7XG4gIGxldCBhbmltYXRlMyA9IGFuaW1hdGVMaXN0KHZpc3VhbEVsZW1lbnQpO1xuICBjb25zdCBzdGF0ZSA9IGNyZWF0ZVN0YXRlKCk7XG4gIGxldCBpc0luaXRpYWxSZW5kZXIgPSB0cnVlO1xuICBjb25zdCBidWlsZFJlc29sdmVkVHlwZVZhbHVlcyA9IChhY2MsIGRlZmluaXRpb24pID0+IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgY29uc3QgX2EgPSByZXNvbHZlZCwgeyB0cmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kIH0gPSBfYSwgdGFyZ2V0ID0gX19vYmpSZXN0KF9hLCBbXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbkVuZFwiXSk7XG4gICAgICBhY2MgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgYWNjKSwgdGFyZ2V0KSwgdHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH07XG4gIGZ1bmN0aW9uIHNldEFuaW1hdGVGdW5jdGlvbihtYWtlQW5pbWF0b3IpIHtcbiAgICBhbmltYXRlMyA9IG1ha2VBbmltYXRvcih2aXN1YWxFbGVtZW50KTtcbiAgfVxuICBmdW5jdGlvbiBhbmltYXRlQ2hhbmdlcyhvcHRpb25zLCBjaGFuZ2VkQWN0aXZlVHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdmlzdWFsRWxlbWVudC5nZXRWYXJpYW50Q29udGV4dCh0cnVlKSB8fCB7fTtcbiAgICBjb25zdCBhbmltYXRpb25zMiA9IFtdO1xuICAgIGNvbnN0IHJlbW92ZWRLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgZW5jb3VudGVyZWRLZXlzID0ge307XG4gICAgbGV0IHJlbW92ZWRWYXJpYW50SW5kZXggPSBJbmZpbml0eTtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtQW5pbWF0aW9uVHlwZXM7IGkyKyspIHtcbiAgICAgIGNvbnN0IHR5cGUgPSByZXZlcnNlUHJpb3JpdHlPcmRlcltpMl07XG4gICAgICBjb25zdCB0eXBlU3RhdGUgPSBzdGF0ZVt0eXBlXTtcbiAgICAgIGNvbnN0IHByb3AgPSAoX2EgPSBwcm9wc1t0eXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGV4dFt0eXBlXTtcbiAgICAgIGNvbnN0IHByb3BJc1ZhcmlhbnQgPSBpc1ZhcmlhbnRMYWJlbChwcm9wKTtcbiAgICAgIGNvbnN0IGFjdGl2ZURlbHRhID0gdHlwZSA9PT0gY2hhbmdlZEFjdGl2ZVR5cGUgPyB0eXBlU3RhdGUuaXNBY3RpdmUgOiBudWxsO1xuICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgcmVtb3ZlZFZhcmlhbnRJbmRleCA9IGkyO1xuICAgICAgbGV0IGlzSW5oZXJpdGVkID0gcHJvcCA9PT0gY29udGV4dFt0eXBlXSAmJiBwcm9wICE9PSBwcm9wc1t0eXBlXSAmJiBwcm9wSXNWYXJpYW50O1xuICAgICAgaWYgKGlzSW5oZXJpdGVkICYmIGlzSW5pdGlhbFJlbmRlciAmJiB2aXN1YWxFbGVtZW50Lm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQpIHtcbiAgICAgICAgaXNJbmhlcml0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHR5cGVTdGF0ZS5wcm90ZWN0ZWRLZXlzID0gX19zcHJlYWRWYWx1ZXMoe30sIGVuY291bnRlcmVkS2V5cyk7XG4gICAgICBpZiAoIXR5cGVTdGF0ZS5pc0FjdGl2ZSAmJiBhY3RpdmVEZWx0YSA9PT0gbnVsbCB8fCAhcHJvcCAmJiAhdHlwZVN0YXRlLnByZXZQcm9wIHx8IGlzQW5pbWF0aW9uQ29udHJvbHMocHJvcCkgfHwgdHlwZW9mIHByb3AgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFyaWFudERpZENoYW5nZSA9IGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UodHlwZVN0YXRlLnByZXZQcm9wLCBwcm9wKTtcbiAgICAgIGxldCBzaG91bGRBbmltYXRlVHlwZSA9IHZhcmlhbnREaWRDaGFuZ2UgfHwgdHlwZSA9PT0gY2hhbmdlZEFjdGl2ZVR5cGUgJiYgdHlwZVN0YXRlLmlzQWN0aXZlICYmICFpc0luaGVyaXRlZCAmJiBwcm9wSXNWYXJpYW50IHx8IGkyID4gcmVtb3ZlZFZhcmlhbnRJbmRleCAmJiBwcm9wSXNWYXJpYW50O1xuICAgICAgY29uc3QgZGVmaW5pdGlvbkxpc3QgPSBBcnJheS5pc0FycmF5KHByb3ApID8gcHJvcCA6IFtwcm9wXTtcbiAgICAgIGxldCByZXNvbHZlZFZhbHVlcyA9IGRlZmluaXRpb25MaXN0LnJlZHVjZShidWlsZFJlc29sdmVkVHlwZVZhbHVlcywge30pO1xuICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgcmVzb2x2ZWRWYWx1ZXMgPSB7fTtcbiAgICAgIGNvbnN0IHsgcHJldlJlc29sdmVkVmFsdWVzID0ge30gfSA9IHR5cGVTdGF0ZTtcbiAgICAgIGNvbnN0IGFsbEtleXMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJldlJlc29sdmVkVmFsdWVzKSwgcmVzb2x2ZWRWYWx1ZXMpO1xuICAgICAgY29uc3QgbWFya1RvQW5pbWF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgc2hvdWxkQW5pbWF0ZVR5cGUgPSB0cnVlO1xuICAgICAgICByZW1vdmVkS2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAgdHlwZVN0YXRlLm5lZWRzQW5pbWF0aW5nW2tleV0gPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHJlc29sdmVkVmFsdWVzW2tleV07XG4gICAgICAgIGNvbnN0IHByZXYgPSBwcmV2UmVzb2x2ZWRWYWx1ZXNba2V5XTtcbiAgICAgICAgaWYgKGVuY291bnRlcmVkS2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobmV4dCAhPT0gcHJldikge1xuICAgICAgICAgIGlmIChpc0tleWZyYW1lc1RhcmdldChuZXh0KSAmJiBpc0tleWZyYW1lc1RhcmdldChwcmV2KSkge1xuICAgICAgICAgICAgaWYgKCFzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KSB8fCB2YXJpYW50RGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHR5cGVTdGF0ZS5wcm90ZWN0ZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZWRLZXlzLmFkZChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZXh0ICE9PSB2b2lkIDAgJiYgcmVtb3ZlZEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHR5cGVTdGF0ZS5wcmV2UHJvcCA9IHByb3A7XG4gICAgICB0eXBlU3RhdGUucHJldlJlc29sdmVkVmFsdWVzID0gcmVzb2x2ZWRWYWx1ZXM7XG4gICAgICBpZiAodHlwZVN0YXRlLmlzQWN0aXZlKSB7XG4gICAgICAgIGVuY291bnRlcmVkS2V5cyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBlbmNvdW50ZXJlZEtleXMpLCByZXNvbHZlZFZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNJbml0aWFsUmVuZGVyICYmIHZpc3VhbEVsZW1lbnQuYmxvY2tJbml0aWFsQW5pbWF0aW9uKSB7XG4gICAgICAgIHNob3VsZEFuaW1hdGVUeXBlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkQW5pbWF0ZVR5cGUgJiYgIWlzSW5oZXJpdGVkKSB7XG4gICAgICAgIGFuaW1hdGlvbnMyLnB1c2goLi4uZGVmaW5pdGlvbkxpc3QubWFwKChhbmltYXRpb24pID0+ICh7XG4gICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgIG9wdGlvbnM6IF9fc3ByZWFkVmFsdWVzKHsgdHlwZSB9LCBvcHRpb25zKVxuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVtb3ZlZEtleXMuc2l6ZSkge1xuICAgICAgY29uc3QgZmFsbGJhY2tBbmltYXRpb24gPSB7fTtcbiAgICAgIHJlbW92ZWRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBmYWxsYmFja1RhcmdldCA9IHZpc3VhbEVsZW1lbnQuZ2V0QmFzZVRhcmdldChrZXkpO1xuICAgICAgICBpZiAoZmFsbGJhY2tUYXJnZXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGZhbGxiYWNrQW5pbWF0aW9uW2tleV0gPSBmYWxsYmFja1RhcmdldDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhbmltYXRpb25zMi5wdXNoKHsgYW5pbWF0aW9uOiBmYWxsYmFja0FuaW1hdGlvbiB9KTtcbiAgICB9XG4gICAgbGV0IHNob3VsZEFuaW1hdGUgPSBCb29sZWFuKGFuaW1hdGlvbnMyLmxlbmd0aCk7XG4gICAgaWYgKGlzSW5pdGlhbFJlbmRlciAmJiBwcm9wcy5pbml0aWFsID09PSBmYWxzZSAmJiAhdmlzdWFsRWxlbWVudC5tYW51YWxseUFuaW1hdGVPbk1vdW50KSB7XG4gICAgICBzaG91bGRBbmltYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGlzSW5pdGlhbFJlbmRlciA9IGZhbHNlO1xuICAgIHJldHVybiBzaG91bGRBbmltYXRlID8gYW5pbWF0ZTMoYW5pbWF0aW9uczIpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWN0aXZlKHR5cGUsIGlzQWN0aXZlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChzdGF0ZVt0eXBlXS5pc0FjdGl2ZSA9PT0gaXNBY3RpdmUpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgKF9hID0gdmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiAoX2EyID0gY2hpbGQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLnNldEFjdGl2ZSh0eXBlLCBpc0FjdGl2ZSk7XG4gICAgfSk7XG4gICAgc3RhdGVbdHlwZV0uaXNBY3RpdmUgPSBpc0FjdGl2ZTtcbiAgICBjb25zdCBhbmltYXRpb25zMiA9IGFuaW1hdGVDaGFuZ2VzKG9wdGlvbnMsIHR5cGUpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHN0YXRlKSB7XG4gICAgICBzdGF0ZVtrZXldLnByb3RlY3RlZEtleXMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnMyO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5pbWF0ZUNoYW5nZXMsXG4gICAgc2V0QWN0aXZlLFxuICAgIHNldEFuaW1hdGVGdW5jdGlvbixcbiAgICBnZXRTdGF0ZTogKCkgPT4gc3RhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UocHJldiwgbmV4dCkge1xuICBpZiAodHlwZW9mIG5leHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbmV4dCAhPT0gcHJldjtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgcmV0dXJuICFzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlU3RhdGUoaXNBY3RpdmUgPSBmYWxzZSkge1xuICByZXR1cm4ge1xuICAgIGlzQWN0aXZlLFxuICAgIHByb3RlY3RlZEtleXM6IHt9LFxuICAgIG5lZWRzQW5pbWF0aW5nOiB7fSxcbiAgICBwcmV2UmVzb2x2ZWRWYWx1ZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBbQW5pbWF0aW9uVHlwZS5BbmltYXRlXTogY3JlYXRlVHlwZVN0YXRlKHRydWUpLFxuICAgIFtBbmltYXRpb25UeXBlLkluVmlld106IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgIFtBbmltYXRpb25UeXBlLkhvdmVyXTogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgW0FuaW1hdGlvblR5cGUuVGFwXTogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgW0FuaW1hdGlvblR5cGUuRHJhZ106IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgIFtBbmltYXRpb25UeXBlLkZvY3VzXTogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgW0FuaW1hdGlvblR5cGUuRXhpdF06IGNyZWF0ZVR5cGVTdGF0ZSgpXG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2FuaW1hdGlvbnMubWpzXG52YXIgYW5pbWF0aW9ucyA9IHtcbiAgYW5pbWF0aW9uOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCgoeyB2aXN1YWxFbGVtZW50LCBhbmltYXRlOiBhbmltYXRlMyB9KSA9PiB7XG4gICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSB8fCAodmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSA9IGNyZWF0ZUFuaW1hdGlvblN0YXRlKHZpc3VhbEVsZW1lbnQpKTtcbiAgICBpZiAoaXNBbmltYXRpb25Db250cm9scyhhbmltYXRlMykpIHtcbiAgICAgICgwLCBpbXBvcnRfcmVhY3QyMy51c2VFZmZlY3QpKCgpID0+IGFuaW1hdGUzLnN1YnNjcmliZSh2aXN1YWxFbGVtZW50KSwgW2FuaW1hdGUzXSk7XG4gICAgfVxuICB9KSxcbiAgZXhpdDogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQoKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjdXN0b20sIHZpc3VhbEVsZW1lbnQgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtpc1ByZXNlbnQsIHNhZmVUb1JlbW92ZV0gPSB1c2VQcmVzZW5jZSgpO1xuICAgIGNvbnN0IHByZXNlbmNlQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QyMy51c2VDb250ZXh0KShQcmVzZW5jZUNvbnRleHQpO1xuICAgICgwLCBpbXBvcnRfcmVhY3QyMy51c2VFZmZlY3QpKCgpID0+IHtcbiAgICAgIHZpc3VhbEVsZW1lbnQuaXNQcmVzZW50ID0gaXNQcmVzZW50O1xuICAgICAgY29uc3QgYW5pbWF0aW9uID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSAmJiB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkV4aXQsICFpc1ByZXNlbnQsIHtcbiAgICAgICAgY3VzdG9tOiBwcmVzZW5jZUNvbnRleHQgJiYgcHJlc2VuY2VDb250ZXh0LmN1c3RvbSB8fCBjdXN0b21cbiAgICAgIH0pO1xuICAgICAgaWYgKGFuaW1hdGlvbiAmJiAhaXNQcmVzZW50KSB7XG4gICAgICAgIGFuaW1hdGlvbi50aGVuKHNhZmVUb1JlbW92ZSk7XG4gICAgICB9XG4gICAgfSwgW2lzUHJlc2VudF0pO1xuICB9KVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3VzZS1kcmFnLm1qc1xudmFyIGltcG9ydF9yZWFjdDI0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL1BhblNlc3Npb24ubWpzXG52YXIgUGFuU2Vzc2lvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZXZlbnQsIGhhbmRsZXJzLCB7IHRyYW5zZm9ybVBhZ2VQb2ludCB9ID0ge30pIHtcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xuICAgIHRoaXMubGFzdE1vdmVFdmVudCA9IG51bGw7XG4gICAgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbyA9IG51bGw7XG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMudXBkYXRlUG9pbnQgPSAoKSA9PiB7XG4gICAgICBpZiAoISh0aGlzLmxhc3RNb3ZlRXZlbnQgJiYgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGluZm8yID0gZ2V0UGFuSW5mbyh0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvLCB0aGlzLmhpc3RvcnkpO1xuICAgICAgY29uc3QgaXNQYW5TdGFydGVkID0gdGhpcy5zdGFydEV2ZW50ICE9PSBudWxsO1xuICAgICAgY29uc3QgaXNEaXN0YW5jZVBhc3RUaHJlc2hvbGQgPSBkaXN0YW5jZShpbmZvMi5vZmZzZXQsIHsgeDogMCwgeTogMCB9KSA+PSAzO1xuICAgICAgaWYgKCFpc1BhblN0YXJ0ZWQgJiYgIWlzRGlzdGFuY2VQYXN0VGhyZXNob2xkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IHBvaW50OiBwb2ludDMgfSA9IGluZm8yO1xuICAgICAgY29uc3QgeyB0aW1lc3RhbXA6IHRpbWVzdGFtcDIgfSA9IGdldEZyYW1lRGF0YSgpO1xuICAgICAgdGhpcy5oaXN0b3J5LnB1c2goX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcG9pbnQzKSwgeyB0aW1lc3RhbXA6IHRpbWVzdGFtcDIgfSkpO1xuICAgICAgY29uc3QgeyBvblN0YXJ0LCBvbk1vdmUgfSA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICBpZiAoIWlzUGFuU3RhcnRlZCkge1xuICAgICAgICBvblN0YXJ0ICYmIG9uU3RhcnQodGhpcy5sYXN0TW92ZUV2ZW50LCBpbmZvMik7XG4gICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IHRoaXMubGFzdE1vdmVFdmVudDtcbiAgICAgIH1cbiAgICAgIG9uTW92ZSAmJiBvbk1vdmUodGhpcy5sYXN0TW92ZUV2ZW50LCBpbmZvMik7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlID0gKGV2ZW50MiwgaW5mbzIpID0+IHtcbiAgICAgIHRoaXMubGFzdE1vdmVFdmVudCA9IGV2ZW50MjtcbiAgICAgIHRoaXMubGFzdE1vdmVFdmVudEluZm8gPSB0cmFuc2Zvcm1Qb2ludChpbmZvMiwgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudDIpICYmIGV2ZW50Mi5idXR0b25zID09PSAwKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwKGV2ZW50MiwgaW5mbzIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlc19kZWZhdWx0LnVwZGF0ZSh0aGlzLnVwZGF0ZVBvaW50LCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gKGV2ZW50MiwgaW5mbzIpID0+IHtcbiAgICAgIHRoaXMuZW5kKCk7XG4gICAgICBjb25zdCB7IG9uRW5kLCBvblNlc3Npb25FbmQgfSA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICBjb25zdCBwYW5JbmZvID0gZ2V0UGFuSW5mbyh0cmFuc2Zvcm1Qb2ludChpbmZvMiwgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpLCB0aGlzLmhpc3RvcnkpO1xuICAgICAgaWYgKHRoaXMuc3RhcnRFdmVudCAmJiBvbkVuZCkge1xuICAgICAgICBvbkVuZChldmVudDIsIHBhbkluZm8pO1xuICAgICAgfVxuICAgICAgb25TZXNzaW9uRW5kICYmIG9uU2Vzc2lvbkVuZChldmVudDIsIHBhbkluZm8pO1xuICAgIH07XG4gICAgaWYgKGlzVG91Y2hFdmVudChldmVudCkgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICB0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCA9IHRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgICBjb25zdCBpbmZvID0gZXh0cmFjdEV2ZW50SW5mbyhldmVudCk7XG4gICAgY29uc3QgaW5pdGlhbEluZm8gPSB0cmFuc2Zvcm1Qb2ludChpbmZvLCB0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gICAgY29uc3QgeyBwb2ludDogcG9pbnQyIH0gPSBpbml0aWFsSW5mbztcbiAgICBjb25zdCB7IHRpbWVzdGFtcCB9ID0gZ2V0RnJhbWVEYXRhKCk7XG4gICAgdGhpcy5oaXN0b3J5ID0gW19fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHBvaW50MiksIHsgdGltZXN0YW1wIH0pXTtcbiAgICBjb25zdCB7IG9uU2Vzc2lvblN0YXJ0IH0gPSBoYW5kbGVycztcbiAgICBvblNlc3Npb25TdGFydCAmJiBvblNlc3Npb25TdGFydChldmVudCwgZ2V0UGFuSW5mbyhpbml0aWFsSW5mbywgdGhpcy5oaXN0b3J5KSk7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMgPSBwaXBlKGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcm1vdmVcIiwgdGhpcy5oYW5kbGVQb2ludGVyTW92ZSksIGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcnVwXCIsIHRoaXMuaGFuZGxlUG9pbnRlclVwKSwgYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVyY2FuY2VsXCIsIHRoaXMuaGFuZGxlUG9pbnRlclVwKSk7XG4gIH1cbiAgdXBkYXRlSGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gIH1cbiAgZW5kKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzICYmIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgY2FuY2VsU3luYy51cGRhdGUodGhpcy51cGRhdGVQb2ludCk7XG4gIH1cbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChpbmZvLCB0cmFuc2Zvcm1QYWdlUG9pbnQpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybVBhZ2VQb2ludCA/IHsgcG9pbnQ6IHRyYW5zZm9ybVBhZ2VQb2ludChpbmZvLnBvaW50KSB9IDogaW5mbztcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0UG9pbnQoYTIsIGIyKSB7XG4gIHJldHVybiB7IHg6IGEyLnggLSBiMi54LCB5OiBhMi55IC0gYjIueSB9O1xufVxuZnVuY3Rpb24gZ2V0UGFuSW5mbyh7IHBvaW50OiBwb2ludDIgfSwgaGlzdG9yeSkge1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBwb2ludDIsXG4gICAgZGVsdGE6IHN1YnRyYWN0UG9pbnQocG9pbnQyLCBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSkpLFxuICAgIG9mZnNldDogc3VidHJhY3RQb2ludChwb2ludDIsIHN0YXJ0RGV2aWNlUG9pbnQoaGlzdG9yeSkpLFxuICAgIHZlbG9jaXR5OiBnZXRWZWxvY2l0eTIoaGlzdG9yeSwgMC4xKVxuICB9O1xufVxuZnVuY3Rpb24gc3RhcnREZXZpY2VQb2ludChoaXN0b3J5KSB7XG4gIHJldHVybiBoaXN0b3J5WzBdO1xufVxuZnVuY3Rpb24gbGFzdERldmljZVBvaW50KGhpc3RvcnkpIHtcbiAgcmV0dXJuIGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGdldFZlbG9jaXR5MihoaXN0b3J5LCB0aW1lRGVsdGEpIHtcbiAgaWYgKGhpc3RvcnkubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgfVxuICBsZXQgaTIgPSBoaXN0b3J5Lmxlbmd0aCAtIDE7XG4gIGxldCB0aW1lc3RhbXBlZFBvaW50ID0gbnVsbDtcbiAgY29uc3QgbGFzdFBvaW50ID0gbGFzdERldmljZVBvaW50KGhpc3RvcnkpO1xuICB3aGlsZSAoaTIgPj0gMCkge1xuICAgIHRpbWVzdGFtcGVkUG9pbnQgPSBoaXN0b3J5W2kyXTtcbiAgICBpZiAobGFzdFBvaW50LnRpbWVzdGFtcCAtIHRpbWVzdGFtcGVkUG9pbnQudGltZXN0YW1wID4gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRpbWVEZWx0YSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpMi0tO1xuICB9XG4gIGlmICghdGltZXN0YW1wZWRQb2ludCkge1xuICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgfVxuICBjb25zdCB0aW1lID0gKGxhc3RQb2ludC50aW1lc3RhbXAgLSB0aW1lc3RhbXBlZFBvaW50LnRpbWVzdGFtcCkgLyAxZTM7XG4gIGlmICh0aW1lID09PSAwKSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICB9XG4gIGNvbnN0IGN1cnJlbnRWZWxvY2l0eSA9IHtcbiAgICB4OiAobGFzdFBvaW50LnggLSB0aW1lc3RhbXBlZFBvaW50LngpIC8gdGltZSxcbiAgICB5OiAobGFzdFBvaW50LnkgLSB0aW1lc3RhbXBlZFBvaW50LnkpIC8gdGltZVxuICB9O1xuICBpZiAoY3VycmVudFZlbG9jaXR5LnggPT09IEluZmluaXR5KSB7XG4gICAgY3VycmVudFZlbG9jaXR5LnggPSAwO1xuICB9XG4gIGlmIChjdXJyZW50VmVsb2NpdHkueSA9PT0gSW5maW5pdHkpIHtcbiAgICBjdXJyZW50VmVsb2NpdHkueSA9IDA7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRWZWxvY2l0eTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWNhbGMubWpzXG5mdW5jdGlvbiBjYWxjTGVuZ3RoKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMubWF4IC0gYXhpcy5taW47XG59XG5mdW5jdGlvbiBpc05lYXIodmFsdWUsIHRhcmdldCA9IDAsIG1heERpc3RhbmNlID0gMC4wMSkge1xuICByZXR1cm4gZGlzdGFuY2UodmFsdWUsIHRhcmdldCkgPCBtYXhEaXN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbGNBeGlzRGVsdGEoZGVsdGEsIHNvdXJjZSwgdGFyZ2V0LCBvcmlnaW4gPSAwLjUpIHtcbiAgZGVsdGEub3JpZ2luID0gb3JpZ2luO1xuICBkZWx0YS5vcmlnaW5Qb2ludCA9IG1peChzb3VyY2UubWluLCBzb3VyY2UubWF4LCBkZWx0YS5vcmlnaW4pO1xuICBkZWx0YS5zY2FsZSA9IGNhbGNMZW5ndGgodGFyZ2V0KSAvIGNhbGNMZW5ndGgoc291cmNlKTtcbiAgaWYgKGlzTmVhcihkZWx0YS5zY2FsZSwgMSwgMWUtNCkgfHwgaXNOYU4oZGVsdGEuc2NhbGUpKVxuICAgIGRlbHRhLnNjYWxlID0gMTtcbiAgZGVsdGEudHJhbnNsYXRlID0gbWl4KHRhcmdldC5taW4sIHRhcmdldC5tYXgsIGRlbHRhLm9yaWdpbikgLSBkZWx0YS5vcmlnaW5Qb2ludDtcbiAgaWYgKGlzTmVhcihkZWx0YS50cmFuc2xhdGUpIHx8IGlzTmFOKGRlbHRhLnRyYW5zbGF0ZSkpXG4gICAgZGVsdGEudHJhbnNsYXRlID0gMDtcbn1cbmZ1bmN0aW9uIGNhbGNCb3hEZWx0YShkZWx0YSwgc291cmNlLCB0YXJnZXQsIG9yaWdpbikge1xuICBjYWxjQXhpc0RlbHRhKGRlbHRhLngsIHNvdXJjZS54LCB0YXJnZXQueCwgb3JpZ2luID09PSBudWxsIHx8IG9yaWdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luLm9yaWdpblgpO1xuICBjYWxjQXhpc0RlbHRhKGRlbHRhLnksIHNvdXJjZS55LCB0YXJnZXQueSwgb3JpZ2luID09PSBudWxsIHx8IG9yaWdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luLm9yaWdpblkpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQsIHJlbGF0aXZlLCBwYXJlbnQpIHtcbiAgdGFyZ2V0Lm1pbiA9IHBhcmVudC5taW4gKyByZWxhdGl2ZS5taW47XG4gIHRhcmdldC5tYXggPSB0YXJnZXQubWluICsgY2FsY0xlbmd0aChyZWxhdGl2ZSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVCb3godGFyZ2V0LCByZWxhdGl2ZSwgcGFyZW50KSB7XG4gIGNhbGNSZWxhdGl2ZUF4aXModGFyZ2V0LngsIHJlbGF0aXZlLngsIHBhcmVudC54KTtcbiAgY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQueSwgcmVsYXRpdmUueSwgcGFyZW50LnkpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uKHRhcmdldCwgbGF5b3V0LCBwYXJlbnQpIHtcbiAgdGFyZ2V0Lm1pbiA9IGxheW91dC5taW4gLSBwYXJlbnQubWluO1xuICB0YXJnZXQubWF4ID0gdGFyZ2V0Lm1pbiArIGNhbGNMZW5ndGgobGF5b3V0KTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHRhcmdldCwgbGF5b3V0LCBwYXJlbnQpIHtcbiAgY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uKHRhcmdldC54LCBsYXlvdXQueCwgcGFyZW50LngpO1xuICBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24odGFyZ2V0LnksIGxheW91dC55LCBwYXJlbnQueSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91dGlscy9jb25zdHJhaW50cy5tanNcbmZ1bmN0aW9uIGFwcGx5Q29uc3RyYWludHMocG9pbnQyLCB7IG1pbiwgbWF4IH0sIGVsYXN0aWMpIHtcbiAgaWYgKG1pbiAhPT0gdm9pZCAwICYmIHBvaW50MiA8IG1pbikge1xuICAgIHBvaW50MiA9IGVsYXN0aWMgPyBtaXgobWluLCBwb2ludDIsIGVsYXN0aWMubWluKSA6IE1hdGgubWF4KHBvaW50MiwgbWluKTtcbiAgfSBlbHNlIGlmIChtYXggIT09IHZvaWQgMCAmJiBwb2ludDIgPiBtYXgpIHtcbiAgICBwb2ludDIgPSBlbGFzdGljID8gbWl4KG1heCwgcG9pbnQyLCBlbGFzdGljLm1heCkgOiBNYXRoLm1pbihwb2ludDIsIG1heCk7XG4gIH1cbiAgcmV0dXJuIHBvaW50Mjtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhheGlzLCBtaW4sIG1heCkge1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluICE9PSB2b2lkIDAgPyBheGlzLm1pbiArIG1pbiA6IHZvaWQgMCxcbiAgICBtYXg6IG1heCAhPT0gdm9pZCAwID8gYXhpcy5tYXggKyBtYXggLSAoYXhpcy5tYXggLSBheGlzLm1pbikgOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUNvbnN0cmFpbnRzKGxheW91dEJveCwgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSkge1xuICByZXR1cm4ge1xuICAgIHg6IGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueCwgbGVmdCwgcmlnaHQpLFxuICAgIHk6IGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueSwgdG9wLCBib3R0b20pXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjVmlld3BvcnRBeGlzQ29uc3RyYWludHMobGF5b3V0QXhpcywgY29uc3RyYWludHNBeGlzKSB7XG4gIGxldCBtaW4gPSBjb25zdHJhaW50c0F4aXMubWluIC0gbGF5b3V0QXhpcy5taW47XG4gIGxldCBtYXggPSBjb25zdHJhaW50c0F4aXMubWF4IC0gbGF5b3V0QXhpcy5tYXg7XG4gIGlmIChjb25zdHJhaW50c0F4aXMubWF4IC0gY29uc3RyYWludHNBeGlzLm1pbiA8IGxheW91dEF4aXMubWF4IC0gbGF5b3V0QXhpcy5taW4pIHtcbiAgICBbbWluLCBtYXhdID0gW21heCwgbWluXTtcbiAgfVxuICByZXR1cm4geyBtaW4sIG1heCB9O1xufVxuZnVuY3Rpb24gY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMobGF5b3V0Qm94LCBjb25zdHJhaW50c0JveCkge1xuICByZXR1cm4ge1xuICAgIHg6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueCwgY29uc3RyYWludHNCb3gueCksXG4gICAgeTogY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC55LCBjb25zdHJhaW50c0JveC55KVxuICB9O1xufVxuZnVuY3Rpb24gY2FsY09yaWdpbjIoc291cmNlLCB0YXJnZXQpIHtcbiAgbGV0IG9yaWdpbiA9IDAuNTtcbiAgY29uc3Qgc291cmNlTGVuZ3RoID0gY2FsY0xlbmd0aChzb3VyY2UpO1xuICBjb25zdCB0YXJnZXRMZW5ndGggPSBjYWxjTGVuZ3RoKHRhcmdldCk7XG4gIGlmICh0YXJnZXRMZW5ndGggPiBzb3VyY2VMZW5ndGgpIHtcbiAgICBvcmlnaW4gPSBwcm9ncmVzcyh0YXJnZXQubWluLCB0YXJnZXQubWF4IC0gc291cmNlTGVuZ3RoLCBzb3VyY2UubWluKTtcbiAgfSBlbHNlIGlmIChzb3VyY2VMZW5ndGggPiB0YXJnZXRMZW5ndGgpIHtcbiAgICBvcmlnaW4gPSBwcm9ncmVzcyhzb3VyY2UubWluLCBzb3VyY2UubWF4IC0gdGFyZ2V0TGVuZ3RoLCB0YXJnZXQubWluKTtcbiAgfVxuICByZXR1cm4gY2xhbXAyKDAsIDEsIG9yaWdpbik7XG59XG5mdW5jdGlvbiByZWJhc2VBeGlzQ29uc3RyYWludHMobGF5b3V0LCBjb25zdHJhaW50cykge1xuICBjb25zdCByZWxhdGl2ZUNvbnN0cmFpbnRzID0ge307XG4gIGlmIChjb25zdHJhaW50cy5taW4gIT09IHZvaWQgMCkge1xuICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWluID0gY29uc3RyYWludHMubWluIC0gbGF5b3V0Lm1pbjtcbiAgfVxuICBpZiAoY29uc3RyYWludHMubWF4ICE9PSB2b2lkIDApIHtcbiAgICByZWxhdGl2ZUNvbnN0cmFpbnRzLm1heCA9IGNvbnN0cmFpbnRzLm1heCAtIGxheW91dC5taW47XG4gIH1cbiAgcmV0dXJuIHJlbGF0aXZlQ29uc3RyYWludHM7XG59XG52YXIgZGVmYXVsdEVsYXN0aWMgPSAwLjM1O1xuZnVuY3Rpb24gcmVzb2x2ZURyYWdFbGFzdGljKGRyYWdFbGFzdGljID0gZGVmYXVsdEVsYXN0aWMpIHtcbiAgaWYgKGRyYWdFbGFzdGljID09PSBmYWxzZSkge1xuICAgIGRyYWdFbGFzdGljID0gMDtcbiAgfSBlbHNlIGlmIChkcmFnRWxhc3RpYyA9PT0gdHJ1ZSkge1xuICAgIGRyYWdFbGFzdGljID0gZGVmYXVsdEVsYXN0aWM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiByZXNvbHZlQXhpc0VsYXN0aWMoZHJhZ0VsYXN0aWMsIFwibGVmdFwiLCBcInJpZ2h0XCIpLFxuICAgIHk6IHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgXCJ0b3BcIiwgXCJib3R0b21cIilcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgbWluTGFiZWwsIG1heExhYmVsKSB7XG4gIHJldHVybiB7XG4gICAgbWluOiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBtaW5MYWJlbCksXG4gICAgbWF4OiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBtYXhMYWJlbClcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIGxhYmVsKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIHR5cGVvZiBkcmFnRWxhc3RpYyA9PT0gXCJudW1iZXJcIiA/IGRyYWdFbGFzdGljIDogKF9hID0gZHJhZ0VsYXN0aWNbbGFiZWxdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvbW9kZWxzLm1qc1xudmFyIGNyZWF0ZUF4aXNEZWx0YSA9ICgpID0+ICh7XG4gIHRyYW5zbGF0ZTogMCxcbiAgc2NhbGU6IDEsXG4gIG9yaWdpbjogMCxcbiAgb3JpZ2luUG9pbnQ6IDBcbn0pO1xudmFyIGNyZWF0ZURlbHRhID0gKCkgPT4gKHtcbiAgeDogY3JlYXRlQXhpc0RlbHRhKCksXG4gIHk6IGNyZWF0ZUF4aXNEZWx0YSgpXG59KTtcbnZhciBjcmVhdGVBeGlzID0gKCkgPT4gKHsgbWluOiAwLCBtYXg6IDAgfSk7XG52YXIgY3JlYXRlQm94ID0gKCkgPT4gKHtcbiAgeDogY3JlYXRlQXhpcygpLFxuICB5OiBjcmVhdGVBeGlzKClcbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vdXRpbHMvZWFjaC1heGlzLm1qc1xuZnVuY3Rpb24gZWFjaEF4aXMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIFtjYWxsYmFjayhcInhcIiksIGNhbGxiYWNrKFwieVwiKV07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9jb252ZXJzaW9uLm1qc1xuZnVuY3Rpb24gY29udmVydEJvdW5kaW5nQm94VG9Cb3goeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gfSkge1xuICByZXR1cm4ge1xuICAgIHg6IHsgbWluOiBsZWZ0LCBtYXg6IHJpZ2h0IH0sXG4gICAgeTogeyBtaW46IHRvcCwgbWF4OiBib3R0b20gfVxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydEJveFRvQm91bmRpbmdCb3goeyB4LCB5IH0pIHtcbiAgcmV0dXJuIHsgdG9wOiB5Lm1pbiwgcmlnaHQ6IHgubWF4LCBib3R0b206IHkubWF4LCBsZWZ0OiB4Lm1pbiB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQm94UG9pbnRzKHBvaW50MiwgdHJhbnNmb3JtUG9pbnQyKSB7XG4gIGlmICghdHJhbnNmb3JtUG9pbnQyKVxuICAgIHJldHVybiBwb2ludDI7XG4gIGNvbnN0IHRvcExlZnQgPSB0cmFuc2Zvcm1Qb2ludDIoeyB4OiBwb2ludDIubGVmdCwgeTogcG9pbnQyLnRvcCB9KTtcbiAgY29uc3QgYm90dG9tUmlnaHQgPSB0cmFuc2Zvcm1Qb2ludDIoeyB4OiBwb2ludDIucmlnaHQsIHk6IHBvaW50Mi5ib3R0b20gfSk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3BMZWZ0LnksXG4gICAgbGVmdDogdG9wTGVmdC54LFxuICAgIGJvdHRvbTogYm90dG9tUmlnaHQueSxcbiAgICByaWdodDogYm90dG9tUmlnaHQueFxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vdXRpbHMvaGFzLXRyYW5zZm9ybS5tanNcbmZ1bmN0aW9uIGlzSWRlbnRpdHlTY2FsZShzY2FsZTIpIHtcbiAgcmV0dXJuIHNjYWxlMiA9PT0gdm9pZCAwIHx8IHNjYWxlMiA9PT0gMTtcbn1cbmZ1bmN0aW9uIGhhc1NjYWxlKHsgc2NhbGU6IHNjYWxlMiwgc2NhbGVYLCBzY2FsZVkgfSkge1xuICByZXR1cm4gIWlzSWRlbnRpdHlTY2FsZShzY2FsZTIpIHx8ICFpc0lkZW50aXR5U2NhbGUoc2NhbGVYKSB8fCAhaXNJZGVudGl0eVNjYWxlKHNjYWxlWSk7XG59XG5mdW5jdGlvbiBoYXNUcmFuc2Zvcm0odmFsdWVzKSB7XG4gIHJldHVybiBoYXNTY2FsZSh2YWx1ZXMpIHx8IGhhczJEVHJhbnNsYXRlKHZhbHVlcykgfHwgdmFsdWVzLnogfHwgdmFsdWVzLnJvdGF0ZSB8fCB2YWx1ZXMucm90YXRlWCB8fCB2YWx1ZXMucm90YXRlWTtcbn1cbmZ1bmN0aW9uIGhhczJEVHJhbnNsYXRlKHZhbHVlcykge1xuICByZXR1cm4gaXMyRFRyYW5zbGF0ZSh2YWx1ZXMueCkgfHwgaXMyRFRyYW5zbGF0ZSh2YWx1ZXMueSk7XG59XG5mdW5jdGlvbiBpczJEVHJhbnNsYXRlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZSAhPT0gXCIwJVwiO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvZGVsdGEtYXBwbHkubWpzXG5mdW5jdGlvbiBzY2FsZVBvaW50KHBvaW50Miwgc2NhbGUyLCBvcmlnaW5Qb2ludCkge1xuICBjb25zdCBkaXN0YW5jZUZyb21PcmlnaW4gPSBwb2ludDIgLSBvcmlnaW5Qb2ludDtcbiAgY29uc3Qgc2NhbGVkID0gc2NhbGUyICogZGlzdGFuY2VGcm9tT3JpZ2luO1xuICByZXR1cm4gb3JpZ2luUG9pbnQgKyBzY2FsZWQ7XG59XG5mdW5jdGlvbiBhcHBseVBvaW50RGVsdGEocG9pbnQyLCB0cmFuc2xhdGUsIHNjYWxlMiwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKSB7XG4gIGlmIChib3hTY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgcG9pbnQyID0gc2NhbGVQb2ludChwb2ludDIsIGJveFNjYWxlLCBvcmlnaW5Qb2ludCk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlUG9pbnQocG9pbnQyLCBzY2FsZTIsIG9yaWdpblBvaW50KSArIHRyYW5zbGF0ZTtcbn1cbmZ1bmN0aW9uIGFwcGx5QXhpc0RlbHRhKGF4aXMsIHRyYW5zbGF0ZSA9IDAsIHNjYWxlMiA9IDEsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICBheGlzLm1pbiA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1pbiwgdHJhbnNsYXRlLCBzY2FsZTIsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG4gIGF4aXMubWF4ID0gYXBwbHlQb2ludERlbHRhKGF4aXMubWF4LCB0cmFuc2xhdGUsIHNjYWxlMiwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbmZ1bmN0aW9uIGFwcGx5Qm94RGVsdGEoYm94LCB7IHgsIHkgfSkge1xuICBhcHBseUF4aXNEZWx0YShib3gueCwgeC50cmFuc2xhdGUsIHguc2NhbGUsIHgub3JpZ2luUG9pbnQpO1xuICBhcHBseUF4aXNEZWx0YShib3gueSwgeS50cmFuc2xhdGUsIHkuc2NhbGUsIHkub3JpZ2luUG9pbnQpO1xufVxuZnVuY3Rpb24gYXBwbHlUcmVlRGVsdGFzKGJveCwgdHJlZVNjYWxlLCB0cmVlUGF0aCwgaXNTaGFyZWRUcmFuc2l0aW9uID0gZmFsc2UpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdHJlZUxlbmd0aCA9IHRyZWVQYXRoLmxlbmd0aDtcbiAgaWYgKCF0cmVlTGVuZ3RoKVxuICAgIHJldHVybjtcbiAgdHJlZVNjYWxlLnggPSB0cmVlU2NhbGUueSA9IDE7XG4gIGxldCBub2RlO1xuICBsZXQgZGVsdGE7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCB0cmVlTGVuZ3RoOyBpMisrKSB7XG4gICAgbm9kZSA9IHRyZWVQYXRoW2kyXTtcbiAgICBkZWx0YSA9IG5vZGUucHJvamVjdGlvbkRlbHRhO1xuICAgIGlmICgoKF9iID0gKF9hID0gbm9kZS5pbnN0YW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0eWxlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzcGxheSkgPT09IFwiY29udGVudHNcIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChpc1NoYXJlZFRyYW5zaXRpb24gJiYgbm9kZS5vcHRpb25zLmxheW91dFNjcm9sbCAmJiBub2RlLnNjcm9sbCAmJiBub2RlICE9PSBub2RlLnJvb3QpIHtcbiAgICAgIHRyYW5zZm9ybUJveChib3gsIHsgeDogLW5vZGUuc2Nyb2xsLngsIHk6IC1ub2RlLnNjcm9sbC55IH0pO1xuICAgIH1cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIHRyZWVTY2FsZS54ICo9IGRlbHRhLnguc2NhbGU7XG4gICAgICB0cmVlU2NhbGUueSAqPSBkZWx0YS55LnNjYWxlO1xuICAgICAgYXBwbHlCb3hEZWx0YShib3gsIGRlbHRhKTtcbiAgICB9XG4gICAgaWYgKGlzU2hhcmVkVHJhbnNpdGlvbiAmJiBoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICB0cmFuc2Zvcm1Cb3goYm94LCBub2RlLmxhdGVzdFZhbHVlcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVBeGlzKGF4aXMsIGRpc3RhbmNlMikge1xuICBheGlzLm1pbiA9IGF4aXMubWluICsgZGlzdGFuY2UyO1xuICBheGlzLm1heCA9IGF4aXMubWF4ICsgZGlzdGFuY2UyO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQXhpcyhheGlzLCB0cmFuc2Zvcm1zLCBba2V5LCBzY2FsZUtleSwgb3JpZ2luS2V5XSkge1xuICBjb25zdCBheGlzT3JpZ2luID0gdHJhbnNmb3Jtc1tvcmlnaW5LZXldICE9PSB2b2lkIDAgPyB0cmFuc2Zvcm1zW29yaWdpbktleV0gOiAwLjU7XG4gIGNvbnN0IG9yaWdpblBvaW50ID0gbWl4KGF4aXMubWluLCBheGlzLm1heCwgYXhpc09yaWdpbik7XG4gIGFwcGx5QXhpc0RlbHRhKGF4aXMsIHRyYW5zZm9ybXNba2V5XSwgdHJhbnNmb3Jtc1tzY2FsZUtleV0sIG9yaWdpblBvaW50LCB0cmFuc2Zvcm1zLnNjYWxlKTtcbn1cbnZhciB4S2V5cyA9IFtcInhcIiwgXCJzY2FsZVhcIiwgXCJvcmlnaW5YXCJdO1xudmFyIHlLZXlzID0gW1wieVwiLCBcInNjYWxlWVwiLCBcIm9yaWdpbllcIl07XG5mdW5jdGlvbiB0cmFuc2Zvcm1Cb3goYm94LCB0cmFuc2Zvcm0pIHtcbiAgdHJhbnNmb3JtQXhpcyhib3gueCwgdHJhbnNmb3JtLCB4S2V5cyk7XG4gIHRyYW5zZm9ybUF4aXMoYm94LnksIHRyYW5zZm9ybSwgeUtleXMpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vdXRpbHMvbWVhc3VyZS5tanNcbmZ1bmN0aW9uIG1lYXN1cmVWaWV3cG9ydEJveChpbnN0YW5jZSwgdHJhbnNmb3JtUG9pbnQyKSB7XG4gIHJldHVybiBjb252ZXJ0Qm91bmRpbmdCb3hUb0JveCh0cmFuc2Zvcm1Cb3hQb2ludHMoaW5zdGFuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRyYW5zZm9ybVBvaW50MikpO1xufVxuZnVuY3Rpb24gbWVhc3VyZVBhZ2VCb3goZWxlbWVudCwgcm9vdFByb2plY3Rpb25Ob2RlMiwgdHJhbnNmb3JtUGFnZVBvaW50KSB7XG4gIGNvbnN0IHZpZXdwb3J0Qm94ID0gbWVhc3VyZVZpZXdwb3J0Qm94KGVsZW1lbnQsIHRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gIGNvbnN0IHsgc2Nyb2xsOiBzY3JvbGwyIH0gPSByb290UHJvamVjdGlvbk5vZGUyO1xuICBpZiAoc2Nyb2xsMikge1xuICAgIHRyYW5zbGF0ZUF4aXModmlld3BvcnRCb3gueCwgc2Nyb2xsMi54KTtcbiAgICB0cmFuc2xhdGVBeGlzKHZpZXdwb3J0Qm94LnksIHNjcm9sbDIueSk7XG4gIH1cbiAgcmV0dXJuIHZpZXdwb3J0Qm94O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2RyYWcvVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5tanNcbnZhciBlbGVtZW50RHJhZ0NvbnRyb2xzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgVmlzdWFsRWxlbWVudERyYWdDb250cm9scyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmlzdWFsRWxlbWVudCkge1xuICAgIHRoaXMub3Blbkdsb2JhbExvY2sgPSBudWxsO1xuICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudERpcmVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5Qb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBmYWxzZTtcbiAgICB0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cyA9IGZhbHNlO1xuICAgIHRoaXMuZWxhc3RpYyA9IGNyZWF0ZUJveCgpO1xuICAgIHRoaXMudmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnQ7XG4gIH1cbiAgc3RhcnQob3JpZ2luRXZlbnQsIHsgc25hcFRvQ3Vyc29yID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMudmlzdWFsRWxlbWVudC5pc1ByZXNlbnQgPT09IGZhbHNlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9uU2Vzc2lvblN0YXJ0ID0gKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICAgIGlmIChzbmFwVG9DdXJzb3IpIHtcbiAgICAgICAgdGhpcy5zbmFwVG9DdXJzb3IoZXh0cmFjdEV2ZW50SW5mbyhldmVudCwgXCJwYWdlXCIpLnBvaW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uU3RhcnQgPSAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHsgZHJhZzogZHJhZzIsIGRyYWdQcm9wYWdhdGlvbiwgb25EcmFnU3RhcnQgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgIGlmIChkcmFnMiAmJiAhZHJhZ1Byb3BhZ2F0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICAgIHRoaXMub3Blbkdsb2JhbExvY2soKTtcbiAgICAgICAgdGhpcy5vcGVuR2xvYmFsTG9jayA9IGdldEdsb2JhbExvY2soZHJhZzIpO1xuICAgICAgICBpZiAoIXRoaXMub3Blbkdsb2JhbExvY2spXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuY3VycmVudERpcmVjdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygpO1xuICAgICAgaWYgKHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uKSB7XG4gICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLmlzQW5pbWF0aW9uQmxvY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLnRhcmdldCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpLmdldCgpIHx8IDA7XG4gICAgICAgIGlmIChwZXJjZW50LnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlZEF4aXMgPSAoX2IgPSAoX2EyID0gdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24pID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLmxheW91dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxheW91dEJveFtheGlzXTtcbiAgICAgICAgICBpZiAobWVhc3VyZWRBeGlzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjYWxjTGVuZ3RoKG1lYXN1cmVkQXhpcyk7XG4gICAgICAgICAgICBjdXJyZW50ID0gbGVuZ3RoICogKHBhcnNlRmxvYXQoY3VycmVudCkgLyAxMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9yaWdpblBvaW50W2F4aXNdID0gY3VycmVudDtcbiAgICAgIH0pO1xuICAgICAgb25EcmFnU3RhcnQgPT09IG51bGwgfHwgb25EcmFnU3RhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRHJhZ1N0YXJ0KGV2ZW50LCBpbmZvKTtcbiAgICAgIChfYSA9IHRoaXMudmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkRyYWcsIHRydWUpO1xuICAgIH07XG4gICAgY29uc3Qgb25Nb3ZlID0gKGV2ZW50LCBpbmZvKSA9PiB7XG4gICAgICBjb25zdCB7IGRyYWdQcm9wYWdhdGlvbiwgZHJhZ0RpcmVjdGlvbkxvY2ssIG9uRGlyZWN0aW9uTG9jaywgb25EcmFnIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICBpZiAoIWRyYWdQcm9wYWdhdGlvbiAmJiAhdGhpcy5vcGVuR2xvYmFsTG9jaylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgeyBvZmZzZXQgfSA9IGluZm87XG4gICAgICBpZiAoZHJhZ0RpcmVjdGlvbkxvY2sgJiYgdGhpcy5jdXJyZW50RGlyZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERpcmVjdGlvbiA9IGdldEN1cnJlbnREaXJlY3Rpb24ob2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERpcmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIG9uRGlyZWN0aW9uTG9jayA9PT0gbnVsbCB8fCBvbkRpcmVjdGlvbkxvY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRGlyZWN0aW9uTG9jayh0aGlzLmN1cnJlbnREaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlQXhpcyhcInhcIiwgaW5mby5wb2ludCwgb2Zmc2V0KTtcbiAgICAgIHRoaXMudXBkYXRlQXhpcyhcInlcIiwgaW5mby5wb2ludCwgb2Zmc2V0KTtcbiAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIG9uRHJhZyA9PT0gbnVsbCB8fCBvbkRyYWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRHJhZyhldmVudCwgaW5mbyk7XG4gICAgfTtcbiAgICBjb25zdCBvblNlc3Npb25FbmQgPSAoZXZlbnQsIGluZm8pID0+IHRoaXMuc3RvcChldmVudCwgaW5mbyk7XG4gICAgdGhpcy5wYW5TZXNzaW9uID0gbmV3IFBhblNlc3Npb24ob3JpZ2luRXZlbnQsIHtcbiAgICAgIG9uU2Vzc2lvblN0YXJ0LFxuICAgICAgb25TdGFydCxcbiAgICAgIG9uTW92ZSxcbiAgICAgIG9uU2Vzc2lvbkVuZFxuICAgIH0sIHsgdHJhbnNmb3JtUGFnZVBvaW50OiB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCkgfSk7XG4gIH1cbiAgc3RvcChldmVudCwgaW5mbykge1xuICAgIGNvbnN0IGlzRHJhZ2dpbmcgPSB0aGlzLmlzRHJhZ2dpbmc7XG4gICAgdGhpcy5jYW5jZWwoKTtcbiAgICBpZiAoIWlzRHJhZ2dpbmcpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyB2ZWxvY2l0eSB9ID0gaW5mbztcbiAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKHZlbG9jaXR5KTtcbiAgICBjb25zdCB7IG9uRHJhZ0VuZCB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgIG9uRHJhZ0VuZCA9PT0gbnVsbCB8fCBvbkRyYWdFbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRHJhZ0VuZChldmVudCwgaW5mbyk7XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uKSB7XG4gICAgICB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi5pc0FuaW1hdGlvbkJsb2NrZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5wYW5TZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kKCk7XG4gICAgdGhpcy5wYW5TZXNzaW9uID0gdm9pZCAwO1xuICAgIGNvbnN0IHsgZHJhZ1Byb3BhZ2F0aW9uIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgaWYgKCFkcmFnUHJvcGFnYXRpb24gJiYgdGhpcy5vcGVuR2xvYmFsTG9jaykge1xuICAgICAgdGhpcy5vcGVuR2xvYmFsTG9jaygpO1xuICAgICAgdGhpcy5vcGVuR2xvYmFsTG9jayA9IG51bGw7XG4gICAgfVxuICAgIChfYiA9IHRoaXMudmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkRyYWcsIGZhbHNlKTtcbiAgfVxuICB1cGRhdGVBeGlzKGF4aXMsIF9wb2ludCwgb2Zmc2V0KSB7XG4gICAgY29uc3QgeyBkcmFnOiBkcmFnMiB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgIGlmICghb2Zmc2V0IHx8ICFzaG91bGREcmFnKGF4aXMsIGRyYWcyLCB0aGlzLmN1cnJlbnREaXJlY3Rpb24pKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgIGxldCBuZXh0ID0gdGhpcy5vcmlnaW5Qb2ludFtheGlzXSArIG9mZnNldFtheGlzXTtcbiAgICBpZiAodGhpcy5jb25zdHJhaW50cyAmJiB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdKSB7XG4gICAgICBuZXh0ID0gYXBwbHlDb25zdHJhaW50cyhuZXh0LCB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdLCB0aGlzLmVsYXN0aWNbYXhpc10pO1xuICAgIH1cbiAgICBheGlzVmFsdWUuc2V0KG5leHQpO1xuICB9XG4gIHJlc29sdmVDb25zdHJhaW50cygpIHtcbiAgICBjb25zdCB7IGRyYWdDb25zdHJhaW50cywgZHJhZ0VsYXN0aWMgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICBjb25zdCB7IGxheW91dCB9ID0gdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24gfHwge307XG4gICAgY29uc3QgcHJldkNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICBpZiAoZHJhZ0NvbnN0cmFpbnRzICYmIGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykpIHtcbiAgICAgIGlmICghdGhpcy5jb25zdHJhaW50cykge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gdGhpcy5yZXNvbHZlUmVmQ29uc3RyYWludHMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRyYWdDb25zdHJhaW50cyAmJiBsYXlvdXQpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGNhbGNSZWxhdGl2ZUNvbnN0cmFpbnRzKGxheW91dC5sYXlvdXRCb3gsIGRyYWdDb25zdHJhaW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZWxhc3RpYyA9IHJlc29sdmVEcmFnRWxhc3RpYyhkcmFnRWxhc3RpYyk7XG4gICAgaWYgKHByZXZDb25zdHJhaW50cyAhPT0gdGhpcy5jb25zdHJhaW50cyAmJiBsYXlvdXQgJiYgdGhpcy5jb25zdHJhaW50cyAmJiAhdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHMpIHtcbiAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKSkge1xuICAgICAgICAgIHRoaXMuY29uc3RyYWludHNbYXhpc10gPSByZWJhc2VBeGlzQ29uc3RyYWludHMobGF5b3V0LmxheW91dEJveFtheGlzXSwgdGhpcy5jb25zdHJhaW50c1theGlzXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXNvbHZlUmVmQ29uc3RyYWludHMoKSB7XG4gICAgY29uc3QgeyBkcmFnQ29uc3RyYWludHM6IGNvbnN0cmFpbnRzLCBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICBpZiAoIWNvbnN0cmFpbnRzIHx8ICFpc1JlZk9iamVjdChjb25zdHJhaW50cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY29uc3RyYWludHNFbGVtZW50ID0gY29uc3RyYWludHMuY3VycmVudDtcbiAgICBpbnZhcmlhbnQoY29uc3RyYWludHNFbGVtZW50ICE9PSBudWxsLCBcIklmIGBkcmFnQ29uc3RyYWludHNgIGlzIHNldCBhcyBhIFJlYWN0IHJlZiwgdGhhdCByZWYgbXVzdCBiZSBwYXNzZWQgdG8gYW5vdGhlciBjb21wb25lbnQncyBgcmVmYCBwcm9wLlwiKTtcbiAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICBpZiAoIXByb2plY3Rpb24gfHwgIXByb2plY3Rpb24ubGF5b3V0KVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzQm94ID0gbWVhc3VyZVBhZ2VCb3goY29uc3RyYWludHNFbGVtZW50LCBwcm9qZWN0aW9uLnJvb3QsIHRoaXMudmlzdWFsRWxlbWVudC5nZXRUcmFuc2Zvcm1QYWdlUG9pbnQoKSk7XG4gICAgbGV0IG1lYXN1cmVkQ29uc3RyYWludHMgPSBjYWxjVmlld3BvcnRDb25zdHJhaW50cyhwcm9qZWN0aW9uLmxheW91dC5sYXlvdXRCb3gsIGNvbnN0cmFpbnRzQm94KTtcbiAgICBpZiAob25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKSB7XG4gICAgICBjb25zdCB1c2VyQ29uc3RyYWludHMgPSBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMoY29udmVydEJveFRvQm91bmRpbmdCb3gobWVhc3VyZWRDb25zdHJhaW50cykpO1xuICAgICAgdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHMgPSAhIXVzZXJDb25zdHJhaW50cztcbiAgICAgIGlmICh1c2VyQ29uc3RyYWludHMpIHtcbiAgICAgICAgbWVhc3VyZWRDb25zdHJhaW50cyA9IGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHVzZXJDb25zdHJhaW50cyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZWFzdXJlZENvbnN0cmFpbnRzO1xuICB9XG4gIHN0YXJ0QW5pbWF0aW9uKHZlbG9jaXR5KSB7XG4gICAgY29uc3QgeyBkcmFnOiBkcmFnMiwgZHJhZ01vbWVudHVtLCBkcmFnRWxhc3RpYywgZHJhZ1RyYW5zaXRpb24sIGRyYWdTbmFwVG9PcmlnaW4sIG9uRHJhZ1RyYW5zaXRpb25FbmQgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHMgfHwge307XG4gICAgY29uc3QgbW9tZW50dW1BbmltYXRpb25zID0gZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnMiwgdGhpcy5jdXJyZW50RGlyZWN0aW9uKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdHJhbnNpdGlvbiA9IChfYSA9IGNvbnN0cmFpbnRzID09PSBudWxsIHx8IGNvbnN0cmFpbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25zdHJhaW50c1theGlzXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICBpZiAoZHJhZ1NuYXBUb09yaWdpbilcbiAgICAgICAgdHJhbnNpdGlvbiA9IHsgbWluOiAwLCBtYXg6IDAgfTtcbiAgICAgIGNvbnN0IGJvdW5jZVN0aWZmbmVzcyA9IGRyYWdFbGFzdGljID8gMjAwIDogMWU2O1xuICAgICAgY29uc3QgYm91bmNlRGFtcGluZyA9IGRyYWdFbGFzdGljID8gNDAgOiAxZTc7XG4gICAgICBjb25zdCBpbmVydGlhMiA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgdHlwZTogXCJpbmVydGlhXCIsXG4gICAgICAgIHZlbG9jaXR5OiBkcmFnTW9tZW50dW0gPyB2ZWxvY2l0eVtheGlzXSA6IDAsXG4gICAgICAgIGJvdW5jZVN0aWZmbmVzcyxcbiAgICAgICAgYm91bmNlRGFtcGluZyxcbiAgICAgICAgdGltZUNvbnN0YW50OiA3NTAsXG4gICAgICAgIHJlc3REZWx0YTogMSxcbiAgICAgICAgcmVzdFNwZWVkOiAxMFxuICAgICAgfSwgZHJhZ1RyYW5zaXRpb24pLCB0cmFuc2l0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uKGF4aXMsIGluZXJ0aWEyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwobW9tZW50dW1BbmltYXRpb25zKS50aGVuKG9uRHJhZ1RyYW5zaXRpb25FbmQpO1xuICB9XG4gIHN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uKGF4aXMsIHRyYW5zaXRpb24pIHtcbiAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICByZXR1cm4gc3RhcnRBbmltYXRpb24oYXhpcywgYXhpc1ZhbHVlLCAwLCB0cmFuc2l0aW9uKTtcbiAgfVxuICBzdG9wQW5pbWF0aW9uKCkge1xuICAgIGVhY2hBeGlzKChheGlzKSA9PiB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5zdG9wKCkpO1xuICB9XG4gIGdldEF4aXNNb3Rpb25WYWx1ZShheGlzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBkcmFnS2V5ID0gXCJfZHJhZ1wiICsgYXhpcy50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGV4dGVybmFsTW90aW9uVmFsdWUgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKVtkcmFnS2V5XTtcbiAgICByZXR1cm4gZXh0ZXJuYWxNb3Rpb25WYWx1ZSA/IGV4dGVybmFsTW90aW9uVmFsdWUgOiB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoYXhpcywgKF9iID0gKF9hID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCkuaW5pdGlhbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2F4aXNdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgfVxuICBzbmFwVG9DdXJzb3IocG9pbnQyKSB7XG4gICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgIGNvbnN0IHsgZHJhZzogZHJhZzIgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnMiwgdGhpcy5jdXJyZW50RGlyZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgIGlmIChwcm9qZWN0aW9uICYmIHByb2plY3Rpb24ubGF5b3V0KSB7XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHByb2plY3Rpb24ubGF5b3V0LmxheW91dEJveFtheGlzXTtcbiAgICAgICAgYXhpc1ZhbHVlLnNldChwb2ludDJbYXhpc10gLSBtaXgobWluLCBtYXgsIDAuNSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNjYWxlUG9zaXRpb25XaXRoaW5Db25zdHJhaW50cygpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGRyYWc6IGRyYWcyLCBkcmFnQ29uc3RyYWludHMgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICBpZiAoIWlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykgfHwgIXByb2plY3Rpb24gfHwgIXRoaXMuY29uc3RyYWludHMpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgY29uc3QgYm94UHJvZ3Jlc3MgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICBpZiAoYXhpc1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdCA9IGF4aXNWYWx1ZS5nZXQoKTtcbiAgICAgICAgYm94UHJvZ3Jlc3NbYXhpc10gPSBjYWxjT3JpZ2luMih7IG1pbjogbGF0ZXN0LCBtYXg6IGxhdGVzdCB9LCB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB7IHRyYW5zZm9ybVRlbXBsYXRlIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICB0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZSA/IHRyYW5zZm9ybVRlbXBsYXRlKHt9LCBcIlwiKSA6IFwibm9uZVwiO1xuICAgIChfYSA9IHByb2plY3Rpb24ucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZVNjcm9sbCgpO1xuICAgIHByb2plY3Rpb24udXBkYXRlTGF5b3V0KCk7XG4gICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoKTtcbiAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcyLCBudWxsKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdO1xuICAgICAgYXhpc1ZhbHVlLnNldChtaXgobWluLCBtYXgsIGJveFByb2dyZXNzW2F4aXNdKSk7XG4gICAgfSk7XG4gIH1cbiAgYWRkTGlzdGVuZXJzKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGVsZW1lbnREcmFnQ29udHJvbHMuc2V0KHRoaXMudmlzdWFsRWxlbWVudCwgdGhpcyk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50O1xuICAgIGNvbnN0IHN0b3BQb2ludGVyTGlzdGVuZXIgPSBhZGRQb2ludGVyRXZlbnQoZWxlbWVudCwgXCJwb2ludGVyZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgZHJhZzogZHJhZzIsIGRyYWdMaXN0ZW5lciA9IHRydWUgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgIGRyYWcyICYmIGRyYWdMaXN0ZW5lciAmJiB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB9KTtcbiAgICBjb25zdCBtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyBkcmFnQ29uc3RyYWludHMgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgIGlmIChpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpKSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSB0aGlzLnJlc29sdmVSZWZDb25zdHJhaW50cygpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgY29uc3Qgc3RvcE1lYXN1cmVMYXlvdXRMaXN0ZW5lciA9IHByb2plY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcIm1lYXN1cmVcIiwgbWVhc3VyZURyYWdDb25zdHJhaW50cyk7XG4gICAgaWYgKHByb2plY3Rpb24gJiYgIXByb2plY3Rpb24ubGF5b3V0KSB7XG4gICAgICAoX2EgPSBwcm9qZWN0aW9uLnJvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGVTY3JvbGwoKTtcbiAgICAgIHByb2plY3Rpb24udXBkYXRlTGF5b3V0KCk7XG4gICAgfVxuICAgIG1lYXN1cmVEcmFnQ29uc3RyYWludHMoKTtcbiAgICBjb25zdCBzdG9wUmVzaXplTGlzdGVuZXIgPSBhZGREb21FdmVudCh3aW5kb3csIFwicmVzaXplXCIsICgpID0+IHRoaXMuc2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzKCkpO1xuICAgIGNvbnN0IHN0b3BMYXlvdXRVcGRhdGVMaXN0ZW5lciA9IHByb2plY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRpZFVwZGF0ZVwiLCAoeyBkZWx0YSwgaGFzTGF5b3V0Q2hhbmdlZCB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0RyYWdnaW5nICYmIGhhc0xheW91dENoYW5nZWQpIHtcbiAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICBjb25zdCBtb3Rpb25WYWx1ZTIgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgICBpZiAoIW1vdGlvblZhbHVlMilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB0aGlzLm9yaWdpblBvaW50W2F4aXNdICs9IGRlbHRhW2F4aXNdLnRyYW5zbGF0ZTtcbiAgICAgICAgICBtb3Rpb25WYWx1ZTIuc2V0KG1vdGlvblZhbHVlMi5nZXQoKSArIGRlbHRhW2F4aXNdLnRyYW5zbGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN0b3BSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgc3RvcFBvaW50ZXJMaXN0ZW5lcigpO1xuICAgICAgc3RvcE1lYXN1cmVMYXlvdXRMaXN0ZW5lcigpO1xuICAgICAgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyID09PSBudWxsIHx8IHN0b3BMYXlvdXRVcGRhdGVMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuICBnZXRQcm9wcygpIHtcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgIGNvbnN0IHsgZHJhZzogZHJhZzIgPSBmYWxzZSwgZHJhZ0RpcmVjdGlvbkxvY2sgPSBmYWxzZSwgZHJhZ1Byb3BhZ2F0aW9uID0gZmFsc2UsIGRyYWdDb25zdHJhaW50cyA9IGZhbHNlLCBkcmFnRWxhc3RpYyA9IGRlZmF1bHRFbGFzdGljLCBkcmFnTW9tZW50dW0gPSB0cnVlIH0gPSBwcm9wcztcbiAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpLCB7XG4gICAgICBkcmFnOiBkcmFnMixcbiAgICAgIGRyYWdEaXJlY3Rpb25Mb2NrLFxuICAgICAgZHJhZ1Byb3BhZ2F0aW9uLFxuICAgICAgZHJhZ0NvbnN0cmFpbnRzLFxuICAgICAgZHJhZ0VsYXN0aWMsXG4gICAgICBkcmFnTW9tZW50dW1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZERyYWcoZGlyZWN0aW9uLCBkcmFnMiwgY3VycmVudERpcmVjdGlvbikge1xuICByZXR1cm4gKGRyYWcyID09PSB0cnVlIHx8IGRyYWcyID09PSBkaXJlY3Rpb24pICYmIChjdXJyZW50RGlyZWN0aW9uID09PSBudWxsIHx8IGN1cnJlbnREaXJlY3Rpb24gPT09IGRpcmVjdGlvbik7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50RGlyZWN0aW9uKG9mZnNldCwgbG9ja1RocmVzaG9sZCA9IDEwKSB7XG4gIGxldCBkaXJlY3Rpb24gPSBudWxsO1xuICBpZiAoTWF0aC5hYnMob2Zmc2V0LnkpID4gbG9ja1RocmVzaG9sZCkge1xuICAgIGRpcmVjdGlvbiA9IFwieVwiO1xuICB9IGVsc2UgaWYgKE1hdGguYWJzKG9mZnNldC54KSA+IGxvY2tUaHJlc2hvbGQpIHtcbiAgICBkaXJlY3Rpb24gPSBcInhcIjtcbiAgfVxuICByZXR1cm4gZGlyZWN0aW9uO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2RyYWcvdXNlLWRyYWcubWpzXG5mdW5jdGlvbiB1c2VEcmFnKHByb3BzKSB7XG4gIGNvbnN0IHsgZHJhZ0NvbnRyb2xzOiBncm91cERyYWdDb250cm9scywgdmlzdWFsRWxlbWVudCB9ID0gcHJvcHM7XG4gIGNvbnN0IGRyYWdDb250cm9scyA9IHVzZUNvbnN0YW50KCgpID0+IG5ldyBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzKHZpc3VhbEVsZW1lbnQpKTtcbiAgKDAsIGltcG9ydF9yZWFjdDI0LnVzZUVmZmVjdCkoKCkgPT4gZ3JvdXBEcmFnQ29udHJvbHMgJiYgZ3JvdXBEcmFnQ29udHJvbHMuc3Vic2NyaWJlKGRyYWdDb250cm9scyksIFtkcmFnQ29udHJvbHMsIGdyb3VwRHJhZ0NvbnRyb2xzXSk7XG4gICgwLCBpbXBvcnRfcmVhY3QyNC51c2VFZmZlY3QpKCgpID0+IGRyYWdDb250cm9scy5hZGRMaXN0ZW5lcnMoKSwgW2RyYWdDb250cm9sc10pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS1wYW4tZ2VzdHVyZS5tanNcbnZhciBpbXBvcnRfcmVhY3QyNSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIHVzZVBhbkdlc3R1cmUoeyBvblBhbiwgb25QYW5TdGFydCwgb25QYW5FbmQsIG9uUGFuU2Vzc2lvblN0YXJ0LCB2aXN1YWxFbGVtZW50IH0pIHtcbiAgY29uc3QgaGFzUGFuRXZlbnRzID0gb25QYW4gfHwgb25QYW5TdGFydCB8fCBvblBhbkVuZCB8fCBvblBhblNlc3Npb25TdGFydDtcbiAgY29uc3QgcGFuU2Vzc2lvbiA9ICgwLCBpbXBvcnRfcmVhY3QyNS51c2VSZWYpKG51bGwpO1xuICBjb25zdCB7IHRyYW5zZm9ybVBhZ2VQb2ludCB9ID0gKDAsIGltcG9ydF9yZWFjdDI1LnVzZUNvbnRleHQpKE1vdGlvbkNvbmZpZ0NvbnRleHQpO1xuICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICBvblNlc3Npb25TdGFydDogb25QYW5TZXNzaW9uU3RhcnQsXG4gICAgb25TdGFydDogb25QYW5TdGFydCxcbiAgICBvbk1vdmU6IG9uUGFuLFxuICAgIG9uRW5kOiAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgIHBhblNlc3Npb24uY3VycmVudCA9IG51bGw7XG4gICAgICBvblBhbkVuZCAmJiBvblBhbkVuZChldmVudCwgaW5mbyk7XG4gICAgfVxuICB9O1xuICAoMCwgaW1wb3J0X3JlYWN0MjUudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgaWYgKHBhblNlc3Npb24uY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgcGFuU2Vzc2lvbi5jdXJyZW50LnVwZGF0ZUhhbmRsZXJzKGhhbmRsZXJzKTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgcGFuU2Vzc2lvbi5jdXJyZW50ID0gbmV3IFBhblNlc3Npb24oZXZlbnQsIGhhbmRsZXJzLCB7XG4gICAgICB0cmFuc2Zvcm1QYWdlUG9pbnRcbiAgICB9KTtcbiAgfVxuICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudCwgXCJwb2ludGVyZG93blwiLCBoYXNQYW5FdmVudHMgJiYgb25Qb2ludGVyRG93bik7XG4gIHVzZVVubW91bnRFZmZlY3QoKCkgPT4gcGFuU2Vzc2lvbi5jdXJyZW50ICYmIHBhblNlc3Npb24uY3VycmVudC5lbmQoKSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2RyYWcubWpzXG52YXIgZHJhZyA9IHtcbiAgcGFuOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VQYW5HZXN0dXJlKSxcbiAgZHJhZzogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlRHJhZylcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9jc3MtdmFyaWFibGVzLWNvbnZlcnNpb24ubWpzXG5mdW5jdGlvbiBpc0NTU1ZhcmlhYmxlMih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoXCJ2YXIoLS1cIik7XG59XG52YXIgY3NzVmFyaWFibGVSZWdleCA9IC92YXJcXCgoLS1bYS16QS1aMC05LV9dKyksPyA/KFthLXpBLVowLTkgKCklIy4sLV0rKT9cXCkvO1xuZnVuY3Rpb24gcGFyc2VDU1NWYXJpYWJsZShjdXJyZW50KSB7XG4gIGNvbnN0IG1hdGNoID0gY3NzVmFyaWFibGVSZWdleC5leGVjKGN1cnJlbnQpO1xuICBpZiAoIW1hdGNoKVxuICAgIHJldHVybiBbLF07XG4gIGNvbnN0IFssIHRva2VuLCBmYWxsYmFja10gPSBtYXRjaDtcbiAgcmV0dXJuIFt0b2tlbiwgZmFsbGJhY2tdO1xufVxudmFyIG1heERlcHRoID0gNDtcbmZ1bmN0aW9uIGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCwgZGVwdGggPSAxKSB7XG4gIGludmFyaWFudChkZXB0aCA8PSBtYXhEZXB0aCwgYE1heCBDU1MgdmFyaWFibGUgZmFsbGJhY2sgZGVwdGggZGV0ZWN0ZWQgaW4gcHJvcGVydHkgXCIke2N1cnJlbnR9XCIuIFRoaXMgbWF5IGluZGljYXRlIGEgY2lyY3VsYXIgZmFsbGJhY2sgZGVwZW5kZW5jeS5gKTtcbiAgY29uc3QgW3Rva2VuLCBmYWxsYmFja10gPSBwYXJzZUNTU1ZhcmlhYmxlKGN1cnJlbnQpO1xuICBpZiAoIXRva2VuKVxuICAgIHJldHVybjtcbiAgY29uc3QgcmVzb2x2ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHRva2VuKTtcbiAgaWYgKHJlc29sdmVkKSB7XG4gICAgcmV0dXJuIHJlc29sdmVkLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChpc0NTU1ZhcmlhYmxlMihmYWxsYmFjaykpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWFibGVWYWx1ZShmYWxsYmFjaywgZWxlbWVudCwgZGVwdGggKyAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVDU1NWYXJpYWJsZXModmlzdWFsRWxlbWVudCwgX2EsIHRyYW5zaXRpb25FbmQpIHtcbiAgdmFyIHRhcmdldCA9IF9fb2JqUmVzdChfYSwgW10pO1xuICBjb25zdCBlbGVtZW50ID0gdmlzdWFsRWxlbWVudC5jdXJyZW50O1xuICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpXG4gICAgcmV0dXJuIHsgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kIH07XG4gIGlmICh0cmFuc2l0aW9uRW5kKSB7XG4gICAgdHJhbnNpdGlvbkVuZCA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0cmFuc2l0aW9uRW5kKTtcbiAgfVxuICB2aXN1YWxFbGVtZW50LnZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB2YWx1ZS5nZXQoKTtcbiAgICBpZiAoIWlzQ1NTVmFyaWFibGUyKGN1cnJlbnQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJlc29sdmVkID0gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50KTtcbiAgICBpZiAocmVzb2x2ZWQpXG4gICAgICB2YWx1ZS5zZXQocmVzb2x2ZWQpO1xuICB9KTtcbiAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRhcmdldFtrZXldO1xuICAgIGlmICghaXNDU1NWYXJpYWJsZTIoY3VycmVudCkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCByZXNvbHZlZCA9IGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCk7XG4gICAgaWYgKCFyZXNvbHZlZClcbiAgICAgIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gcmVzb2x2ZWQ7XG4gICAgaWYgKHRyYW5zaXRpb25FbmQgJiYgdHJhbnNpdGlvbkVuZFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIHRyYW5zaXRpb25FbmRba2V5XSA9IGN1cnJlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHRhcmdldCwgdHJhbnNpdGlvbkVuZCB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvdW5pdC1jb252ZXJzaW9uLm1qc1xudmFyIHBvc2l0aW9uYWxLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIndpZHRoXCIsXG4gIFwiaGVpZ2h0XCIsXG4gIFwidG9wXCIsXG4gIFwibGVmdFwiLFxuICBcInJpZ2h0XCIsXG4gIFwiYm90dG9tXCIsXG4gIFwieFwiLFxuICBcInlcIlxuXSk7XG52YXIgaXNQb3NpdGlvbmFsS2V5ID0gKGtleSkgPT4gcG9zaXRpb25hbEtleXMuaGFzKGtleSk7XG52YXIgaGFzUG9zaXRpb25hbEtleSA9ICh0YXJnZXQpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuc29tZShpc1Bvc2l0aW9uYWxLZXkpO1xufTtcbnZhciBzZXRBbmRSZXNldFZlbG9jaXR5ID0gKHZhbHVlLCB0bykgPT4ge1xuICB2YWx1ZS5zZXQodG8sIGZhbHNlKTtcbiAgdmFsdWUuc2V0KHRvKTtcbn07XG52YXIgaXNOdW1PclB4VHlwZSA9ICh2KSA9PiB2ID09PSBudW1iZXIgfHwgdiA9PT0gcHg7XG52YXIgQm91bmRpbmdCb3hEaW1lbnNpb247XG4oZnVuY3Rpb24oQm91bmRpbmdCb3hEaW1lbnNpb24yKSB7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcIndpZHRoXCJdID0gXCJ3aWR0aFwiO1xuICBCb3VuZGluZ0JveERpbWVuc2lvbjJbXCJoZWlnaHRcIl0gPSBcImhlaWdodFwiO1xuICBCb3VuZGluZ0JveERpbWVuc2lvbjJbXCJsZWZ0XCJdID0gXCJsZWZ0XCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcInJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICBCb3VuZGluZ0JveERpbWVuc2lvbjJbXCJ0b3BcIl0gPSBcInRvcFwiO1xuICBCb3VuZGluZ0JveERpbWVuc2lvbjJbXCJib3R0b21cIl0gPSBcImJvdHRvbVwiO1xufSkoQm91bmRpbmdCb3hEaW1lbnNpb24gfHwgKEJvdW5kaW5nQm94RGltZW5zaW9uID0ge30pKTtcbnZhciBnZXRQb3NGcm9tTWF0cml4ID0gKG1hdHJpeCwgcG9zKSA9PiBwYXJzZUZsb2F0KG1hdHJpeC5zcGxpdChcIiwgXCIpW3Bvc10pO1xudmFyIGdldFRyYW5zbGF0ZUZyb21NYXRyaXggPSAocG9zMiwgcG9zMykgPT4gKF9iYm94LCB7IHRyYW5zZm9ybSB9KSA9PiB7XG4gIGlmICh0cmFuc2Zvcm0gPT09IFwibm9uZVwiIHx8ICF0cmFuc2Zvcm0pXG4gICAgcmV0dXJuIDA7XG4gIGNvbnN0IG1hdHJpeDNkID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4M2RcXCgoLispXFwpJC8pO1xuICBpZiAobWF0cml4M2QpIHtcbiAgICByZXR1cm4gZ2V0UG9zRnJvbU1hdHJpeChtYXRyaXgzZFsxXSwgcG9zMyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0cml4ID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4XFwoKC4rKVxcKSQvKTtcbiAgICBpZiAobWF0cml4KSB7XG4gICAgICByZXR1cm4gZ2V0UG9zRnJvbU1hdHJpeChtYXRyaXhbMV0sIHBvczIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbn07XG52YXIgdHJhbnNmb3JtS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInhcIiwgXCJ5XCIsIFwielwiXSk7XG52YXIgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMgPSB0cmFuc2Zvcm1Qcm9wT3JkZXIuZmlsdGVyKChrZXkpID0+ICF0cmFuc2Zvcm1LZXlzLmhhcyhrZXkpKTtcbmZ1bmN0aW9uIHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0odmlzdWFsRWxlbWVudCkge1xuICBjb25zdCByZW1vdmVkVHJhbnNmb3JtcyA9IFtdO1xuICBub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmVtb3ZlZFRyYW5zZm9ybXMucHVzaChba2V5LCB2YWx1ZS5nZXQoKV0pO1xuICAgICAgdmFsdWUuc2V0KGtleS5zdGFydHNXaXRoKFwic2NhbGVcIikgPyAxIDogMCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKHJlbW92ZWRUcmFuc2Zvcm1zLmxlbmd0aClcbiAgICB2aXN1YWxFbGVtZW50LnJlbmRlcigpO1xuICByZXR1cm4gcmVtb3ZlZFRyYW5zZm9ybXM7XG59XG52YXIgcG9zaXRpb25hbFZhbHVlcyA9IHtcbiAgd2lkdGg6ICh7IHggfSwgeyBwYWRkaW5nTGVmdCA9IFwiMFwiLCBwYWRkaW5nUmlnaHQgPSBcIjBcIiB9KSA9PiB4Lm1heCAtIHgubWluIC0gcGFyc2VGbG9hdChwYWRkaW5nTGVmdCkgLSBwYXJzZUZsb2F0KHBhZGRpbmdSaWdodCksXG4gIGhlaWdodDogKHsgeSB9LCB7IHBhZGRpbmdUb3AgPSBcIjBcIiwgcGFkZGluZ0JvdHRvbSA9IFwiMFwiIH0pID0+IHkubWF4IC0geS5taW4gLSBwYXJzZUZsb2F0KHBhZGRpbmdUb3ApIC0gcGFyc2VGbG9hdChwYWRkaW5nQm90dG9tKSxcbiAgdG9wOiAoX2Jib3gsIHsgdG9wIH0pID0+IHBhcnNlRmxvYXQodG9wKSxcbiAgbGVmdDogKF9iYm94LCB7IGxlZnQgfSkgPT4gcGFyc2VGbG9hdChsZWZ0KSxcbiAgYm90dG9tOiAoeyB5IH0sIHsgdG9wIH0pID0+IHBhcnNlRmxvYXQodG9wKSArICh5Lm1heCAtIHkubWluKSxcbiAgcmlnaHQ6ICh7IHggfSwgeyBsZWZ0IH0pID0+IHBhcnNlRmxvYXQobGVmdCkgKyAoeC5tYXggLSB4Lm1pbiksXG4gIHg6IGdldFRyYW5zbGF0ZUZyb21NYXRyaXgoNCwgMTMpLFxuICB5OiBnZXRUcmFuc2xhdGVGcm9tTWF0cml4KDUsIDE0KVxufTtcbnZhciBjb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXMgPSAodGFyZ2V0LCB2aXN1YWxFbGVtZW50LCBjaGFuZ2VkS2V5cykgPT4ge1xuICBjb25zdCBvcmlnaW5CYm94ID0gdmlzdWFsRWxlbWVudC5tZWFzdXJlVmlld3BvcnRCb3goKTtcbiAgY29uc3QgZWxlbWVudCA9IHZpc3VhbEVsZW1lbnQuY3VycmVudDtcbiAgY29uc3QgZWxlbWVudENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBjb25zdCB7IGRpc3BsYXkgfSA9IGVsZW1lbnRDb21wdXRlZFN0eWxlO1xuICBjb25zdCBvcmlnaW4gPSB7fTtcbiAgaWYgKGRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgdmlzdWFsRWxlbWVudC5zZXRTdGF0aWNWYWx1ZShcImRpc3BsYXlcIiwgdGFyZ2V0LmRpc3BsYXkgfHwgXCJibG9ja1wiKTtcbiAgfVxuICBjaGFuZ2VkS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBvcmlnaW5ba2V5XSA9IHBvc2l0aW9uYWxWYWx1ZXNba2V5XShvcmlnaW5CYm94LCBlbGVtZW50Q29tcHV0ZWRTdHlsZSk7XG4gIH0pO1xuICB2aXN1YWxFbGVtZW50LnJlbmRlcigpO1xuICBjb25zdCB0YXJnZXRCYm94ID0gdmlzdWFsRWxlbWVudC5tZWFzdXJlVmlld3BvcnRCb3goKTtcbiAgY2hhbmdlZEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgc2V0QW5kUmVzZXRWZWxvY2l0eSh2YWx1ZSwgb3JpZ2luW2tleV0pO1xuICAgIHRhcmdldFtrZXldID0gcG9zaXRpb25hbFZhbHVlc1trZXldKHRhcmdldEJib3gsIGVsZW1lbnRDb21wdXRlZFN0eWxlKTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIGNoZWNrQW5kQ29udmVydENoYW5nZWRWYWx1ZVR5cGVzID0gKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luID0ge30sIHRyYW5zaXRpb25FbmQgPSB7fSkgPT4ge1xuICB0YXJnZXQgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdGFyZ2V0KTtcbiAgdHJhbnNpdGlvbkVuZCA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0cmFuc2l0aW9uRW5kKTtcbiAgY29uc3QgdGFyZ2V0UG9zaXRpb25hbEtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpLmZpbHRlcihpc1Bvc2l0aW9uYWxLZXkpO1xuICBsZXQgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcyA9IFtdO1xuICBsZXQgaGFzQXR0ZW1wdGVkVG9SZW1vdmVUcmFuc2Zvcm1WYWx1ZXMgPSBmYWxzZTtcbiAgY29uc3QgY2hhbmdlZFZhbHVlVHlwZUtleXMgPSBbXTtcbiAgdGFyZ2V0UG9zaXRpb25hbEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgaWYgKCF2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGZyb20gPSBvcmlnaW5ba2V5XTtcbiAgICBsZXQgZnJvbVR5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKGZyb20pO1xuICAgIGNvbnN0IHRvID0gdGFyZ2V0W2tleV07XG4gICAgbGV0IHRvVHlwZTtcbiAgICBpZiAoaXNLZXlmcmFtZXNUYXJnZXQodG8pKSB7XG4gICAgICBjb25zdCBudW1LZXlmcmFtZXMgPSB0by5sZW5ndGg7XG4gICAgICBjb25zdCBmcm9tSW5kZXggPSB0b1swXSA9PT0gbnVsbCA/IDEgOiAwO1xuICAgICAgZnJvbSA9IHRvW2Zyb21JbmRleF07XG4gICAgICBmcm9tVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUoZnJvbSk7XG4gICAgICBmb3IgKGxldCBpMiA9IGZyb21JbmRleDsgaTIgPCBudW1LZXlmcmFtZXM7IGkyKyspIHtcbiAgICAgICAgaWYgKCF0b1R5cGUpIHtcbiAgICAgICAgICB0b1R5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKHRvW2kyXSk7XG4gICAgICAgICAgaW52YXJpYW50KHRvVHlwZSA9PT0gZnJvbVR5cGUgfHwgaXNOdW1PclB4VHlwZShmcm9tVHlwZSkgJiYgaXNOdW1PclB4VHlwZSh0b1R5cGUpLCBcIktleWZyYW1lcyBtdXN0IGJlIG9mIHRoZSBzYW1lIGRpbWVuc2lvbiBhcyB0aGUgY3VycmVudCB2YWx1ZVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZhcmlhbnQoZmluZERpbWVuc2lvblZhbHVlVHlwZSh0b1tpMl0pID09PSB0b1R5cGUsIFwiQWxsIGtleWZyYW1lcyBtdXN0IGJlIG9mIHRoZSBzYW1lIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdG9UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZSh0byk7XG4gICAgfVxuICAgIGlmIChmcm9tVHlwZSAhPT0gdG9UeXBlKSB7XG4gICAgICBpZiAoaXNOdW1PclB4VHlwZShmcm9tVHlwZSkgJiYgaXNOdW1PclB4VHlwZSh0b1R5cGUpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB2YWx1ZS5nZXQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdmFsdWUuc2V0KHBhcnNlRmxvYXQoY3VycmVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHBhcnNlRmxvYXQodG8pO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodG8pICYmIHRvVHlwZSA9PT0gcHgpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHRvLm1hcChwYXJzZUZsb2F0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoZnJvbVR5cGUgPT09IG51bGwgfHwgZnJvbVR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZyb21UeXBlLnRyYW5zZm9ybSkgJiYgKHRvVHlwZSA9PT0gbnVsbCB8fCB0b1R5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvVHlwZS50cmFuc2Zvcm0pICYmIChmcm9tID09PSAwIHx8IHRvID09PSAwKSkge1xuICAgICAgICBpZiAoZnJvbSA9PT0gMCkge1xuICAgICAgICAgIHZhbHVlLnNldCh0b1R5cGUudHJhbnNmb3JtKGZyb20pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IGZyb21UeXBlLnRyYW5zZm9ybSh0byk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzQXR0ZW1wdGVkVG9SZW1vdmVUcmFuc2Zvcm1WYWx1ZXMpIHtcbiAgICAgICAgICByZW1vdmVkVHJhbnNmb3JtVmFsdWVzID0gcmVtb3ZlTm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybSh2aXN1YWxFbGVtZW50KTtcbiAgICAgICAgICBoYXNBdHRlbXB0ZWRUb1JlbW92ZVRyYW5zZm9ybVZhbHVlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlZFZhbHVlVHlwZUtleXMucHVzaChrZXkpO1xuICAgICAgICB0cmFuc2l0aW9uRW5kW2tleV0gPSB0cmFuc2l0aW9uRW5kW2tleV0gIT09IHZvaWQgMCA/IHRyYW5zaXRpb25FbmRba2V5XSA6IHRhcmdldFtrZXldO1xuICAgICAgICBzZXRBbmRSZXNldFZlbG9jaXR5KHZhbHVlLCB0byk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKGNoYW5nZWRWYWx1ZVR5cGVLZXlzLmxlbmd0aCkge1xuICAgIGNvbnN0IHNjcm9sbFkgPSBjaGFuZ2VkVmFsdWVUeXBlS2V5cy5pbmRleE9mKFwiaGVpZ2h0XCIpID49IDAgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiBudWxsO1xuICAgIGNvbnN0IGNvbnZlcnRlZFRhcmdldCA9IGNvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyh0YXJnZXQsIHZpc3VhbEVsZW1lbnQsIGNoYW5nZWRWYWx1ZVR5cGVLZXlzKTtcbiAgICBpZiAocmVtb3ZlZFRyYW5zZm9ybVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHJlbW92ZWRUcmFuc2Zvcm1WYWx1ZXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KS5zZXQodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gICAgaWYgKGlzQnJvd3NlciAmJiBzY3JvbGxZICE9PSBudWxsKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oeyB0b3A6IHNjcm9sbFkgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IHRhcmdldDogY29udmVydGVkVGFyZ2V0LCB0cmFuc2l0aW9uRW5kIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kIH07XG4gIH1cbn07XG5mdW5jdGlvbiB1bml0Q29udmVyc2lvbih2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCkge1xuICByZXR1cm4gaGFzUG9zaXRpb25hbEtleSh0YXJnZXQpID8gY2hlY2tBbmRDb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXModmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpIDogeyB0YXJnZXQsIHRyYW5zaXRpb25FbmQgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL3BhcnNlLWRvbS12YXJpYW50Lm1qc1xudmFyIHBhcnNlRG9tVmFyaWFudCA9ICh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCkgPT4ge1xuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVDU1NWYXJpYWJsZXModmlzdWFsRWxlbWVudCwgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kKTtcbiAgdGFyZ2V0ID0gcmVzb2x2ZWQudGFyZ2V0O1xuICB0cmFuc2l0aW9uRW5kID0gcmVzb2x2ZWQudHJhbnNpdGlvbkVuZDtcbiAgcmV0dXJuIHVuaXRDb252ZXJzaW9uKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL1Zpc3VhbEVsZW1lbnQubWpzXG52YXIgaW1wb3J0X3JlYWN0MjYgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvcmVkdWNlZC1tb3Rpb24vc3RhdGUubWpzXG52YXIgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPSB7IGN1cnJlbnQ6IG51bGwgfTtcbnZhciBoYXNSZWR1Y2VkTW90aW9uTGlzdGVuZXIgPSB7IGN1cnJlbnQ6IGZhbHNlIH07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvcmVkdWNlZC1tb3Rpb24vaW5kZXgubWpzXG5mdW5jdGlvbiBpbml0UHJlZmVyc1JlZHVjZWRNb3Rpb24oKSB7XG4gIGhhc1JlZHVjZWRNb3Rpb25MaXN0ZW5lci5jdXJyZW50ID0gdHJ1ZTtcbiAgaWYgKCFpc0Jyb3dzZXIpXG4gICAgcmV0dXJuO1xuICBpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICBjb25zdCBtb3Rpb25NZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbilcIik7XG4gICAgY29uc3Qgc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzID0gKCkgPT4gcHJlZmVyc1JlZHVjZWRNb3Rpb24uY3VycmVudCA9IG1vdGlvbk1lZGlhUXVlcnkubWF0Y2hlcztcbiAgICBtb3Rpb25NZWRpYVF1ZXJ5LmFkZExpc3RlbmVyKHNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcyk7XG4gICAgc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzKCk7XG4gIH0gZWxzZSB7XG4gICAgcHJlZmVyc1JlZHVjZWRNb3Rpb24uY3VycmVudCA9IGZhbHNlO1xuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL21vdGlvbi12YWx1ZXMubWpzXG5mdW5jdGlvbiB1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMoZWxlbWVudCwgbmV4dCwgcHJldikge1xuICBjb25zdCB7IHdpbGxDaGFuZ2UgfSA9IG5leHQ7XG4gIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICBjb25zdCBuZXh0VmFsdWUgPSBuZXh0W2tleV07XG4gICAgY29uc3QgcHJldlZhbHVlID0gcHJldltrZXldO1xuICAgIGlmIChpc01vdGlvblZhbHVlKG5leHRWYWx1ZSkpIHtcbiAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBuZXh0VmFsdWUpO1xuICAgICAgaWYgKGlzV2lsbENoYW5nZU1vdGlvblZhbHVlKHdpbGxDaGFuZ2UpKSB7XG4gICAgICAgIHdpbGxDaGFuZ2UuYWRkKGtleSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICB3YXJuT25jZShuZXh0VmFsdWUudmVyc2lvbiA9PT0gXCI3LjYuN1wiLCBgQXR0ZW1wdGluZyB0byBtaXggRnJhbWVyIE1vdGlvbiB2ZXJzaW9ucyAke25leHRWYWx1ZS52ZXJzaW9ufSB3aXRoIDcuNi43IG1heSBub3Qgd29yayBhcyBleHBlY3RlZC5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTW90aW9uVmFsdWUocHJldlZhbHVlKSkge1xuICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKG5leHRWYWx1ZSkpO1xuICAgICAgaWYgKGlzV2lsbENoYW5nZU1vdGlvblZhbHVlKHdpbGxDaGFuZ2UpKSB7XG4gICAgICAgIHdpbGxDaGFuZ2UucmVtb3ZlKGtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2VmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgICAgaWYgKGVsZW1lbnQuaGFzVmFsdWUoa2V5KSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gZWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICAhZXhpc3RpbmdWYWx1ZS5oYXNBbmltYXRlZCAmJiBleGlzdGluZ1ZhbHVlLnNldChuZXh0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0VmFsdWUgPSBlbGVtZW50LmdldFN0YXRpY1ZhbHVlKGtleSk7XG4gICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZShsYXRlc3RWYWx1ZSAhPT0gdm9pZCAwID8gbGF0ZXN0VmFsdWUgOiBuZXh0VmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgIGlmIChuZXh0W2tleV0gPT09IHZvaWQgMClcbiAgICAgIGVsZW1lbnQucmVtb3ZlVmFsdWUoa2V5KTtcbiAgfVxuICByZXR1cm4gbmV4dDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvVmlzdWFsRWxlbWVudC5tanNcbnZhciBmZWF0dXJlTmFtZXMgPSBPYmplY3Qua2V5cyhmZWF0dXJlRGVmaW5pdGlvbnMpO1xudmFyIG51bUZlYXR1cmVzID0gZmVhdHVyZU5hbWVzLmxlbmd0aDtcbnZhciBwcm9wRXZlbnRIYW5kbGVycyA9IFtcbiAgXCJBbmltYXRpb25TdGFydFwiLFxuICBcIkFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gIFwiVXBkYXRlXCIsXG4gIFwiVW5tb3VudFwiLFxuICBcIkJlZm9yZUxheW91dE1lYXN1cmVcIixcbiAgXCJMYXlvdXRNZWFzdXJlXCIsXG4gIFwiTGF5b3V0QW5pbWF0aW9uU3RhcnRcIixcbiAgXCJMYXlvdXRBbmltYXRpb25Db21wbGV0ZVwiXG5dO1xudmFyIFZpc3VhbEVsZW1lbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHsgcGFyZW50LCBwcm9wcywgcmVkdWNlZE1vdGlvbkNvbmZpZywgdmlzdWFsU3RhdGUgfSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmlzVmFyaWFudE5vZGUgPSBmYWxzZTtcbiAgICB0aGlzLmlzQ29udHJvbGxpbmdWYXJpYW50cyA9IGZhbHNlO1xuICAgIHRoaXMuc2hvdWxkUmVkdWNlTW90aW9uID0gbnVsbDtcbiAgICB0aGlzLnZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5pc1ByZXNlbnQgPSB0cnVlO1xuICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZXZNb3Rpb25WYWx1ZXMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgIHRoaXMubm90aWZ5VXBkYXRlID0gKCkgPT4gdGhpcy5ub3RpZnkoXCJVcGRhdGVcIiwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgIHRoaXMucmVuZGVyID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmN1cnJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMudHJpZ2dlckJ1aWxkKCk7XG4gICAgICB0aGlzLnJlbmRlckluc3RhbmNlKHRoaXMuY3VycmVudCwgdGhpcy5yZW5kZXJTdGF0ZSwgdGhpcy5wcm9wcy5zdHlsZSwgdGhpcy5wcm9qZWN0aW9uKTtcbiAgICB9O1xuICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIgPSAoKSA9PiBlc19kZWZhdWx0LnJlbmRlcih0aGlzLnJlbmRlciwgZmFsc2UsIHRydWUpO1xuICAgIGNvbnN0IHsgbGF0ZXN0VmFsdWVzLCByZW5kZXJTdGF0ZSB9ID0gdmlzdWFsU3RhdGU7XG4gICAgdGhpcy5sYXRlc3RWYWx1ZXMgPSBsYXRlc3RWYWx1ZXM7XG4gICAgdGhpcy5iYXNlVGFyZ2V0ID0gX19zcHJlYWRWYWx1ZXMoe30sIGxhdGVzdFZhbHVlcyk7XG4gICAgdGhpcy5pbml0aWFsVmFsdWVzID0gcHJvcHMuaW5pdGlhbCA/IF9fc3ByZWFkVmFsdWVzKHt9LCBsYXRlc3RWYWx1ZXMpIDoge307XG4gICAgdGhpcy5yZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmRlcHRoID0gcGFyZW50ID8gcGFyZW50LmRlcHRoICsgMSA6IDA7XG4gICAgdGhpcy5yZWR1Y2VkTW90aW9uQ29uZmlnID0gcmVkdWNlZE1vdGlvbkNvbmZpZztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaXNDb250cm9sbGluZ1ZhcmlhbnRzID0gaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKTtcbiAgICB0aGlzLmlzVmFyaWFudE5vZGUgPSBpc1ZhcmlhbnROb2RlKHByb3BzKTtcbiAgICBpZiAodGhpcy5pc1ZhcmlhbnROb2RlKSB7XG4gICAgICB0aGlzLnZhcmlhbnRDaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHRoaXMubWFudWFsbHlBbmltYXRlT25Nb3VudCA9IEJvb2xlYW4ocGFyZW50ICYmIHBhcmVudC5jdXJyZW50KTtcbiAgICBjb25zdCBfYSA9IHRoaXMuc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKSwgeyB3aWxsQ2hhbmdlIH0gPSBfYSwgaW5pdGlhbE1vdGlvblZhbHVlcyA9IF9fb2JqUmVzdChfYSwgW1wid2lsbENoYW5nZVwiXSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5pdGlhbE1vdGlvblZhbHVlcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbml0aWFsTW90aW9uVmFsdWVzW2tleV07XG4gICAgICBpZiAobGF0ZXN0VmFsdWVzW2tleV0gIT09IHZvaWQgMCAmJiBpc01vdGlvblZhbHVlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5zZXQobGF0ZXN0VmFsdWVzW2tleV0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGlzV2lsbENoYW5nZU1vdGlvblZhbHVlKHdpbGxDaGFuZ2UpKSB7XG4gICAgICAgICAgd2lsbENoYW5nZS5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMoX3Byb3BzKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIG1vdW50KGluc3RhbmNlKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuY3VycmVudCA9IGluc3RhbmNlO1xuICAgIGlmICh0aGlzLnByb2plY3Rpb24pIHtcbiAgICAgIHRoaXMucHJvamVjdGlvbi5tb3VudChpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLmlzVmFyaWFudE5vZGUgJiYgIXRoaXMuaXNDb250cm9sbGluZ1ZhcmlhbnRzKSB7XG4gICAgICB0aGlzLnJlbW92ZUZyb21WYXJpYW50VHJlZSA9IChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkVmFyaWFudENoaWxkKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0aGlzLmJpbmRUb01vdGlvblZhbHVlKGtleSwgdmFsdWUpKTtcbiAgICBpZiAoIWhhc1JlZHVjZWRNb3Rpb25MaXN0ZW5lci5jdXJyZW50KSB7XG4gICAgICBpbml0UHJlZmVyc1JlZHVjZWRNb3Rpb24oKTtcbiAgICB9XG4gICAgdGhpcy5zaG91bGRSZWR1Y2VNb3Rpb24gPSB0aGlzLnJlZHVjZWRNb3Rpb25Db25maWcgPT09IFwibmV2ZXJcIiA/IGZhbHNlIDogdGhpcy5yZWR1Y2VkTW90aW9uQ29uZmlnID09PSBcImFsd2F5c1wiID8gdHJ1ZSA6IHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQ7XG4gICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uYWRkKHRoaXMpO1xuICAgIHRoaXMuc2V0UHJvcHModGhpcy5wcm9wcyk7XG4gIH1cbiAgdW5tb3VudCgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAoX2EgPSB0aGlzLnByb2plY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm1vdW50KCk7XG4gICAgY2FuY2VsU3luYy51cGRhdGUodGhpcy5ub3RpZnlVcGRhdGUpO1xuICAgIGNhbmNlbFN5bmMucmVuZGVyKHRoaXMucmVuZGVyKTtcbiAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5mb3JFYWNoKChyZW1vdmUpID0+IHJlbW92ZSgpKTtcbiAgICAoX2IgPSB0aGlzLnJlbW92ZUZyb21WYXJpYW50VHJlZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcyk7XG4gICAgKF9jID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jaGlsZHJlbi5kZWxldGUodGhpcyk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgIHRoaXMuZXZlbnRzW2tleV0uY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgfVxuICBiaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgcmVtb3ZlT25DaGFuZ2UgPSB2YWx1ZS5vbkNoYW5nZSgobGF0ZXN0VmFsdWUpID0+IHtcbiAgICAgIHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gPSBsYXRlc3RWYWx1ZTtcbiAgICAgIHRoaXMucHJvcHMub25VcGRhdGUgJiYgZXNfZGVmYXVsdC51cGRhdGUodGhpcy5ub3RpZnlVcGRhdGUsIGZhbHNlLCB0cnVlKTtcbiAgICB9KTtcbiAgICBjb25zdCByZW1vdmVPblJlbmRlclJlcXVlc3QgPSB2YWx1ZS5vblJlbmRlclJlcXVlc3QodGhpcy5zY2hlZHVsZVJlbmRlcik7XG4gICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuc2V0KGtleSwgKCkgPT4ge1xuICAgICAgcmVtb3ZlT25DaGFuZ2UoKTtcbiAgICAgIHJlbW92ZU9uUmVuZGVyUmVxdWVzdCgpO1xuICAgIH0pO1xuICB9XG4gIHNvcnROb2RlUG9zaXRpb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudCB8fCAhdGhpcy5zb3J0SW5zdGFuY2VOb2RlUG9zaXRpb24gfHwgdGhpcy50eXBlICE9PSBvdGhlci50eXBlKVxuICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHRoaXMuc29ydEluc3RhbmNlTm9kZVBvc2l0aW9uKHRoaXMuY3VycmVudCwgb3RoZXIuY3VycmVudCk7XG4gIH1cbiAgbG9hZEZlYXR1cmVzKHJlbmRlcmVkUHJvcHMsIGlzU3RyaWN0LCBwcmVsb2FkZWRGZWF0dXJlcywgcHJvamVjdGlvbklkLCBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yLCBpbml0aWFsTGF5b3V0R3JvdXBDb25maWcpIHtcbiAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgIGlmIChlbnYgIT09IFwicHJvZHVjdGlvblwiICYmIHByZWxvYWRlZEZlYXR1cmVzICYmIGlzU3RyaWN0KSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IGhhdmUgcmVuZGVyZWQgYSBgbW90aW9uYCBjb21wb25lbnQgd2l0aGluIGEgYExhenlNb3Rpb25gIGNvbXBvbmVudC4gVGhpcyB3aWxsIGJyZWFrIHRyZWUgc2hha2luZy4gSW1wb3J0IGFuZCByZW5kZXIgYSBgbWAgY29tcG9uZW50IGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtRmVhdHVyZXM7IGkyKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBmZWF0dXJlTmFtZXNbaTJdO1xuICAgICAgY29uc3QgeyBpc0VuYWJsZWQsIENvbXBvbmVudCB9ID0gZmVhdHVyZURlZmluaXRpb25zW25hbWVdO1xuICAgICAgaWYgKGlzRW5hYmxlZChyZW5kZXJlZFByb3BzKSAmJiBDb21wb25lbnQpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaCgoMCwgaW1wb3J0X3JlYWN0MjYuY3JlYXRlRWxlbWVudCkoQ29tcG9uZW50LCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICBrZXk6IG5hbWVcbiAgICAgICAgfSwgcmVuZGVyZWRQcm9wcyksIHtcbiAgICAgICAgICB2aXN1YWxFbGVtZW50OiB0aGlzXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5wcm9qZWN0aW9uICYmIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMucHJvamVjdGlvbiA9IG5ldyBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKHByb2plY3Rpb25JZCwgdGhpcy5sYXRlc3RWYWx1ZXMsIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnByb2plY3Rpb24pO1xuICAgICAgY29uc3QgeyBsYXlvdXRJZCwgbGF5b3V0LCBkcmFnOiBkcmFnMiwgZHJhZ0NvbnN0cmFpbnRzLCBsYXlvdXRTY3JvbGwgfSA9IHJlbmRlcmVkUHJvcHM7XG4gICAgICB0aGlzLnByb2plY3Rpb24uc2V0T3B0aW9ucyh7XG4gICAgICAgIGxheW91dElkLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGFsd2F5c01lYXN1cmVMYXlvdXQ6IEJvb2xlYW4oZHJhZzIpIHx8IGRyYWdDb25zdHJhaW50cyAmJiBpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpLFxuICAgICAgICB2aXN1YWxFbGVtZW50OiB0aGlzLFxuICAgICAgICBzY2hlZHVsZVJlbmRlcjogKCkgPT4gdGhpcy5zY2hlZHVsZVJlbmRlcigpLFxuICAgICAgICBhbmltYXRpb25UeXBlOiB0eXBlb2YgbGF5b3V0ID09PSBcInN0cmluZ1wiID8gbGF5b3V0IDogXCJib3RoXCIsXG4gICAgICAgIGluaXRpYWxQcm9tb3Rpb25Db25maWc6IGluaXRpYWxMYXlvdXRHcm91cENvbmZpZyxcbiAgICAgICAgbGF5b3V0U2Nyb2xsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG4gIHRyaWdnZXJCdWlsZCgpIHtcbiAgICB0aGlzLmJ1aWxkKHRoaXMucmVuZGVyU3RhdGUsIHRoaXMubGF0ZXN0VmFsdWVzLCB0aGlzLm9wdGlvbnMsIHRoaXMucHJvcHMpO1xuICB9XG4gIG1lYXN1cmVWaWV3cG9ydEJveCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID8gdGhpcy5tZWFzdXJlSW5zdGFuY2VWaWV3cG9ydEJveCh0aGlzLmN1cnJlbnQsIHRoaXMucHJvcHMpIDogY3JlYXRlQm94KCk7XG4gIH1cbiAgZ2V0U3RhdGljVmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZXN0VmFsdWVzW2tleV07XG4gIH1cbiAgc2V0U3RhdGljVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICBtYWtlVGFyZ2V0QW5pbWF0YWJsZSh0YXJnZXQsIGNhbk11dGF0ZSA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVGFyZ2V0QW5pbWF0YWJsZUZyb21JbnN0YW5jZSh0YXJnZXQsIHRoaXMucHJvcHMsIGNhbk11dGF0ZSk7XG4gIH1cbiAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICBpZiAocHJvcHMudHJhbnNmb3JtVGVtcGxhdGUgfHwgdGhpcy5wcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgIH1cbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHByb3BFdmVudEhhbmRsZXJzLmxlbmd0aDsgaTIrKykge1xuICAgICAgY29uc3Qga2V5ID0gcHJvcEV2ZW50SGFuZGxlcnNbaTJdO1xuICAgICAgaWYgKHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldKSB7XG4gICAgICAgIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gcHJvcHNbXCJvblwiICsga2V5XTtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XSA9IHRoaXMub24oa2V5LCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJldk1vdGlvblZhbHVlcyA9IHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyh0aGlzLCB0aGlzLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcyksIHRoaXMucHJldk1vdGlvblZhbHVlcyk7XG4gIH1cbiAgZ2V0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHM7XG4gIH1cbiAgZ2V0VmFyaWFudChuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnByb3BzLnZhcmlhbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbbmFtZV07XG4gIH1cbiAgZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMudHJhbnNpdGlvbjtcbiAgfVxuICBnZXRUcmFuc2Zvcm1QYWdlUG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMudHJhbnNmb3JtUGFnZVBvaW50O1xuICB9XG4gIGdldENsb3Nlc3RWYXJpYW50Tm9kZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHRoaXMuaXNWYXJpYW50Tm9kZSA/IHRoaXMgOiAoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldENsb3Nlc3RWYXJpYW50Tm9kZSgpO1xuICB9XG4gIGdldFZhcmlhbnRDb250ZXh0KHN0YXJ0QXRQYXJlbnQgPSBmYWxzZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHN0YXJ0QXRQYXJlbnQpXG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRWYXJpYW50Q29udGV4dCgpO1xuICAgIGlmICghdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHMpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQyID0gKChfYiA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0VmFyaWFudENvbnRleHQoKSkgfHwge307XG4gICAgICBpZiAodGhpcy5wcm9wcy5pbml0aWFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dDIuaW5pdGlhbCA9IHRoaXMucHJvcHMuaW5pdGlhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZXh0MjtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IHt9O1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1WYXJpYW50UHJvcHM7IGkyKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB2YXJpYW50UHJvcHMyW2kyXTtcbiAgICAgIGNvbnN0IHByb3AgPSB0aGlzLnByb3BzW25hbWVdO1xuICAgICAgaWYgKGlzVmFyaWFudExhYmVsKHByb3ApIHx8IHByb3AgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRleHRbbmFtZV0gPSBwcm9wO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBhZGRWYXJpYW50Q2hpbGQoY2hpbGQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY2xvc2VzdFZhcmlhbnROb2RlID0gdGhpcy5nZXRDbG9zZXN0VmFyaWFudE5vZGUoKTtcbiAgICBpZiAoY2xvc2VzdFZhcmlhbnROb2RlKSB7XG4gICAgICAoX2EgPSBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkKGNoaWxkKTtcbiAgICAgIHJldHVybiAoKSA9PiBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuLmRlbGV0ZShjaGlsZCk7XG4gICAgfVxuICB9XG4gIGFkZFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXNWYWx1ZShrZXkpKVxuICAgICAgdGhpcy5yZW1vdmVWYWx1ZShrZXkpO1xuICAgIHRoaXMudmFsdWVzLnNldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLmxhdGVzdFZhbHVlc1trZXldID0gdmFsdWUuZ2V0KCk7XG4gICAgdGhpcy5iaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKTtcbiAgfVxuICByZW1vdmVWYWx1ZShrZXkpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy52YWx1ZXMuZGVsZXRlKGtleSk7XG4gICAgKF9hID0gdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYSgpO1xuICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmRlbGV0ZShrZXkpO1xuICAgIGRlbGV0ZSB0aGlzLmxhdGVzdFZhbHVlc1trZXldO1xuICAgIHRoaXMucmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUoa2V5LCB0aGlzLnJlbmRlclN0YXRlKTtcbiAgfVxuICBoYXNWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMuaGFzKGtleSk7XG4gIH1cbiAgZ2V0VmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy52YWx1ZXMgJiYgdGhpcy5wcm9wcy52YWx1ZXNba2V5XSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMudmFsdWVzW2tleV07XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWVzLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwICYmIGRlZmF1bHRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IG1vdGlvblZhbHVlKGRlZmF1bHRWYWx1ZSk7XG4gICAgICB0aGlzLmFkZFZhbHVlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZFZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLmxhdGVzdFZhbHVlc1trZXldICE9PSB2b2lkIDAgfHwgIXRoaXMuY3VycmVudCA/IHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gOiB0aGlzLnJlYWRWYWx1ZUZyb21JbnN0YW5jZSh0aGlzLmN1cnJlbnQsIGtleSwgdGhpcy5vcHRpb25zKTtcbiAgfVxuICBzZXRCYXNlVGFyZ2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmJhc2VUYXJnZXRba2V5XSA9IHZhbHVlO1xuICB9XG4gIGdldEJhc2VUYXJnZXQoa2V5KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgaW5pdGlhbCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB2YWx1ZUZyb21Jbml0aWFsID0gdHlwZW9mIGluaXRpYWwgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGluaXRpYWwgPT09IFwib2JqZWN0XCIgPyAoX2EgPSByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyh0aGlzLnByb3BzLCBpbml0aWFsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2tleV0gOiB2b2lkIDA7XG4gICAgaWYgKGluaXRpYWwgJiYgdmFsdWVGcm9tSW5pdGlhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdmFsdWVGcm9tSW5pdGlhbDtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRCYXNlVGFyZ2V0RnJvbVByb3BzKHRoaXMucHJvcHMsIGtleSk7XG4gICAgaWYgKHRhcmdldCAhPT0gdm9pZCAwICYmICFpc01vdGlvblZhbHVlKHRhcmdldCkpXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZXNba2V5XSAhPT0gdm9pZCAwICYmIHZhbHVlRnJvbUluaXRpYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMuYmFzZVRhcmdldFtrZXldO1xuICB9XG4gIG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5hZGQoY2FsbGJhY2spO1xuICB9XG4gIG5vdGlmeShldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vdGlmeSguLi5hcmdzKTtcbiAgfVxufTtcbnZhciB2YXJpYW50UHJvcHMyID0gW1wiaW5pdGlhbFwiLCAuLi52YXJpYW50UHJpb3JpdHlPcmRlcl07XG52YXIgbnVtVmFyaWFudFByb3BzID0gdmFyaWFudFByb3BzMi5sZW5ndGg7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS9ET01WaXN1YWxFbGVtZW50Lm1qc1xudmFyIERPTVZpc3VhbEVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIFZpc3VhbEVsZW1lbnQge1xuICBzb3J0SW5zdGFuY2VOb2RlUG9zaXRpb24oYTIsIGIyKSB7XG4gICAgcmV0dXJuIGEyLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIyKSAmIDIgPyAxIDogLTE7XG4gIH1cbiAgZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyhwcm9wcywga2V5KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBwcm9wcy5zdHlsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2tleV07XG4gIH1cbiAgcmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUoa2V5LCB7IHZhcnMsIHN0eWxlIH0pIHtcbiAgICBkZWxldGUgdmFyc1trZXldO1xuICAgIGRlbGV0ZSBzdHlsZVtrZXldO1xuICB9XG4gIG1ha2VUYXJnZXRBbmltYXRhYmxlRnJvbUluc3RhbmNlKF9hLCB7IHRyYW5zZm9ybVZhbHVlcyB9LCBpc01vdW50ZWQpIHtcbiAgICB2YXIgX2IgPSBfYSwgeyB0cmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kIH0gPSBfYiwgdGFyZ2V0ID0gX19vYmpSZXN0KF9iLCBbXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbkVuZFwiXSk7XG4gICAgbGV0IG9yaWdpbiA9IGdldE9yaWdpbih0YXJnZXQsIHRyYW5zaXRpb24gfHwge30sIHRoaXMpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWx1ZXMpIHtcbiAgICAgIGlmICh0cmFuc2l0aW9uRW5kKVxuICAgICAgICB0cmFuc2l0aW9uRW5kID0gdHJhbnNmb3JtVmFsdWVzKHRyYW5zaXRpb25FbmQpO1xuICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtVmFsdWVzKHRhcmdldCk7XG4gICAgICBpZiAob3JpZ2luKVxuICAgICAgICBvcmlnaW4gPSB0cmFuc2Zvcm1WYWx1ZXMob3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXModGhpcywgdGFyZ2V0LCBvcmlnaW4pO1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VEb21WYXJpYW50KHRoaXMsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKTtcbiAgICAgIHRyYW5zaXRpb25FbmQgPSBwYXJzZWQudHJhbnNpdGlvbkVuZDtcbiAgICAgIHRhcmdldCA9IHBhcnNlZC50YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgdHJhbnNpdGlvbkVuZFxuICAgIH0sIHRhcmdldCk7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvSFRNTFZpc3VhbEVsZW1lbnQubWpzXG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlMihlbGVtZW50KSB7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbnZhciBIVE1MVmlzdWFsRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgRE9NVmlzdWFsRWxlbWVudCB7XG4gIHJlYWRWYWx1ZUZyb21JbnN0YW5jZShpbnN0YW5jZSwga2V5KSB7XG4gICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICBjb25zdCBkZWZhdWx0VHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgICAgIHJldHVybiBkZWZhdWx0VHlwZSA/IGRlZmF1bHRUeXBlLmRlZmF1bHQgfHwgMCA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlMihpbnN0YW5jZSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IChpc0NTU1ZhcmlhYmxlKGtleSkgPyBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoa2V5KSA6IGNvbXB1dGVkU3R5bGVba2V5XSkgfHwgMDtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS50cmltKCkgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgbWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3goaW5zdGFuY2UsIHsgdHJhbnNmb3JtUGFnZVBvaW50IH0pIHtcbiAgICByZXR1cm4gbWVhc3VyZVZpZXdwb3J0Qm94KGluc3RhbmNlLCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICB9XG4gIGJ1aWxkKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzKSB7XG4gICAgYnVpbGRIVE1MU3R5bGVzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgfVxuICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKTtcbiAgfVxuICByZW5kZXJJbnN0YW5jZShpbnN0YW5jZSwgcmVuZGVyU3RhdGUsIHN0eWxlUHJvcCwgcHJvamVjdGlvbikge1xuICAgIHJlbmRlckhUTUwoaW5zdGFuY2UsIHJlbmRlclN0YXRlLCBzdHlsZVByb3AsIHByb2plY3Rpb24pO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvU1ZHVmlzdWFsRWxlbWVudC5tanNcbnZhciBTVkdWaXN1YWxFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBET01WaXN1YWxFbGVtZW50IHtcbiAgZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyhwcm9wcywga2V5KSB7XG4gICAgcmV0dXJuIHByb3BzW2tleV07XG4gIH1cbiAgcmVhZFZhbHVlRnJvbUluc3RhbmNlKGluc3RhbmNlLCBrZXkpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gKChfYSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlZmF1bHQpIHx8IDA7XG4gICAgfVxuICAgIGtleSA9ICFjYW1lbENhc2VBdHRyaWJ1dGVzLmhhcyhrZXkpID8gY2FtZWxUb0Rhc2goa2V5KSA6IGtleTtcbiAgICByZXR1cm4gaW5zdGFuY2UuZ2V0QXR0cmlidXRlKGtleSk7XG4gIH1cbiAgbWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3goKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJveCgpO1xuICB9XG4gIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMyKHByb3BzKTtcbiAgfVxuICBidWlsZChyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBvcHRpb25zLCBwcm9wcykge1xuICAgIGJ1aWxkU1ZHQXR0cnMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICB9XG4gIHJlbmRlckluc3RhbmNlKGluc3RhbmNlLCByZW5kZXJTdGF0ZSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gICAgcmVuZGVyU1ZHKGluc3RhbmNlLCByZW5kZXJTdGF0ZSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL2NyZWF0ZS12aXN1YWwtZWxlbWVudC5tanNcbnZhciBjcmVhdGVEb21WaXN1YWxFbGVtZW50ID0gKENvbXBvbmVudCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KSA/IG5ldyBTVkdWaXN1YWxFbGVtZW50KG9wdGlvbnMsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IGZhbHNlIH0pIDogbmV3IEhUTUxWaXN1YWxFbGVtZW50KG9wdGlvbnMsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IHRydWUgfSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9sYXlvdXQvTWVhc3VyZUxheW91dC5tanNcbnZhciBpbXBvcnRfcmVhY3QyNyA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpLCAxKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1ib3JkZXItcmFkaXVzLm1qc1xuZnVuY3Rpb24gcGl4ZWxzVG9QZXJjZW50KHBpeGVscywgYXhpcykge1xuICBpZiAoYXhpcy5tYXggPT09IGF4aXMubWluKVxuICAgIHJldHVybiAwO1xuICByZXR1cm4gcGl4ZWxzIC8gKGF4aXMubWF4IC0gYXhpcy5taW4pICogMTAwO1xufVxudmFyIGNvcnJlY3RCb3JkZXJSYWRpdXMgPSB7XG4gIGNvcnJlY3Q6IChsYXRlc3QsIG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUudGFyZ2V0KVxuICAgICAgcmV0dXJuIGxhdGVzdDtcbiAgICBpZiAodHlwZW9mIGxhdGVzdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHB4LnRlc3QobGF0ZXN0KSkge1xuICAgICAgICBsYXRlc3QgPSBwYXJzZUZsb2F0KGxhdGVzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGF0ZXN0O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB4ID0gcGl4ZWxzVG9QZXJjZW50KGxhdGVzdCwgbm9kZS50YXJnZXQueCk7XG4gICAgY29uc3QgeSA9IHBpeGVsc1RvUGVyY2VudChsYXRlc3QsIG5vZGUudGFyZ2V0LnkpO1xuICAgIHJldHVybiBgJHt4fSUgJHt5fSVgO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWJveC1zaGFkb3cubWpzXG52YXIgdmFyVG9rZW4gPSBcIl8kY3NzXCI7XG52YXIgY29ycmVjdEJveFNoYWRvdyA9IHtcbiAgY29ycmVjdDogKGxhdGVzdCwgeyB0cmVlU2NhbGUsIHByb2plY3Rpb25EZWx0YSB9KSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSBsYXRlc3Q7XG4gICAgY29uc3QgY29udGFpbnNDU1NWYXJpYWJsZXMgPSBsYXRlc3QuaW5jbHVkZXMoXCJ2YXIoXCIpO1xuICAgIGNvbnN0IGNzc1ZhcmlhYmxlcyA9IFtdO1xuICAgIGlmIChjb250YWluc0NTU1ZhcmlhYmxlcykge1xuICAgICAgbGF0ZXN0ID0gbGF0ZXN0LnJlcGxhY2UoY3NzVmFyaWFibGVSZWdleCwgKG1hdGNoKSA9PiB7XG4gICAgICAgIGNzc1ZhcmlhYmxlcy5wdXNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHZhclRva2VuO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNoYWRvdyA9IGNvbXBsZXgucGFyc2UobGF0ZXN0KTtcbiAgICBpZiAoc2hhZG93Lmxlbmd0aCA+IDUpXG4gICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBjb21wbGV4LmNyZWF0ZVRyYW5zZm9ybWVyKGxhdGVzdCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdHlwZW9mIHNoYWRvd1swXSAhPT0gXCJudW1iZXJcIiA/IDEgOiAwO1xuICAgIGNvbnN0IHhTY2FsZSA9IHByb2plY3Rpb25EZWx0YS54LnNjYWxlICogdHJlZVNjYWxlLng7XG4gICAgY29uc3QgeVNjYWxlID0gcHJvamVjdGlvbkRlbHRhLnkuc2NhbGUgKiB0cmVlU2NhbGUueTtcbiAgICBzaGFkb3dbMCArIG9mZnNldF0gLz0geFNjYWxlO1xuICAgIHNoYWRvd1sxICsgb2Zmc2V0XSAvPSB5U2NhbGU7XG4gICAgY29uc3QgYXZlcmFnZVNjYWxlID0gbWl4KHhTY2FsZSwgeVNjYWxlLCAwLjUpO1xuICAgIGlmICh0eXBlb2Ygc2hhZG93WzIgKyBvZmZzZXRdID09PSBcIm51bWJlclwiKVxuICAgICAgc2hhZG93WzIgKyBvZmZzZXRdIC89IGF2ZXJhZ2VTY2FsZTtcbiAgICBpZiAodHlwZW9mIHNoYWRvd1szICsgb2Zmc2V0XSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHNoYWRvd1szICsgb2Zmc2V0XSAvPSBhdmVyYWdlU2NhbGU7XG4gICAgbGV0IG91dHB1dCA9IHRlbXBsYXRlKHNoYWRvdyk7XG4gICAgaWYgKGNvbnRhaW5zQ1NTVmFyaWFibGVzKSB7XG4gICAgICBsZXQgaTIgPSAwO1xuICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UodmFyVG9rZW4sICgpID0+IHtcbiAgICAgICAgY29uc3QgY3NzVmFyaWFibGUgPSBjc3NWYXJpYWJsZXNbaTJdO1xuICAgICAgICBpMisrO1xuICAgICAgICByZXR1cm4gY3NzVmFyaWFibGU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvbGF5b3V0L01lYXN1cmVMYXlvdXQubWpzXG52YXIgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfcmVhY3QyNy5kZWZhdWx0LkNvbXBvbmVudCB7XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCwgbGF5b3V0R3JvdXAsIHN3aXRjaExheW91dEdyb3VwLCBsYXlvdXRJZCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHZpc3VhbEVsZW1lbnQ7XG4gICAgYWRkU2NhbGVDb3JyZWN0b3IoZGVmYXVsdFNjYWxlQ29ycmVjdG9ycyk7XG4gICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgIGlmIChsYXlvdXRHcm91cC5ncm91cClcbiAgICAgICAgbGF5b3V0R3JvdXAuZ3JvdXAuYWRkKHByb2plY3Rpb24pO1xuICAgICAgaWYgKHN3aXRjaExheW91dEdyb3VwICYmIHN3aXRjaExheW91dEdyb3VwLnJlZ2lzdGVyICYmIGxheW91dElkKSB7XG4gICAgICAgIHN3aXRjaExheW91dEdyb3VwLnJlZ2lzdGVyKHByb2plY3Rpb24pO1xuICAgICAgfVxuICAgICAgcHJvamVjdGlvbi5yb290LmRpZFVwZGF0ZSgpO1xuICAgICAgcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uQ29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgICBwcm9qZWN0aW9uLnNldE9wdGlvbnMoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvamVjdGlvbi5vcHRpb25zKSwge1xuICAgICAgICBvbkV4aXRDb21wbGV0ZTogKCkgPT4gdGhpcy5zYWZlVG9SZW1vdmUoKVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzRXZlclVwZGF0ZWQgPSB0cnVlO1xuICB9XG4gIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGNvbnN0IHsgbGF5b3V0RGVwZW5kZW5jeSwgdmlzdWFsRWxlbWVudCwgZHJhZzogZHJhZzIsIGlzUHJlc2VudCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uO1xuICAgIGlmICghcHJvamVjdGlvbilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHByb2plY3Rpb24uaXNQcmVzZW50ID0gaXNQcmVzZW50O1xuICAgIGlmIChkcmFnMiB8fCBwcmV2UHJvcHMubGF5b3V0RGVwZW5kZW5jeSAhPT0gbGF5b3V0RGVwZW5kZW5jeSB8fCBsYXlvdXREZXBlbmRlbmN5ID09PSB2b2lkIDApIHtcbiAgICAgIHByb2plY3Rpb24ud2lsbFVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAocHJldlByb3BzLmlzUHJlc2VudCAhPT0gaXNQcmVzZW50KSB7XG4gICAgICBpZiAoaXNQcmVzZW50KSB7XG4gICAgICAgIHByb2plY3Rpb24ucHJvbW90ZSgpO1xuICAgICAgfSBlbHNlIGlmICghcHJvamVjdGlvbi5yZWxlZ2F0ZSgpKSB7XG4gICAgICAgIGVzX2RlZmF1bHQucG9zdFJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGlmICghKChfYSA9IHByb2plY3Rpb24uZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lbWJlcnMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnByb3BzLnZpc3VhbEVsZW1lbnQ7XG4gICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgIHByb2plY3Rpb24ucm9vdC5kaWRVcGRhdGUoKTtcbiAgICAgIGlmICghcHJvamVjdGlvbi5jdXJyZW50QW5pbWF0aW9uICYmIHByb2plY3Rpb24uaXNMZWFkKCkpIHtcbiAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgY29uc3QgeyB2aXN1YWxFbGVtZW50LCBsYXlvdXRHcm91cCwgc3dpdGNoTGF5b3V0R3JvdXA6IHByb21vdGVDb250ZXh0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgcHJvamVjdGlvbi5zY2hlZHVsZUNoZWNrQWZ0ZXJVbm1vdW50KCk7XG4gICAgICBpZiAobGF5b3V0R3JvdXAgPT09IG51bGwgfHwgbGF5b3V0R3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dEdyb3VwLmdyb3VwKVxuICAgICAgICBsYXlvdXRHcm91cC5ncm91cC5yZW1vdmUocHJvamVjdGlvbik7XG4gICAgICBpZiAocHJvbW90ZUNvbnRleHQgPT09IG51bGwgfHwgcHJvbW90ZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb21vdGVDb250ZXh0LmRlcmVnaXN0ZXIpXG4gICAgICAgIHByb21vdGVDb250ZXh0LmRlcmVnaXN0ZXIocHJvamVjdGlvbik7XG4gICAgfVxuICB9XG4gIHNhZmVUb1JlbW92ZSgpIHtcbiAgICBjb25zdCB7IHNhZmVUb1JlbW92ZSB9ID0gdGhpcy5wcm9wcztcbiAgICBzYWZlVG9SZW1vdmUgPT09IG51bGwgfHwgc2FmZVRvUmVtb3ZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzYWZlVG9SZW1vdmUoKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5mdW5jdGlvbiBNZWFzdXJlTGF5b3V0KHByb3BzKSB7XG4gIGNvbnN0IFtpc1ByZXNlbnQsIHNhZmVUb1JlbW92ZV0gPSB1c2VQcmVzZW5jZSgpO1xuICBjb25zdCBsYXlvdXRHcm91cCA9ICgwLCBpbXBvcnRfcmVhY3QyNy51c2VDb250ZXh0KShMYXlvdXRHcm91cENvbnRleHQpO1xuICByZXR1cm4gaW1wb3J0X3JlYWN0MjcuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpLCB7IGxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cDogKDAsIGltcG9ydF9yZWFjdDI3LnVzZUNvbnRleHQpKFN3aXRjaExheW91dEdyb3VwQ29udGV4dCksIGlzUHJlc2VudCwgc2FmZVRvUmVtb3ZlIH0pKTtcbn1cbnZhciBkZWZhdWx0U2NhbGVDb3JyZWN0b3JzID0ge1xuICBib3JkZXJSYWRpdXM6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGNvcnJlY3RCb3JkZXJSYWRpdXMpLCB7XG4gICAgYXBwbHlUbzogW1xuICAgICAgXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXG4gICAgICBcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXG4gICAgICBcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIixcbiAgICAgIFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIlxuICAgIF1cbiAgfSksXG4gIGJvcmRlclRvcExlZnRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgYm94U2hhZG93OiBjb3JyZWN0Qm94U2hhZG93XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9sYXlvdXQvaW5kZXgubWpzXG52YXIgbGF5b3V0RmVhdHVyZXMgPSB7XG4gIG1lYXN1cmVMYXlvdXQ6IE1lYXN1cmVMYXlvdXRcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2FuaW1hdGUubWpzXG5mdW5jdGlvbiBhbmltYXRlMihmcm9tLCB0bywgdHJhbnNpdGlvbiA9IHt9KSB7XG4gIGNvbnN0IHZhbHVlID0gaXNNb3Rpb25WYWx1ZShmcm9tKSA/IGZyb20gOiBtb3Rpb25WYWx1ZShmcm9tKTtcbiAgc3RhcnRBbmltYXRpb24oXCJcIiwgdmFsdWUsIHRvLCB0cmFuc2l0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICBzdG9wOiAoKSA9PiB2YWx1ZS5zdG9wKCksXG4gICAgaXNBbmltYXRpbmc6ICgpID0+IHZhbHVlLmlzQW5pbWF0aW5nKClcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2FuaW1hdGlvbi9taXgtdmFsdWVzLm1qc1xudmFyIGJvcmRlcnMgPSBbXCJUb3BMZWZ0XCIsIFwiVG9wUmlnaHRcIiwgXCJCb3R0b21MZWZ0XCIsIFwiQm90dG9tUmlnaHRcIl07XG52YXIgbnVtQm9yZGVycyA9IGJvcmRlcnMubGVuZ3RoO1xudmFyIGFzTnVtYmVyID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHZhbHVlO1xudmFyIGlzUHggPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBweC50ZXN0KHZhbHVlKTtcbmZ1bmN0aW9uIG1peFZhbHVlcyh0YXJnZXQsIGZvbGxvdywgbGVhZCwgcHJvZ3Jlc3MzLCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5LCBpc09ubHlNZW1iZXIpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBpZiAoc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSkge1xuICAgIHRhcmdldC5vcGFjaXR5ID0gbWl4KFxuICAgICAgMCxcbiAgICAgIChfYSA9IGxlYWQub3BhY2l0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSxcbiAgICAgIGVhc2VDcm9zc2ZhZGVJbihwcm9ncmVzczMpXG4gICAgKTtcbiAgICB0YXJnZXQub3BhY2l0eUV4aXQgPSBtaXgoKF9iID0gZm9sbG93Lm9wYWNpdHkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEsIDAsIGVhc2VDcm9zc2ZhZGVPdXQocHJvZ3Jlc3MzKSk7XG4gIH0gZWxzZSBpZiAoaXNPbmx5TWVtYmVyKSB7XG4gICAgdGFyZ2V0Lm9wYWNpdHkgPSBtaXgoKF9jID0gZm9sbG93Lm9wYWNpdHkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDEsIChfZCA9IGxlYWQub3BhY2l0eSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMSwgcHJvZ3Jlc3MzKTtcbiAgfVxuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtQm9yZGVyczsgaTIrKykge1xuICAgIGNvbnN0IGJvcmRlckxhYmVsID0gYGJvcmRlciR7Ym9yZGVyc1tpMl19UmFkaXVzYDtcbiAgICBsZXQgZm9sbG93UmFkaXVzID0gZ2V0UmFkaXVzKGZvbGxvdywgYm9yZGVyTGFiZWwpO1xuICAgIGxldCBsZWFkUmFkaXVzID0gZ2V0UmFkaXVzKGxlYWQsIGJvcmRlckxhYmVsKTtcbiAgICBpZiAoZm9sbG93UmFkaXVzID09PSB2b2lkIDAgJiYgbGVhZFJhZGl1cyA9PT0gdm9pZCAwKVxuICAgICAgY29udGludWU7XG4gICAgZm9sbG93UmFkaXVzIHx8IChmb2xsb3dSYWRpdXMgPSAwKTtcbiAgICBsZWFkUmFkaXVzIHx8IChsZWFkUmFkaXVzID0gMCk7XG4gICAgY29uc3QgY2FuTWl4ID0gZm9sbG93UmFkaXVzID09PSAwIHx8IGxlYWRSYWRpdXMgPT09IDAgfHwgaXNQeChmb2xsb3dSYWRpdXMpID09PSBpc1B4KGxlYWRSYWRpdXMpO1xuICAgIGlmIChjYW5NaXgpIHtcbiAgICAgIHRhcmdldFtib3JkZXJMYWJlbF0gPSBNYXRoLm1heChtaXgoYXNOdW1iZXIoZm9sbG93UmFkaXVzKSwgYXNOdW1iZXIobGVhZFJhZGl1cyksIHByb2dyZXNzMyksIDApO1xuICAgICAgaWYgKHBlcmNlbnQudGVzdChsZWFkUmFkaXVzKSB8fCBwZXJjZW50LnRlc3QoZm9sbG93UmFkaXVzKSkge1xuICAgICAgICB0YXJnZXRbYm9yZGVyTGFiZWxdICs9IFwiJVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRbYm9yZGVyTGFiZWxdID0gbGVhZFJhZGl1cztcbiAgICB9XG4gIH1cbiAgaWYgKGZvbGxvdy5yb3RhdGUgfHwgbGVhZC5yb3RhdGUpIHtcbiAgICB0YXJnZXQucm90YXRlID0gbWl4KGZvbGxvdy5yb3RhdGUgfHwgMCwgbGVhZC5yb3RhdGUgfHwgMCwgcHJvZ3Jlc3MzKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmFkaXVzKHZhbHVlcywgcmFkaXVzTmFtZSkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSB2YWx1ZXNbcmFkaXVzTmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlcy5ib3JkZXJSYWRpdXM7XG59XG52YXIgZWFzZUNyb3NzZmFkZUluID0gY29tcHJlc3MoMCwgMC41LCBjaXJjT3V0KTtcbnZhciBlYXNlQ3Jvc3NmYWRlT3V0ID0gY29tcHJlc3MoMC41LCAwLjk1LCBsaW5lYXIpO1xuZnVuY3Rpb24gY29tcHJlc3MobWluLCBtYXgsIGVhc2luZykge1xuICByZXR1cm4gKHAyKSA9PiB7XG4gICAgaWYgKHAyIDwgbWluKVxuICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHAyID4gbWF4KVxuICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIGVhc2luZyhwcm9ncmVzcyhtaW4sIG1heCwgcDIpKTtcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2NvcHkubWpzXG5mdW5jdGlvbiBjb3B5QXhpc0ludG8oYXhpcywgb3JpZ2luQXhpcykge1xuICBheGlzLm1pbiA9IG9yaWdpbkF4aXMubWluO1xuICBheGlzLm1heCA9IG9yaWdpbkF4aXMubWF4O1xufVxuZnVuY3Rpb24gY29weUJveEludG8oYm94LCBvcmlnaW5Cb3gpIHtcbiAgY29weUF4aXNJbnRvKGJveC54LCBvcmlnaW5Cb3gueCk7XG4gIGNvcHlBeGlzSW50byhib3gueSwgb3JpZ2luQm94LnkpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvZGVsdGEtcmVtb3ZlLm1qc1xuZnVuY3Rpb24gcmVtb3ZlUG9pbnREZWx0YShwb2ludDIsIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgcG9pbnQyIC09IHRyYW5zbGF0ZTtcbiAgcG9pbnQyID0gc2NhbGVQb2ludChwb2ludDIsIDEgLyBzY2FsZTIsIG9yaWdpblBvaW50KTtcbiAgaWYgKGJveFNjYWxlICE9PSB2b2lkIDApIHtcbiAgICBwb2ludDIgPSBzY2FsZVBvaW50KHBvaW50MiwgMSAvIGJveFNjYWxlLCBvcmlnaW5Qb2ludCk7XG4gIH1cbiAgcmV0dXJuIHBvaW50Mjtcbn1cbmZ1bmN0aW9uIHJlbW92ZUF4aXNEZWx0YShheGlzLCB0cmFuc2xhdGUgPSAwLCBzY2FsZTIgPSAxLCBvcmlnaW4gPSAwLjUsIGJveFNjYWxlLCBvcmlnaW5BeGlzID0gYXhpcywgc291cmNlQXhpcyA9IGF4aXMpIHtcbiAgaWYgKHBlcmNlbnQudGVzdCh0cmFuc2xhdGUpKSB7XG4gICAgdHJhbnNsYXRlID0gcGFyc2VGbG9hdCh0cmFuc2xhdGUpO1xuICAgIGNvbnN0IHJlbGF0aXZlUHJvZ3Jlc3MgPSBtaXgoc291cmNlQXhpcy5taW4sIHNvdXJjZUF4aXMubWF4LCB0cmFuc2xhdGUgLyAxMDApO1xuICAgIHRyYW5zbGF0ZSA9IHJlbGF0aXZlUHJvZ3Jlc3MgLSBzb3VyY2VBeGlzLm1pbjtcbiAgfVxuICBpZiAodHlwZW9mIHRyYW5zbGF0ZSAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm47XG4gIGxldCBvcmlnaW5Qb2ludCA9IG1peChvcmlnaW5BeGlzLm1pbiwgb3JpZ2luQXhpcy5tYXgsIG9yaWdpbik7XG4gIGlmIChheGlzID09PSBvcmlnaW5BeGlzKVxuICAgIG9yaWdpblBvaW50IC09IHRyYW5zbGF0ZTtcbiAgYXhpcy5taW4gPSByZW1vdmVQb2ludERlbHRhKGF4aXMubWluLCB0cmFuc2xhdGUsIHNjYWxlMiwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbiAgYXhpcy5tYXggPSByZW1vdmVQb2ludERlbHRhKGF4aXMubWF4LCB0cmFuc2xhdGUsIHNjYWxlMiwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGF4aXMsIHRyYW5zZm9ybXMsIFtrZXksIHNjYWxlS2V5LCBvcmlnaW5LZXldLCBvcmlnaW4sIHNvdXJjZUF4aXMpIHtcbiAgcmVtb3ZlQXhpc0RlbHRhKGF4aXMsIHRyYW5zZm9ybXNba2V5XSwgdHJhbnNmb3Jtc1tzY2FsZUtleV0sIHRyYW5zZm9ybXNbb3JpZ2luS2V5XSwgdHJhbnNmb3Jtcy5zY2FsZSwgb3JpZ2luLCBzb3VyY2VBeGlzKTtcbn1cbnZhciB4S2V5czIgPSBbXCJ4XCIsIFwic2NhbGVYXCIsIFwib3JpZ2luWFwiXTtcbnZhciB5S2V5czIgPSBbXCJ5XCIsIFwic2NhbGVZXCIsIFwib3JpZ2luWVwiXTtcbmZ1bmN0aW9uIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94LCB0cmFuc2Zvcm1zLCBvcmlnaW5Cb3gsIHNvdXJjZUJveCkge1xuICByZW1vdmVBeGlzVHJhbnNmb3Jtcyhib3gueCwgdHJhbnNmb3JtcywgeEtleXMyLCBvcmlnaW5Cb3ggPT09IG51bGwgfHwgb3JpZ2luQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5Cb3gueCwgc291cmNlQm94ID09PSBudWxsIHx8IHNvdXJjZUJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlQm94LngpO1xuICByZW1vdmVBeGlzVHJhbnNmb3Jtcyhib3gueSwgdHJhbnNmb3JtcywgeUtleXMyLCBvcmlnaW5Cb3ggPT09IG51bGwgfHwgb3JpZ2luQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5Cb3gueSwgc291cmNlQm94ID09PSBudWxsIHx8IHNvdXJjZUJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlQm94LnkpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvdXRpbHMubWpzXG5mdW5jdGlvbiBpc0F4aXNEZWx0YVplcm8oZGVsdGEpIHtcbiAgcmV0dXJuIGRlbHRhLnRyYW5zbGF0ZSA9PT0gMCAmJiBkZWx0YS5zY2FsZSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGlzRGVsdGFaZXJvKGRlbHRhKSB7XG4gIHJldHVybiBpc0F4aXNEZWx0YVplcm8oZGVsdGEueCkgJiYgaXNBeGlzRGVsdGFaZXJvKGRlbHRhLnkpO1xufVxuZnVuY3Rpb24gYm94RXF1YWxzKGEyLCBiMikge1xuICByZXR1cm4gYTIueC5taW4gPT09IGIyLngubWluICYmIGEyLngubWF4ID09PSBiMi54Lm1heCAmJiBhMi55Lm1pbiA9PT0gYjIueS5taW4gJiYgYTIueS5tYXggPT09IGIyLnkubWF4O1xufVxuZnVuY3Rpb24gYXNwZWN0UmF0aW8oYm94KSB7XG4gIHJldHVybiBjYWxjTGVuZ3RoKGJveC54KSAvIGNhbGNMZW5ndGgoYm94LnkpO1xufVxuZnVuY3Rpb24gaXNDbG9zZVRvKGEyLCBiMiwgbWF4ID0gMC4xKSB7XG4gIHJldHVybiBkaXN0YW5jZShhMiwgYjIpIDw9IG1heDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3NoYXJlZC9zdGFjay5tanNcbnZhciBOb2RlU3RhY2sgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWVtYmVycyA9IFtdO1xuICB9XG4gIGFkZChub2RlKSB7XG4gICAgYWRkVW5pcXVlSXRlbSh0aGlzLm1lbWJlcnMsIG5vZGUpO1xuICAgIG5vZGUuc2NoZWR1bGVSZW5kZXIoKTtcbiAgfVxuICByZW1vdmUobm9kZSkge1xuICAgIHJlbW92ZUl0ZW0odGhpcy5tZW1iZXJzLCBub2RlKTtcbiAgICBpZiAobm9kZSA9PT0gdGhpcy5wcmV2TGVhZCkge1xuICAgICAgdGhpcy5wcmV2TGVhZCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IHRoaXMubGVhZCkge1xuICAgICAgY29uc3QgcHJldkxlYWQgPSB0aGlzLm1lbWJlcnNbdGhpcy5tZW1iZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgIHRoaXMucHJvbW90ZShwcmV2TGVhZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbGVnYXRlKG5vZGUpIHtcbiAgICBjb25zdCBpbmRleE9mTm9kZSA9IHRoaXMubWVtYmVycy5maW5kSW5kZXgoKG1lbWJlcikgPT4gbm9kZSA9PT0gbWVtYmVyKTtcbiAgICBpZiAoaW5kZXhPZk5vZGUgPT09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHByZXZMZWFkO1xuICAgIGZvciAobGV0IGkyID0gaW5kZXhPZk5vZGU7IGkyID49IDA7IGkyLS0pIHtcbiAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMubWVtYmVyc1tpMl07XG4gICAgICBpZiAobWVtYmVyLmlzUHJlc2VudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgcHJldkxlYWQgPSBtZW1iZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldkxlYWQpIHtcbiAgICAgIHRoaXMucHJvbW90ZShwcmV2TGVhZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBwcm9tb3RlKG5vZGUsIHByZXNlcnZlRm9sbG93T3BhY2l0eSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcmV2TGVhZCA9IHRoaXMubGVhZDtcbiAgICBpZiAobm9kZSA9PT0gcHJldkxlYWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5wcmV2TGVhZCA9IHByZXZMZWFkO1xuICAgIHRoaXMubGVhZCA9IG5vZGU7XG4gICAgbm9kZS5zaG93KCk7XG4gICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICBwcmV2TGVhZC5pbnN0YW5jZSAmJiBwcmV2TGVhZC5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgbm9kZS5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgbm9kZS5yZXN1bWVGcm9tID0gcHJldkxlYWQ7XG4gICAgICBpZiAocHJlc2VydmVGb2xsb3dPcGFjaXR5KSB7XG4gICAgICAgIG5vZGUucmVzdW1lRnJvbS5wcmVzZXJ2ZU9wYWNpdHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZMZWFkLnNuYXBzaG90KSB7XG4gICAgICAgIG5vZGUuc25hcHNob3QgPSBwcmV2TGVhZC5zbmFwc2hvdDtcbiAgICAgICAgbm9kZS5zbmFwc2hvdC5sYXRlc3RWYWx1ZXMgPSBwcmV2TGVhZC5hbmltYXRpb25WYWx1ZXMgfHwgcHJldkxlYWQubGF0ZXN0VmFsdWVzO1xuICAgICAgICBub2RlLnNuYXBzaG90LmlzU2hhcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICgoX2EgPSBub2RlLnJvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1VwZGF0aW5nKSB7XG4gICAgICAgIG5vZGUuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGNyb3NzZmFkZSB9ID0gbm9kZS5vcHRpb25zO1xuICAgICAgaWYgKGNyb3NzZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcHJldkxlYWQuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBleGl0QW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgdGhpcy5tZW1iZXJzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAoX2IgPSAoX2EgPSBub2RlLm9wdGlvbnMpLm9uRXhpdENvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAoX2UgPSAoX2MgPSBub2RlLnJlc3VtaW5nRnJvbSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZCA9IF9jLm9wdGlvbnMpLm9uRXhpdENvbXBsZXRlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCk7XG4gICAgfSk7XG4gIH1cbiAgc2NoZWR1bGVSZW5kZXIoKSB7XG4gICAgdGhpcy5tZW1iZXJzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5vZGUuaW5zdGFuY2UgJiYgbm9kZS5zY2hlZHVsZVJlbmRlcihmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlTGVhZFNuYXBzaG90KCkge1xuICAgIGlmICh0aGlzLmxlYWQgJiYgdGhpcy5sZWFkLnNuYXBzaG90KSB7XG4gICAgICB0aGlzLmxlYWQuc25hcHNob3QgPSB2b2lkIDA7XG4gICAgfVxuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3RyYW5zZm9ybS5tanNcbnZhciBpZGVudGl0eVByb2plY3Rpb24gPSBcInRyYW5zbGF0ZTNkKDBweCwgMHB4LCAwKSBzY2FsZSgxLCAxKSBzY2FsZSgxLCAxKVwiO1xuZnVuY3Rpb24gYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtKGRlbHRhLCB0cmVlU2NhbGUsIGxhdGVzdFRyYW5zZm9ybSkge1xuICBjb25zdCB4VHJhbnNsYXRlID0gZGVsdGEueC50cmFuc2xhdGUgLyB0cmVlU2NhbGUueDtcbiAgY29uc3QgeVRyYW5zbGF0ZSA9IGRlbHRhLnkudHJhbnNsYXRlIC8gdHJlZVNjYWxlLnk7XG4gIGxldCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4VHJhbnNsYXRlfXB4LCAke3lUcmFuc2xhdGV9cHgsIDApIGA7XG4gIHRyYW5zZm9ybSArPSBgc2NhbGUoJHsxIC8gdHJlZVNjYWxlLnh9LCAkezEgLyB0cmVlU2NhbGUueX0pIGA7XG4gIGlmIChsYXRlc3RUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCB7IHJvdGF0ZSwgcm90YXRlWCwgcm90YXRlWSB9ID0gbGF0ZXN0VHJhbnNmb3JtO1xuICAgIGlmIChyb3RhdGUpXG4gICAgICB0cmFuc2Zvcm0gKz0gYHJvdGF0ZSgke3JvdGF0ZX1kZWcpIGA7XG4gICAgaWYgKHJvdGF0ZVgpXG4gICAgICB0cmFuc2Zvcm0gKz0gYHJvdGF0ZVgoJHtyb3RhdGVYfWRlZykgYDtcbiAgICBpZiAocm90YXRlWSlcbiAgICAgIHRyYW5zZm9ybSArPSBgcm90YXRlWSgke3JvdGF0ZVl9ZGVnKSBgO1xuICB9XG4gIGNvbnN0IGVsZW1lbnRTY2FsZVggPSBkZWx0YS54LnNjYWxlICogdHJlZVNjYWxlLng7XG4gIGNvbnN0IGVsZW1lbnRTY2FsZVkgPSBkZWx0YS55LnNjYWxlICogdHJlZVNjYWxlLnk7XG4gIHRyYW5zZm9ybSArPSBgc2NhbGUoJHtlbGVtZW50U2NhbGVYfSwgJHtlbGVtZW50U2NhbGVZfSlgO1xuICByZXR1cm4gdHJhbnNmb3JtID09PSBpZGVudGl0eVByb2plY3Rpb24gPyBcIm5vbmVcIiA6IHRyYW5zZm9ybTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvY29tcGFyZS1ieS1kZXB0aC5tanNcbnZhciBjb21wYXJlQnlEZXB0aCA9IChhMiwgYjIpID0+IGEyLmRlcHRoIC0gYjIuZGVwdGg7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2ZsYXQtdHJlZS5tanNcbnZhciBGbGF0VHJlZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICB9XG4gIGFkZChjaGlsZCkge1xuICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xuICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gIH1cbiAgcmVtb3ZlKGNoaWxkKSB7XG4gICAgcmVtb3ZlSXRlbSh0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XG4gICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgfVxuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pc0RpcnR5ICYmIHRoaXMuY2hpbGRyZW4uc29ydChjb21wYXJlQnlEZXB0aCk7XG4gICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvY3JlYXRlLXByb2plY3Rpb24tbm9kZS5tanNcbnZhciB0cmFuc2Zvcm1BeGVzID0gW1wiXCIsIFwiWFwiLCBcIllcIiwgXCJaXCJdO1xudmFyIGFuaW1hdGlvblRhcmdldCA9IDFlMztcbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3Rpb25Ob2RlKHsgYXR0YWNoUmVzaXplTGlzdGVuZXIsIGRlZmF1bHRQYXJlbnQsIG1lYXN1cmVTY3JvbGwsIGNoZWNrSXNTY3JvbGxSb290LCByZXNldFRyYW5zZm9ybSB9KSB7XG4gIHJldHVybiBjbGFzcyBQcm9qZWN0aW9uTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudElkLCBsYXRlc3RWYWx1ZXMgPSB7fSwgcGFyZW50ID0gZGVmYXVsdFBhcmVudCA9PT0gbnVsbCB8fCBkZWZhdWx0UGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZhdWx0UGFyZW50KCkpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmlzVHJlZUFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0FuaW1hdGlvbkJsb2NrZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xuICAgICAgdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMudXBkYXRlQmxvY2tlZEJ5UmVzaXplID0gZmFsc2U7XG4gICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNTVkcgPSBmYWxzZTtcbiAgICAgIHRoaXMubmVlZHNSZXNldCA9IGZhbHNlO1xuICAgICAgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgdGhpcy50cmVlU2NhbGUgPSB7IHg6IDEsIHk6IDEgfTtcbiAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnBvdGVudGlhbE5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuY2hlY2tVcGRhdGVGYWlsZWQgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNsZWFyQWxsU25hcHNob3RzKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChyZXNvbHZlVGFyZ2V0RGVsdGEpO1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2FsY1Byb2plY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzID0gMDtcbiAgICAgIHRoaXMuc2hhcmVkTm9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5lbGVtZW50SWQgPSBlbGVtZW50SWQ7XG4gICAgICB0aGlzLmxhdGVzdFZhbHVlcyA9IGxhdGVzdFZhbHVlcztcbiAgICAgIHRoaXMucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IHx8IHBhcmVudCA6IHRoaXM7XG4gICAgICB0aGlzLnBhdGggPSBwYXJlbnQgPyBbLi4ucGFyZW50LnBhdGgsIHBhcmVudF0gOiBbXTtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy5kZXB0aCA9IHBhcmVudCA/IHBhcmVudC5kZXB0aCArIDEgOiAwO1xuICAgICAgZWxlbWVudElkICYmIHRoaXMucm9vdC5yZWdpc3RlclBvdGVudGlhbE5vZGUoZWxlbWVudElkLCB0aGlzKTtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0aGlzLnBhdGgubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIHRoaXMucGF0aFtpMl0uc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucm9vdCA9PT0gdGhpcylcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5ldyBGbGF0VHJlZSgpO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghdGhpcy5ldmVudEhhbmRsZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMuc2V0KG5hbWUsIG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRIYW5kbGVycy5nZXQobmFtZSkuYWRkKGhhbmRsZXIpO1xuICAgIH1cbiAgICBub3RpZnlMaXN0ZW5lcnMobmFtZSwgLi4uYXJncykge1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uTWFuYWdlciA9IHRoaXMuZXZlbnRIYW5kbGVycy5nZXQobmFtZSk7XG4gICAgICBzdWJzY3JpcHRpb25NYW5hZ2VyID09PSBudWxsIHx8IHN1YnNjcmlwdGlvbk1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YnNjcmlwdGlvbk1hbmFnZXIubm90aWZ5KC4uLmFyZ3MpO1xuICAgIH1cbiAgICBoYXNMaXN0ZW5lcnMobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRIYW5kbGVycy5oYXMobmFtZSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyUG90ZW50aWFsTm9kZShpZDIsIG5vZGUpIHtcbiAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMuc2V0KGlkMiwgbm9kZSk7XG4gICAgfVxuICAgIG1vdW50KGluc3RhbmNlLCBpc0xheW91dERpcnR5ID0gZmFsc2UpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICh0aGlzLmluc3RhbmNlKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmlzU1ZHID0gaW5zdGFuY2UgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIGluc3RhbmNlLnRhZ05hbWUgIT09IFwic3ZnXCI7XG4gICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICBjb25zdCB7IGxheW91dElkLCBsYXlvdXQsIHZpc3VhbEVsZW1lbnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmICh2aXN1YWxFbGVtZW50ICYmICF2aXN1YWxFbGVtZW50LmN1cnJlbnQpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5tb3VudChpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJvb3Qubm9kZXMuYWRkKHRoaXMpO1xuICAgICAgKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGlsZHJlbi5hZGQodGhpcyk7XG4gICAgICB0aGlzLmVsZW1lbnRJZCAmJiB0aGlzLnJvb3QucG90ZW50aWFsTm9kZXMuZGVsZXRlKHRoaXMuZWxlbWVudElkKTtcbiAgICAgIGlmIChpc0xheW91dERpcnR5ICYmIChsYXlvdXQgfHwgbGF5b3V0SWQpKSB7XG4gICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYXR0YWNoUmVzaXplTGlzdGVuZXIpIHtcbiAgICAgICAgbGV0IGNhbmNlbERlbGF5O1xuICAgICAgICBjb25zdCByZXNpemVVbmJsb2NrVXBkYXRlID0gKCkgPT4gdGhpcy5yb290LnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICBhdHRhY2hSZXNpemVMaXN0ZW5lcihpbnN0YW5jZSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMucm9vdC51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSB0cnVlO1xuICAgICAgICAgIGNhbmNlbERlbGF5ICYmIGNhbmNlbERlbGF5KCk7XG4gICAgICAgICAgY2FuY2VsRGVsYXkgPSBkZWxheShyZXNpemVVbmJsb2NrVXBkYXRlLCAyNTApO1xuICAgICAgICAgIGlmIChnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSkge1xuICAgICAgICAgICAgZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0FuaW1hdGVkU2luY2VSZXNpemUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChmaW5pc2hBbmltYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobGF5b3V0SWQpIHtcbiAgICAgICAgdGhpcy5yb290LnJlZ2lzdGVyU2hhcmVkTm9kZShsYXlvdXRJZCwgdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlICYmIHZpc3VhbEVsZW1lbnQgJiYgKGxheW91dElkIHx8IGxheW91dCkpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiZGlkVXBkYXRlXCIsICh7IGRlbHRhLCBoYXNMYXlvdXRDaGFuZ2VkLCBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQsIGxheW91dDogbmV3TGF5b3V0IH0pID0+IHtcbiAgICAgICAgICB2YXIgX2EyLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICBpZiAodGhpcy5pc1RyZWVBbmltYXRpb25CbG9ja2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbGF5b3V0VHJhbnNpdGlvbiA9IChfYiA9IChfYTIgPSB0aGlzLm9wdGlvbnMudHJhbnNpdGlvbikgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiB2aXN1YWxFbGVtZW50LmdldERlZmF1bHRUcmFuc2l0aW9uKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRMYXlvdXRUcmFuc2l0aW9uO1xuICAgICAgICAgIGNvbnN0IHsgb25MYXlvdXRBbmltYXRpb25TdGFydCwgb25MYXlvdXRBbmltYXRpb25Db21wbGV0ZSB9ID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgICAgIGNvbnN0IHRhcmdldENoYW5nZWQgPSAhdGhpcy50YXJnZXRMYXlvdXQgfHwgIWJveEVxdWFscyh0aGlzLnRhcmdldExheW91dCwgbmV3TGF5b3V0KSB8fCBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgY29uc3QgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9ICFoYXNMYXlvdXRDaGFuZ2VkICYmIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZDtcbiAgICAgICAgICBpZiAoKChfYyA9IHRoaXMucmVzdW1lRnJvbSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmluc3RhbmNlKSB8fCBoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkIHx8IGhhc0xheW91dENoYW5nZWQgJiYgKHRhcmdldENoYW5nZWQgfHwgIXRoaXMuY3VycmVudEFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtZUZyb20pIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20gPSB0aGlzLnJlc3VtZUZyb207XG4gICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLnJlc3VtaW5nRnJvbSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uT3JpZ2luKGRlbHRhLCBoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBnZXRWYWx1ZVRyYW5zaXRpb24obGF5b3V0VHJhbnNpdGlvbiwgXCJsYXlvdXRcIikpLCB7XG4gICAgICAgICAgICAgIG9uUGxheTogb25MYXlvdXRBbmltYXRpb25TdGFydCxcbiAgICAgICAgICAgICAgb25Db21wbGV0ZTogb25MYXlvdXRBbmltYXRpb25Db21wbGV0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmlzdWFsRWxlbWVudC5zaG91bGRSZWR1Y2VNb3Rpb24pIHtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9ucy5kZWxheSA9IDA7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMudHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbihhbmltYXRpb25PcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNMYXlvdXRDaGFuZ2VkICYmIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPT09IDApIHtcbiAgICAgICAgICAgICAgZmluaXNoQW5pbWF0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc0xlYWQoKSAmJiAoKF9lID0gKF9kID0gdGhpcy5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50YXJnZXRMYXlvdXQgPSBuZXdMYXlvdXQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB1bm1vdW50KCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHRoaXMub3B0aW9ucy5sYXlvdXRJZCAmJiB0aGlzLndpbGxVcGRhdGUoKTtcbiAgICAgIHRoaXMucm9vdC5ub2Rlcy5yZW1vdmUodGhpcyk7XG4gICAgICAoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUodGhpcyk7XG4gICAgICAoX2IgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoaWxkcmVuLmRlbGV0ZSh0aGlzKTtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgICBjYW5jZWxTeW5jLnByZVJlbmRlcih0aGlzLnVwZGF0ZVByb2plY3Rpb24pO1xuICAgIH1cbiAgICBibG9ja1VwZGF0ZSgpIHtcbiAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdW5ibG9ja1VwZGF0ZSgpIHtcbiAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICAgIGlzVXBkYXRlQmxvY2tlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCB8fCB0aGlzLnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZTtcbiAgICB9XG4gICAgaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiB0aGlzLmlzQW5pbWF0aW9uQmxvY2tlZCB8fCAoKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1RyZWVBbmltYXRpb25CbG9ja2VkKCkpIHx8IGZhbHNlO1xuICAgIH1cbiAgICBzdGFydFVwZGF0ZSgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICh0aGlzLmlzVXBkYXRlQmxvY2tlZCgpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmlzVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgKF9hID0gdGhpcy5ub2RlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2gocmVzZXRSb3RhdGlvbik7XG4gICAgfVxuICAgIHdpbGxVcGRhdGUoc2hvdWxkTm90aWZ5TGlzdGVuZXJzID0gdHJ1ZSkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBpZiAodGhpcy5yb290LmlzVXBkYXRlQmxvY2tlZCgpKSB7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgIXRoaXMucm9vdC5pc1VwZGF0aW5nICYmIHRoaXMucm9vdC5zdGFydFVwZGF0ZSgpO1xuICAgICAgaWYgKHRoaXMuaXNMYXlvdXREaXJ0eSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0aGlzLnBhdGgubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaTJdO1xuICAgICAgICBub2RlLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgbm9kZS51cGRhdGVTY3JvbGwoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbGF5b3V0SWQsIGxheW91dCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKGxheW91dElkID09PSB2b2lkIDAgJiYgIWxheW91dClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGUgPSAoX2MgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlID0gdHJhbnNmb3JtVGVtcGxhdGUgPT09IG51bGwgfHwgdHJhbnNmb3JtVGVtcGxhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKTtcbiAgICAgIHRoaXMudXBkYXRlU25hcHNob3QoKTtcbiAgICAgIHNob3VsZE5vdGlmeUxpc3RlbmVycyAmJiB0aGlzLm5vdGlmeUxpc3RlbmVycyhcIndpbGxVcGRhdGVcIik7XG4gICAgfVxuICAgIGRpZFVwZGF0ZSgpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZVdhc0Jsb2NrZWQgPSB0aGlzLmlzVXBkYXRlQmxvY2tlZCgpO1xuICAgICAgaWYgKHVwZGF0ZVdhc0Jsb2NrZWQpIHtcbiAgICAgICAgdGhpcy51bmJsb2NrVXBkYXRlKCk7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNsZWFyTWVhc3VyZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzVXBkYXRpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMucG90ZW50aWFsTm9kZXMuc2l6ZSkge1xuICAgICAgICB0aGlzLnBvdGVudGlhbE5vZGVzLmZvckVhY2gobW91bnROb2RlRWFybHkpO1xuICAgICAgICB0aGlzLnBvdGVudGlhbE5vZGVzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm5vZGVzLmZvckVhY2gocmVzZXRUcmFuc2Zvcm1TdHlsZSk7XG4gICAgICB0aGlzLm5vZGVzLmZvckVhY2godXBkYXRlTGF5b3V0KTtcbiAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChub3RpZnlMYXlvdXRVcGRhdGUpO1xuICAgICAgdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgZmx1c2hTeW5jLnVwZGF0ZSgpO1xuICAgICAgZmx1c2hTeW5jLnByZVJlbmRlcigpO1xuICAgICAgZmx1c2hTeW5jLnJlbmRlcigpO1xuICAgIH1cbiAgICBjbGVhckFsbFNuYXBzaG90cygpIHtcbiAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChjbGVhclNuYXBzaG90KTtcbiAgICAgIHRoaXMuc2hhcmVkTm9kZXMuZm9yRWFjaChyZW1vdmVMZWFkU25hcHNob3RzKTtcbiAgICB9XG4gICAgc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uKCkge1xuICAgICAgZXNfZGVmYXVsdC5wcmVSZW5kZXIodGhpcy51cGRhdGVQcm9qZWN0aW9uLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQoKSB7XG4gICAgICBlc19kZWZhdWx0LnBvc3RSZW5kZXIoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc0xheW91dERpcnR5KSB7XG4gICAgICAgICAgdGhpcy5yb290LmRpZFVwZGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucm9vdC5jaGVja1VwZGF0ZUZhaWxlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlU25hcHNob3QoKSB7XG4gICAgICBpZiAodGhpcy5zbmFwc2hvdCB8fCAhdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5zbmFwc2hvdCA9IHRoaXMubWVhc3VyZSgpO1xuICAgIH1cbiAgICB1cGRhdGVMYXlvdXQoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMudXBkYXRlU2Nyb2xsKCk7XG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMuYWx3YXlzTWVhc3VyZUxheW91dCAmJiB0aGlzLmlzTGVhZCgpKSAmJiAhdGhpcy5pc0xheW91dERpcnR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlc3VtZUZyb20gJiYgIXRoaXMucmVzdW1lRnJvbS5pbnN0YW5jZSkge1xuICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgdGhpcy5wYXRoLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaTJdO1xuICAgICAgICAgIG5vZGUudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZMYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICAgIHRoaXMubGF5b3V0ID0gdGhpcy5tZWFzdXJlKGZhbHNlKTtcbiAgICAgIHRoaXMubGF5b3V0Q29ycmVjdGVkID0gY3JlYXRlQm94KCk7XG4gICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gdm9pZCAwO1xuICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJtZWFzdXJlXCIsIHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAoX2EgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vdGlmeShcIkxheW91dE1lYXN1cmVcIiwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCBwcmV2TGF5b3V0ID09PSBudWxsIHx8IHByZXZMYXlvdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZMYXlvdXQubGF5b3V0Qm94KTtcbiAgICB9XG4gICAgdXBkYXRlU2Nyb2xsKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiYgdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmlzU2Nyb2xsUm9vdCA9IGNoZWNrSXNTY3JvbGxSb290KHRoaXMuaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLnNjcm9sbCA9IG1lYXN1cmVTY3JvbGwodGhpcy5pbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2V0VHJhbnNmb3JtKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFyZXNldFRyYW5zZm9ybSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaXNSZXNldFJlcXVlc3RlZCA9IHRoaXMuaXNMYXlvdXREaXJ0eSB8fCB0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtO1xuICAgICAgY29uc3QgaGFzUHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbkRlbHRhICYmICFpc0RlbHRhWmVybyh0aGlzLnByb2plY3Rpb25EZWx0YSk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZSA9IChfYSA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UHJvcHMoKS50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB0cmFuc2Zvcm1UZW1wbGF0ZSA9PT0gbnVsbCB8fCB0cmFuc2Zvcm1UZW1wbGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGVIYXNDaGFuZ2VkID0gdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSAhPT0gdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZTtcbiAgICAgIGlmIChpc1Jlc2V0UmVxdWVzdGVkICYmIChoYXNQcm9qZWN0aW9uIHx8IGhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykgfHwgdHJhbnNmb3JtVGVtcGxhdGVIYXNDaGFuZ2VkKSkge1xuICAgICAgICByZXNldFRyYW5zZm9ybSh0aGlzLmluc3RhbmNlLCB0cmFuc2Zvcm1UZW1wbGF0ZVZhbHVlKTtcbiAgICAgICAgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmUocmVtb3ZlVHJhbnNmb3JtID0gdHJ1ZSkge1xuICAgICAgY29uc3QgcGFnZUJveCA9IHRoaXMubWVhc3VyZVBhZ2VCb3goKTtcbiAgICAgIGxldCBsYXlvdXRCb3ggPSB0aGlzLnJlbW92ZUVsZW1lbnRTY3JvbGwocGFnZUJveCk7XG4gICAgICBpZiAocmVtb3ZlVHJhbnNmb3JtKSB7XG4gICAgICAgIGxheW91dEJveCA9IHRoaXMucmVtb3ZlVHJhbnNmb3JtKGxheW91dEJveCk7XG4gICAgICB9XG4gICAgICByb3VuZEJveChsYXlvdXRCb3gpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVhc3VyZWRCb3g6IHBhZ2VCb3gsXG4gICAgICAgIGxheW91dEJveCxcbiAgICAgICAgbGF0ZXN0VmFsdWVzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgbWVhc3VyZVBhZ2VCb3goKSB7XG4gICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJveCgpO1xuICAgICAgY29uc3QgYm94ID0gdmlzdWFsRWxlbWVudC5tZWFzdXJlVmlld3BvcnRCb3goKTtcbiAgICAgIGNvbnN0IHsgc2Nyb2xsOiBzY3JvbGwyIH0gPSB0aGlzLnJvb3Q7XG4gICAgICBpZiAoc2Nyb2xsMikge1xuICAgICAgICB0cmFuc2xhdGVBeGlzKGJveC54LCBzY3JvbGwyLngpO1xuICAgICAgICB0cmFuc2xhdGVBeGlzKGJveC55LCBzY3JvbGwyLnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveDtcbiAgICB9XG4gICAgcmVtb3ZlRWxlbWVudFNjcm9sbChib3gpIHtcbiAgICAgIGNvbnN0IGJveFdpdGhvdXRTY3JvbGwgPSBjcmVhdGVCb3goKTtcbiAgICAgIGNvcHlCb3hJbnRvKGJveFdpdGhvdXRTY3JvbGwsIGJveCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgdGhpcy5wYXRoLmxlbmd0aDsgaTIrKykge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2kyXTtcbiAgICAgICAgY29uc3QgeyBzY3JvbGw6IHNjcm9sbDIsIG9wdGlvbnMsIGlzU2Nyb2xsUm9vdCB9ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUgIT09IHRoaXMucm9vdCAmJiBzY3JvbGwyICYmIG9wdGlvbnMubGF5b3V0U2Nyb2xsKSB7XG4gICAgICAgICAgaWYgKGlzU2Nyb2xsUm9vdCkge1xuICAgICAgICAgICAgY29weUJveEludG8oYm94V2l0aG91dFNjcm9sbCwgYm94KTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsOiByb290U2Nyb2xsIH0gPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICBpZiAocm9vdFNjcm9sbCkge1xuICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueCwgLXJvb3RTY3JvbGwueCk7XG4gICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC55LCAtcm9vdFNjcm9sbC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLngsIHNjcm9sbDIueCk7XG4gICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLnksIHNjcm9sbDIueSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBib3hXaXRob3V0U2Nyb2xsO1xuICAgIH1cbiAgICBhcHBseVRyYW5zZm9ybShib3gsIHRyYW5zZm9ybU9ubHkgPSBmYWxzZSkge1xuICAgICAgY29uc3Qgd2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgIGNvcHlCb3hJbnRvKHdpdGhUcmFuc2Zvcm1zLCBib3gpO1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGF0aC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpMl07XG4gICAgICAgIGlmICghdHJhbnNmb3JtT25seSAmJiBub2RlLm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmIG5vZGUuc2Nyb2xsICYmIG5vZGUgIT09IG5vZGUucm9vdCkge1xuICAgICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3Jtcywge1xuICAgICAgICAgICAgeDogLW5vZGUuc2Nyb2xsLngsXG4gICAgICAgICAgICB5OiAtbm9kZS5zY3JvbGwueVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCBub2RlLmxhdGVzdFZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICB0cmFuc2Zvcm1Cb3god2l0aFRyYW5zZm9ybXMsIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aXRoVHJhbnNmb3JtcztcbiAgICB9XG4gICAgcmVtb3ZlVHJhbnNmb3JtKGJveCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgYm94V2l0aG91dFRyYW5zZm9ybSA9IGNyZWF0ZUJveCgpO1xuICAgICAgY29weUJveEludG8oYm94V2l0aG91dFRyYW5zZm9ybSwgYm94KTtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0aGlzLnBhdGgubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaTJdO1xuICAgICAgICBpZiAoIW5vZGUuaW5zdGFuY2UpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaGFzU2NhbGUobm9kZS5sYXRlc3RWYWx1ZXMpICYmIG5vZGUudXBkYXRlU25hcHNob3QoKTtcbiAgICAgICAgY29uc3Qgc291cmNlQm94ID0gY3JlYXRlQm94KCk7XG4gICAgICAgIGNvbnN0IG5vZGVCb3ggPSBub2RlLm1lYXN1cmVQYWdlQm94KCk7XG4gICAgICAgIGNvcHlCb3hJbnRvKHNvdXJjZUJveCwgbm9kZUJveCk7XG4gICAgICAgIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94V2l0aG91dFRyYW5zZm9ybSwgbm9kZS5sYXRlc3RWYWx1ZXMsIChfYSA9IG5vZGUuc25hcHNob3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXlvdXRCb3gsIHNvdXJjZUJveCk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICByZW1vdmVCb3hUcmFuc2Zvcm1zKGJveFdpdGhvdXRUcmFuc2Zvcm0sIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib3hXaXRob3V0VHJhbnNmb3JtO1xuICAgIH1cbiAgICBzZXRUYXJnZXREZWx0YShkZWx0YSkge1xuICAgICAgdGhpcy50YXJnZXREZWx0YSA9IGRlbHRhO1xuICAgICAgdGhpcy5yb290LnNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpLCB7XG4gICAgICAgIGNyb3NzZmFkZTogb3B0aW9ucy5jcm9zc2ZhZGUgIT09IHZvaWQgMCA/IG9wdGlvbnMuY3Jvc3NmYWRlIDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNsZWFyTWVhc3VyZW1lbnRzKCkge1xuICAgICAgdGhpcy5zY3JvbGwgPSB2b2lkIDA7XG4gICAgICB0aGlzLmxheW91dCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuc25hcHNob3QgPSB2b2lkIDA7XG4gICAgICB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlID0gdm9pZCAwO1xuICAgICAgdGhpcy50YXJnZXREZWx0YSA9IHZvaWQgMDtcbiAgICAgIHRoaXMudGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIHJlc29sdmVUYXJnZXREZWx0YSgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHsgbGF5b3V0LCBsYXlvdXRJZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKCF0aGlzLmxheW91dCB8fCAhKGxheW91dCB8fCBsYXlvdXRJZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghdGhpcy50YXJnZXREZWx0YSAmJiAhdGhpcy5yZWxhdGl2ZVRhcmdldCkge1xuICAgICAgICBjb25zdCByZWxhdGl2ZVBhcmVudCA9IHRoaXMuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlUGFyZW50ICYmIHJlbGF0aXZlUGFyZW50LmxheW91dCkge1xuICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSByZWxhdGl2ZVBhcmVudDtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sIHRoaXMubGF5b3V0LmxheW91dEJveCwgcmVsYXRpdmVQYXJlbnQubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgY29weUJveEludG8odGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudCA9IHRoaXMucmVsYXRpdmVUYXJnZXQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5yZWxhdGl2ZVRhcmdldCAmJiAhdGhpcy50YXJnZXREZWx0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLnRhcmdldCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICB0aGlzLnRhcmdldFdpdGhUcmFuc2Zvcm1zID0gY3JlYXRlQm94KCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWxhdGl2ZVRhcmdldCAmJiB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luICYmICgoX2EgPSB0aGlzLnJlbGF0aXZlUGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGFyZ2V0KSkge1xuICAgICAgICBjYWxjUmVsYXRpdmVCb3godGhpcy50YXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVQYXJlbnQudGFyZ2V0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50YXJnZXREZWx0YSkge1xuICAgICAgICBpZiAoQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkpIHtcbiAgICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0odGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnRhcmdldCwgdGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgfVxuICAgICAgICBhcHBseUJveERlbHRhKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldERlbHRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlCb3hJbnRvKHRoaXMudGFyZ2V0LCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGFyZW50ID0gdGhpcy5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICBpZiAocmVsYXRpdmVQYXJlbnQgJiYgQm9vbGVhbihyZWxhdGl2ZVBhcmVudC5yZXN1bWluZ0Zyb20pID09PSBCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSAmJiAhcmVsYXRpdmVQYXJlbnQub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiYgcmVsYXRpdmVQYXJlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudCA9IHJlbGF0aXZlUGFyZW50O1xuICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24odGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgdGhpcy50YXJnZXQsIHJlbGF0aXZlUGFyZW50LnRhcmdldCk7XG4gICAgICAgICAgY29weUJveEludG8odGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudCA9IHRoaXMucmVsYXRpdmVUYXJnZXQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKSB7XG4gICAgICBpZiAoIXRoaXMucGFyZW50IHx8IGhhc1NjYWxlKHRoaXMucGFyZW50LmxhdGVzdFZhbHVlcykgfHwgaGFzMkRUcmFuc2xhdGUodGhpcy5wYXJlbnQubGF0ZXN0VmFsdWVzKSlcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIGlmICgodGhpcy5wYXJlbnQucmVsYXRpdmVUYXJnZXQgfHwgdGhpcy5wYXJlbnQudGFyZ2V0RGVsdGEpICYmIHRoaXMucGFyZW50LmxheW91dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2FsY1Byb2plY3Rpb24oKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB7IGxheW91dCwgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIHRoaXMuaXNUcmVlQW5pbWF0aW5nID0gQm9vbGVhbigoKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1RyZWVBbmltYXRpbmcpIHx8IHRoaXMuY3VycmVudEFuaW1hdGlvbiB8fCB0aGlzLnBlbmRpbmdBbmltYXRpb24pO1xuICAgICAgaWYgKCF0aGlzLmlzVHJlZUFuaW1hdGluZykge1xuICAgICAgICB0aGlzLnRhcmdldERlbHRhID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIShsYXlvdXQgfHwgbGF5b3V0SWQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICBjb3B5Qm94SW50byh0aGlzLmxheW91dENvcnJlY3RlZCwgdGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgIGFwcGx5VHJlZURlbHRhcyh0aGlzLmxheW91dENvcnJlY3RlZCwgdGhpcy50cmVlU2NhbGUsIHRoaXMucGF0aCwgQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkgfHwgdGhpcyAhPT0gbGVhZCk7XG4gICAgICBjb25zdCB7IHRhcmdldCB9ID0gbGVhZDtcbiAgICAgIGlmICghdGFyZ2V0KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoIXRoaXMucHJvamVjdGlvbkRlbHRhKSB7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZUcmVlU2NhbGVYID0gdGhpcy50cmVlU2NhbGUueDtcbiAgICAgIGNvbnN0IHByZXZUcmVlU2NhbGVZID0gdGhpcy50cmVlU2NhbGUueTtcbiAgICAgIGNvbnN0IHByZXZQcm9qZWN0aW9uVHJhbnNmb3JtID0gdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtO1xuICAgICAgY2FsY0JveERlbHRhKHRoaXMucHJvamVjdGlvbkRlbHRhLCB0aGlzLmxheW91dENvcnJlY3RlZCwgdGFyZ2V0LCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm0gPSBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0odGhpcy5wcm9qZWN0aW9uRGVsdGEsIHRoaXMudHJlZVNjYWxlKTtcbiAgICAgIGlmICh0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm0gIT09IHByZXZQcm9qZWN0aW9uVHJhbnNmb3JtIHx8IHRoaXMudHJlZVNjYWxlLnggIT09IHByZXZUcmVlU2NhbGVYIHx8IHRoaXMudHJlZVNjYWxlLnkgIT09IHByZXZUcmVlU2NhbGVZKSB7XG4gICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcInByb2plY3Rpb25VcGRhdGVcIiwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHNjaGVkdWxlUmVuZGVyKG5vdGlmeUFsbDIgPSB0cnVlKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucykuc2NoZWR1bGVSZW5kZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgIG5vdGlmeUFsbDIgJiYgKChfYyA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNjaGVkdWxlUmVuZGVyKCkpO1xuICAgICAgaWYgKHRoaXMucmVzdW1pbmdGcm9tICYmICF0aGlzLnJlc3VtaW5nRnJvbS5pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0QW5pbWF0aW9uT3JpZ2luKGRlbHRhLCBoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gZmFsc2UpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gdGhpcy5zbmFwc2hvdDtcbiAgICAgIGNvbnN0IHNuYXBzaG90TGF0ZXN0VmFsdWVzID0gKHNuYXBzaG90ID09PSBudWxsIHx8IHNuYXBzaG90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbmFwc2hvdC5sYXRlc3RWYWx1ZXMpIHx8IHt9O1xuICAgICAgY29uc3QgbWl4ZWRWYWx1ZXMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgY29uc3QgdGFyZ2V0RGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSB2b2lkIDA7XG4gICAgICB0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCA9ICFoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkO1xuICAgICAgY29uc3QgcmVsYXRpdmVMYXlvdXQgPSBjcmVhdGVCb3goKTtcbiAgICAgIGNvbnN0IGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uID0gc25hcHNob3QgPT09IG51bGwgfHwgc25hcHNob3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNuYXBzaG90LmlzU2hhcmVkO1xuICAgICAgY29uc3QgaXNPbmx5TWVtYmVyID0gKCgoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZW1iZXJzLmxlbmd0aCkgfHwgMCkgPD0gMTtcbiAgICAgIGNvbnN0IHNob3VsZENyb3NzZmFkZU9wYWNpdHkgPSBCb29sZWFuKGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uICYmICFpc09ubHlNZW1iZXIgJiYgdGhpcy5vcHRpb25zLmNyb3NzZmFkZSA9PT0gdHJ1ZSAmJiAhdGhpcy5wYXRoLnNvbWUoaGFzT3BhY2l0eUNyb3NzZmFkZSkpO1xuICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgICB0aGlzLm1peFRhcmdldERlbHRhID0gKGxhdGVzdCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBjb25zdCBwcm9ncmVzczMgPSBsYXRlc3QgLyAxZTM7XG4gICAgICAgIG1peEF4aXNEZWx0YSh0YXJnZXREZWx0YS54LCBkZWx0YS54LCBwcm9ncmVzczMpO1xuICAgICAgICBtaXhBeGlzRGVsdGEodGFyZ2V0RGVsdGEueSwgZGVsdGEueSwgcHJvZ3Jlc3MzKTtcbiAgICAgICAgdGhpcy5zZXRUYXJnZXREZWx0YSh0YXJnZXREZWx0YSk7XG4gICAgICAgIGlmICh0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gJiYgdGhpcy5sYXlvdXQgJiYgKChfYTIgPSB0aGlzLnJlbGF0aXZlUGFyZW50KSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMi5sYXlvdXQpKSB7XG4gICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVMYXlvdXQsIHRoaXMubGF5b3V0LmxheW91dEJveCwgdGhpcy5yZWxhdGl2ZVBhcmVudC5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICBtaXhCb3godGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgcmVsYXRpdmVMYXlvdXQsIHByb2dyZXNzMyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRpb25WYWx1ZXMgPSBtaXhlZFZhbHVlcztcbiAgICAgICAgICBtaXhWYWx1ZXMobWl4ZWRWYWx1ZXMsIHNuYXBzaG90TGF0ZXN0VmFsdWVzLCB0aGlzLmxhdGVzdFZhbHVlcywgcHJvZ3Jlc3MzLCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5LCBpc09ubHlNZW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdC5zY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzID0gcHJvZ3Jlc3MzO1xuICAgICAgfTtcbiAgICAgIHRoaXMubWl4VGFyZ2V0RGVsdGEoMCk7XG4gICAgfVxuICAgIHN0YXJ0QW5pbWF0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcImFuaW1hdGlvblN0YXJ0XCIpO1xuICAgICAgKF9hID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpO1xuICAgICAgaWYgKHRoaXMucmVzdW1pbmdGcm9tKSB7XG4gICAgICAgIChfYiA9IHRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wZW5kaW5nQW5pbWF0aW9uKSB7XG4gICAgICAgIGNhbmNlbFN5bmMudXBkYXRlKHRoaXMucGVuZGluZ0FuaW1hdGlvbik7XG4gICAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbiA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbiA9IGVzX2RlZmF1bHQudXBkYXRlKCgpID0+IHtcbiAgICAgICAgZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0FuaW1hdGVkU2luY2VSZXNpemUgPSB0cnVlO1xuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRlMigwLCBhbmltYXRpb25UYXJnZXQsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICAgICAgb25VcGRhdGU6IChsYXRlc3QpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICB0aGlzLm1peFRhcmdldERlbHRhKGxhdGVzdCk7XG4gICAgICAgICAgICAoX2EyID0gb3B0aW9ucy5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zLCBsYXRlc3QpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgIChfYTIgPSBvcHRpb25zLm9uQ29tcGxldGUpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLmNhbGwob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlQW5pbWF0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSkge1xuICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24gPSB0aGlzLmN1cnJlbnRBbmltYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gdm9pZCAwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXBsZXRlQW5pbWF0aW9uKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMucmVzdW1pbmdGcm9tKSB7XG4gICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24gPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLnByZXNlcnZlT3BhY2l0eSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4aXRBbmltYXRpb25Db21wbGV0ZSgpO1xuICAgICAgdGhpcy5yZXN1bWluZ0Zyb20gPSB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvblZhbHVlcyA9IHZvaWQgMDtcbiAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwiYW5pbWF0aW9uQ29tcGxldGVcIik7XG4gICAgfVxuICAgIGZpbmlzaEFuaW1hdGlvbigpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgICAgKF9hID0gdGhpcy5taXhUYXJnZXREZWx0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgYW5pbWF0aW9uVGFyZ2V0KTtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29tcGxldGVBbmltYXRpb24oKTtcbiAgICB9XG4gICAgYXBwbHlUcmFuc2Zvcm1zVG9UYXJnZXQoKSB7XG4gICAgICBjb25zdCBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICBsZXQgeyB0YXJnZXRXaXRoVHJhbnNmb3JtcywgdGFyZ2V0LCBsYXlvdXQsIGxhdGVzdFZhbHVlcyB9ID0gbGVhZDtcbiAgICAgIGlmICghdGFyZ2V0V2l0aFRyYW5zZm9ybXMgfHwgIXRhcmdldCB8fCAhbGF5b3V0KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcyAhPT0gbGVhZCAmJiB0aGlzLmxheW91dCAmJiBsYXlvdXQgJiYgc2hvdWxkQW5pbWF0ZVBvc2l0aW9uT25seSh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uVHlwZSwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCBsYXlvdXQubGF5b3V0Qm94KSkge1xuICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldCB8fCBjcmVhdGVCb3goKTtcbiAgICAgICAgY29uc3QgeExlbmd0aCA9IGNhbGNMZW5ndGgodGhpcy5sYXlvdXQubGF5b3V0Qm94LngpO1xuICAgICAgICB0YXJnZXQueC5taW4gPSBsZWFkLnRhcmdldC54Lm1pbjtcbiAgICAgICAgdGFyZ2V0LngubWF4ID0gdGFyZ2V0LngubWluICsgeExlbmd0aDtcbiAgICAgICAgY29uc3QgeUxlbmd0aCA9IGNhbGNMZW5ndGgodGhpcy5sYXlvdXQubGF5b3V0Qm94LnkpO1xuICAgICAgICB0YXJnZXQueS5taW4gPSBsZWFkLnRhcmdldC55Lm1pbjtcbiAgICAgICAgdGFyZ2V0LnkubWF4ID0gdGFyZ2V0LnkubWluICsgeUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGNvcHlCb3hJbnRvKHRhcmdldFdpdGhUcmFuc2Zvcm1zLCB0YXJnZXQpO1xuICAgICAgdHJhbnNmb3JtQm94KHRhcmdldFdpdGhUcmFuc2Zvcm1zLCBsYXRlc3RWYWx1ZXMpO1xuICAgICAgY2FsY0JveERlbHRhKHRoaXMucHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSwgdGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRhcmdldFdpdGhUcmFuc2Zvcm1zLCBsYXRlc3RWYWx1ZXMpO1xuICAgIH1cbiAgICByZWdpc3RlclNoYXJlZE5vZGUobGF5b3V0SWQsIG5vZGUpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgaWYgKCF0aGlzLnNoYXJlZE5vZGVzLmhhcyhsYXlvdXRJZCkpIHtcbiAgICAgICAgdGhpcy5zaGFyZWROb2Rlcy5zZXQobGF5b3V0SWQsIG5ldyBOb2RlU3RhY2soKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFjayA9IHRoaXMuc2hhcmVkTm9kZXMuZ2V0KGxheW91dElkKTtcbiAgICAgIHN0YWNrLmFkZChub2RlKTtcbiAgICAgIG5vZGUucHJvbW90ZSh7XG4gICAgICAgIHRyYW5zaXRpb246IChfYSA9IG5vZGUub3B0aW9ucy5pbml0aWFsUHJvbW90aW9uQ29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNpdGlvbixcbiAgICAgICAgcHJlc2VydmVGb2xsb3dPcGFjaXR5OiAoX2MgPSAoX2IgPSBub2RlLm9wdGlvbnMuaW5pdGlhbFByb21vdGlvbkNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNob3VsZFByZXNlcnZlRm9sbG93T3BhY2l0eSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIG5vZGUpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaXNMZWFkKCkge1xuICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICByZXR1cm4gc3RhY2sgPyBzdGFjay5sZWFkID09PSB0aGlzIDogdHJ1ZTtcbiAgICB9XG4gICAgZ2V0TGVhZCgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHsgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIHJldHVybiBsYXlvdXRJZCA/ICgoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZWFkKSB8fCB0aGlzIDogdGhpcztcbiAgICB9XG4gICAgZ2V0UHJldkxlYWQoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB7IGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICByZXR1cm4gbGF5b3V0SWQgPyAoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmV2TGVhZCA6IHZvaWQgMDtcbiAgICB9XG4gICAgZ2V0U3RhY2soKSB7XG4gICAgICBjb25zdCB7IGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAobGF5b3V0SWQpXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2hhcmVkTm9kZXMuZ2V0KGxheW91dElkKTtcbiAgICB9XG4gICAgcHJvbW90ZSh7IG5lZWRzUmVzZXQsIHRyYW5zaXRpb24sIHByZXNlcnZlRm9sbG93T3BhY2l0eSB9ID0ge30pIHtcbiAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgaWYgKHN0YWNrKVxuICAgICAgICBzdGFjay5wcm9tb3RlKHRoaXMsIHByZXNlcnZlRm9sbG93T3BhY2l0eSk7XG4gICAgICBpZiAobmVlZHNSZXNldCkge1xuICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5uZWVkc1Jlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2l0aW9uKVxuICAgICAgICB0aGlzLnNldE9wdGlvbnMoeyB0cmFuc2l0aW9uIH0pO1xuICAgIH1cbiAgICByZWxlZ2F0ZSgpIHtcbiAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgIHJldHVybiBzdGFjay5yZWxlZ2F0ZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRSb3RhdGlvbigpIHtcbiAgICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgaGFzUm90YXRlID0gZmFsc2U7XG4gICAgICBjb25zdCByZXNldFZhbHVlcyA9IHt9O1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRyYW5zZm9ybUF4ZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IGF4aXMgPSB0cmFuc2Zvcm1BeGVzW2kyXTtcbiAgICAgICAgY29uc3Qga2V5ID0gXCJyb3RhdGVcIiArIGF4aXM7XG4gICAgICAgIGlmICghdmlzdWFsRWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFzUm90YXRlID0gdHJ1ZTtcbiAgICAgICAgcmVzZXRWYWx1ZXNba2V5XSA9IHZpc3VhbEVsZW1lbnQuZ2V0U3RhdGljVmFsdWUoa2V5KTtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRTdGF0aWNWYWx1ZShrZXksIDApO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNSb3RhdGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc2V0VmFsdWVzKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0U3RhdGljVmFsdWUoa2V5LCByZXNldFZhbHVlc1trZXldKTtcbiAgICAgIH1cbiAgICAgIHZpc3VhbEVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICB9XG4gICAgZ2V0UHJvamVjdGlvblN0eWxlcyhzdHlsZVByb3AgPSB7fSkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBjb25zdCBzdHlsZXMgPSB7fTtcbiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSB8fCB0aGlzLmlzU1ZHKVxuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICByZXR1cm4geyB2aXNpYmlsaXR5OiBcImhpZGRlblwiIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZXMudmlzaWJpbGl0eSA9IFwiXCI7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZSA9IChfYSA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UHJvcHMoKS50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICAgIGlmICh0aGlzLm5lZWRzUmVzZXQpIHtcbiAgICAgICAgdGhpcy5uZWVkc1Jlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0eWxlcy5vcGFjaXR5ID0gXCJcIjtcbiAgICAgICAgc3R5bGVzLnBvaW50ZXJFdmVudHMgPSByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCI7XG4gICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZSA/IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKSA6IFwibm9uZVwiO1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVhZCA9IHRoaXMuZ2V0TGVhZCgpO1xuICAgICAgaWYgKCF0aGlzLnByb2plY3Rpb25EZWx0YSB8fCAhdGhpcy5sYXlvdXQgfHwgIWxlYWQudGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IGVtcHR5U3R5bGVzID0ge307XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0SWQpIHtcbiAgICAgICAgICBlbXB0eVN0eWxlcy5vcGFjaXR5ID0gdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eSAhPT0gdm9pZCAwID8gdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eSA6IDE7XG4gICAgICAgICAgZW1wdHlTdHlsZXMucG9pbnRlckV2ZW50cyA9IHJlc29sdmVNb3Rpb25WYWx1ZShzdHlsZVByb3AucG9pbnRlckV2ZW50cykgfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNQcm9qZWN0ZWQgJiYgIWhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICBlbXB0eVN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZSA/IHRyYW5zZm9ybVRlbXBsYXRlKHt9LCBcIlwiKSA6IFwibm9uZVwiO1xuICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtcHR5U3R5bGVzO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVzVG9SZW5kZXIgPSBsZWFkLmFuaW1hdGlvblZhbHVlcyB8fCBsZWFkLmxhdGVzdFZhbHVlcztcbiAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zVG9UYXJnZXQoKTtcbiAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0odGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtLCB0aGlzLnRyZWVTY2FsZSwgdmFsdWVzVG9SZW5kZXIpO1xuICAgICAgaWYgKHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZSh2YWx1ZXNUb1JlbmRlciwgc3R5bGVzLnRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMucHJvamVjdGlvbkRlbHRhO1xuICAgICAgc3R5bGVzLnRyYW5zZm9ybU9yaWdpbiA9IGAke3gub3JpZ2luICogMTAwfSUgJHt5Lm9yaWdpbiAqIDEwMH0lIDBgO1xuICAgICAgaWYgKGxlYWQuYW5pbWF0aW9uVmFsdWVzKSB7XG4gICAgICAgIHN0eWxlcy5vcGFjaXR5ID0gbGVhZCA9PT0gdGhpcyA/IChfYyA9IChfYiA9IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDEgOiB0aGlzLnByZXNlcnZlT3BhY2l0eSA/IHRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHkgOiB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlcy5vcGFjaXR5ID0gbGVhZCA9PT0gdGhpcyA/IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHkgIT09IHZvaWQgMCA/IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHkgOiBcIlwiIDogdmFsdWVzVG9SZW5kZXIub3BhY2l0eUV4aXQgIT09IHZvaWQgMCA/IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHlFeGl0IDogMDtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjYWxlQ29ycmVjdG9ycykge1xuICAgICAgICBpZiAodmFsdWVzVG9SZW5kZXJba2V5XSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB7IGNvcnJlY3QsIGFwcGx5VG8gfSA9IHNjYWxlQ29ycmVjdG9yc1trZXldO1xuICAgICAgICBjb25zdCBjb3JyZWN0ZWQgPSBjb3JyZWN0KHZhbHVlc1RvUmVuZGVyW2tleV0sIGxlYWQpO1xuICAgICAgICBpZiAoYXBwbHlUbykge1xuICAgICAgICAgIGNvbnN0IG51bSA9IGFwcGx5VG8ubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW07IGkyKyspIHtcbiAgICAgICAgICAgIHN0eWxlc1thcHBseVRvW2kyXV0gPSBjb3JyZWN0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlc1trZXldID0gY29ycmVjdGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxheW91dElkKSB7XG4gICAgICAgIHN0eWxlcy5wb2ludGVyRXZlbnRzID0gbGVhZCA9PT0gdGhpcyA/IHJlc29sdmVNb3Rpb25WYWx1ZShzdHlsZVByb3AucG9pbnRlckV2ZW50cykgfHwgXCJcIiA6IFwibm9uZVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9XG4gICAgY2xlYXJTbmFwc2hvdCgpIHtcbiAgICAgIHRoaXMucmVzdW1lRnJvbSA9IHRoaXMuc25hcHNob3QgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJlc2V0VHJlZSgpIHtcbiAgICAgIHRoaXMucm9vdC5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IG5vZGUuY3VycmVudEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yb290Lm5vZGVzLmZvckVhY2goY2xlYXJNZWFzdXJlbWVudHMpO1xuICAgICAgdGhpcy5yb290LnNoYXJlZE5vZGVzLmNsZWFyKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlTGF5b3V0KG5vZGUpIHtcbiAgbm9kZS51cGRhdGVMYXlvdXQoKTtcbn1cbmZ1bmN0aW9uIG5vdGlmeUxheW91dFVwZGF0ZShub2RlKSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBzbmFwc2hvdCA9ICgoX2EgPSBub2RlLnJlc3VtZUZyb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zbmFwc2hvdCkgfHwgbm9kZS5zbmFwc2hvdDtcbiAgaWYgKG5vZGUuaXNMZWFkKCkgJiYgbm9kZS5sYXlvdXQgJiYgc25hcHNob3QgJiYgbm9kZS5oYXNMaXN0ZW5lcnMoXCJkaWRVcGRhdGVcIikpIHtcbiAgICBjb25zdCB7IGxheW91dEJveDogbGF5b3V0LCBtZWFzdXJlZEJveDogbWVhc3VyZWRMYXlvdXQgfSA9IG5vZGUubGF5b3V0O1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uVHlwZSB9ID0gbm9kZS5vcHRpb25zO1xuICAgIGlmIChhbmltYXRpb25UeXBlID09PSBcInNpemVcIikge1xuICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgY29uc3QgYXhpc1NuYXBzaG90ID0gc25hcHNob3QuaXNTaGFyZWQgPyBzbmFwc2hvdC5tZWFzdXJlZEJveFtheGlzXSA6IHNuYXBzaG90LmxheW91dEJveFtheGlzXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY2FsY0xlbmd0aChheGlzU25hcHNob3QpO1xuICAgICAgICBheGlzU25hcHNob3QubWluID0gbGF5b3V0W2F4aXNdLm1pbjtcbiAgICAgICAgYXhpc1NuYXBzaG90Lm1heCA9IGF4aXNTbmFwc2hvdC5taW4gKyBsZW5ndGg7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNob3VsZEFuaW1hdGVQb3NpdGlvbk9ubHkoYW5pbWF0aW9uVHlwZSwgc25hcHNob3QubGF5b3V0Qm94LCBsYXlvdXQpKSB7XG4gICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICBjb25zdCBheGlzU25hcHNob3QgPSBzbmFwc2hvdC5pc1NoYXJlZCA/IHNuYXBzaG90Lm1lYXN1cmVkQm94W2F4aXNdIDogc25hcHNob3QubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjYWxjTGVuZ3RoKGxheW91dFtheGlzXSk7XG4gICAgICAgIGF4aXNTbmFwc2hvdC5tYXggPSBheGlzU25hcHNob3QubWluICsgbGVuZ3RoO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGxheW91dERlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICBjYWxjQm94RGVsdGEobGF5b3V0RGVsdGEsIGxheW91dCwgc25hcHNob3QubGF5b3V0Qm94KTtcbiAgICBjb25zdCB2aXN1YWxEZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgaWYgKHNuYXBzaG90LmlzU2hhcmVkKSB7XG4gICAgICBjYWxjQm94RGVsdGEodmlzdWFsRGVsdGEsIG5vZGUuYXBwbHlUcmFuc2Zvcm0obWVhc3VyZWRMYXlvdXQsIHRydWUpLCBzbmFwc2hvdC5tZWFzdXJlZEJveCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGNCb3hEZWx0YSh2aXN1YWxEZWx0YSwgbGF5b3V0LCBzbmFwc2hvdC5sYXlvdXRCb3gpO1xuICAgIH1cbiAgICBjb25zdCBoYXNMYXlvdXRDaGFuZ2VkID0gIWlzRGVsdGFaZXJvKGxheW91dERlbHRhKTtcbiAgICBsZXQgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gZmFsc2U7XG4gICAgaWYgKCFub2RlLnJlc3VtZUZyb20pIHtcbiAgICAgIGNvbnN0IHJlbGF0aXZlUGFyZW50ID0gbm9kZS5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgaWYgKHJlbGF0aXZlUGFyZW50ICYmICFyZWxhdGl2ZVBhcmVudC5yZXN1bWVGcm9tKSB7XG4gICAgICAgIGNvbnN0IHsgc25hcHNob3Q6IHBhcmVudFNuYXBzaG90LCBsYXlvdXQ6IHBhcmVudExheW91dCB9ID0gcmVsYXRpdmVQYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnRTbmFwc2hvdCAmJiBwYXJlbnRMYXlvdXQpIHtcbiAgICAgICAgICBjb25zdCByZWxhdGl2ZVNuYXBzaG90ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVTbmFwc2hvdCwgc25hcHNob3QubGF5b3V0Qm94LCBwYXJlbnRTbmFwc2hvdC5sYXlvdXRCb3gpO1xuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlTGF5b3V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVMYXlvdXQsIGxheW91dCwgcGFyZW50TGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgaWYgKCFib3hFcXVhbHMocmVsYXRpdmVTbmFwc2hvdCwgcmVsYXRpdmVMYXlvdXQpKSB7XG4gICAgICAgICAgICBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBub2RlLm5vdGlmeUxpc3RlbmVycyhcImRpZFVwZGF0ZVwiLCB7XG4gICAgICBsYXlvdXQsXG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGRlbHRhOiB2aXN1YWxEZWx0YSxcbiAgICAgIGxheW91dERlbHRhLFxuICAgICAgaGFzTGF5b3V0Q2hhbmdlZCxcbiAgICAgIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKG5vZGUuaXNMZWFkKCkpIHtcbiAgICAoX2MgPSAoX2IgPSBub2RlLm9wdGlvbnMpLm9uRXhpdENvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYik7XG4gIH1cbiAgbm9kZS5vcHRpb25zLnRyYW5zaXRpb24gPSB2b2lkIDA7XG59XG5mdW5jdGlvbiBjbGVhclNuYXBzaG90KG5vZGUpIHtcbiAgbm9kZS5jbGVhclNuYXBzaG90KCk7XG59XG5mdW5jdGlvbiBjbGVhck1lYXN1cmVtZW50cyhub2RlKSB7XG4gIG5vZGUuY2xlYXJNZWFzdXJlbWVudHMoKTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJhbnNmb3JtU3R5bGUobm9kZSkge1xuICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IG5vZGUub3B0aW9ucztcbiAgaWYgKHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpLm9uQmVmb3JlTGF5b3V0TWVhc3VyZSkge1xuICAgIHZpc3VhbEVsZW1lbnQubm90aWZ5KFwiQmVmb3JlTGF5b3V0TWVhc3VyZVwiKTtcbiAgfVxuICBub2RlLnJlc2V0VHJhbnNmb3JtKCk7XG59XG5mdW5jdGlvbiBmaW5pc2hBbmltYXRpb24obm9kZSkge1xuICBub2RlLmZpbmlzaEFuaW1hdGlvbigpO1xuICBub2RlLnRhcmdldERlbHRhID0gbm9kZS5yZWxhdGl2ZVRhcmdldCA9IG5vZGUudGFyZ2V0ID0gdm9pZCAwO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldERlbHRhKG5vZGUpIHtcbiAgbm9kZS5yZXNvbHZlVGFyZ2V0RGVsdGEoKTtcbn1cbmZ1bmN0aW9uIGNhbGNQcm9qZWN0aW9uKG5vZGUpIHtcbiAgbm9kZS5jYWxjUHJvamVjdGlvbigpO1xufVxuZnVuY3Rpb24gcmVzZXRSb3RhdGlvbihub2RlKSB7XG4gIG5vZGUucmVzZXRSb3RhdGlvbigpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGVhZFNuYXBzaG90cyhzdGFjaykge1xuICBzdGFjay5yZW1vdmVMZWFkU25hcHNob3QoKTtcbn1cbmZ1bmN0aW9uIG1peEF4aXNEZWx0YShvdXRwdXQsIGRlbHRhLCBwMikge1xuICBvdXRwdXQudHJhbnNsYXRlID0gbWl4KGRlbHRhLnRyYW5zbGF0ZSwgMCwgcDIpO1xuICBvdXRwdXQuc2NhbGUgPSBtaXgoZGVsdGEuc2NhbGUsIDEsIHAyKTtcbiAgb3V0cHV0Lm9yaWdpbiA9IGRlbHRhLm9yaWdpbjtcbiAgb3V0cHV0Lm9yaWdpblBvaW50ID0gZGVsdGEub3JpZ2luUG9pbnQ7XG59XG5mdW5jdGlvbiBtaXhBeGlzKG91dHB1dCwgZnJvbSwgdG8sIHAyKSB7XG4gIG91dHB1dC5taW4gPSBtaXgoZnJvbS5taW4sIHRvLm1pbiwgcDIpO1xuICBvdXRwdXQubWF4ID0gbWl4KGZyb20ubWF4LCB0by5tYXgsIHAyKTtcbn1cbmZ1bmN0aW9uIG1peEJveChvdXRwdXQsIGZyb20sIHRvLCBwMikge1xuICBtaXhBeGlzKG91dHB1dC54LCBmcm9tLngsIHRvLngsIHAyKTtcbiAgbWl4QXhpcyhvdXRwdXQueSwgZnJvbS55LCB0by55LCBwMik7XG59XG5mdW5jdGlvbiBoYXNPcGFjaXR5Q3Jvc3NmYWRlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuYW5pbWF0aW9uVmFsdWVzICYmIG5vZGUuYW5pbWF0aW9uVmFsdWVzLm9wYWNpdHlFeGl0ICE9PSB2b2lkIDA7XG59XG52YXIgZGVmYXVsdExheW91dFRyYW5zaXRpb24gPSB7XG4gIGR1cmF0aW9uOiAwLjQ1LFxuICBlYXNlOiBbMC40LCAwLCAwLjEsIDFdXG59O1xuZnVuY3Rpb24gbW91bnROb2RlRWFybHkobm9kZSwgaWQyKSB7XG4gIGxldCBzZWFyY2hOb2RlID0gbm9kZS5yb290O1xuICBmb3IgKGxldCBpMiA9IG5vZGUucGF0aC5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgaWYgKEJvb2xlYW4obm9kZS5wYXRoW2kyXS5pbnN0YW5jZSkpIHtcbiAgICAgIHNlYXJjaE5vZGUgPSBub2RlLnBhdGhbaTJdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlYXJjaEVsZW1lbnQgPSBzZWFyY2hOb2RlICYmIHNlYXJjaE5vZGUgIT09IG5vZGUucm9vdCA/IHNlYXJjaE5vZGUuaW5zdGFuY2UgOiBkb2N1bWVudDtcbiAgY29uc3QgZWxlbWVudCA9IHNlYXJjaEVsZW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcHJvamVjdGlvbi1pZD1cIiR7aWQyfVwiXWApO1xuICBpZiAoZWxlbWVudClcbiAgICBub2RlLm1vdW50KGVsZW1lbnQsIHRydWUpO1xufVxuZnVuY3Rpb24gcm91bmRBeGlzKGF4aXMpIHtcbiAgYXhpcy5taW4gPSBNYXRoLnJvdW5kKGF4aXMubWluKTtcbiAgYXhpcy5tYXggPSBNYXRoLnJvdW5kKGF4aXMubWF4KTtcbn1cbmZ1bmN0aW9uIHJvdW5kQm94KGJveCkge1xuICByb3VuZEF4aXMoYm94LngpO1xuICByb3VuZEF4aXMoYm94LnkpO1xufVxuZnVuY3Rpb24gc2hvdWxkQW5pbWF0ZVBvc2l0aW9uT25seShhbmltYXRpb25UeXBlLCBzbmFwc2hvdCwgbGF5b3V0KSB7XG4gIHJldHVybiBhbmltYXRpb25UeXBlID09PSBcInBvc2l0aW9uXCIgfHwgYW5pbWF0aW9uVHlwZSA9PT0gXCJwcmVzZXJ2ZS1hc3BlY3RcIiAmJiAhaXNDbG9zZVRvKGFzcGVjdFJhdGlvKHNuYXBzaG90KSwgYXNwZWN0UmF0aW8obGF5b3V0KSwgMC4yKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvRG9jdW1lbnRQcm9qZWN0aW9uTm9kZS5tanNcbnZhciBEb2N1bWVudFByb2plY3Rpb25Ob2RlID0gY3JlYXRlUHJvamVjdGlvbk5vZGUoe1xuICBhdHRhY2hSZXNpemVMaXN0ZW5lcjogKHJlZiwgbm90aWZ5KSA9PiBhZGREb21FdmVudChyZWYsIFwicmVzaXplXCIsIG5vdGlmeSksXG4gIG1lYXN1cmVTY3JvbGw6ICgpID0+ICh7XG4gICAgeDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LFxuICAgIHk6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3BcbiAgfSksXG4gIGNoZWNrSXNTY3JvbGxSb290OiAoKSA9PiB0cnVlXG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvSFRNTFByb2plY3Rpb25Ob2RlLm1qc1xudmFyIHJvb3RQcm9qZWN0aW9uTm9kZSA9IHtcbiAgY3VycmVudDogdm9pZCAwXG59O1xudmFyIEhUTUxQcm9qZWN0aW9uTm9kZSA9IGNyZWF0ZVByb2plY3Rpb25Ob2RlKHtcbiAgbWVhc3VyZVNjcm9sbDogKGluc3RhbmNlKSA9PiAoe1xuICAgIHg6IGluc3RhbmNlLnNjcm9sbExlZnQsXG4gICAgeTogaW5zdGFuY2Uuc2Nyb2xsVG9wXG4gIH0pLFxuICBkZWZhdWx0UGFyZW50OiAoKSA9PiB7XG4gICAgaWYgKCFyb290UHJvamVjdGlvbk5vZGUuY3VycmVudCkge1xuICAgICAgY29uc3QgZG9jdW1lbnROb2RlID0gbmV3IERvY3VtZW50UHJvamVjdGlvbk5vZGUoMCwge30pO1xuICAgICAgZG9jdW1lbnROb2RlLm1vdW50KHdpbmRvdyk7XG4gICAgICBkb2N1bWVudE5vZGUuc2V0T3B0aW9ucyh7IGxheW91dFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgIHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50ID0gZG9jdW1lbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQ7XG4gIH0sXG4gIHJlc2V0VHJhbnNmb3JtOiAoaW5zdGFuY2UsIHZhbHVlKSA9PiB7XG4gICAgaW5zdGFuY2Uuc3R5bGUudHJhbnNmb3JtID0gdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogXCJub25lXCI7XG4gIH0sXG4gIGNoZWNrSXNTY3JvbGxSb290OiAoaW5zdGFuY2UpID0+IEJvb2xlYW4od2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5zdGFuY2UpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpXG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL21vdGlvbi5tanNcbnZhciBmZWF0dXJlQnVuZGxlID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGFuaW1hdGlvbnMpLCBnZXN0dXJlQW5pbWF0aW9ucyksIGRyYWcpLCBsYXlvdXRGZWF0dXJlcyk7XG52YXIgbW90aW9uID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZU1vdGlvblByb3h5KChDb21wb25lbnQsIGNvbmZpZykgPT4gY3JlYXRlRG9tTW90aW9uQ29uZmlnKENvbXBvbmVudCwgY29uZmlnLCBmZWF0dXJlQnVuZGxlLCBjcmVhdGVEb21WaXN1YWxFbGVtZW50LCBIVE1MUHJvamVjdGlvbk5vZGUpKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9jbGFtcC5lcy5qc1xudmFyIGNsYW1wMyA9IChtaW4sIG1heCwgdikgPT4gTWF0aC5taW4oTWF0aC5tYXgodiwgbWluKSwgbWF4KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9pcy1udW1iZXIuZXMuanNcbnZhciBpc051bWJlciA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2lzLWVhc2luZy1saXN0LmVzLmpzXG52YXIgaXNFYXNpbmdMaXN0ID0gKGVhc2luZykgPT4gQXJyYXkuaXNBcnJheShlYXNpbmcpICYmICFpc051bWJlcihlYXNpbmdbMF0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L3dyYXAuZXMuanNcbnZhciB3cmFwID0gKG1pbiwgbWF4LCB2KSA9PiB7XG4gIGNvbnN0IHJhbmdlU2l6ZSA9IG1heCAtIG1pbjtcbiAgcmV0dXJuICgodiAtIG1pbikgJSByYW5nZVNpemUgKyByYW5nZVNpemUpICUgcmFuZ2VTaXplICsgbWluO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9lYXNpbmcuZXMuanNcbmZ1bmN0aW9uIGdldEVhc2luZ0ZvclNlZ21lbnQoZWFzaW5nLCBpMikge1xuICByZXR1cm4gaXNFYXNpbmdMaXN0KGVhc2luZykgPyBlYXNpbmdbd3JhcCgwLCBlYXNpbmcubGVuZ3RoLCBpMildIDogZWFzaW5nO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L21peC5lcy5qc1xudmFyIG1peDIgPSAobWluLCBtYXgsIHByb2dyZXNzMykgPT4gLXByb2dyZXNzMyAqIG1pbiArIHByb2dyZXNzMyAqIG1heCArIG1pbjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9ub29wLmVzLmpzXG52YXIgbm9vcFJldHVybiA9ICh2KSA9PiB2O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L3Byb2dyZXNzLmVzLmpzXG52YXIgcHJvZ3Jlc3MyID0gKG1pbiwgbWF4LCB2YWx1ZSkgPT4gbWF4IC0gbWluID09PSAwID8gMSA6ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9vZmZzZXQuZXMuanNcbmZ1bmN0aW9uIGZpbGxPZmZzZXQob2Zmc2V0LCByZW1haW5pbmcpIHtcbiAgY29uc3QgbWluID0gb2Zmc2V0W29mZnNldC5sZW5ndGggLSAxXTtcbiAgZm9yIChsZXQgaTIgPSAxOyBpMiA8PSByZW1haW5pbmc7IGkyKyspIHtcbiAgICBjb25zdCBvZmZzZXRQcm9ncmVzcyA9IHByb2dyZXNzMigwLCByZW1haW5pbmcsIGkyKTtcbiAgICBvZmZzZXQucHVzaChtaXgyKG1pbiwgMSwgb2Zmc2V0UHJvZ3Jlc3MpKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmYXVsdE9mZnNldDIobGVuZ3RoKSB7XG4gIGNvbnN0IG9mZnNldCA9IFswXTtcbiAgZmlsbE9mZnNldChvZmZzZXQsIGxlbmd0aCAtIDEpO1xuICByZXR1cm4gb2Zmc2V0O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2ludGVycG9sYXRlLmVzLmpzXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZTIob3V0cHV0LCBpbnB1dCA9IGRlZmF1bHRPZmZzZXQyKG91dHB1dC5sZW5ndGgpLCBlYXNpbmcgPSBub29wUmV0dXJuKSB7XG4gIGNvbnN0IGxlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG4gIGNvbnN0IHJlbWFpbmRlciA9IGxlbmd0aCAtIGlucHV0Lmxlbmd0aDtcbiAgcmVtYWluZGVyID4gMCAmJiBmaWxsT2Zmc2V0KGlucHV0LCByZW1haW5kZXIpO1xuICByZXR1cm4gKHQpID0+IHtcbiAgICBsZXQgaTIgPSAwO1xuICAgIGZvciAoOyBpMiA8IGxlbmd0aCAtIDI7IGkyKyspIHtcbiAgICAgIGlmICh0IDwgaW5wdXRbaTIgKyAxXSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBwcm9ncmVzc0luUmFuZ2UgPSBjbGFtcDMoMCwgMSwgcHJvZ3Jlc3MyKGlucHV0W2kyXSwgaW5wdXRbaTIgKyAxXSwgdCkpO1xuICAgIGNvbnN0IHNlZ21lbnRFYXNpbmcgPSBnZXRFYXNpbmdGb3JTZWdtZW50KGVhc2luZywgaTIpO1xuICAgIHByb2dyZXNzSW5SYW5nZSA9IHNlZ21lbnRFYXNpbmcocHJvZ3Jlc3NJblJhbmdlKTtcbiAgICByZXR1cm4gbWl4MihvdXRwdXRbaTJdLCBvdXRwdXRbaTIgKyAxXSwgcHJvZ3Jlc3NJblJhbmdlKTtcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9pcy1mdW5jdGlvbi5lcy5qc1xudmFyIGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2lzLXN0cmluZy5lcy5qc1xudmFyIGlzU3RyaW5nMiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L3ZlbG9jaXR5LmVzLmpzXG5mdW5jdGlvbiB2ZWxvY2l0eVBlclNlY29uZDIodmVsb2NpdHksIGZyYW1lRHVyYXRpb24pIHtcbiAgcmV0dXJuIGZyYW1lRHVyYXRpb24gPyB2ZWxvY2l0eSAqICgxZTMgLyBmcmFtZUR1cmF0aW9uKSA6IDA7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L3V0aWxzL3Jlc29sdmUtZWxlbWVudHMuZXMuanNcbmZ1bmN0aW9uIHJlc29sdmVFbGVtZW50cyhlbGVtZW50cywgc2VsZWN0b3JDYWNoZSkge1xuICB2YXIgX2E7XG4gIGlmICh0eXBlb2YgZWxlbWVudHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoc2VsZWN0b3JDYWNoZSkge1xuICAgICAgKF9hID0gc2VsZWN0b3JDYWNoZVtlbGVtZW50c10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNlbGVjdG9yQ2FjaGVbZWxlbWVudHNdID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbGVtZW50cyk7XG4gICAgICBlbGVtZW50cyA9IHNlbGVjdG9yQ2FjaGVbZWxlbWVudHNdO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudHMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbGVtZW50cyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudHMgfHwgW10pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvdHNsaWIvbW9kdWxlcy9pbmRleC5qc1xudmFyIGltcG9ydF90c2xpYjQgPSBfX3RvRVNNKHJlcXVpcmVfdHNsaWIyKCksIDEpO1xudmFyIHtcbiAgX19leHRlbmRzOiBfX2V4dGVuZHMyLFxuICBfX2Fzc2lnbjogX19hc3NpZ24yLFxuICBfX3Jlc3Q6IF9fcmVzdDIsXG4gIF9fZGVjb3JhdGU6IF9fZGVjb3JhdGUyLFxuICBfX3BhcmFtOiBfX3BhcmFtMixcbiAgX19tZXRhZGF0YTogX19tZXRhZGF0YTIsXG4gIF9fYXdhaXRlcjogX19hd2FpdGVyMixcbiAgX19nZW5lcmF0b3I6IF9fZ2VuZXJhdG9yMixcbiAgX19leHBvcnRTdGFyOiBfX2V4cG9ydFN0YXIyLFxuICBfX2NyZWF0ZUJpbmRpbmc6IF9fY3JlYXRlQmluZGluZzIsXG4gIF9fdmFsdWVzOiBfX3ZhbHVlczIsXG4gIF9fcmVhZDogX19yZWFkMixcbiAgX19zcHJlYWQ6IF9fc3ByZWFkMixcbiAgX19zcHJlYWRBcnJheXM6IF9fc3ByZWFkQXJyYXlzMixcbiAgX19zcHJlYWRBcnJheTogX19zcHJlYWRBcnJheTIsXG4gIF9fYXdhaXQ6IF9fYXdhaXQyLFxuICBfX2FzeW5jR2VuZXJhdG9yOiBfX2FzeW5jR2VuZXJhdG9yMixcbiAgX19hc3luY0RlbGVnYXRvcjogX19hc3luY0RlbGVnYXRvcjIsXG4gIF9fYXN5bmNWYWx1ZXM6IF9fYXN5bmNWYWx1ZXMyLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdDogX19tYWtlVGVtcGxhdGVPYmplY3QyLFxuICBfX2ltcG9ydFN0YXI6IF9faW1wb3J0U3RhcjIsXG4gIF9faW1wb3J0RGVmYXVsdDogX19pbXBvcnREZWZhdWx0MixcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEdldDogX19jbGFzc1ByaXZhdGVGaWVsZEdldDIsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ6IF9fY2xhc3NQcml2YXRlRmllbGRTZXQyLFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW46IF9fY2xhc3NQcml2YXRlRmllbGRJbjJcbn0gPSBpbXBvcnRfdHNsaWI0LmRlZmF1bHQ7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Jlc2l6ZS9oYW5kbGUtZWxlbWVudC5lcy5qc1xudmFyIHJlc2l6ZUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgb2JzZXJ2ZXI7XG5mdW5jdGlvbiBnZXRFbGVtZW50U2l6ZSh0YXJnZXQsIGJvcmRlckJveFNpemUpIHtcbiAgaWYgKGJvcmRlckJveFNpemUpIHtcbiAgICBjb25zdCB7IGlubGluZVNpemUsIGJsb2NrU2l6ZSB9ID0gYm9yZGVyQm94U2l6ZVswXTtcbiAgICByZXR1cm4geyB3aWR0aDogaW5saW5lU2l6ZSwgaGVpZ2h0OiBibG9ja1NpemUgfTtcbiAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIFwiZ2V0QkJveFwiIGluIHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuZ2V0QkJveCgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGFyZ2V0Lm9mZnNldFdpZHRoLFxuICAgICAgaGVpZ2h0OiB0YXJnZXQub2Zmc2V0SGVpZ2h0XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gbm90aWZ5VGFyZ2V0KHsgdGFyZ2V0LCBjb250ZW50UmVjdCwgYm9yZGVyQm94U2l6ZSB9KSB7XG4gIHZhciBfYTtcbiAgKF9hID0gcmVzaXplSGFuZGxlcnMuZ2V0KHRhcmdldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgaGFuZGxlcih7XG4gICAgICB0YXJnZXQsXG4gICAgICBjb250ZW50U2l6ZTogY29udGVudFJlY3QsXG4gICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIGdldEVsZW1lbnRTaXplKHRhcmdldCwgYm9yZGVyQm94U2l6ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gbm90aWZ5QWxsKGVudHJpZXMpIHtcbiAgZW50cmllcy5mb3JFYWNoKG5vdGlmeVRhcmdldCk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcigpIHtcbiAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXR1cm47XG4gIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKG5vdGlmeUFsbCk7XG59XG5mdW5jdGlvbiByZXNpemVFbGVtZW50KHRhcmdldCwgaGFuZGxlcikge1xuICBpZiAoIW9ic2VydmVyKVxuICAgIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKCk7XG4gIGNvbnN0IGVsZW1lbnRzID0gcmVzb2x2ZUVsZW1lbnRzKHRhcmdldCk7XG4gIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICBsZXQgZWxlbWVudEhhbmRsZXJzID0gcmVzaXplSGFuZGxlcnMuZ2V0KGVsZW1lbnQpO1xuICAgIGlmICghZWxlbWVudEhhbmRsZXJzKSB7XG4gICAgICBlbGVtZW50SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgcmVzaXplSGFuZGxlcnMuc2V0KGVsZW1lbnQsIGVsZW1lbnRIYW5kbGVycyk7XG4gICAgfVxuICAgIGVsZW1lbnRIYW5kbGVycy5hZGQoaGFuZGxlcik7XG4gICAgb2JzZXJ2ZXIgPT09IG51bGwgfHwgb2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRIYW5kbGVycyA9IHJlc2l6ZUhhbmRsZXJzLmdldChlbGVtZW50KTtcbiAgICAgIGVsZW1lbnRIYW5kbGVycyA9PT0gbnVsbCB8fCBlbGVtZW50SGFuZGxlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnRIYW5kbGVycy5kZWxldGUoaGFuZGxlcik7XG4gICAgICBpZiAoIShlbGVtZW50SGFuZGxlcnMgPT09IG51bGwgfHwgZWxlbWVudEhhbmRsZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50SGFuZGxlcnMuc2l6ZSkpIHtcbiAgICAgICAgb2JzZXJ2ZXIgPT09IG51bGwgfHwgb2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvcmVzaXplL2hhbmRsZS13aW5kb3cuZXMuanNcbnZhciB3aW5kb3dDYWxsYmFja3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIHdpbmRvd1Jlc2l6ZUhhbmRsZXI7XG5mdW5jdGlvbiBjcmVhdGVXaW5kb3dSZXNpemVIYW5kbGVyKCkge1xuICB3aW5kb3dSZXNpemVIYW5kbGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IHNpemUgPSB7XG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgIH07XG4gICAgY29uc3QgaW5mbyA9IHtcbiAgICAgIHRhcmdldDogd2luZG93LFxuICAgICAgc2l6ZSxcbiAgICAgIGNvbnRlbnRTaXplOiBzaXplXG4gICAgfTtcbiAgICB3aW5kb3dDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGluZm8pKTtcbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgd2luZG93UmVzaXplSGFuZGxlcik7XG59XG5mdW5jdGlvbiByZXNpemVXaW5kb3coY2FsbGJhY2spIHtcbiAgd2luZG93Q2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gIGlmICghd2luZG93UmVzaXplSGFuZGxlcilcbiAgICBjcmVhdGVXaW5kb3dSZXNpemVIYW5kbGVyKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgd2luZG93Q2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgaWYgKCF3aW5kb3dDYWxsYmFja3Muc2l6ZSAmJiB3aW5kb3dSZXNpemVIYW5kbGVyKSB7XG4gICAgICB3aW5kb3dSZXNpemVIYW5kbGVyID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvcmVzaXplL2luZGV4LmVzLmpzXG5mdW5jdGlvbiByZXNpemUoYTIsIGIyKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKGEyKSA/IHJlc2l6ZVdpbmRvdyhhMikgOiByZXNpemVFbGVtZW50KGEyLCBiMik7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9pbmZvLmVzLmpzXG52YXIgbWF4RWxhcHNlZDIgPSA1MDtcbnZhciBjcmVhdGVBeGlzSW5mbyA9ICgpID0+ICh7XG4gIGN1cnJlbnQ6IDAsXG4gIG9mZnNldDogW10sXG4gIHByb2dyZXNzOiAwLFxuICBzY3JvbGxMZW5ndGg6IDAsXG4gIHRhcmdldE9mZnNldDogMCxcbiAgdGFyZ2V0TGVuZ3RoOiAwLFxuICBjb250YWluZXJMZW5ndGg6IDAsXG4gIHZlbG9jaXR5OiAwXG59KTtcbnZhciBjcmVhdGVTY3JvbGxJbmZvID0gKCkgPT4gKHtcbiAgdGltZTogMCxcbiAgeDogY3JlYXRlQXhpc0luZm8oKSxcbiAgeTogY3JlYXRlQXhpc0luZm8oKVxufSk7XG52YXIga2V5cyA9IHtcbiAgeDoge1xuICAgIGxlbmd0aDogXCJXaWR0aFwiLFxuICAgIHBvc2l0aW9uOiBcIkxlZnRcIlxuICB9LFxuICB5OiB7XG4gICAgbGVuZ3RoOiBcIkhlaWdodFwiLFxuICAgIHBvc2l0aW9uOiBcIlRvcFwiXG4gIH1cbn07XG5mdW5jdGlvbiB1cGRhdGVBeGlzSW5mbyhlbGVtZW50LCBheGlzTmFtZSwgaW5mbywgdGltZSkge1xuICBjb25zdCBheGlzID0gaW5mb1theGlzTmFtZV07XG4gIGNvbnN0IHsgbGVuZ3RoLCBwb3NpdGlvbiB9ID0ga2V5c1theGlzTmFtZV07XG4gIGNvbnN0IHByZXYgPSBheGlzLmN1cnJlbnQ7XG4gIGNvbnN0IHByZXZUaW1lID0gaW5mby50aW1lO1xuICBheGlzLmN1cnJlbnQgPSBlbGVtZW50W1wic2Nyb2xsXCIgKyBwb3NpdGlvbl07XG4gIGF4aXMuc2Nyb2xsTGVuZ3RoID0gZWxlbWVudFtcInNjcm9sbFwiICsgbGVuZ3RoXSAtIGVsZW1lbnRbXCJjbGllbnRcIiArIGxlbmd0aF07XG4gIGF4aXMub2Zmc2V0Lmxlbmd0aCA9IDA7XG4gIGF4aXMub2Zmc2V0WzBdID0gMDtcbiAgYXhpcy5vZmZzZXRbMV0gPSBheGlzLnNjcm9sbExlbmd0aDtcbiAgYXhpcy5wcm9ncmVzcyA9IHByb2dyZXNzMigwLCBheGlzLnNjcm9sbExlbmd0aCwgYXhpcy5jdXJyZW50KTtcbiAgY29uc3QgZWxhcHNlZCA9IHRpbWUgLSBwcmV2VGltZTtcbiAgYXhpcy52ZWxvY2l0eSA9IGVsYXBzZWQgPiBtYXhFbGFwc2VkMiA/IDAgOiB2ZWxvY2l0eVBlclNlY29uZDIoYXhpcy5jdXJyZW50IC0gcHJldiwgZWxhcHNlZCk7XG59XG5mdW5jdGlvbiB1cGRhdGVTY3JvbGxJbmZvKGVsZW1lbnQsIGluZm8sIHRpbWUpIHtcbiAgdXBkYXRlQXhpc0luZm8oZWxlbWVudCwgXCJ4XCIsIGluZm8sIHRpbWUpO1xuICB1cGRhdGVBeGlzSW5mbyhlbGVtZW50LCBcInlcIiwgaW5mbywgdGltZSk7XG4gIGluZm8udGltZSA9IHRpbWU7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9vZmZzZXRzL2luc2V0LmVzLmpzXG5mdW5jdGlvbiBjYWxjSW5zZXQoZWxlbWVudCwgY29udGFpbmVyKSB7XG4gIGxldCBpbnNldCA9IHsgeDogMCwgeTogMCB9O1xuICBsZXQgY3VycmVudCA9IGVsZW1lbnQ7XG4gIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGNvbnRhaW5lcikge1xuICAgIGlmIChjdXJyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIGluc2V0LnggKz0gY3VycmVudC5vZmZzZXRMZWZ0O1xuICAgICAgaW5zZXQueSArPSBjdXJyZW50Lm9mZnNldFRvcDtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm9mZnNldFBhcmVudDtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBTVkdHcmFwaGljc0VsZW1lbnQgJiYgXCJnZXRCQm94XCIgaW4gY3VycmVudCkge1xuICAgICAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IGN1cnJlbnQuZ2V0QkJveCgpO1xuICAgICAgaW5zZXQueCArPSBsZWZ0O1xuICAgICAgaW5zZXQueSArPSB0b3A7XG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnRhZ05hbWUgIT09IFwic3ZnXCIpIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluc2V0O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvb2Zmc2V0cy9wcmVzZXRzLmVzLmpzXG52YXIgU2Nyb2xsT2Zmc2V0ID0ge1xuICBFbnRlcjogW1xuICAgIFswLCAxXSxcbiAgICBbMSwgMV1cbiAgXSxcbiAgRXhpdDogW1xuICAgIFswLCAwXSxcbiAgICBbMSwgMF1cbiAgXSxcbiAgQW55OiBbXG4gICAgWzEsIDBdLFxuICAgIFswLCAxXVxuICBdLFxuICBBbGw6IFtcbiAgICBbMCwgMF0sXG4gICAgWzEsIDFdXG4gIF1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9vZmZzZXRzL2VkZ2UuZXMuanNcbnZhciBuYW1lZEVkZ2VzID0ge1xuICBzdGFydDogMCxcbiAgY2VudGVyOiAwLjUsXG4gIGVuZDogMVxufTtcbmZ1bmN0aW9uIHJlc29sdmVFZGdlKGVkZ2UsIGxlbmd0aCwgaW5zZXQgPSAwKSB7XG4gIGxldCBkZWx0YSA9IDA7XG4gIGlmIChuYW1lZEVkZ2VzW2VkZ2VdICE9PSB2b2lkIDApIHtcbiAgICBlZGdlID0gbmFtZWRFZGdlc1tlZGdlXTtcbiAgfVxuICBpZiAoaXNTdHJpbmcyKGVkZ2UpKSB7XG4gICAgY29uc3QgYXNOdW1iZXIyID0gcGFyc2VGbG9hdChlZGdlKTtcbiAgICBpZiAoZWRnZS5lbmRzV2l0aChcInB4XCIpKSB7XG4gICAgICBkZWx0YSA9IGFzTnVtYmVyMjtcbiAgICB9IGVsc2UgaWYgKGVkZ2UuZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICBlZGdlID0gYXNOdW1iZXIyIC8gMTAwO1xuICAgIH0gZWxzZSBpZiAoZWRnZS5lbmRzV2l0aChcInZ3XCIpKSB7XG4gICAgICBkZWx0YSA9IGFzTnVtYmVyMiAvIDEwMCAqIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB9IGVsc2UgaWYgKGVkZ2UuZW5kc1dpdGgoXCJ2aFwiKSkge1xuICAgICAgZGVsdGEgPSBhc051bWJlcjIgLyAxMDAgKiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGdlID0gYXNOdW1iZXIyO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOdW1iZXIoZWRnZSkpIHtcbiAgICBkZWx0YSA9IGxlbmd0aCAqIGVkZ2U7XG4gIH1cbiAgcmV0dXJuIGluc2V0ICsgZGVsdGE7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9vZmZzZXRzL29mZnNldC5lcy5qc1xudmFyIGRlZmF1bHRPZmZzZXQzID0gWzAsIDBdO1xuZnVuY3Rpb24gcmVzb2x2ZU9mZnNldChvZmZzZXQsIGNvbnRhaW5lckxlbmd0aCwgdGFyZ2V0TGVuZ3RoLCB0YXJnZXRJbnNldCkge1xuICBsZXQgb2Zmc2V0RGVmaW5pdGlvbiA9IEFycmF5LmlzQXJyYXkob2Zmc2V0KSA/IG9mZnNldCA6IGRlZmF1bHRPZmZzZXQzO1xuICBsZXQgdGFyZ2V0UG9pbnQgPSAwO1xuICBsZXQgY29udGFpbmVyUG9pbnQgPSAwO1xuICBpZiAoaXNOdW1iZXIob2Zmc2V0KSkge1xuICAgIG9mZnNldERlZmluaXRpb24gPSBbb2Zmc2V0LCBvZmZzZXRdO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nMihvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0LnRyaW0oKTtcbiAgICBpZiAob2Zmc2V0LmluY2x1ZGVzKFwiIFwiKSkge1xuICAgICAgb2Zmc2V0RGVmaW5pdGlvbiA9IG9mZnNldC5zcGxpdChcIiBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldERlZmluaXRpb24gPSBbb2Zmc2V0LCBuYW1lZEVkZ2VzW29mZnNldF0gPyBvZmZzZXQgOiBgMGBdO1xuICAgIH1cbiAgfVxuICB0YXJnZXRQb2ludCA9IHJlc29sdmVFZGdlKG9mZnNldERlZmluaXRpb25bMF0sIHRhcmdldExlbmd0aCwgdGFyZ2V0SW5zZXQpO1xuICBjb250YWluZXJQb2ludCA9IHJlc29sdmVFZGdlKG9mZnNldERlZmluaXRpb25bMV0sIGNvbnRhaW5lckxlbmd0aCk7XG4gIHJldHVybiB0YXJnZXRQb2ludCAtIGNvbnRhaW5lclBvaW50O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvb2Zmc2V0cy9pbmRleC5lcy5qc1xudmFyIHBvaW50ID0geyB4OiAwLCB5OiAwIH07XG5mdW5jdGlvbiByZXNvbHZlT2Zmc2V0cyhjb250YWluZXIsIGluZm8sIG9wdGlvbnMpIHtcbiAgbGV0IHsgb2Zmc2V0OiBvZmZzZXREZWZpbml0aW9uID0gU2Nyb2xsT2Zmc2V0LkFsbCB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyB0YXJnZXQgPSBjb250YWluZXIsIGF4aXMgPSBcInlcIiB9ID0gb3B0aW9ucztcbiAgY29uc3QgbGVuZ3RoTGFiZWwgPSBheGlzID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG4gIGNvbnN0IGluc2V0ID0gdGFyZ2V0ICE9PSBjb250YWluZXIgPyBjYWxjSW5zZXQodGFyZ2V0LCBjb250YWluZXIpIDogcG9pbnQ7XG4gIGNvbnN0IHRhcmdldFNpemUgPSB0YXJnZXQgPT09IGNvbnRhaW5lciA/IHsgd2lkdGg6IGNvbnRhaW5lci5zY3JvbGxXaWR0aCwgaGVpZ2h0OiBjb250YWluZXIuc2Nyb2xsSGVpZ2h0IH0gOiB7IHdpZHRoOiB0YXJnZXQuY2xpZW50V2lkdGgsIGhlaWdodDogdGFyZ2V0LmNsaWVudEhlaWdodCB9O1xuICBjb25zdCBjb250YWluZXJTaXplID0ge1xuICAgIHdpZHRoOiBjb250YWluZXIuY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0OiBjb250YWluZXIuY2xpZW50SGVpZ2h0XG4gIH07XG4gIGluZm9bYXhpc10ub2Zmc2V0Lmxlbmd0aCA9IDA7XG4gIGxldCBoYXNDaGFuZ2VkID0gIWluZm9bYXhpc10uaW50ZXJwb2xhdGU7XG4gIGNvbnN0IG51bU9mZnNldHMgPSBvZmZzZXREZWZpbml0aW9uLmxlbmd0aDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bU9mZnNldHM7IGkyKyspIHtcbiAgICBjb25zdCBvZmZzZXQgPSByZXNvbHZlT2Zmc2V0KG9mZnNldERlZmluaXRpb25baTJdLCBjb250YWluZXJTaXplW2xlbmd0aExhYmVsXSwgdGFyZ2V0U2l6ZVtsZW5ndGhMYWJlbF0sIGluc2V0W2F4aXNdKTtcbiAgICBpZiAoIWhhc0NoYW5nZWQgJiYgb2Zmc2V0ICE9PSBpbmZvW2F4aXNdLmludGVycG9sYXRvck9mZnNldHNbaTJdKSB7XG4gICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaW5mb1theGlzXS5vZmZzZXRbaTJdID0gb2Zmc2V0O1xuICB9XG4gIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgaW5mb1theGlzXS5pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlMihkZWZhdWx0T2Zmc2V0MihudW1PZmZzZXRzKSwgaW5mb1theGlzXS5vZmZzZXQpO1xuICAgIGluZm9bYXhpc10uaW50ZXJwb2xhdG9yT2Zmc2V0cyA9IFsuLi5pbmZvW2F4aXNdLm9mZnNldF07XG4gIH1cbiAgaW5mb1theGlzXS5wcm9ncmVzcyA9IGluZm9bYXhpc10uaW50ZXJwb2xhdGUoaW5mb1theGlzXS5jdXJyZW50KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL29uLXNjcm9sbC1oYW5kbGVyLmVzLmpzXG5mdW5jdGlvbiBtZWFzdXJlKGNvbnRhaW5lciwgdGFyZ2V0ID0gY29udGFpbmVyLCBpbmZvKSB7XG4gIGluZm8ueC50YXJnZXRPZmZzZXQgPSAwO1xuICBpbmZvLnkudGFyZ2V0T2Zmc2V0ID0gMDtcbiAgaWYgKHRhcmdldCAhPT0gY29udGFpbmVyKSB7XG4gICAgbGV0IG5vZGUgPSB0YXJnZXQ7XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPSBjb250YWluZXIpIHtcbiAgICAgIGluZm8ueC50YXJnZXRPZmZzZXQgKz0gbm9kZS5vZmZzZXRMZWZ0O1xuICAgICAgaW5mby55LnRhcmdldE9mZnNldCArPSBub2RlLm9mZnNldFRvcDtcbiAgICAgIG5vZGUgPSBub2RlLm9mZnNldFBhcmVudDtcbiAgICB9XG4gIH1cbiAgaW5mby54LnRhcmdldExlbmd0aCA9IHRhcmdldCA9PT0gY29udGFpbmVyID8gdGFyZ2V0LnNjcm9sbFdpZHRoIDogdGFyZ2V0LmNsaWVudFdpZHRoO1xuICBpbmZvLnkudGFyZ2V0TGVuZ3RoID0gdGFyZ2V0ID09PSBjb250YWluZXIgPyB0YXJnZXQuc2Nyb2xsSGVpZ2h0IDogdGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgaW5mby54LmNvbnRhaW5lckxlbmd0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgaW5mby55LmNvbnRhaW5lckxlbmd0aCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVPblNjcm9sbEhhbmRsZXIoZWxlbWVudCwgb25TY3JvbGwsIGluZm8sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8IFwieVwiO1xuICByZXR1cm4ge1xuICAgIG1lYXN1cmU6ICgpID0+IG1lYXN1cmUoZWxlbWVudCwgb3B0aW9ucy50YXJnZXQsIGluZm8pLFxuICAgIHVwZGF0ZTogKHRpbWUpID0+IHtcbiAgICAgIHVwZGF0ZVNjcm9sbEluZm8oZWxlbWVudCwgaW5mbywgdGltZSk7XG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXQgfHwgb3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgcmVzb2x2ZU9mZnNldHMoZWxlbWVudCwgaW5mbywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBub3RpZnk6IGlzRnVuY3Rpb24ob25TY3JvbGwpID8gKCkgPT4gb25TY3JvbGwoaW5mbykgOiBzY3J1YkFuaW1hdGlvbihvblNjcm9sbCwgaW5mb1theGlzXSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHNjcnViQW5pbWF0aW9uKGNvbnRyb2xzLCBheGlzSW5mbykge1xuICBjb250cm9scy5wYXVzZSgpO1xuICBjb250cm9scy5mb3JFYWNoTmF0aXZlKChhbmltYXRpb24sIHsgZWFzaW5nIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChhbmltYXRpb24udXBkYXRlRHVyYXRpb24pIHtcbiAgICAgIGlmICghZWFzaW5nKVxuICAgICAgICBhbmltYXRpb24uZWFzaW5nID0gbm9vcFJldHVybjtcbiAgICAgIGFuaW1hdGlvbi51cGRhdGVEdXJhdGlvbigxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGltaW5nT3B0aW9ucyA9IHsgZHVyYXRpb246IDFlMyB9O1xuICAgICAgaWYgKCFlYXNpbmcpXG4gICAgICAgIHRpbWluZ09wdGlvbnMuZWFzaW5nID0gXCJsaW5lYXJcIjtcbiAgICAgIChfYiA9IChfYSA9IGFuaW1hdGlvbi5lZmZlY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGVUaW1pbmcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aW1pbmdPcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnRyb2xzLmN1cnJlbnRUaW1lID0gYXhpc0luZm8ucHJvZ3Jlc3M7XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9pbmRleC5lcy5qc1xudmFyIHNjcm9sbExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIHJlc2l6ZUxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIG9uU2Nyb2xsSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBnZXRFdmVudFRhcmdldCA9IChlbGVtZW50KSA9PiBlbGVtZW50ID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyB3aW5kb3cgOiBlbGVtZW50O1xuZnVuY3Rpb24gc2Nyb2xsKG9uU2Nyb2xsLCBfYSA9IHt9KSB7XG4gIHZhciB7IGNvbnRhaW5lciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB9ID0gX2EsIG9wdGlvbnMgPSBfX3Jlc3QyKF9hLCBbXCJjb250YWluZXJcIl0pO1xuICBsZXQgY29udGFpbmVySGFuZGxlcnMgPSBvblNjcm9sbEhhbmRsZXJzLmdldChjb250YWluZXIpO1xuICBpZiAoIWNvbnRhaW5lckhhbmRsZXJzKSB7XG4gICAgY29udGFpbmVySGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIG9uU2Nyb2xsSGFuZGxlcnMuc2V0KGNvbnRhaW5lciwgY29udGFpbmVySGFuZGxlcnMpO1xuICB9XG4gIGNvbnN0IGluZm8gPSBjcmVhdGVTY3JvbGxJbmZvKCk7XG4gIGNvbnN0IGNvbnRhaW5lckhhbmRsZXIgPSBjcmVhdGVPblNjcm9sbEhhbmRsZXIoY29udGFpbmVyLCBvblNjcm9sbCwgaW5mbywgb3B0aW9ucyk7XG4gIGNvbnRhaW5lckhhbmRsZXJzLmFkZChjb250YWluZXJIYW5kbGVyKTtcbiAgaWYgKCFzY3JvbGxMaXN0ZW5lcnMuaGFzKGNvbnRhaW5lcikpIHtcbiAgICBjb25zdCBsaXN0ZW5lcjIgPSAoKSA9PiB7XG4gICAgICBjb25zdCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgY29udGFpbmVySGFuZGxlcnMpXG4gICAgICAgIGhhbmRsZXIubWVhc3VyZSgpO1xuICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGNvbnRhaW5lckhhbmRsZXJzKVxuICAgICAgICBoYW5kbGVyLnVwZGF0ZSh0aW1lKTtcbiAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBjb250YWluZXJIYW5kbGVycylcbiAgICAgICAgaGFuZGxlci5ub3RpZnkoKTtcbiAgICB9O1xuICAgIHNjcm9sbExpc3RlbmVycy5zZXQoY29udGFpbmVyLCBsaXN0ZW5lcjIpO1xuICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGNvbnRhaW5lcik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbGlzdGVuZXIyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgaWYgKGNvbnRhaW5lciAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICByZXNpemVMaXN0ZW5lcnMuc2V0KGNvbnRhaW5lciwgcmVzaXplKGNvbnRhaW5lciwgbGlzdGVuZXIyKSk7XG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGxpc3RlbmVyMiwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICB9XG4gIGNvbnN0IGxpc3RlbmVyID0gc2Nyb2xsTGlzdGVuZXJzLmdldChjb250YWluZXIpO1xuICBjb25zdCBvbkxvYWRQcm9jZXNzcyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsaXN0ZW5lcik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAodHlwZW9mIG9uU2Nyb2xsICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICBvblNjcm9sbC5zdG9wKCk7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUob25Mb2FkUHJvY2Vzc3MpO1xuICAgIGNvbnN0IGNvbnRhaW5lckhhbmRsZXJzMiA9IG9uU2Nyb2xsSGFuZGxlcnMuZ2V0KGNvbnRhaW5lcik7XG4gICAgaWYgKCFjb250YWluZXJIYW5kbGVyczIpXG4gICAgICByZXR1cm47XG4gICAgY29udGFpbmVySGFuZGxlcnMyLmRlbGV0ZShjb250YWluZXJIYW5kbGVyKTtcbiAgICBpZiAoY29udGFpbmVySGFuZGxlcnMyLnNpemUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbGlzdGVuZXIyID0gc2Nyb2xsTGlzdGVuZXJzLmdldChjb250YWluZXIpO1xuICAgIHNjcm9sbExpc3RlbmVycy5kZWxldGUoY29udGFpbmVyKTtcbiAgICBpZiAobGlzdGVuZXIyKSB7XG4gICAgICBnZXRFdmVudFRhcmdldChjb250YWluZXIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbGlzdGVuZXIyKTtcbiAgICAgIChfYTIgPSByZXNpemVMaXN0ZW5lcnMuZ2V0KGNvbnRhaW5lcikpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyKCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBsaXN0ZW5lcjIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91c2Utc2Nyb2xsLm1qc1xudmFyIGltcG9ydF9yZWFjdDI4ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIGNyZWF0ZVNjcm9sbE1vdGlvblZhbHVlcyA9ICgpID0+ICh7XG4gIHNjcm9sbFg6IG1vdGlvblZhbHVlKDApLFxuICBzY3JvbGxZOiBtb3Rpb25WYWx1ZSgwKSxcbiAgc2Nyb2xsWFByb2dyZXNzOiBtb3Rpb25WYWx1ZSgwKSxcbiAgc2Nyb2xsWVByb2dyZXNzOiBtb3Rpb25WYWx1ZSgwKVxufSk7XG5mdW5jdGlvbiB1c2VTY3JvbGwoX2EgPSB7fSkge1xuICB2YXIgX2IgPSBfYSwgeyBjb250YWluZXIsIHRhcmdldCwgbGF5b3V0RWZmZWN0ID0gdHJ1ZSB9ID0gX2IsIG9wdGlvbnMgPSBfX29ialJlc3QoX2IsIFtcImNvbnRhaW5lclwiLCBcInRhcmdldFwiLCBcImxheW91dEVmZmVjdFwiXSk7XG4gIGNvbnN0IHZhbHVlcyA9IHVzZUNvbnN0YW50KGNyZWF0ZVNjcm9sbE1vdGlvblZhbHVlcyk7XG4gIGNvbnN0IHVzZUxpZmVjeWNsZUVmZmVjdCA9IGxheW91dEVmZmVjdCA/IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgOiBpbXBvcnRfcmVhY3QyOC51c2VFZmZlY3Q7XG4gIHVzZUxpZmVjeWNsZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHNjcm9sbCgoeyB4LCB5IH0pID0+IHtcbiAgICAgIHZhbHVlcy5zY3JvbGxYLnNldCh4LmN1cnJlbnQpO1xuICAgICAgdmFsdWVzLnNjcm9sbFhQcm9ncmVzcy5zZXQoeC5wcm9ncmVzcyk7XG4gICAgICB2YWx1ZXMuc2Nyb2xsWS5zZXQoeS5jdXJyZW50KTtcbiAgICAgIHZhbHVlcy5zY3JvbGxZUHJvZ3Jlc3Muc2V0KHkucHJvZ3Jlc3MpO1xuICAgIH0sIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICBjb250YWluZXI6IChjb250YWluZXIgPT09IG51bGwgfHwgY29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250YWluZXIuY3VycmVudCkgfHwgdm9pZCAwLFxuICAgICAgdGFyZ2V0OiAodGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0LmN1cnJlbnQpIHx8IHZvaWQgMFxuICAgIH0pKTtcbiAgfSwgW10pO1xuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vLyBzcmMvTWVudS50c3hcbnZhciBpbXBvcnRfanN4X3J1bnRpbWUyID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIE1lbnUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgc2Nyb2xsWVByb2dyZXNzIH0gPSB1c2VTY3JvbGwoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3hzKShcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcImhpZGRlbiBzbTpibG9ja1wiLFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4KShtb3Rpb24uZGl2LCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJwcm9ncmVzcy1iYXJcIixcbiAgICAgICAgc3R5bGU6IHsgc2NhbGVYOiBzY3JvbGxZUHJvZ3Jlc3MgfVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4cykoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwiZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIGJnLWdyYWRpZW50LXRvLXIgZnJvbS1ibHVlLTQwMCB0by1ibHVlLTUwMFwiLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyb3VuZGVkLXhsIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiL1wiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJQeWxhclxcdTIxMjIgQUlcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4KShcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicm91bmRlZC14bCBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGVcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4KShcImFcIiwge1xuICAgICAgICAgICAgICBocmVmOiBcIi9ibG9nXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkRhaWx5IFdvcmtcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4KShcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicm91bmRlZC14bCBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGVcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4KShcImFcIiwge1xuICAgICAgICAgICAgICBocmVmOiBcIi93aGF0LWlzLXB5bGFyXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkFib3V0XCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCIvcHlsYXItbGljZW5zZVwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJUaGUgTGljZW5zZVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyb3VuZGVkLXhsIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiaHR0cHM6Ly9wZW5jaWwuZG9tYWluc1wiLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgIHJlbDogXCJub3JlZmVycmVyXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlBlbmNpbCBEb21haW5zXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeHMpKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWRkZW4gcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlIG1kOmJsb2NrXCIsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWRkZW4gcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlIG1kOmJsb2NrXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICAgICAgICBocmVmOiBcImh0dHA6Ly90d2l0dGVyLmNvbS9zdXBlcmRhdGFzXCIsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgICByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiVHdpdHRlclwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICAgICAgaHJlZjogXCJodHRwOi8vZ2l0aHViLmNvbS9taWd1ZWxnYXJnYWxsby9uZXh0MTMtZ2FsbGVyeS1pbWFnZS10dXJib1wiLFxuICAgICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgICByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWRkZW4gcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlIG1kOmJsb2NrXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwicGljdHVyZVwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoXCJpbWdcIiwge1xuICAgICAgICAgICAgICAgICAgICBzcmM6IFwiaHR0cHM6Ly9pbWcuc2hpZWxkcy5pby9naXRodWIvc3RhcnMvbWlndWVsZ2FyZ2FsbG8vTmV4dDEzLWdhbGxlcnktaW1hZ2UtdHVyYm8/c3R5bGU9c29jaWFsXCIsXG4gICAgICAgICAgICAgICAgICAgIGFsdDogXCJMYW5kc2NhcGUgcGljdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAwLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoVmVyc2lvbiwge30pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xufTtcblxuLy8gc3JjL01lbnVQeWxhci50c3hcbnZhciBpbXBvcnRfanN4X3J1bnRpbWUzID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIE1lbnVQeWxhciA9ICgpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMy5qc3gpKFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwiZmxleCBoaWRkZW4gZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBiZy1ncmFkaWVudC10by1yIGZyb20tYmx1ZS00MDAgdG8tYmx1ZS01MDAgc206YmxvY2tcIixcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUzLmpzeHMpKFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJmbGV4IGZsZXgtcm93XCIsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTMuanN4KShcImJ1dHRvblwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMy5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICBocmVmOiBcIi9ibG9nXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJPdXIgRGFpbHkgV29ya1wiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMy5qc3gpKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicm91bmRlZC14bCBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGVcIixcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUzLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgIGhyZWY6IFwiL3doYXQtaXMtcHlsYXJcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIldoYXQgaXMgUHlsYXIgQUlcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTMuanN4KShcImJ1dHRvblwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMy5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICBocmVmOiBcIi9weWxhci1saWNlbnNlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJMaWNlbnNlXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgXVxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL1RpdGxlUHlsYXIudHN4XG52YXIgaW1wb3J0X2pzeF9ydW50aW1lNCA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBUaXRsZVB5bGFyID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeHMpKFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeHMpKFwiaDFcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicHktOCB0ZXh0LWNlbnRlciB0ZXh0LTV4bCBmb250LWJvbGRcIixcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDAuNSwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiUFwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeCkobW90aW9uLnNwYW4sIHtcbiAgICAgICAgICAgIGluaXRpYWw6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgYW5pbWF0ZTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB7IGRlbGF5OiAwLjYsIGR1cmF0aW9uOiAxLjUgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcInlcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMC43LCBkdXJhdGlvbjogMS41IH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJsXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDAuOCwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiYVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeCkobW90aW9uLnNwYW4sIHtcbiAgICAgICAgICAgIGluaXRpYWw6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgYW5pbWF0ZTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB7IGRlbGF5OiAwLjksIGR1cmF0aW9uOiAxLjUgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcInJcXHUyMTIyXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDEsIGR1cmF0aW9uOiAxLjUgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIlxceEEwXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDEuMSwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiQVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeCkobW90aW9uLnNwYW4sIHtcbiAgICAgICAgICAgIGluaXRpYWw6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgYW5pbWF0ZTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB7IGRlbGF5OiAxLjIsIGR1cmF0aW9uOiAxLjUgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIklcIlxuICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeHMpKG1vdGlvbi5oMiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicHktOCB0ZXh0LWNlbnRlciB0ZXh0LTR4bCBmb250LWJvbGRcIixcbiAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB0cmFuc2l0aW9uOiB7IGRlbGF5OiAxLjQsIGR1cmF0aW9uOiAxLjUgfSxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShcInNwYW5cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInRleHQtYmx1ZS01MDBcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIlB5XCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBcInRob25cIixcbiAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShcInNwYW5cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInRleHQtYmx1ZS01MDBcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIkxcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIFwiZWFybmluZ1wiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiQVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJydGlmaWNpYWxcIixcbiAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShcInNwYW5cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInRleHQtYmx1ZS01MDBcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIlJcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIFwiZXNlYXJjaFxcdTIxMjJcIixcbiAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShcInNwYW5cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInRleHQtYmxhY2tcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIiBcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiQVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJydGlmaWNpYWxcIixcbiAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShcInNwYW5cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInRleHQtYmx1ZS01MDBcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIklcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIFwibnRlbGxpZ2VuY2VcIixcbiAgICAgICAgICBcIiBcIlxuICAgICAgICBdXG4gICAgICB9KVxuICAgIF1cbiAgfSk7XG59O1xuXG4vLyBzcmMvTGlzdFB5bGFyLnRzeFxudmFyIGltcG9ydF9qc3hfcnVudGltZTUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgTGlzdFB5bGFyID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeCkoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJtdC04IGZsZXggZmxleC1yb3cganVzdGlmeS1jZW50ZXJcIixcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeHMpKFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJmbGV4IHctMy80IGZsZXgtY29sXCIsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4KShcImgyXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC0yeGwgZm9udC1ib2xkXCIsXG4gICAgICAgICAgY2hpbGRyZW46IFwiV2VsY29tZSB0byB0aGUgUHlsYXIgQUkgQmxvZ1wiXG4gICAgICAgIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4cykoXCJwXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibXQtNCB0ZXh0LWxnXCIsXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIFwiUHlsYXIgQUkgaXM6XCIsXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4cykoXCJ1bFwiLCB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJsaXN0LWluc2lkZSBsaXN0LWRpc2NcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4KShcImxpXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkdlbmVyYXRpdmUgYXJ0IHJlc3VsdHNcIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJXaGF0IGlzIGdlbmVyYXRpdmUgYXJ0PyBHZW5lcmF0aXZlIGFydCBpcyBhIGZvcm0gb2YgYXJ0IHRoYXQgdXNlcyBhIGNvbXB1dGVyIHRvIGNyZWF0ZSBhcnQuIFRoZSBjb21wdXRlciBpcyBwcm9ncmFtbWVkIHRvIGNyZWF0ZSBhcnQgYmFzZWQgb24gYSBzZXQgb2YgcnVsZXMuXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4KShcInBcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiXFx4QTBcIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwibGlcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUHJvbXQgRW5naW5lZXJpbmcgZGVzaWduXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4KShcImFcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUHJvbXQgRW5naW5lZXJpbmcgaXMgYSBmb3JtIG9mIGVuZ2luZWVyaW5nIHRoYXQgdXNlcyBhIGNvbXB1dGVyIHRvIGNyZWF0ZSBlbmdpbmVlcmluZy4gVGhlIGNvbXB1dGVyIGlzIHByb2dyYW1tZWQgdG8gY3JlYXRlIGVuZ2luZWVyaW5nIGJhc2VkIG9uIGEgc2V0IG9mIHJ1bGVzLlwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeCkoXCJwXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlxceEEwXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4KShcImxpXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlN0YWJsZURpZmZ1c2lvbiAyLjAgbW9kaWZpZWRcIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJTdGFibGVEaWZmdXNpb24gMi4wIGlzIGEgY29tcHV0ZXIgcHJvZ3JhbSB0aGF0IGlzIHVzZWQgdG8gY3JlYXRlIGFydCBiYXNlZCBvbiBhIHNldCBvZiBydWxlcy5cIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwicFwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJcXHhBMFwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyBzcmMvRm9vdGVyLnRzeFxudmFyIGltcG9ydF9qc3hfcnVudGltZTYgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgRm9vdGVyID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU2LmpzeHMpKFwiZm9vdGVyXCIsIHtcbiAgICBjbGFzc05hbWU6IFwiYmctd2hpdGUgcHktOCB0ZXh0LWNlbnRlclwiLFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTYuanN4KShcImRpdlwiLCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTYuanN4cykoXCJhXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgXCJNYWRlIHdpdGggXFx1Mjc2NFxcdUZFMEYgYnlcIixcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU2LmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCJodHRwczovL3R3aXR0ZXIuY29tL21pZ3VlbGdhcmdhbGxvXCIsXG4gICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImhvdmVyOnRleHQtYmx1ZSB0ZXh0LWluZGlnby02MDBcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiTWlndWVsIEdhcmdhbGxvXCJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCIuXCJcbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3gpKFwiZGl2XCIsIHtcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3hzKShcImFcIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBcIjIwMjIgXFx4QTlcIixcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU2LmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCJodHRwczovL2h1Z2dpbmdmYWNlLmNvL3NwYWNlcy9zdXBlcmRhdGFzL0xJQ0VOU0VcIixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgICByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaG92ZXI6dGV4dC1ibHVlIHRleHQtaW5kaWdvLTYwMFwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJQeWxhclxcdTIxMjIgQUkgY3JlYXRpdmUgTUwgbGljZW5zZVwiXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwiLlwiXG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTYuanN4KShcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJoaWRkZW4gc206YmxvY2tcIixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3gpKFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiZmxleCB3LWZ1bGwgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCIsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vc3BhY2VzL3N1cGVyZGF0YXMvTElDRU5TRVwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWRkZW4gcC0yIG1kOmJsb2NrXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU2LmpzeCkoXCJwaWN0dXJlXCIsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3gpKFwiaW1nXCIsIHtcbiAgICAgICAgICAgICAgICBzcmM6IFwiaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9mcm9udC9hc3NldHMvaHVnZ2luZ2ZhY2VfbG9nby5zdmdcIixcbiAgICAgICAgICAgICAgICBhbHQ6IFwiTGFuZHNjYXBlIHBpY3R1cmVcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogNDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTYuanN4KShcInBcIiwge1xuICAgICAgICBjaGlsZHJlbjogXCJUaGFua3MgZm9yIHlvdXIgdGltZS5cIlxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xufTtcblxuLy8gc3JjL1Njcm9sbGFibGUudHN4XG52YXIgaW1wb3J0X2pzeF9ydW50aW1lNyA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBTY3JvbGxhYmxlID0gKCkgPT4ge1xuICBjb25zdCB7IHNjcm9sbFlQcm9ncmVzcyB9ID0gdXNlU2Nyb2xsKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTcuanN4KShtb3Rpb24uZGl2LCB7XG4gICAgY2xhc3NOYW1lOiBcInByb2dyZXNzLWJhclwiLFxuICAgIHN0eWxlOiB7IHNjYWxlWDogc2Nyb2xsWVByb2dyZXNzIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvQmxvZ1B5bGFyL2Jsb2cudHN4XG52YXIgaW1wb3J0X2pzeF9ydW50aW1lOCA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBFTEVNRU5UUzIgPSA1O1xudmFyIGJsb2cgPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTguanN4KShcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOC5qc3gpKFwic3ZnXCIsIHtcbiAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICB3aWR0aDogXCI5NVwiLFxuICAgICAgaGVpZ2h0OiBcIjk1XCIsXG4gICAgICBzdHJva2U6IFwiI0ZGRlwiLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCIwXCIsXG4gICAgICB2aWV3Qm94OiBcIjAgMCA5NSA5NVwiLFxuICAgICAgY2xhc3NOYW1lOiBcIm0tMiByb3VuZGVkLXhsIHB5LTIgc2hhZG93LW1kIGhvdmVyOnNoYWRvdy14bFwiLFxuICAgICAgc3R5bGU6IGsoRUxFTUVOVFMyKSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTguanN4KShcInBhdGhcIiwge1xuICAgICAgICBkOiBcIk0zMi44MTYsMTIuOTUsMzAuMzQ5LDguNTY4aDQuNzhhLjQzOS40MzksMCwwLDEsLjM0Ni4ybC45MzEsMS41MzRjLjU1OC45MiwxLjIyNSwyLjAyLDEuNjA3LDIuNjQ4Wk0yMy45NzUsMzkuNDk1YS4zMzkuMzM5LDAsMCwxLS4zMTUuMjA3SDE4Ljc3Mmw3LjU5NS0xMy42MzVhLjczMS43MzEsMCwwLDAtLjYzNi0xLjA4N2gwTDEyLjc4NywyNWwtMi41NzQtNC40NTZIMjkuMDc2Yy4wMTEsMCwuMDIsMCwuMDMxLDBhLjY3Ny42NzcsMCwwLDAsLjIxNy0uMDQ1bC4wNDctLjAyYS43MjIuNzIyLDAsMCwwLC4zNDYtLjMxM2wzLjEwOC01Ljc0NWg1LjEzWm0tNi40NjgtLjUxOC0uNjEzLTEuMDA5Yy0uNzg1LTEuMy0xLjc5MS0yLjk1NS0xLjktMy4xMzdhLjM4NS4zODUsMCwwLDEsLjAyNC0uMzU1bDQuNDU3LTguMDI3LDUuMDE5LS4wMDZaTTguOTQ4LDMwLjQ0NCw2LjQ1MywyNi4wMTEsOC45NjgsMjEuM2wyLjUyMiw0LjM2N0MxMC43MDYsMjcuMTQsOS40ODMsMjkuNDQyLDguOTQ4LDMwLjQ0NFptLTMuMzQ4LjY5SDIuODgxYS40NDMuNDQzLDAsMCwxLS4zNDMtLjJMMS43MjYsMjkuNkMxLjE0NywyOC42NDEuNDA5LDI3LjQyNSwwLDI2Ljc1Mkg1LjJsMi40NjYsNC4zODNaTTE0LjAzNy4yMDhBLjMzOC4zMzgsMCwwLDEsMTQuMzUxLDBoNC45MUwxMS42NDYsMTMuNjM2Yy0uMDA2LjAxMS0uMDEuMDIzLS4wMTYuMDM1cy0uMDIxLjA0Ni0uMDMuMDctLjAxNS4wNDYtLjAyMS4wNjktLjAxMS4wNDQtLjAxNC4wNjZhLjY0OC42NDgsMCwwLDAtLjAwOC4wODFjMCwuMDEyLDAsLjAyMywwLC4wMzZzMCwuMDE4LDAsLjAyN2EuNTkxLjU5MSwwLDAsMCwuMDA4LjA3OS41MzguNTM4LDAsMCwwLC4wMTIuMDY2Yy4wMDYuMDIzLjAxMy4wNDUuMDIxLjA2OHMuMDE2LjA0NS4wMjUuMDY2LjAyMS4wNDEuMDMzLjA2Mi4wMjMuMDQuMDM3LjA1OWEuNjQ0LjY0NCwwLDAsMCwuMDQ1LjA1NWMuMDE2LjAxNy4wMzEuMDM1LjA0OC4wNTFzLjAzNS4wMjkuMDUzLjA0M2EuNjM0LjYzNCwwLDAsMCwuMDYzLjA0NWwuMDIzLjAxNmMuMDA4LDAsLjAxOC4wMDYuMDI3LjAxMWEuNzI5LjcyOSwwLDAsMCwuMTE5LjA0OGMuMDE1LDAsLjAyOS4wMS4wNDQuMDEzYS43LjcsMCwwLDAsLjE2NC4wMjFoLjMzbDEyLjYxOS0uMDE3Yy4zMzQuNTguOTU3LDEuNjczLDEuNDg5LDIuNnEuNjEyLDEuMDcyLDEuMDEsMS43NjhIOC45NDljLS4wMDgsMC0uMDE2LDAtLjAyNCwwYS43MjUuNzI1LDAsMCwwLS42MzEuMzgyTDUuMTg1LDI1LjI5SC4wNTlabTYuNDc5LjUzNC40NTYuNzVjLjgsMS4zMjEsMS45MzIsMy4xODUsMi4wNTIsMy4zNzlBLjM4My4zODMsMCwwLDEsMjMsNS4yMjdsLTQuNDU3LDguMDI3LTUuMDE3LjAwNlptOC41NDYsOC41MTEsMi41LDQuNDM1LTIuNTQ1LDQuN2MtLjMtLjUyOS0uNjgtMS4xODktMS4wMzQtMS44MDgtLjctMS4yMjQtMS4yMDgtMi4xMTUtMS40OTUtMi42MTNDMjcuMDI4LDEyLjk3NywyOC40NjIsMTAuMzQ5LDI5LjA2Miw5LjI1M1pcIixcbiAgICAgICAgaWQ6IFwiRmlsbC0xXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJmaWxsLXllbGxvdy01MDBcIlxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9CbG9nUHlsYXIvcG9zdDEyMDMyMDIyLnRzeFxudmFyIGltcG9ydF9qc3hfcnVudGltZTkgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgRUxFTUVOVFMzID0gNTtcbnZhciBwb3N0MTIwMzIwMjIgPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTkuanN4KShcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOS5qc3gpKFwic3ZnXCIsIHtcbiAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICB3aWR0aDogXCI5NVwiLFxuICAgICAgaGVpZ2h0OiBcIjk1XCIsXG4gICAgICBzdHJva2U6IFwiI0ZGRlwiLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCIwXCIsXG4gICAgICB2aWV3Qm94OiBcIjAgMCA5NSA5NVwiLFxuICAgICAgY2xhc3NOYW1lOiBcIm0tMiByb3VuZGVkLXhsIHB5LTIgc2hhZG93LW1kIGhvdmVyOnNoYWRvdy14bFwiLFxuICAgICAgc3R5bGU6IGsoRUxFTUVOVFMzKSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTkuanN4KShcInBhdGhcIiwge1xuICAgICAgICBkOiBcIk0zMi44MTYsMTIuOTUsMzAuMzQ5LDguNTY4aDQuNzhhLjQzOS40MzksMCwwLDEsLjM0Ni4ybC45MzEsMS41MzRjLjU1OC45MiwxLjIyNSwyLjAyLDEuNjA3LDIuNjQ4Wk0yMy45NzUsMzkuNDk1YS4zMzkuMzM5LDAsMCwxLS4zMTUuMjA3SDE4Ljc3Mmw3LjU5NS0xMy42MzVhLjczMS43MzEsMCwwLDAtLjYzNi0xLjA4N2gwTDEyLjc4NywyNWwtMi41NzQtNC40NTZIMjkuMDc2Yy4wMTEsMCwuMDIsMCwuMDMxLDBhLjY3Ny42NzcsMCwwLDAsLjIxNy0uMDQ1bC4wNDctLjAyYS43MjIuNzIyLDAsMCwwLC4zNDYtLjMxM2wzLjEwOC01Ljc0NWg1LjEzWm0tNi40NjgtLjUxOC0uNjEzLTEuMDA5Yy0uNzg1LTEuMy0xLjc5MS0yLjk1NS0xLjktMy4xMzdhLjM4NS4zODUsMCwwLDEsLjAyNC0uMzU1bDQuNDU3LTguMDI3LDUuMDE5LS4wMDZaTTguOTQ4LDMwLjQ0NCw2LjQ1MywyNi4wMTEsOC45NjgsMjEuM2wyLjUyMiw0LjM2N0MxMC43MDYsMjcuMTQsOS40ODMsMjkuNDQyLDguOTQ4LDMwLjQ0NFptLTMuMzQ4LjY5SDIuODgxYS40NDMuNDQzLDAsMCwxLS4zNDMtLjJMMS43MjYsMjkuNkMxLjE0NywyOC42NDEuNDA5LDI3LjQyNSwwLDI2Ljc1Mkg1LjJsMi40NjYsNC4zODNaTTE0LjAzNy4yMDhBLjMzOC4zMzgsMCwwLDEsMTQuMzUxLDBoNC45MUwxMS42NDYsMTMuNjM2Yy0uMDA2LjAxMS0uMDEuMDIzLS4wMTYuMDM1cy0uMDIxLjA0Ni0uMDMuMDctLjAxNS4wNDYtLjAyMS4wNjktLjAxMS4wNDQtLjAxNC4wNjZhLjY0OC42NDgsMCwwLDAtLjAwOC4wODFjMCwuMDEyLDAsLjAyMywwLC4wMzZzMCwuMDE4LDAsLjAyN2EuNTkxLjU5MSwwLDAsMCwuMDA4LjA3OS41MzguNTM4LDAsMCwwLC4wMTIuMDY2Yy4wMDYuMDIzLjAxMy4wNDUuMDIxLjA2OHMuMDE2LjA0NS4wMjUuMDY2LjAyMS4wNDEuMDMzLjA2Mi4wMjMuMDQuMDM3LjA1OWEuNjQ0LjY0NCwwLDAsMCwuMDQ1LjA1NWMuMDE2LjAxNy4wMzEuMDM1LjA0OC4wNTFzLjAzNS4wMjkuMDUzLjA0M2EuNjM0LjYzNCwwLDAsMCwuMDYzLjA0NWwuMDIzLjAxNmMuMDA4LDAsLjAxOC4wMDYuMDI3LjAxMWEuNzI5LjcyOSwwLDAsMCwuMTE5LjA0OGMuMDE1LDAsLjAyOS4wMS4wNDQuMDEzYS43LjcsMCwwLDAsLjE2NC4wMjFoLjMzbDEyLjYxOS0uMDE3Yy4zMzQuNTguOTU3LDEuNjczLDEuNDg5LDIuNnEuNjEyLDEuMDcyLDEuMDEsMS43NjhIOC45NDljLS4wMDgsMC0uMDE2LDAtLjAyNCwwYS43MjUuNzI1LDAsMCwwLS42MzEuMzgyTDUuMTg1LDI1LjI5SC4wNTlabTYuNDc5LjUzNC40NTYuNzVjLjgsMS4zMjEsMS45MzIsMy4xODUsMi4wNTIsMy4zNzlBLjM4My4zODMsMCwwLDEsMjMsNS4yMjdsLTQuNDU3LDguMDI3LTUuMDE3LjAwNlptOC41NDYsOC41MTEsMi41LDQuNDM1LTIuNTQ1LDQuN2MtLjMtLjUyOS0uNjgtMS4xODktMS4wMzQtMS44MDgtLjctMS4yMjQtMS4yMDgtMi4xMTUtMS40OTUtMi42MTNDMjcuMDI4LDEyLjk3NywyOC40NjIsMTAuMzQ5LDI5LjA2Miw5LjI1M1pcIixcbiAgICAgICAgaWQ6IFwiRmlsbC0xXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJmaWxsLXllbGxvdy01MDBcIlxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRm9vdGVyLFxuICBMaXN0UHlsYXIsXG4gIE1lbnUsXG4gIE1lbnVQeWxhcixcbiAgU2Nyb2xsYWJsZSxcbiAgVGl0bGVQeWxhcixcbiAgVmVyc2lvbixcbiAgYmxvZyxcbiAgcG9zdDEyMDMyMDIyXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../packages/ui/dist/index.js\n");

/***/ }),

/***/ "next/head":
/*!****************************!*\
  !*** external "next/head" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("next/head");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = require("react");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "react/jsx-runtime":
/*!************************************!*\
  !*** external "react/jsx-runtime" ***!
  \************************************/
/***/ ((module) => {

module.exports = require("react/jsx-runtime");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("./src/pages/index.tsx"));
module.exports = __webpack_exports__;

})();