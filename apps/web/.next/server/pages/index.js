"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/index";
exports.ids = ["pages/index"];
exports.modules = {

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"next/head\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ui */ \"../../packages/ui/dist/index.js\");\n/* harmony import */ var ui__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ui__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable react/jsx-no-comment-textnodes */ \n\n\n\n\nfunction Home() {\n    console.log(\"âœ… Pylar AI\");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-w-screen flex min-h-screen flex-col bg-white\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Pylar AI by Pencil\"\n                    }, void 0, false, {\n                        fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                        lineNumber: 12,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"./favicon.ico\"\n                    }, void 0, false, {\n                        fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                        lineNumber: 13,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                lineNumber: 11,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ui__WEBPACK_IMPORTED_MODULE_2__.Menu, {}, void 0, false, {\n                fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                lineNumber: 15,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ui__WEBPACK_IMPORTED_MODULE_2__.TitlePylar, {}, void 0, false, {\n                        fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                        lineNumber: 17,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"pylarDiv\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                className: \"pylarDimension\",\n                                src: \"https://raw.githubusercontent.com/miguelgargallo/Next13-Gallery-Image-Turbo/main/Data.pylar/Images/Pylar-v1.1/A_photography_of_the_earth__from_the_moon_on_a_fis_AAAGOLjw_RealESRGAN_x4plus.jpeg\",\n                                alt: \"Pylar AI\"\n                            }, void 0, false, {\n                                fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                                lineNumber: 19,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                className: \"pylarDimension\",\n                                src: \"https://raw.githubusercontent.com/miguelgargallo/Next13-Gallery-Image-Turbo/main/Data.pylar/Images/Pylar-v1.1/A_photography_of_the_earth__from_the_moon_on_a_fis_AAAGOLjw_RealESRGAN_x4plus.jpeg\",\n                                alt: \"Pylar AI\"\n                            }, void 0, false, {\n                                fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                                lineNumber: 24,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                        lineNumber: 18,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ui__WEBPACK_IMPORTED_MODULE_2__.Footer, {}, void 0, false, {\n                fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                lineNumber: 31,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n        lineNumber: 10,\n        columnNumber: 5\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXgudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpREFBaUQsR0FDakQ7QUFBNkI7QUFDSDtBQUNNO0FBQ0o7QUFFYixTQUFTSSxPQUFPO0lBQzdCQyxRQUFRQyxHQUFHLENBQUM7SUFDWixxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNSLGtEQUFJQTs7a0NBQ0gsOERBQUNTO2tDQUFNOzs7Ozs7a0NBQ1AsOERBQUNDO3dCQUFLQyxLQUFJO3dCQUFPQyxNQUFLOzs7Ozs7Ozs7Ozs7MEJBRXhCLDhEQUFDWCxvQ0FBSUE7Ozs7OzBCQUNMLDhEQUFDWTs7a0NBQ0MsOERBQUNYLDBDQUFVQTs7Ozs7a0NBQ1gsOERBQUNLO3dCQUFJQyxXQUFVOzswQ0FDYiw4REFBQ007Z0NBQ0NOLFdBQVU7Z0NBQ1ZPLEtBQUk7Z0NBQ0pDLEtBQUk7Ozs7OzswQ0FFTiw4REFBQ0Y7Z0NBQ0NOLFdBQVU7Z0NBQ1ZPLEtBQUk7Z0NBQ0pDLEtBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFJViw4REFBQ2Isc0NBQU1BOzs7Ozs7Ozs7OztBQUdiLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9zcmMvcGFnZXMvaW5kZXgudHN4PzE5YTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcmVhY3QvanN4LW5vLWNvbW1lbnQtdGV4dG5vZGVzICovXG5pbXBvcnQgSGVhZCBmcm9tIFwibmV4dC9oZWFkXCI7XG5pbXBvcnQgeyBNZW51IH0gZnJvbSBcInVpXCI7XG5pbXBvcnQgeyBUaXRsZVB5bGFyIH0gZnJvbSBcInVpXCI7XG5pbXBvcnQgeyBGb290ZXIgfSBmcm9tIFwidWlcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcbiAgY29uc29sZS5sb2coXCLinIUgUHlsYXIgQUlcIik7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtaW4tdy1zY3JlZW4gZmxleCBtaW4taC1zY3JlZW4gZmxleC1jb2wgYmctd2hpdGVcIj5cbiAgICAgIDxIZWFkPlxuICAgICAgICA8dGl0bGU+UHlsYXIgQUkgYnkgUGVuY2lsPC90aXRsZT5cbiAgICAgICAgPGxpbmsgcmVsPVwiaWNvblwiIGhyZWY9XCIuL2Zhdmljb24uaWNvXCIgLz5cbiAgICAgIDwvSGVhZD5cbiAgICAgIDxNZW51IC8+XG4gICAgICA8bWFpbj5cbiAgICAgICAgPFRpdGxlUHlsYXIgLz5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJweWxhckRpdlwiPlxuICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInB5bGFyRGltZW5zaW9uXCJcbiAgICAgICAgICAgIHNyYz1cImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9taWd1ZWxnYXJnYWxsby9OZXh0MTMtR2FsbGVyeS1JbWFnZS1UdXJiby9tYWluL0RhdGEucHlsYXIvSW1hZ2VzL1B5bGFyLXYxLjEvQV9waG90b2dyYXBoeV9vZl90aGVfZWFydGhfX2Zyb21fdGhlX21vb25fb25fYV9maXNfQUFBR09MandfUmVhbEVTUkdBTl94NHBsdXMuanBlZ1wiXG4gICAgICAgICAgICBhbHQ9XCJQeWxhciBBSVwiXG4gICAgICAgICAgLz5cbiAgICAgICAgICA8aW1nXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJweWxhckRpbWVuc2lvblwiXG4gICAgICAgICAgICBzcmM9XCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vbWlndWVsZ2FyZ2FsbG8vTmV4dDEzLUdhbGxlcnktSW1hZ2UtVHVyYm8vbWFpbi9EYXRhLnB5bGFyL0ltYWdlcy9QeWxhci12MS4xL0FfcGhvdG9ncmFwaHlfb2ZfdGhlX2VhcnRoX19mcm9tX3RoZV9tb29uX29uX2FfZmlzX0FBQUdPTGp3X1JlYWxFU1JHQU5feDRwbHVzLmpwZWdcIlxuICAgICAgICAgICAgYWx0PVwiUHlsYXIgQUlcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9tYWluPlxuICAgICAgPEZvb3RlciAvPlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbIkhlYWQiLCJNZW51IiwiVGl0bGVQeWxhciIsIkZvb3RlciIsIkhvbWUiLCJjb25zb2xlIiwibG9nIiwiZGl2IiwiY2xhc3NOYW1lIiwidGl0bGUiLCJsaW5rIiwicmVsIiwiaHJlZiIsIm1haW4iLCJpbWciLCJzcmMiLCJhbHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n");

/***/ }),

/***/ "../../packages/ui/dist/index.js":
/*!***************************************!*\
  !*** ../../packages/ui/dist/index.js ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a2, b2) => {\n  for (var prop in b2 || (b2 = {}))\n    if (__hasOwnProp.call(b2, prop))\n      __defNormalProp(a2, prop, b2[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b2)) {\n      if (__propIsEnum.call(b2, prop))\n        __defNormalProp(a2, prop, b2[prop]);\n    }\n  return a2;\n};\nvar __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb2, mod) => function __require() {\n  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// ../../node_modules/@emotion/memoize/dist/memoize.esm.js\nfunction memoize(fn) {\n  var cache = {};\n  return function(arg) {\n    if (cache[arg] === void 0)\n      cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\nvar memoize_esm_default;\nvar init_memoize_esm = __esm({\n  \"../../node_modules/@emotion/memoize/dist/memoize.esm.js\"() {\n    memoize_esm_default = memoize;\n  }\n});\n\n// ../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\nvar is_prop_valid_esm_exports = {};\n__export(is_prop_valid_esm_exports, {\n  default: () => is_prop_valid_esm_default\n});\nvar reactPropsRegex, index, is_prop_valid_esm_default;\nvar init_is_prop_valid_esm = __esm({\n  \"../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\"() {\n    init_memoize_esm();\n    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;\n    index = memoize_esm_default(\n      function(prop) {\n        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;\n      }\n    );\n    is_prop_valid_esm_default = index;\n  }\n});\n\n// ../../node_modules/popmotion/node_modules/tslib/tslib.js\nvar require_tslib = __commonJS({\n  \"../../node_modules/popmotion/node_modules/tslib/tslib.js\"(exports, module2) {\n    var __extends3;\n    var __assign3;\n    var __rest3;\n    var __decorate3;\n    var __param3;\n    var __metadata3;\n    var __awaiter3;\n    var __generator3;\n    var __exportStar3;\n    var __values3;\n    var __read3;\n    var __spread3;\n    var __spreadArrays3;\n    var __spreadArray3;\n    var __await3;\n    var __asyncGenerator3;\n    var __asyncDelegator3;\n    var __asyncValues3;\n    var __makeTemplateObject3;\n    var __importStar3;\n    var __importDefault3;\n    var __classPrivateFieldGet3;\n    var __classPrivateFieldSet3;\n    var __classPrivateFieldIn3;\n    var __createBinding3;\n    (function(factory) {\n      var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n      if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function(exports2) {\n          factory(createExporter(root, createExporter(exports2)));\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      } else {}\n      function createExporter(exports2, previous) {\n        if (exports2 !== root) {\n          if (typeof Object.create === \"function\") {\n            Object.defineProperty(exports2, \"__esModule\", { value: true });\n          } else {\n            exports2.__esModule = true;\n          }\n        }\n        return function(id2, v) {\n          return exports2[id2] = previous ? previous(id2, v) : v;\n        };\n      }\n    })(function(exporter) {\n      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p2 in b2)\n          if (Object.prototype.hasOwnProperty.call(b2, p2))\n            d2[p2] = b2[p2];\n      };\n      __extends3 = function(d2, b2) {\n        if (typeof b2 !== \"function\" && b2 !== null)\n          throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n        extendStatics(d2, b2);\n        function __() {\n          this.constructor = d2;\n        }\n        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n      };\n      __assign3 = Object.assign || function(t) {\n        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {\n          s = arguments[i2];\n          for (var p2 in s)\n            if (Object.prototype.hasOwnProperty.call(s, p2))\n              t[p2] = s[p2];\n        }\n        return t;\n      };\n      __rest3 = function(s, e) {\n        var t = {};\n        for (var p2 in s)\n          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)\n            t[p2] = s[p2];\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {\n            if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))\n              t[p2[i2]] = s[p2[i2]];\n          }\n        return t;\n      };\n      __decorate3 = function(decorators, target, key, desc) {\n        var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n          r = Reflect.decorate(decorators, target, key, desc);\n        else\n          for (var i2 = decorators.length - 1; i2 >= 0; i2--)\n            if (d2 = decorators[i2])\n              r = (c3 < 3 ? d2(r) : c3 > 3 ? d2(target, key, r) : d2(target, key)) || r;\n        return c3 > 3 && r && Object.defineProperty(target, key, r), r;\n      };\n      __param3 = function(paramIndex, decorator) {\n        return function(target, key) {\n          decorator(target, key, paramIndex);\n        };\n      };\n      __metadata3 = function(metadataKey, metadataValue) {\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n          return Reflect.metadata(metadataKey, metadataValue);\n      };\n      __awaiter3 = function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      __generator3 = function(thisArg, body) {\n        var _ = { label: 0, sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        }, trys: [], ops: [] }, f2, y, t, g2;\n        return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n          return this;\n        }), g2;\n        function verb(n) {\n          return function(v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f2)\n            throw new TypeError(\"Generator is already executing.\");\n          while (_)\n            try {\n              if (f2 = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                return t;\n              if (y = 0, t)\n                op = [op[0] & 2, t.value];\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n                case 4:\n                  _.label++;\n                  return { value: op[1], done: false };\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n                case 7:\n                  op = _.ops.pop();\n                  _.trys.pop();\n                  continue;\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n                    _.ops.push(op);\n                    break;\n                  }\n                  if (t[2])\n                    _.ops.pop();\n                  _.trys.pop();\n                  continue;\n              }\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f2 = t = 0;\n            }\n          if (op[0] & 5)\n            throw op[1];\n          return { value: op[0] ? op[1] : void 0, done: true };\n        }\n      };\n      __exportStar3 = function(m, o) {\n        for (var p2 in m)\n          if (p2 !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p2))\n            __createBinding3(o, m, p2);\n      };\n      __createBinding3 = Object.create ? function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        var desc = Object.getOwnPropertyDescriptor(m, k2);\n        if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n          desc = { enumerable: true, get: function() {\n            return m[k2];\n          } };\n        }\n        Object.defineProperty(o, k22, desc);\n      } : function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        o[k22] = m[k2];\n      };\n      __values3 = function(o) {\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i2 = 0;\n        if (m)\n          return m.call(o);\n        if (o && typeof o.length === \"number\")\n          return {\n            next: function() {\n              if (o && i2 >= o.length)\n                o = void 0;\n              return { value: o && o[i2++], done: !o };\n            }\n          };\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n      };\n      __read3 = function(o, n) {\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n        if (!m)\n          return o;\n        var i2 = m.call(o), r, ar = [], e;\n        try {\n          while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)\n            ar.push(r.value);\n        } catch (error) {\n          e = { error };\n        } finally {\n          try {\n            if (r && !r.done && (m = i2[\"return\"]))\n              m.call(i2);\n          } finally {\n            if (e)\n              throw e.error;\n          }\n        }\n        return ar;\n      };\n      __spread3 = function() {\n        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)\n          ar = ar.concat(__read3(arguments[i2]));\n        return ar;\n      };\n      __spreadArrays3 = function() {\n        for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n          s += arguments[i2].length;\n        for (var r = Array(s), k2 = 0, i2 = 0; i2 < il; i2++)\n          for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k2++)\n            r[k2] = a2[j];\n        return r;\n      };\n      __spreadArray3 = function(to, from, pack) {\n        if (pack || arguments.length === 2)\n          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {\n            if (ar || !(i2 in from)) {\n              if (!ar)\n                ar = Array.prototype.slice.call(from, 0, i2);\n              ar[i2] = from[i2];\n            }\n          }\n        return to.concat(ar || Array.prototype.slice.call(from));\n      };\n      __await3 = function(v) {\n        return this instanceof __await3 ? (this.v = v, this) : new __await3(v);\n      };\n      __asyncGenerator3 = function(thisArg, _arguments, generator) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];\n        return i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2;\n        function verb(n) {\n          if (g2[n])\n            i2[n] = function(v) {\n              return new Promise(function(a2, b2) {\n                q.push([n, v, a2, b2]) > 1 || resume(n, v);\n              });\n            };\n        }\n        function resume(n, v) {\n          try {\n            step(g2[n](v));\n          } catch (e) {\n            settle(q[0][3], e);\n          }\n        }\n        function step(r) {\n          r.value instanceof __await3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n        }\n        function fulfill(value) {\n          resume(\"next\", value);\n        }\n        function reject(value) {\n          resume(\"throw\", value);\n        }\n        function settle(f2, v) {\n          if (f2(v), q.shift(), q.length)\n            resume(q[0][0], q[0][1]);\n        }\n      };\n      __asyncDelegator3 = function(o) {\n        var i2, p2;\n        return i2 = {}, verb(\"next\"), verb(\"throw\", function(e) {\n          throw e;\n        }), verb(\"return\"), i2[Symbol.iterator] = function() {\n          return this;\n        }, i2;\n        function verb(n, f2) {\n          i2[n] = o[n] ? function(v) {\n            return (p2 = !p2) ? { value: __await3(o[n](v)), done: n === \"return\" } : f2 ? f2(v) : v;\n          } : f2;\n        }\n      };\n      __asyncValues3 = function(o) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var m = o[Symbol.asyncIterator], i2;\n        return m ? m.call(o) : (o = typeof __values3 === \"function\" ? __values3(o) : o[Symbol.iterator](), i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2);\n        function verb(n) {\n          i2[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n              v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n          };\n        }\n        function settle(resolve, reject, d2, v) {\n          Promise.resolve(v).then(function(v2) {\n            resolve({ value: v2, done: d2 });\n          }, reject);\n        }\n      };\n      __makeTemplateObject3 = function(cooked, raw) {\n        if (Object.defineProperty) {\n          Object.defineProperty(cooked, \"raw\", { value: raw });\n        } else {\n          cooked.raw = raw;\n        }\n        return cooked;\n      };\n      var __setModuleDefault = Object.create ? function(o, v) {\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n      } : function(o, v) {\n        o[\"default\"] = v;\n      };\n      __importStar3 = function(mod) {\n        if (mod && mod.__esModule)\n          return mod;\n        var result = {};\n        if (mod != null) {\n          for (var k2 in mod)\n            if (k2 !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k2))\n              __createBinding3(result, mod, k2);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n      };\n      __importDefault3 = function(mod) {\n        return mod && mod.__esModule ? mod : { \"default\": mod };\n      };\n      __classPrivateFieldGet3 = function(receiver, state, kind, f2) {\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a getter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n        return kind === \"m\" ? f2 : kind === \"a\" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);\n      };\n      __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {\n        if (kind === \"m\")\n          throw new TypeError(\"Private method is not writable\");\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a setter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n        return kind === \"a\" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;\n      };\n      __classPrivateFieldIn3 = function(state, receiver) {\n        if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\")\n          throw new TypeError(\"Cannot use 'in' operator on non-object\");\n        return typeof state === \"function\" ? receiver === state : state.has(receiver);\n      };\n      exporter(\"__extends\", __extends3);\n      exporter(\"__assign\", __assign3);\n      exporter(\"__rest\", __rest3);\n      exporter(\"__decorate\", __decorate3);\n      exporter(\"__param\", __param3);\n      exporter(\"__metadata\", __metadata3);\n      exporter(\"__awaiter\", __awaiter3);\n      exporter(\"__generator\", __generator3);\n      exporter(\"__exportStar\", __exportStar3);\n      exporter(\"__createBinding\", __createBinding3);\n      exporter(\"__values\", __values3);\n      exporter(\"__read\", __read3);\n      exporter(\"__spread\", __spread3);\n      exporter(\"__spreadArrays\", __spreadArrays3);\n      exporter(\"__spreadArray\", __spreadArray3);\n      exporter(\"__await\", __await3);\n      exporter(\"__asyncGenerator\", __asyncGenerator3);\n      exporter(\"__asyncDelegator\", __asyncDelegator3);\n      exporter(\"__asyncValues\", __asyncValues3);\n      exporter(\"__makeTemplateObject\", __makeTemplateObject3);\n      exporter(\"__importStar\", __importStar3);\n      exporter(\"__importDefault\", __importDefault3);\n      exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet3);\n      exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet3);\n      exporter(\"__classPrivateFieldIn\", __classPrivateFieldIn3);\n    });\n  }\n});\n\n// ../../node_modules/tslib/tslib.js\nvar require_tslib2 = __commonJS({\n  \"../../node_modules/tslib/tslib.js\"(exports, module2) {\n    var __extends3;\n    var __assign3;\n    var __rest3;\n    var __decorate3;\n    var __param3;\n    var __metadata3;\n    var __awaiter3;\n    var __generator3;\n    var __exportStar3;\n    var __values3;\n    var __read3;\n    var __spread3;\n    var __spreadArrays3;\n    var __spreadArray3;\n    var __await3;\n    var __asyncGenerator3;\n    var __asyncDelegator3;\n    var __asyncValues3;\n    var __makeTemplateObject3;\n    var __importStar3;\n    var __importDefault3;\n    var __classPrivateFieldGet3;\n    var __classPrivateFieldSet3;\n    var __classPrivateFieldIn3;\n    var __createBinding3;\n    (function(factory) {\n      var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n      if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function(exports2) {\n          factory(createExporter(root, createExporter(exports2)));\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      } else {}\n      function createExporter(exports2, previous) {\n        if (exports2 !== root) {\n          if (typeof Object.create === \"function\") {\n            Object.defineProperty(exports2, \"__esModule\", { value: true });\n          } else {\n            exports2.__esModule = true;\n          }\n        }\n        return function(id2, v) {\n          return exports2[id2] = previous ? previous(id2, v) : v;\n        };\n      }\n    })(function(exporter) {\n      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p2 in b2)\n          if (Object.prototype.hasOwnProperty.call(b2, p2))\n            d2[p2] = b2[p2];\n      };\n      __extends3 = function(d2, b2) {\n        if (typeof b2 !== \"function\" && b2 !== null)\n          throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n        extendStatics(d2, b2);\n        function __() {\n          this.constructor = d2;\n        }\n        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n      };\n      __assign3 = Object.assign || function(t) {\n        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {\n          s = arguments[i2];\n          for (var p2 in s)\n            if (Object.prototype.hasOwnProperty.call(s, p2))\n              t[p2] = s[p2];\n        }\n        return t;\n      };\n      __rest3 = function(s, e) {\n        var t = {};\n        for (var p2 in s)\n          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)\n            t[p2] = s[p2];\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {\n            if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))\n              t[p2[i2]] = s[p2[i2]];\n          }\n        return t;\n      };\n      __decorate3 = function(decorators, target, key, desc) {\n        var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n          r = Reflect.decorate(decorators, target, key, desc);\n        else\n          for (var i2 = decorators.length - 1; i2 >= 0; i2--)\n            if (d2 = decorators[i2])\n              r = (c3 < 3 ? d2(r) : c3 > 3 ? d2(target, key, r) : d2(target, key)) || r;\n        return c3 > 3 && r && Object.defineProperty(target, key, r), r;\n      };\n      __param3 = function(paramIndex, decorator) {\n        return function(target, key) {\n          decorator(target, key, paramIndex);\n        };\n      };\n      __metadata3 = function(metadataKey, metadataValue) {\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n          return Reflect.metadata(metadataKey, metadataValue);\n      };\n      __awaiter3 = function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      __generator3 = function(thisArg, body) {\n        var _ = { label: 0, sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        }, trys: [], ops: [] }, f2, y, t, g2;\n        return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n          return this;\n        }), g2;\n        function verb(n) {\n          return function(v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f2)\n            throw new TypeError(\"Generator is already executing.\");\n          while (g2 && (g2 = 0, op[0] && (_ = 0)), _)\n            try {\n              if (f2 = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                return t;\n              if (y = 0, t)\n                op = [op[0] & 2, t.value];\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n                case 4:\n                  _.label++;\n                  return { value: op[1], done: false };\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n                case 7:\n                  op = _.ops.pop();\n                  _.trys.pop();\n                  continue;\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n                    _.ops.push(op);\n                    break;\n                  }\n                  if (t[2])\n                    _.ops.pop();\n                  _.trys.pop();\n                  continue;\n              }\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f2 = t = 0;\n            }\n          if (op[0] & 5)\n            throw op[1];\n          return { value: op[0] ? op[1] : void 0, done: true };\n        }\n      };\n      __exportStar3 = function(m, o) {\n        for (var p2 in m)\n          if (p2 !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p2))\n            __createBinding3(o, m, p2);\n      };\n      __createBinding3 = Object.create ? function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        var desc = Object.getOwnPropertyDescriptor(m, k2);\n        if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n          desc = { enumerable: true, get: function() {\n            return m[k2];\n          } };\n        }\n        Object.defineProperty(o, k22, desc);\n      } : function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        o[k22] = m[k2];\n      };\n      __values3 = function(o) {\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i2 = 0;\n        if (m)\n          return m.call(o);\n        if (o && typeof o.length === \"number\")\n          return {\n            next: function() {\n              if (o && i2 >= o.length)\n                o = void 0;\n              return { value: o && o[i2++], done: !o };\n            }\n          };\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n      };\n      __read3 = function(o, n) {\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n        if (!m)\n          return o;\n        var i2 = m.call(o), r, ar = [], e;\n        try {\n          while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)\n            ar.push(r.value);\n        } catch (error) {\n          e = { error };\n        } finally {\n          try {\n            if (r && !r.done && (m = i2[\"return\"]))\n              m.call(i2);\n          } finally {\n            if (e)\n              throw e.error;\n          }\n        }\n        return ar;\n      };\n      __spread3 = function() {\n        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)\n          ar = ar.concat(__read3(arguments[i2]));\n        return ar;\n      };\n      __spreadArrays3 = function() {\n        for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n          s += arguments[i2].length;\n        for (var r = Array(s), k2 = 0, i2 = 0; i2 < il; i2++)\n          for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k2++)\n            r[k2] = a2[j];\n        return r;\n      };\n      __spreadArray3 = function(to, from, pack) {\n        if (pack || arguments.length === 2)\n          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {\n            if (ar || !(i2 in from)) {\n              if (!ar)\n                ar = Array.prototype.slice.call(from, 0, i2);\n              ar[i2] = from[i2];\n            }\n          }\n        return to.concat(ar || Array.prototype.slice.call(from));\n      };\n      __await3 = function(v) {\n        return this instanceof __await3 ? (this.v = v, this) : new __await3(v);\n      };\n      __asyncGenerator3 = function(thisArg, _arguments, generator) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];\n        return i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2;\n        function verb(n) {\n          if (g2[n])\n            i2[n] = function(v) {\n              return new Promise(function(a2, b2) {\n                q.push([n, v, a2, b2]) > 1 || resume(n, v);\n              });\n            };\n        }\n        function resume(n, v) {\n          try {\n            step(g2[n](v));\n          } catch (e) {\n            settle(q[0][3], e);\n          }\n        }\n        function step(r) {\n          r.value instanceof __await3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n        }\n        function fulfill(value) {\n          resume(\"next\", value);\n        }\n        function reject(value) {\n          resume(\"throw\", value);\n        }\n        function settle(f2, v) {\n          if (f2(v), q.shift(), q.length)\n            resume(q[0][0], q[0][1]);\n        }\n      };\n      __asyncDelegator3 = function(o) {\n        var i2, p2;\n        return i2 = {}, verb(\"next\"), verb(\"throw\", function(e) {\n          throw e;\n        }), verb(\"return\"), i2[Symbol.iterator] = function() {\n          return this;\n        }, i2;\n        function verb(n, f2) {\n          i2[n] = o[n] ? function(v) {\n            return (p2 = !p2) ? { value: __await3(o[n](v)), done: n === \"return\" } : f2 ? f2(v) : v;\n          } : f2;\n        }\n      };\n      __asyncValues3 = function(o) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var m = o[Symbol.asyncIterator], i2;\n        return m ? m.call(o) : (o = typeof __values3 === \"function\" ? __values3(o) : o[Symbol.iterator](), i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2);\n        function verb(n) {\n          i2[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n              v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n          };\n        }\n        function settle(resolve, reject, d2, v) {\n          Promise.resolve(v).then(function(v2) {\n            resolve({ value: v2, done: d2 });\n          }, reject);\n        }\n      };\n      __makeTemplateObject3 = function(cooked, raw) {\n        if (Object.defineProperty) {\n          Object.defineProperty(cooked, \"raw\", { value: raw });\n        } else {\n          cooked.raw = raw;\n        }\n        return cooked;\n      };\n      var __setModuleDefault = Object.create ? function(o, v) {\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n      } : function(o, v) {\n        o[\"default\"] = v;\n      };\n      __importStar3 = function(mod) {\n        if (mod && mod.__esModule)\n          return mod;\n        var result = {};\n        if (mod != null) {\n          for (var k2 in mod)\n            if (k2 !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k2))\n              __createBinding3(result, mod, k2);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n      };\n      __importDefault3 = function(mod) {\n        return mod && mod.__esModule ? mod : { \"default\": mod };\n      };\n      __classPrivateFieldGet3 = function(receiver, state, kind, f2) {\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a getter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n        return kind === \"m\" ? f2 : kind === \"a\" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);\n      };\n      __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {\n        if (kind === \"m\")\n          throw new TypeError(\"Private method is not writable\");\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a setter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n        return kind === \"a\" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;\n      };\n      __classPrivateFieldIn3 = function(state, receiver) {\n        if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\")\n          throw new TypeError(\"Cannot use 'in' operator on non-object\");\n        return typeof state === \"function\" ? receiver === state : state.has(receiver);\n      };\n      exporter(\"__extends\", __extends3);\n      exporter(\"__assign\", __assign3);\n      exporter(\"__rest\", __rest3);\n      exporter(\"__decorate\", __decorate3);\n      exporter(\"__param\", __param3);\n      exporter(\"__metadata\", __metadata3);\n      exporter(\"__awaiter\", __awaiter3);\n      exporter(\"__generator\", __generator3);\n      exporter(\"__exportStar\", __exportStar3);\n      exporter(\"__createBinding\", __createBinding3);\n      exporter(\"__values\", __values3);\n      exporter(\"__read\", __read3);\n      exporter(\"__spread\", __spread3);\n      exporter(\"__spreadArrays\", __spreadArrays3);\n      exporter(\"__spreadArray\", __spreadArray3);\n      exporter(\"__await\", __await3);\n      exporter(\"__asyncGenerator\", __asyncGenerator3);\n      exporter(\"__asyncDelegator\", __asyncDelegator3);\n      exporter(\"__asyncValues\", __asyncValues3);\n      exporter(\"__makeTemplateObject\", __makeTemplateObject3);\n      exporter(\"__importStar\", __importStar3);\n      exporter(\"__importDefault\", __importDefault3);\n      exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet3);\n      exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet3);\n      exporter(\"__classPrivateFieldIn\", __classPrivateFieldIn3);\n    });\n  }\n});\n\n// src/index.tsx\nvar src_exports = {};\n__export(src_exports, {\n  Footer: () => Footer,\n  ListPylar: () => ListPylar,\n  Menu: () => Menu,\n  MenuPylar: () => MenuPylar,\n  Scrollable: () => Scrollable,\n  TitlePylar: () => TitlePylar,\n  Version: () => Version,\n  blog: () => blog,\n  post12032022: () => post12032022\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// ../../node_modules/meshgrad/dist/index.mjs\nvar i = () => Math.round(Math.random() * 360);\nvar c = (n) => Math.round(Math.random() * (n * 100) % 100);\nvar g = (n, t, e) => Math.round(t / e * (n * 100) % 100);\nvar d = (n) => {\n  if (!!n) {\n    n = n.replace(/#/g, \"\"), n.length === 3 && (n = n.split(\"\").map(function(b2) {\n      return b2 + b2;\n    }).join(\"\"));\n    var t = /^([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})[\\da-z]{0,0}$/i.exec(n);\n    if (!!t) {\n      var e = parseInt(t[1], 16), r = parseInt(t[2], 16), a2 = parseInt(t[3], 16);\n      e /= 255, r /= 255, a2 /= 255;\n      var o = Math.max(e, r, a2), s = Math.min(e, r, a2), u = (o + s) / 2;\n      if (o == s)\n        u = 0;\n      else {\n        var m = o - s;\n        switch (o) {\n          case e:\n            u = (r - a2) / m + (r < a2 ? 6 : 0);\n            break;\n          case r:\n            u = (a2 - e) / m + 2;\n            break;\n          case a2:\n            u = (e - r) / m + 4;\n            break;\n        }\n        u /= 6;\n      }\n      return u = Math.round(360 * u), u;\n    }\n  }\n};\nvar p = (n, t) => Array.from({ length: n }, (e, r) => r === 0 ? `hsl(${t}, 100%, 80%)` : r < n / 1.4 ? `hsl(${t - 30 * (1 - 2 * (r % 2)) * (r > 2 ? r / 2 : r)}, 100%, ${76 - r * (1 - 2 * (r % 2)) * 1.75}%)` : `hsl(${t - 150 * (1 - 2 * (r % 2))}, 100%, ${76 - r * (1 - 2 * (r % 2)) * 1.25}%)`);\nvar M = (n, t, e) => Array.from({ length: n }, (r, a2) => `radial-gradient(at ${e ? g(a2, e, n) : c(a2)}% ${e ? g(a2 * 10, e, n) : c(a2 * 10)}%, ${t[a2]} 0px, transparent 50%)\n`);\nvar f = (n, t, e) => {\n  let r = p(n, t || i()), a2 = M(n, r, e || void 0);\n  return [r[0], a2.join(\",\")];\n};\nvar k = (n, t, e) => {\n  let [r, a2] = f(n, d(t) ? d(t) : void 0, e || void 0);\n  return { backgroundColor: r, backgroundImage: a2 };\n};\n\n// src/Version.tsx\nvar import_jsx_runtime = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar ELEMENTS = 8;\nvar Version = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(\"button\", {\n    className: \"m-2 hidden rounded-full py-2 px-4 text-xs font-bold text-black shadow-md hover:shadow-xl md:block\",\n    style: k(ELEMENTS),\n    children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(\"a\", {\n      href: \"http://github.com/miguelgargallo/next13-gallery-image-turbo\",\n      target: \"_blank\",\n      rel: \"noopener noreferrer\",\n      children: \"v1.0.1\"\n    })\n  });\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/index.mjs\nvar React = __toESM(__webpack_require__(/*! react */ \"react\"), 1);\nvar import_react13 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs\nvar import_react = __webpack_require__(/*! react */ \"react\");\nvar MotionConfigContext = (0, import_react.createContext)({\n  transformPagePoint: (p2) => p2,\n  isStatic: false,\n  reducedMotion: \"never\"\n});\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/index.mjs\nvar import_react2 = __webpack_require__(/*! react */ \"react\");\nvar MotionContext = (0, import_react2.createContext)({});\nfunction useVisualElementContext() {\n  return (0, import_react2.useContext)(MotionContext).visualElement;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\nvar import_react6 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/context/PresenceContext.mjs\nvar import_react3 = __webpack_require__(/*! react */ \"react\");\nvar PresenceContext = (0, import_react3.createContext)(null);\n\n// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\nvar import_react4 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/utils/is-browser.mjs\nvar isBrowser = typeof document !== \"undefined\";\n\n// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\nvar useIsomorphicLayoutEffect = isBrowser ? import_react4.useLayoutEffect : import_react4.useEffect;\n\n// ../../node_modules/framer-motion/dist/es/context/LazyContext.mjs\nvar import_react5 = __webpack_require__(/*! react */ \"react\");\nvar LazyContext = (0, import_react5.createContext)({ strict: false });\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n  const parent = useVisualElementContext();\n  const lazyContext = (0, import_react6.useContext)(LazyContext);\n  const presenceContext = (0, import_react6.useContext)(PresenceContext);\n  const reducedMotionConfig = (0, import_react6.useContext)(MotionConfigContext).reducedMotion;\n  const visualElementRef = (0, import_react6.useRef)();\n  createVisualElement = createVisualElement || lazyContext.renderer;\n  if (!visualElementRef.current && createVisualElement) {\n    visualElementRef.current = createVisualElement(Component, {\n      visualState,\n      parent,\n      props,\n      presenceId: presenceContext ? presenceContext.id : void 0,\n      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,\n      reducedMotionConfig\n    });\n  }\n  const visualElement = visualElementRef.current;\n  useIsomorphicLayoutEffect(() => {\n    visualElement && visualElement.render();\n  });\n  (0, import_react6.useEffect)(() => {\n    if (visualElement && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n  });\n  useIsomorphicLayoutEffect(() => () => visualElement && visualElement.notify(\"Unmount\"), []);\n  return visualElement;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\nvar import_react7 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/utils/is-ref-object.mjs\nfunction isRefObject(ref) {\n  return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\nfunction useMotionRef(visualState, visualElement, externalRef) {\n  return (0, import_react7.useCallback)(\n    (instance) => {\n      instance && visualState.mount && visualState.mount(instance);\n      if (visualElement) {\n        instance ? visualElement.mount(instance) : visualElement.unmount();\n      }\n      if (externalRef) {\n        if (typeof externalRef === \"function\") {\n          externalRef(instance);\n        } else if (isRefObject(externalRef)) {\n          externalRef.current = instance;\n        }\n      }\n    },\n    [visualElement]\n  );\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\nvar import_react8 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs\nfunction isVariantLabel(v) {\n  return typeof v === \"string\" || Array.isArray(v);\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs\nfunction isAnimationControls(v) {\n  return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs\nvar variantProps = [\n  \"initial\",\n  \"animate\",\n  \"exit\",\n  \"whileHover\",\n  \"whileDrag\",\n  \"whileTap\",\n  \"whileFocus\",\n  \"whileInView\"\n];\nfunction isControllingVariants(props) {\n  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));\n}\nfunction isVariantNode(props) {\n  return Boolean(isControllingVariants(props) || props.variants);\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs\nfunction getCurrentTreeVariants(props, context) {\n  if (isControllingVariants(props)) {\n    const { initial, animate: animate3 } = props;\n    return {\n      initial: initial === false || isVariantLabel(initial) ? initial : void 0,\n      animate: isVariantLabel(animate3) ? animate3 : void 0\n    };\n  }\n  return props.inherit !== false ? context : {};\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\nfunction useCreateMotionContext(props) {\n  const { initial, animate: animate3 } = getCurrentTreeVariants(props, (0, import_react8.useContext)(MotionContext));\n  return (0, import_react8.useMemo)(() => ({ initial, animate: animate3 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate3)]);\n}\nfunction variantLabelsAsDependency(prop) {\n  return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/definitions.mjs\nvar createDefinition = (propNames) => ({\n  isEnabled: (props) => propNames.some((name) => !!props[name])\n});\nvar featureDefinitions = {\n  measureLayout: createDefinition([\"layout\", \"layoutId\", \"drag\"]),\n  animation: createDefinition([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileFocus\",\n    \"whileDrag\",\n    \"whileInView\"\n  ]),\n  exit: createDefinition([\"exit\"]),\n  drag: createDefinition([\"drag\", \"dragControls\"]),\n  focus: createDefinition([\"whileFocus\"]),\n  hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n  tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n  pan: createDefinition([\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanSessionStart\",\n    \"onPanEnd\"\n  ]),\n  inView: createDefinition([\n    \"whileInView\",\n    \"onViewportEnter\",\n    \"onViewportLeave\"\n  ])\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/load-features.mjs\nfunction loadFeatures(features) {\n  for (const key in features) {\n    if (key === \"projectionNodeConstructor\") {\n      featureDefinitions.projectionNodeConstructor = features[key];\n    } else {\n      featureDefinitions[key].Component = features[key];\n    }\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/use-constant.mjs\nvar import_react9 = __webpack_require__(/*! react */ \"react\");\nfunction useConstant(init) {\n  const ref = (0, import_react9.useRef)(null);\n  if (ref.current === null) {\n    ref.current = init();\n  }\n  return ref.current;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/node/state.mjs\nvar globalProjectionState = {\n  hasAnimatedSinceResize: true,\n  hasEverUpdated: false\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/node/id.mjs\nvar id = 1;\nfunction useProjectionId() {\n  return useConstant(() => {\n    if (globalProjectionState.hasEverUpdated) {\n      return id++;\n    }\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs\nvar import_react10 = __webpack_require__(/*! react */ \"react\");\nvar LayoutGroupContext = (0, import_react10.createContext)({});\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/VisualElementHandler.mjs\nvar import_react11 = __toESM(__webpack_require__(/*! react */ \"react\"), 1);\nvar VisualElementHandler = class extends import_react11.default.Component {\n  getSnapshotBeforeUpdate() {\n    const { visualElement, props } = this.props;\n    if (visualElement)\n      visualElement.setProps(props);\n    return null;\n  }\n  componentDidUpdate() {\n  }\n  render() {\n    return this.props.children;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs\nvar import_react12 = __webpack_require__(/*! react */ \"react\");\nvar SwitchLayoutGroupContext = (0, import_react12.createContext)({});\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/symbol.mjs\nvar motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n\n// ../../node_modules/framer-motion/dist/es/motion/index.mjs\nfunction createMotionComponent({ preloadedFeatures, createVisualElement, projectionNodeConstructor, useRender, useVisualState, Component }) {\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  function MotionComponent(props, externalRef) {\n    const configAndProps = __spreadProps(__spreadValues(__spreadValues({}, (0, import_react13.useContext)(MotionConfigContext)), props), {\n      layoutId: useLayoutId(props)\n    });\n    const { isStatic } = configAndProps;\n    let features = null;\n    const context = useCreateMotionContext(props);\n    const projectionId = isStatic ? void 0 : useProjectionId();\n    const visualState = useVisualState(props, isStatic);\n    if (!isStatic && isBrowser) {\n      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);\n      const lazyStrictMode = (0, import_react13.useContext)(LazyContext).strict;\n      const initialLayoutGroupConfig = (0, import_react13.useContext)(SwitchLayoutGroupContext);\n      if (context.visualElement) {\n        features = context.visualElement.loadFeatures(\n          configAndProps,\n          lazyStrictMode,\n          preloadedFeatures,\n          projectionId,\n          projectionNodeConstructor || featureDefinitions.projectionNodeConstructor,\n          initialLayoutGroupConfig\n        );\n      }\n    }\n    return React.createElement(\n      VisualElementHandler,\n      { visualElement: context.visualElement, props: configAndProps },\n      features,\n      React.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement))\n    );\n  }\n  const ForwardRefComponent = (0, import_react13.forwardRef)(MotionComponent);\n  ForwardRefComponent[motionComponentSymbol] = Component;\n  return ForwardRefComponent;\n}\nfunction useLayoutId({ layoutId }) {\n  const layoutGroupId = (0, import_react13.useContext)(LayoutGroupContext).id;\n  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs\nfunction createMotionProxy(createConfig) {\n  function custom(Component, customMotionComponentConfig = {}) {\n    return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n  }\n  if (typeof Proxy === \"undefined\") {\n    return custom;\n  }\n  const componentCache = /* @__PURE__ */ new Map();\n  return new Proxy(custom, {\n    get: (_target, key) => {\n      if (!componentCache.has(key)) {\n        componentCache.set(key, custom(key));\n      }\n      return componentCache.get(key);\n    }\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs\nvar lowercaseSVGElements = [\n  \"animate\",\n  \"circle\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"g\",\n  \"image\",\n  \"line\",\n  \"filter\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"rect\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"tspan\",\n  \"use\",\n  \"view\"\n];\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs\nfunction isSVGComponent(Component) {\n  if (typeof Component !== \"string\" || Component.includes(\"-\")) {\n    return false;\n  } else if (lowercaseSVGElements.indexOf(Component) > -1 || /[A-Z]/.test(Component)) {\n    return true;\n  }\n  return false;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/use-render.mjs\nvar import_react16 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/render/html/use-props.mjs\nvar import_react14 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs\nvar scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n  Object.assign(scaleCorrectors, correctors);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/transform.mjs\nvar transformPropOrder = [\n  \"transformPerspective\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"translateX\",\n  \"translateY\",\n  \"translateZ\",\n  \"scale\",\n  \"scaleX\",\n  \"scaleY\",\n  \"rotate\",\n  \"rotateX\",\n  \"rotateY\",\n  \"rotateZ\",\n  \"skew\",\n  \"skewX\",\n  \"skewY\"\n];\nvar transformProps = new Set(transformPropOrder);\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n  return transformProps.has(key) || key.startsWith(\"origin\") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === \"opacity\");\n}\n\n// ../../node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs\nvar isMotionValue = (value) => !!(value === null || value === void 0 ? void 0 : value.getVelocity);\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\nvar sortTransformProps = (a2, b2) => transformPropOrder.indexOf(a2) - transformPropOrder.indexOf(b2);\nfunction buildTransform({ transform, transformKeys: transformKeys2 }, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {\n  let transformString = \"\";\n  transformKeys2.sort(sortTransformProps);\n  for (const key of transformKeys2) {\n    transformString += `${translateAlias[key] || key}(${transform[key]}) `;\n  }\n  if (enableHardwareAcceleration && !transform.z) {\n    transformString += \"translateZ(0)\";\n  }\n  transformString = transformString.trim();\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n  return transformString;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs\nfunction isCSSVariable(key) {\n  return key.startsWith(\"--\");\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs\nvar getValueAsType = (value, type) => {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n\n// ../../node_modules/style-value-types/dist/es/utils.mjs\nvar clamp = (min, max) => (v) => Math.max(Math.min(v, max), min);\nvar sanitize = (v) => v % 1 ? Number(v.toFixed(5)) : v;\nvar floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nvar colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))/gi;\nvar singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))$/i;\nfunction isString(v) {\n  return typeof v === \"string\";\n}\n\n// ../../node_modules/style-value-types/dist/es/numbers/index.mjs\nvar number = {\n  test: (v) => typeof v === \"number\",\n  parse: parseFloat,\n  transform: (v) => v\n};\nvar alpha = Object.assign(Object.assign({}, number), { transform: clamp(0, 1) });\nvar scale = Object.assign(Object.assign({}, number), { default: 1 });\n\n// ../../node_modules/style-value-types/dist/es/numbers/units.mjs\nvar createUnitType = (unit) => ({\n  test: (v) => isString(v) && v.endsWith(unit) && v.split(\" \").length === 1,\n  parse: parseFloat,\n  transform: (v) => `${v}${unit}`\n});\nvar degrees = createUnitType(\"deg\");\nvar percent = createUnitType(\"%\");\nvar px = createUnitType(\"px\");\nvar vh = createUnitType(\"vh\");\nvar vw = createUnitType(\"vw\");\nvar progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v) => percent.parse(v) / 100, transform: (v) => percent.transform(v * 100) });\n\n// ../../node_modules/style-value-types/dist/es/color/utils.mjs\nvar isColorString = (type, testProp) => (v) => {\n  return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));\n};\nvar splitColor = (aName, bName, cName) => (v) => {\n  if (!isString(v))\n    return v;\n  const [a2, b2, c3, alpha2] = v.match(floatRegex);\n  return {\n    [aName]: parseFloat(a2),\n    [bName]: parseFloat(b2),\n    [cName]: parseFloat(c3),\n    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1\n  };\n};\n\n// ../../node_modules/style-value-types/dist/es/color/hsla.mjs\nvar hsla = {\n  test: isColorString(\"hsl\", \"hue\"),\n  parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n    return \"hsla(\" + Math.round(hue) + \", \" + percent.transform(sanitize(saturation)) + \", \" + percent.transform(sanitize(lightness)) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\";\n  }\n};\n\n// ../../node_modules/style-value-types/dist/es/color/rgba.mjs\nvar clampRgbUnit = clamp(0, 255);\nvar rgbUnit = Object.assign(Object.assign({}, number), { transform: (v) => Math.round(clampRgbUnit(v)) });\nvar rgba = {\n  test: isColorString(\"rgb\", \"red\"),\n  parse: splitColor(\"red\", \"green\", \"blue\"),\n  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" + rgbUnit.transform(red) + \", \" + rgbUnit.transform(green) + \", \" + rgbUnit.transform(blue) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\"\n};\n\n// ../../node_modules/style-value-types/dist/es/color/hex.mjs\nfunction parseHex(v) {\n  let r = \"\";\n  let g2 = \"\";\n  let b2 = \"\";\n  let a2 = \"\";\n  if (v.length > 5) {\n    r = v.substr(1, 2);\n    g2 = v.substr(3, 2);\n    b2 = v.substr(5, 2);\n    a2 = v.substr(7, 2);\n  } else {\n    r = v.substr(1, 1);\n    g2 = v.substr(2, 1);\n    b2 = v.substr(3, 1);\n    a2 = v.substr(4, 1);\n    r += r;\n    g2 += g2;\n    b2 += b2;\n    a2 += a2;\n  }\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g2, 16),\n    blue: parseInt(b2, 16),\n    alpha: a2 ? parseInt(a2, 16) / 255 : 1\n  };\n}\nvar hex = {\n  test: isColorString(\"#\"),\n  parse: parseHex,\n  transform: rgba.transform\n};\n\n// ../../node_modules/style-value-types/dist/es/color/index.mjs\nvar color = {\n  test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n  parse: (v) => {\n    if (rgba.test(v)) {\n      return rgba.parse(v);\n    } else if (hsla.test(v)) {\n      return hsla.parse(v);\n    } else {\n      return hex.parse(v);\n    }\n  },\n  transform: (v) => {\n    return isString(v) ? v : v.hasOwnProperty(\"red\") ? rgba.transform(v) : hsla.transform(v);\n  }\n};\n\n// ../../node_modules/style-value-types/dist/es/complex/index.mjs\nvar colorToken = \"${c}\";\nvar numberToken = \"${n}\";\nfunction test(v) {\n  var _a, _b, _c, _d;\n  return isNaN(v) && isString(v) && ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;\n}\nfunction analyse(v) {\n  if (typeof v === \"number\")\n    v = `${v}`;\n  const values = [];\n  let numColors = 0;\n  const colors = v.match(colorRegex);\n  if (colors) {\n    numColors = colors.length;\n    v = v.replace(colorRegex, colorToken);\n    values.push(...colors.map(color.parse));\n  }\n  const numbers = v.match(floatRegex);\n  if (numbers) {\n    v = v.replace(floatRegex, numberToken);\n    values.push(...numbers.map(number.parse));\n  }\n  return { values, numColors, tokenised: v };\n}\nfunction parse(v) {\n  return analyse(v).values;\n}\nfunction createTransformer(v) {\n  const { values, numColors, tokenised } = analyse(v);\n  const numValues = values.length;\n  return (v2) => {\n    let output = tokenised;\n    for (let i2 = 0; i2 < numValues; i2++) {\n      output = output.replace(i2 < numColors ? colorToken : numberToken, i2 < numColors ? color.transform(v2[i2]) : sanitize(v2[i2]));\n    }\n    return output;\n  };\n}\nvar convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone(v) {\n  const parsed = parse(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\nvar complex = { test, parse, createTransformer, getAnimatableNone };\n\n// ../../node_modules/style-value-types/dist/es/complex/filter.mjs\nvar maxDefaults = /* @__PURE__ */ new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n  let [name, value] = v.slice(0, -1).split(\"(\");\n  if (name === \"drop-shadow\")\n    return v;\n  const [number2] = value.match(floatRegex) || [];\n  if (!number2)\n    return v;\n  const unit = value.replace(number2, \"\");\n  let defaultValue = maxDefaults.has(name) ? 1 : 0;\n  if (number2 !== value)\n    defaultValue *= 100;\n  return name + \"(\" + defaultValue + unit + \")\";\n}\nvar functionRegex = /([a-z-]*)\\(.*?\\)/g;\nvar filter = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v) => {\n  const functions = v.match(functionRegex);\n  return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n} });\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs\nvar int = __spreadProps(__spreadValues({}, number), {\n  transform: Math.round\n});\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs\nvar numberValueTypes = {\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  transformPerspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  zIndex: int,\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n  const { style, vars, transform, transformKeys: transformKeys2, transformOrigin } = state;\n  transformKeys2.length = 0;\n  let hasTransform2 = false;\n  let hasTransformOrigin = false;\n  let transformIsNone = true;\n  for (const key in latestValues) {\n    const value = latestValues[key];\n    if (isCSSVariable(key)) {\n      vars[key] = value;\n      continue;\n    }\n    const valueType = numberValueTypes[key];\n    const valueAsType = getValueAsType(value, valueType);\n    if (transformProps.has(key)) {\n      hasTransform2 = true;\n      transform[key] = valueAsType;\n      transformKeys2.push(key);\n      if (!transformIsNone)\n        continue;\n      if (value !== (valueType.default || 0))\n        transformIsNone = false;\n    } else if (key.startsWith(\"origin\")) {\n      hasTransformOrigin = true;\n      transformOrigin[key] = valueAsType;\n    } else {\n      style[key] = valueAsType;\n    }\n  }\n  if (!latestValues.transform) {\n    if (hasTransform2 || transformTemplate) {\n      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n    } else if (style.transform) {\n      style.transform = \"none\";\n    }\n  }\n  if (hasTransformOrigin) {\n    const { originX = \"50%\", originY = \"50%\", originZ = 0 } = transformOrigin;\n    style.transformOrigin = `${originX} ${originY} ${originZ}`;\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs\nvar createHtmlRenderState = () => ({\n  style: {},\n  transform: {},\n  transformKeys: [],\n  transformOrigin: {},\n  vars: {}\n});\n\n// ../../node_modules/framer-motion/dist/es/render/html/use-props.mjs\nfunction copyRawValuesOnly(target, source, props) {\n  for (const key in source) {\n    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState, isStatic) {\n  return (0, import_react14.useMemo)(() => {\n    const state = createHtmlRenderState();\n    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);\n    return Object.assign({}, state.vars, state.style);\n  }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n  const styleProp = props.style || {};\n  const style = {};\n  copyRawValuesOnly(style, styleProp, props);\n  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n  return props.transformValues ? props.transformValues(style) : style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n  const htmlProps = {};\n  const style = useStyle(props, visualState, isStatic);\n  if (props.drag && props.dragListener !== false) {\n    htmlProps.draggable = false;\n    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n    style.touchAction = props.drag === true ? \"none\" : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n  }\n  htmlProps.style = style;\n  return htmlProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs\nvar animationProps = [\n  \"animate\",\n  \"exit\",\n  \"variants\",\n  \"whileHover\",\n  \"whileTap\",\n  \"whileFocus\",\n  \"whileDrag\",\n  \"whileInView\"\n];\nvar tapProps = [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"];\nvar panProps = [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"];\nvar inViewProps = [\n  \"whileInView\",\n  \"onViewportEnter\",\n  \"onViewportLeave\",\n  \"viewport\"\n];\nvar validMotionProps = /* @__PURE__ */ new Set([\n  \"initial\",\n  \"style\",\n  \"values\",\n  \"variants\",\n  \"transition\",\n  \"transformTemplate\",\n  \"transformValues\",\n  \"custom\",\n  \"inherit\",\n  \"layout\",\n  \"layoutId\",\n  \"layoutDependency\",\n  \"onLayoutAnimationStart\",\n  \"onLayoutAnimationComplete\",\n  \"onLayoutMeasure\",\n  \"onBeforeLayoutMeasure\",\n  \"onAnimationStart\",\n  \"onAnimationComplete\",\n  \"onUpdate\",\n  \"onDragStart\",\n  \"onDrag\",\n  \"onDragEnd\",\n  \"onMeasureDragConstraints\",\n  \"onDirectionLock\",\n  \"onDragTransitionEnd\",\n  \"drag\",\n  \"dragControls\",\n  \"dragListener\",\n  \"dragConstraints\",\n  \"dragDirectionLock\",\n  \"dragSnapToOrigin\",\n  \"_dragX\",\n  \"_dragY\",\n  \"dragElastic\",\n  \"dragMomentum\",\n  \"dragPropagation\",\n  \"dragTransition\",\n  \"onHoverStart\",\n  \"onHoverEnd\",\n  \"layoutScroll\",\n  ...inViewProps,\n  ...tapProps,\n  ...animationProps,\n  ...panProps\n]);\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs\nvar shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n  if (!isValidProp)\n    return;\n  shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\ntry {\n  loadExternalIsValidProp((init_is_prop_valid_esm(), __toCommonJS(is_prop_valid_esm_exports)).default);\n} catch (_a) {\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n  const filteredProps = {};\n  for (const key in props) {\n    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props[\"draggable\"] && key.startsWith(\"onDrag\")) {\n      filteredProps[key] = props[key];\n    }\n  }\n  return filteredProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/use-props.mjs\nvar import_react15 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs\nfunction calcOrigin(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n  return `${pxOriginX} ${pxOriginY}`;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/path.mjs\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n  attrs.pathLength = 1;\n  const keys2 = useDashCase ? dashKeys : camelKeys;\n  attrs[keys2.offset] = px.transform(-offset);\n  const pathLength = px.transform(length);\n  const pathSpacing = px.transform(spacing);\n  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs\nfunction buildSVGAttrs(state, _a, options, transformTemplate) {\n  var _b = _a, {\n    attrX,\n    attrY,\n    originX,\n    originY,\n    pathLength,\n    pathSpacing = 1,\n    pathOffset = 0\n  } = _b, latest = __objRest(_b, [\n    \"attrX\",\n    \"attrY\",\n    \"originX\",\n    \"originY\",\n    \"pathLength\",\n    \"pathSpacing\",\n    \"pathOffset\"\n  ]);\n  buildHTMLStyles(state, latest, options, transformTemplate);\n  state.attrs = state.style;\n  state.style = {};\n  const { attrs, style, dimensions } = state;\n  if (attrs.transform) {\n    if (dimensions)\n      style.transform = attrs.transform;\n    delete attrs.transform;\n  }\n  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);\n  }\n  if (attrX !== void 0)\n    attrs.x = attrX;\n  if (attrY !== void 0)\n    attrs.y = attrY;\n  if (pathLength !== void 0) {\n    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs\nvar createSvgRenderState = () => __spreadProps(__spreadValues({}, createHtmlRenderState()), {\n  attrs: {}\n});\n\n// ../../node_modules/framer-motion/dist/es/render/svg/use-props.mjs\nfunction useSVGProps(props, visualState) {\n  const visualProps = (0, import_react15.useMemo)(() => {\n    const state = createSvgRenderState();\n    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);\n    return __spreadProps(__spreadValues({}, state.attrs), {\n      style: __spreadValues({}, state.style)\n    });\n  }, [visualState]);\n  if (props.style) {\n    const rawStyles = {};\n    copyRawValuesOnly(rawStyles, props.style, props);\n    visualProps.style = __spreadValues(__spreadValues({}, rawStyles), visualProps.style);\n  }\n  return visualProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/use-render.mjs\nfunction createUseRender(forwardMotionProps = false) {\n  const useRender = (Component, props, projectionId, ref, { latestValues }, isStatic) => {\n    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;\n    const visualProps = useVisualProps(props, latestValues, isStatic);\n    const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n    const elementProps = __spreadProps(__spreadValues(__spreadValues({}, filteredProps), visualProps), {\n      ref\n    });\n    if (projectionId) {\n      elementProps[\"data-projection-id\"] = projectionId;\n    }\n    return (0, import_react16.createElement)(Component, elementProps);\n  };\n  return useRender;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs\nvar camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/render.mjs\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n  for (const key in vars) {\n    element.style.setProperty(key, vars[key]);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs\nvar camelCaseAttributes = /* @__PURE__ */ new Set([\n  \"baseFrequency\",\n  \"diffuseConstant\",\n  \"kernelMatrix\",\n  \"kernelUnitLength\",\n  \"keySplines\",\n  \"keyTimes\",\n  \"limitingConeAngle\",\n  \"markerHeight\",\n  \"markerWidth\",\n  \"numOctaves\",\n  \"targetX\",\n  \"targetY\",\n  \"surfaceScale\",\n  \"specularConstant\",\n  \"specularExponent\",\n  \"stdDeviation\",\n  \"tableValues\",\n  \"viewBox\",\n  \"gradientTransform\",\n  \"pathLength\"\n]);\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/render.mjs\nfunction renderSVG(element, renderState, _styleProp, projection) {\n  renderHTML(element, renderState, void 0, projection);\n  for (const key in renderState.attrs) {\n    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs\nfunction scrapeMotionValuesFromProps(props) {\n  const { style } = props;\n  const newValues = {};\n  for (const key in style) {\n    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n      newValues[key] = style[key];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs\nfunction scrapeMotionValuesFromProps2(props) {\n  const newValues = scrapeMotionValuesFromProps(props);\n  for (const key in props) {\n    if (isMotionValue(props[key])) {\n      const targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n      newValues[targetKey] = props[key];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\nvar import_react17 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs\nfunction resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n  }\n  if (typeof definition === \"string\") {\n    definition = props.variants && props.variants[definition];\n  }\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n  }\n  return definition;\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs\nvar isKeyframesTarget = (v) => {\n  return Array.isArray(v);\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/resolve-value.mjs\nvar isCustomValue = (v) => {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = (v) => {\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n// ../../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs\nfunction resolveMotionValue(value) {\n  const unwrappedValue = isMotionValue(value) ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\nfunction makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props, context, presenceContext) {\n  const state = {\n    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),\n    renderState: createRenderState()\n  };\n  if (onMount) {\n    state.mount = (instance) => onMount(props, instance, state);\n  }\n  return state;\n}\nvar makeUseVisualState = (config) => (props, isStatic) => {\n  const context = (0, import_react17.useContext)(MotionContext);\n  const presenceContext = (0, import_react17.useContext)(PresenceContext);\n  const make = () => makeState(config, props, context, presenceContext);\n  return isStatic ? make() : useConstant(make);\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n  const values = {};\n  const motionValues = scrapeMotionValues(props);\n  for (const key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n  let { initial, animate: animate3 } = props;\n  const isControllingVariants$1 = isControllingVariants(props);\n  const isVariantNode$1 = isVariantNode(props);\n  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {\n    if (initial === void 0)\n      initial = context.initial;\n    if (animate3 === void 0)\n      animate3 = context.animate;\n  }\n  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;\n  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n  const variantToSet = isInitialAnimationBlocked ? animate3 : initial;\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n    list.forEach((definition) => {\n      const resolved = resolveVariantFromProps(props, definition);\n      if (!resolved)\n        return;\n      const _a = resolved, { transitionEnd, transition } = _a, target = __objRest(_a, [\"transitionEnd\", \"transition\"]);\n      for (const key in target) {\n        let valueTarget = target[key];\n        if (Array.isArray(valueTarget)) {\n          const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;\n          valueTarget = valueTarget[index2];\n        }\n        if (valueTarget !== null) {\n          values[key] = valueTarget;\n        }\n      }\n      for (const key in transitionEnd)\n        values[key] = transitionEnd[key];\n    });\n  }\n  return values;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/config-motion.mjs\nvar svgMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,\n    createRenderState: createSvgRenderState,\n    onMount: (props, instance, { renderState, latestValues }) => {\n      try {\n        renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n      } catch (e) {\n        renderState.dimensions = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);\n      renderSVG(instance, renderState);\n    }\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/config-motion.mjs\nvar htmlMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps,\n    createRenderState: createHtmlRenderState\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs\nfunction createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures, createVisualElement, projectionNodeConstructor) {\n  const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;\n  return __spreadProps(__spreadValues({}, baseConfig), {\n    preloadedFeatures,\n    useRender: createUseRender(forwardMotionProps),\n    createVisualElement,\n    projectionNodeConstructor,\n    Component\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/types.mjs\nvar AnimationType;\n(function(AnimationType2) {\n  AnimationType2[\"Animate\"] = \"animate\";\n  AnimationType2[\"Hover\"] = \"whileHover\";\n  AnimationType2[\"Tap\"] = \"whileTap\";\n  AnimationType2[\"Drag\"] = \"whileDrag\";\n  AnimationType2[\"Focus\"] = \"whileFocus\";\n  AnimationType2[\"InView\"] = \"whileInView\";\n  AnimationType2[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\n// ../../node_modules/framer-motion/dist/es/events/use-dom-event.mjs\nvar import_react18 = __webpack_require__(/*! react */ \"react\");\nfunction addDomEvent(target, eventName, handler, options = { passive: true }) {\n  target.addEventListener(eventName, handler, options);\n  return () => target.removeEventListener(eventName, handler);\n}\nfunction useDomEvent(ref, eventName, handler, options) {\n  (0, import_react18.useEffect)(() => {\n    const element = ref.current;\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-focus-gesture.mjs\nfunction useFocusGesture({ whileFocus, visualElement }) {\n  const { animationState } = visualElement;\n  const onFocus = () => {\n    animationState && animationState.setActive(AnimationType.Focus, true);\n  };\n  const onBlur = () => {\n    animationState && animationState.setActive(AnimationType.Focus, false);\n  };\n  useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : void 0);\n  useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : void 0);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/utils/event-type.mjs\nfunction isMouseEvent(event) {\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n  return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n  const hasTouches = !!event.touches;\n  return hasTouches;\n}\n\n// ../../node_modules/framer-motion/dist/es/events/event-info.mjs\nfunction filterPrimaryPointer(eventHandler) {\n  return (event) => {\n    const isMouseEvent2 = event instanceof MouseEvent;\n    const isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType = \"page\") {\n  const primaryTouch = e.touches[0] || e.changedTouches[0];\n  const point2 = primaryTouch || defaultPagePoint;\n  return {\n    x: point2[pointType + \"X\"],\n    y: point2[pointType + \"Y\"]\n  };\n}\nfunction pointFromMouse(point2, pointType = \"page\") {\n  return {\n    x: point2[pointType + \"X\"],\n    y: point2[pointType + \"Y\"]\n  };\n}\nfunction extractEventInfo(event, pointType = \"page\") {\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\nvar wrapHandler = (handler, shouldFilterPrimaryPointer = false) => {\n  const listener = (event) => handler(event, extractEventInfo(event));\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n\n// ../../node_modules/framer-motion/dist/es/events/utils.mjs\nvar supportsPointerEvents = () => isBrowser && window.onpointerdown === null;\nvar supportsTouchEvents = () => isBrowser && window.ontouchstart === null;\nvar supportsMouseEvents = () => isBrowser && window.onmousedown === null;\n\n// ../../node_modules/framer-motion/dist/es/events/use-pointer-event.mjs\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n  return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs\nfunction createLock(name) {\n  let lock = null;\n  return () => {\n    const openLock = () => {\n      lock = null;\n    };\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n    return false;\n  };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag2) {\n  let lock = false;\n  if (drag2 === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag2 === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    const openHorizontal = globalHorizontalLock();\n    const openVertical = globalVerticalLock();\n    if (openHorizontal && openVertical) {\n      lock = () => {\n        openHorizontal();\n        openVertical();\n      };\n    } else {\n      if (openHorizontal)\n        openHorizontal();\n      if (openVertical)\n        openVertical();\n    }\n  }\n  return lock;\n}\nfunction isDragActive() {\n  const openGestureLock = getGlobalLock(true);\n  if (!openGestureLock)\n    return true;\n  openGestureLock();\n  return false;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-hover-gesture.mjs\nfunction createHoverEvent(visualElement, isActive, callback) {\n  return (event, info) => {\n    if (!isMouseEvent(event) || isDragActive())\n      return;\n    if (visualElement.animationState) {\n      visualElement.animationState.setActive(AnimationType.Hover, isActive);\n    }\n    callback && callback(event, info);\n  };\n}\nfunction useHoverGesture({ onHoverStart, onHoverEnd, whileHover, visualElement }) {\n  usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover ? createHoverEvent(visualElement, true, onHoverStart) : void 0, { passive: !onHoverStart });\n  usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover ? createHoverEvent(visualElement, false, onHoverEnd) : void 0, { passive: !onHoverEnd });\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs\nvar import_react20 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs\nvar isNodeOrChild = (parent, child) => {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs\nvar import_react19 = __webpack_require__(/*! react */ \"react\");\nfunction useUnmountEffect(callback) {\n  return (0, import_react19.useEffect)(() => () => callback(), []);\n}\n\n// ../../node_modules/popmotion/node_modules/tslib/modules/index.js\nvar import_tslib = __toESM(require_tslib(), 1);\nvar {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __exportStar,\n  __createBinding,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn\n} = import_tslib.default;\n\n// ../../node_modules/hey-listen/dist/hey-listen.es.js\nvar warning = function() {\n};\nvar invariant = function() {\n};\nif (true) {\n  warning = function(check, message) {\n    if (!check && typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n  };\n  invariant = function(check, message) {\n    if (!check) {\n      throw new Error(message);\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/clamp.mjs\nvar clamp2 = (min, max, v) => Math.min(Math.max(v, min), max);\n\n// ../../node_modules/popmotion/dist/es/animations/utils/find-spring.mjs\nvar safeMin = 1e-3;\nvar minDuration = 0.01;\nvar maxDuration = 10;\nvar minDamping = 0.05;\nvar maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {\n  let envelope;\n  let derivative;\n  warning(duration <= maxDuration * 1e3, \"Spring duration must be 10 seconds or less\");\n  let dampingRatio = 1 - bounce;\n  dampingRatio = clamp2(minDamping, maxDamping, dampingRatio);\n  duration = clamp2(minDuration, maxDuration, duration / 1e3);\n  if (dampingRatio < 1) {\n    envelope = (undampedFreq2) => {\n      const exponentialDecay = undampedFreq2 * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const a2 = exponentialDecay - velocity;\n      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);\n      const c3 = Math.exp(-delta);\n      return safeMin - a2 / b2 * c3;\n    };\n    derivative = (undampedFreq2) => {\n      const exponentialDecay = undampedFreq2 * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const d2 = delta * velocity + velocity;\n      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;\n      const f2 = Math.exp(-delta);\n      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);\n      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;\n      return factor * ((d2 - e) * f2) / g2;\n    };\n  } else {\n    envelope = (undampedFreq2) => {\n      const a2 = Math.exp(-undampedFreq2 * duration);\n      const b2 = (undampedFreq2 - velocity) * duration + 1;\n      return -safeMin + a2 * b2;\n    };\n    derivative = (undampedFreq2) => {\n      const a2 = Math.exp(-undampedFreq2 * duration);\n      const b2 = (velocity - undampedFreq2) * (duration * duration);\n      return a2 * b2;\n    };\n  }\n  const initialGuess = 5 / duration;\n  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = duration * 1e3;\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration\n    };\n  } else {\n    const stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\nvar rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  let result = initialGuess;\n  for (let i2 = 1; i2 < rootIterations; i2++) {\n    result = result - envelope(result) / derivative(result);\n  }\n  return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\n// ../../node_modules/popmotion/dist/es/animations/generators/spring.mjs\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys2) {\n  return keys2.some((key) => options[key] !== void 0);\n}\nfunction getSpringOptions(options) {\n  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\nfunction spring(_a) {\n  var { from = 0, to = 1, restSpeed = 2, restDelta } = _a, options = __rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n  const state = { done: false, value: from };\n  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);\n  let resolveSpring = zero;\n  let resolveVelocity = zero;\n  function createSpring() {\n    const initialVelocity = velocity ? -(velocity / 1e3) : 0;\n    const initialDelta = to - from;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;\n    if (restDelta === void 0) {\n      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n    }\n    if (dampingRatio < 1) {\n      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n      resolveSpring = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n      resolveVelocity = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      resolveSpring = (t) => to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n      resolveSpring = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n  createSpring();\n  return {\n    next: (t) => {\n      const current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        const currentVelocity = resolveVelocity(t) * 1e3;\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? to : current;\n      return state;\n    },\n    flipTarget: () => {\n      velocity = -velocity;\n      [from, to] = [to, from];\n      createSpring();\n    }\n  };\n}\nspring.needsInterpolation = (a2, b2) => typeof a2 === \"string\" || typeof b2 === \"string\";\nvar zero = (_t) => 0;\n\n// ../../node_modules/popmotion/dist/es/utils/progress.mjs\nvar progress = (from, to, value) => {\n  const toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\n// ../../node_modules/popmotion/dist/es/utils/mix.mjs\nvar mix = (from, to, progress3) => -progress3 * from + progress3 * to + from;\n\n// ../../node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs\nfunction hueToRgb(p2, q, t) {\n  if (t < 0)\n    t += 1;\n  if (t > 1)\n    t -= 1;\n  if (t < 1 / 6)\n    return p2 + (q - p2) * 6 * t;\n  if (t < 1 / 2)\n    return q;\n  if (t < 2 / 3)\n    return p2 + (q - p2) * (2 / 3 - t) * 6;\n  return p2;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {\n  hue /= 360;\n  saturation /= 100;\n  lightness /= 100;\n  let red = 0;\n  let green = 0;\n  let blue = 0;\n  if (!saturation) {\n    red = green = blue = lightness;\n  } else {\n    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n    const p2 = 2 * lightness - q;\n    red = hueToRgb(p2, q, hue + 1 / 3);\n    green = hueToRgb(p2, q, hue);\n    blue = hueToRgb(p2, q, hue - 1 / 3);\n  }\n  return {\n    red: Math.round(red * 255),\n    green: Math.round(green * 255),\n    blue: Math.round(blue * 255),\n    alpha: alpha2\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/mix-color.mjs\nvar mixLinearColor = (from, to, v) => {\n  const fromExpo = from * from;\n  const toExpo = to * to;\n  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nvar colorTypes = [hex, rgba, hsla];\nvar getColorType = (v) => colorTypes.find((type) => type.test(v));\nvar notAnimatable = (color2) => `'${color2}' is not an animatable color. Use the equivalent color code instead.`;\nvar mixColor = (from, to) => {\n  let fromColorType = getColorType(from);\n  let toColorType = getColorType(to);\n  invariant(!!fromColorType, notAnimatable(from));\n  invariant(!!toColorType, notAnimatable(to));\n  let fromColor = fromColorType.parse(from);\n  let toColor = toColorType.parse(to);\n  if (fromColorType === hsla) {\n    fromColor = hslaToRgba(fromColor);\n    fromColorType = rgba;\n  }\n  if (toColorType === hsla) {\n    toColor = hslaToRgba(toColor);\n    toColorType = rgba;\n  }\n  const blended = Object.assign({}, fromColor);\n  return (v) => {\n    for (const key in blended) {\n      if (key !== \"alpha\") {\n        blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n      }\n    }\n    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n    return fromColorType.transform(blended);\n  };\n};\n\n// ../../node_modules/popmotion/dist/es/utils/inc.mjs\nvar isNum = (v) => typeof v === \"number\";\n\n// ../../node_modules/popmotion/dist/es/utils/pipe.mjs\nvar combineFunctions = (a2, b2) => (v) => b2(a2(v));\nvar pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n// ../../node_modules/popmotion/dist/es/utils/mix-complex.mjs\nfunction getMixer(origin, target) {\n  if (isNum(origin)) {\n    return (v) => mix(origin, target, v);\n  } else if (color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return mixComplex(origin, target);\n  }\n}\nvar mixArray = (from, to) => {\n  const output = [...from];\n  const numValues = output.length;\n  const blendValue = from.map((fromThis, i2) => getMixer(fromThis, to[i2]));\n  return (v) => {\n    for (let i2 = 0; i2 < numValues; i2++) {\n      output[i2] = blendValue[i2](v);\n    }\n    return output;\n  };\n};\nvar mixObject = (origin, target) => {\n  const output = Object.assign(Object.assign({}, origin), target);\n  const blendValue = {};\n  for (const key in output) {\n    if (origin[key] !== void 0 && target[key] !== void 0) {\n      blendValue[key] = getMixer(origin[key], target[key]);\n    }\n  }\n  return (v) => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n    return output;\n  };\n};\nfunction analyse2(value) {\n  const parsed = complex.parse(value);\n  const numValues = parsed.length;\n  let numNumbers = 0;\n  let numRGB = 0;\n  let numHSL = 0;\n  for (let i2 = 0; i2 < numValues; i2++) {\n    if (numNumbers || typeof parsed[i2] === \"number\") {\n      numNumbers++;\n    } else {\n      if (parsed[i2].hue !== void 0) {\n        numHSL++;\n      } else {\n        numRGB++;\n      }\n    }\n  }\n  return { parsed, numNumbers, numRGB, numHSL };\n}\nvar mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyse2(origin);\n  const targetStats = analyse2(target);\n  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n  } else {\n    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return (p2) => `${p2 > 0 ? target : origin}`;\n  }\n};\n\n// ../../node_modules/popmotion/dist/es/utils/interpolate.mjs\nvar mixNumber = (from, to) => (p2) => mix(from, to, p2);\nfunction detectMixerFactory(v) {\n  if (typeof v === \"number\") {\n    return mixNumber;\n  } else if (typeof v === \"string\") {\n    if (color.test(v)) {\n      return mixColor;\n    } else {\n      return mixComplex;\n    }\n  } else if (Array.isArray(v)) {\n    return mixArray;\n  } else if (typeof v === \"object\") {\n    return mixObject;\n  }\n}\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || detectMixerFactory(output[0]);\n  const numMixers = output.length - 1;\n  for (let i2 = 0; i2 < numMixers; i2++) {\n    let mixer = mixerFactory(output[i2], output[i2 + 1]);\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i2] : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n    mixers.push(mixer);\n  }\n  return mixers;\n}\nfunction fastInterpolate([from, to], [mixer]) {\n  return (v) => mixer(progress(from, to, v));\n}\nfunction slowInterpolate(input, mixers) {\n  const inputLength = input.length;\n  const lastInputIndex = inputLength - 1;\n  return (v) => {\n    let mixerIndex = 0;\n    let foundMixerIndex = false;\n    if (v <= input[0]) {\n      foundMixerIndex = true;\n    } else if (v >= input[lastInputIndex]) {\n      mixerIndex = lastInputIndex - 1;\n      foundMixerIndex = true;\n    }\n    if (!foundMixerIndex) {\n      let i2 = 1;\n      for (; i2 < inputLength; i2++) {\n        if (input[i2] > v || i2 === lastInputIndex) {\n          break;\n        }\n      }\n      mixerIndex = i2 - 1;\n    }\n    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n    return mixers[mixerIndex](progressInRange);\n  };\n}\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n  const inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, \"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.\");\n  if (input[0] > input[inputLength - 1]) {\n    input = [].concat(input);\n    output = [].concat(output);\n    input.reverse();\n    output.reverse();\n  }\n  const mixers = createMixers(output, ease, mixer);\n  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);\n  return isClamp ? (v) => interpolator(clamp2(input[0], input[inputLength - 1], v)) : interpolator;\n}\n\n// ../../node_modules/popmotion/dist/es/easing/utils.mjs\nvar reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);\nvar mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;\nvar createExpoIn = (power) => (p2) => Math.pow(p2, power);\nvar createBackIn = (power) => (p2) => p2 * p2 * ((power + 1) * p2 - power);\nvar createAnticipate = (power) => {\n  const backEasing = createBackIn(power);\n  return (p2) => (p2 *= 2) < 1 ? 0.5 * backEasing(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));\n};\n\n// ../../node_modules/popmotion/dist/es/easing/index.mjs\nvar DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nvar BOUNCE_FIRST_THRESHOLD = 4 / 11;\nvar BOUNCE_SECOND_THRESHOLD = 8 / 11;\nvar BOUNCE_THIRD_THRESHOLD = 9 / 10;\nvar linear = (p2) => p2;\nvar easeIn = createExpoIn(2);\nvar easeOut = reverseEasing(easeIn);\nvar easeInOut = mirrorEasing(easeIn);\nvar circIn = (p2) => 1 - Math.sin(Math.acos(p2));\nvar circOut = reverseEasing(circIn);\nvar circInOut = mirrorEasing(circOut);\nvar backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nvar backOut = reverseEasing(backIn);\nvar backInOut = mirrorEasing(backIn);\nvar anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nvar ca = 4356 / 361;\nvar cb = 35442 / 1805;\nvar cc = 16061 / 1805;\nvar bounceOut = (p2) => {\n  if (p2 === 1 || p2 === 0)\n    return p2;\n  const p22 = p2 * p2;\n  return p2 < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p22 : p2 < BOUNCE_SECOND_THRESHOLD ? 9.075 * p22 - 9.9 * p2 + 3.4 : p2 < BOUNCE_THIRD_THRESHOLD ? ca * p22 - cb * p2 + cc : 10.8 * p2 * p2 - 20.52 * p2 + 10.72;\n};\nvar bounceIn = reverseEasing(bounceOut);\nvar bounceInOut = (p2) => p2 < 0.5 ? 0.5 * (1 - bounceOut(1 - p2 * 2)) : 0.5 * bounceOut(p2 * 2 - 1) + 0.5;\n\n// ../../node_modules/popmotion/dist/es/animations/generators/keyframes.mjs\nfunction defaultEasing(values, easing) {\n  return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n  const numValues = values.length;\n  return values.map((_value, i2) => i2 !== 0 ? i2 / (numValues - 1) : 0);\n}\nfunction convertOffsetToTimes(offset, duration) {\n  return offset.map((o) => o * duration);\n}\nfunction keyframes({ from = 0, to = 1, ease, offset, duration = 300 }) {\n  const state = { done: false, value: from };\n  const values = Array.isArray(to) ? to : [from, to];\n  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);\n  function createInterpolator() {\n    return interpolate(times, values, {\n      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)\n    });\n  }\n  let interpolator = createInterpolator();\n  return {\n    next: (t) => {\n      state.value = interpolator(t);\n      state.done = t >= duration;\n      return state;\n    },\n    flipTarget: () => {\n      values.reverse();\n      interpolator = createInterpolator();\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/animations/generators/decay.mjs\nfunction decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {\n  const state = { done: false, value: from };\n  let amplitude = power * velocity;\n  const ideal = from + amplitude;\n  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);\n  if (target !== ideal)\n    amplitude = target - from;\n  return {\n    next: (t) => {\n      const delta = -amplitude * Math.exp(-t / timeConstant);\n      state.done = !(delta > restDelta || delta < -restDelta);\n      state.value = state.done ? target : target + delta;\n      return state;\n    },\n    flipTarget: () => {\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs\nvar types = { keyframes, spring, decay };\nfunction detectAnimationFromOptions(config) {\n  if (Array.isArray(config.to)) {\n    return keyframes;\n  } else if (types[config.type]) {\n    return types[config.type];\n  }\n  const keys2 = new Set(Object.keys(config));\n  if (keys2.has(\"ease\") || keys2.has(\"duration\") && !keys2.has(\"dampingRatio\")) {\n    return keyframes;\n  } else if (keys2.has(\"dampingRatio\") || keys2.has(\"stiffness\") || keys2.has(\"mass\") || keys2.has(\"damping\") || keys2.has(\"restSpeed\") || keys2.has(\"restDelta\")) {\n    return spring;\n  }\n  return keyframes;\n}\n\n// ../../node_modules/framesync/dist/es/on-next-frame.mjs\nvar defaultTimestep = 1 / 60 * 1e3;\nvar getCurrentTime = typeof performance !== \"undefined\" ? () => performance.now() : () => Date.now();\nvar onNextFrame = typeof window !== \"undefined\" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);\n\n// ../../node_modules/framesync/dist/es/create-render-step.mjs\nfunction createRenderStep(runNextFrame2) {\n  let toRun = [];\n  let toRunNextFrame = [];\n  let numToRun = 0;\n  let isProcessing2 = false;\n  let flushNextFrame = false;\n  const toKeepAlive = /* @__PURE__ */ new WeakSet();\n  const step = {\n    schedule: (callback, keepAlive = false, immediate = false) => {\n      const addToCurrentFrame = immediate && isProcessing2;\n      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n      if (keepAlive)\n        toKeepAlive.add(callback);\n      if (buffer.indexOf(callback) === -1) {\n        buffer.push(callback);\n        if (addToCurrentFrame && isProcessing2)\n          numToRun = toRun.length;\n      }\n      return callback;\n    },\n    cancel: (callback) => {\n      const index2 = toRunNextFrame.indexOf(callback);\n      if (index2 !== -1)\n        toRunNextFrame.splice(index2, 1);\n      toKeepAlive.delete(callback);\n    },\n    process: (frameData) => {\n      if (isProcessing2) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing2 = true;\n      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\n      toRunNextFrame.length = 0;\n      numToRun = toRun.length;\n      if (numToRun) {\n        for (let i2 = 0; i2 < numToRun; i2++) {\n          const callback = toRun[i2];\n          callback(frameData);\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame2();\n          }\n        }\n      }\n      isProcessing2 = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\n\n// ../../node_modules/framesync/dist/es/index.mjs\nvar maxElapsed = 40;\nvar useDefaultElapsed = true;\nvar runNextFrame = false;\nvar isProcessing = false;\nvar frame = {\n  delta: 0,\n  timestamp: 0\n};\nvar stepsOrder = [\n  \"read\",\n  \"update\",\n  \"preRender\",\n  \"render\",\n  \"postRender\"\n];\nvar steps = stepsOrder.reduce((acc, key) => {\n  acc[key] = createRenderStep(() => runNextFrame = true);\n  return acc;\n}, {});\nvar sync = stepsOrder.reduce((acc, key) => {\n  const step = steps[key];\n  acc[key] = (process2, keepAlive = false, immediate = false) => {\n    if (!runNextFrame)\n      startLoop();\n    return step.schedule(process2, keepAlive, immediate);\n  };\n  return acc;\n}, {});\nvar cancelSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = steps[key].cancel;\n  return acc;\n}, {});\nvar flushSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = () => steps[key].process(frame);\n  return acc;\n}, {});\nvar processStep = (stepId) => steps[stepId].process(frame);\nvar processFrame = (timestamp) => {\n  runNextFrame = false;\n  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\n  frame.timestamp = timestamp;\n  isProcessing = true;\n  stepsOrder.forEach(processStep);\n  isProcessing = false;\n  if (runNextFrame) {\n    useDefaultElapsed = false;\n    onNextFrame(processFrame);\n  }\n};\nvar startLoop = () => {\n  runNextFrame = true;\n  useDefaultElapsed = true;\n  if (!isProcessing)\n    onNextFrame(processFrame);\n};\nvar getFrameData = () => frame;\nvar es_default = sync;\n\n// ../../node_modules/popmotion/dist/es/animations/utils/elapsed.mjs\nfunction loopElapsed(elapsed, duration, delay2 = 0) {\n  return elapsed - duration - delay2;\n}\nfunction reverseElapsed(elapsed, duration, delay2 = 0, isForwardPlayback = true) {\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay2) : duration - (elapsed - duration) + delay2;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay2, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay2 : elapsed <= -delay2;\n}\n\n// ../../node_modules/popmotion/dist/es/animations/index.mjs\nvar framesync = (update) => {\n  const passTimestamp = ({ delta }) => update(delta);\n  return {\n    start: () => es_default.update(passTimestamp, true),\n    stop: () => cancelSync.update(passTimestamp)\n  };\n};\nfunction animate(_a) {\n  var _b, _c;\n  var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n  let { to } = options;\n  let driverControls;\n  let repeatCount = 0;\n  let computedDuration = options.duration;\n  let latest;\n  let isComplete = false;\n  let isForwardPlayback = true;\n  let interpolateFromNumber;\n  const animator = detectAnimationFromOptions(options);\n  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n    interpolateFromNumber = interpolate([0, 100], [from, to], {\n      clamp: false\n    });\n    from = 0;\n    to = 100;\n  }\n  const animation = animator(Object.assign(Object.assign({}, options), { from, to }));\n  function repeat() {\n    repeatCount++;\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\")\n        animation.flipTarget();\n    }\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n  function complete() {\n    driverControls.stop();\n    onComplete && onComplete();\n  }\n  function update(delta) {\n    if (!isForwardPlayback)\n      delta = -delta;\n    elapsed += delta;\n    if (!isComplete) {\n      const state = animation.next(Math.max(0, elapsed));\n      latest = state.value;\n      if (interpolateFromNumber)\n        latest = interpolateFromNumber(latest);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n    if (isComplete) {\n      if (repeatCount === 0)\n        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n  function play() {\n    onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n  autoplay && play();\n  return {\n    stop: () => {\n      onStop === null || onStop === void 0 ? void 0 : onStop();\n      driverControls.stop();\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/velocity-per-second.mjs\nfunction velocityPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1e3 / frameDuration) : 0;\n}\n\n// ../../node_modules/popmotion/dist/es/animations/inertia.mjs\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {\n  let currentAnimation;\n  function isOutOfBounds(v) {\n    return min !== void 0 && v < min || max !== void 0 && v > max;\n  }\n  function boundaryNearest(v) {\n    if (min === void 0)\n      return max;\n    if (max === void 0)\n      return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  }\n  function startAnimation2(options) {\n    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n    currentAnimation = animate(Object.assign(Object.assign({}, options), {\n      driver,\n      onUpdate: (v) => {\n        var _a;\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n      },\n      onComplete,\n      onStop\n    }));\n  }\n  function startSpring(options) {\n    startAnimation2(Object.assign({ type: \"spring\", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));\n  }\n  if (isOutOfBounds(from)) {\n    startSpring({ from, velocity, to: boundaryNearest(from) });\n  } else {\n    let target = power * velocity + from;\n    if (typeof modifyTarget !== \"undefined\")\n      target = modifyTarget(target);\n    const boundary = boundaryNearest(target);\n    const heading = boundary === min ? -1 : 1;\n    let prev;\n    let current;\n    const checkBoundary = (v) => {\n      prev = current;\n      current = v;\n      velocity = velocityPerSecond(v - prev, getFrameData().delta);\n      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {\n        startSpring({ from: v, to: boundary, velocity });\n      }\n    };\n    startAnimation2({\n      type: \"decay\",\n      from,\n      velocity,\n      timeConstant,\n      power,\n      restDelta,\n      modifyTarget,\n      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0\n    });\n  }\n  return {\n    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/is-point.mjs\nvar isPoint = (point2) => point2.hasOwnProperty(\"x\") && point2.hasOwnProperty(\"y\");\n\n// ../../node_modules/popmotion/dist/es/utils/is-point-3d.mjs\nvar isPoint3D = (point2) => isPoint(point2) && point2.hasOwnProperty(\"z\");\n\n// ../../node_modules/popmotion/dist/es/utils/distance.mjs\nvar distance1D = (a2, b2) => Math.abs(a2 - b2);\nfunction distance(a2, b2) {\n  if (isNum(a2) && isNum(b2)) {\n    return distance1D(a2, b2);\n  } else if (isPoint(a2) && isPoint(b2)) {\n    const xDelta = distance1D(a2.x, b2.x);\n    const yDelta = distance1D(a2.y, b2.y);\n    const zDelta = isPoint3D(a2) && isPoint3D(b2) ? distance1D(a2.z, b2.z) : 0;\n    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n  }\n}\n\n// ../../node_modules/popmotion/dist/es/easing/cubic-bezier.mjs\nvar a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\nvar b = (a1, a2) => 3 * a2 - 6 * a1;\nvar c2 = (a1) => 3 * a1;\nvar calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c2(a1)) * t;\nvar getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c2(a1);\nvar subdivisionPrecision = 1e-7;\nvar subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX;\n  let currentT;\n  let i2 = 0;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);\n  return currentT;\n}\nvar newtonIterations = 8;\nvar newtonMinSlope = 1e-3;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i2 = 0; i2 < newtonIterations; ++i2) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0) {\n      return aGuessT;\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  if (mX1 === mY1 && mX2 === mY2)\n    return linear;\n  const sampleValues = new Float32Array(kSplineTableSize);\n  for (let i2 = 0; i2 < kSplineTableSize; ++i2) {\n    sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);\n  }\n  function getTForX(aX) {\n    let intervalStart = 0;\n    let currentSample = 1;\n    const lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= newtonMinSlope) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs\nfunction useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement }) {\n  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  const isPressing = (0, import_react20.useRef)(false);\n  const cancelPointerEndListeners = (0, import_react20.useRef)(null);\n  const eventOptions = {\n    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)\n  };\n  function removePointerEndListener() {\n    cancelPointerEndListeners.current && cancelPointerEndListeners.current();\n    cancelPointerEndListeners.current = null;\n  }\n  function checkPointerEnd() {\n    removePointerEndListener();\n    isPressing.current = false;\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, false);\n    return !isDragActive();\n  }\n  function onPointerUp(event, info) {\n    if (!checkPointerEnd())\n      return;\n    !isNodeOrChild(visualElement.current, event.target) ? onTapCancel && onTapCancel(event, info) : onTap && onTap(event, info);\n  }\n  function onPointerCancel(event, info) {\n    if (!checkPointerEnd())\n      return;\n    onTapCancel && onTapCancel(event, info);\n  }\n  function onPointerDown(event, info) {\n    removePointerEndListener();\n    if (isPressing.current)\n      return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, true);\n    onTapStart && onTapStart(event, info);\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : void 0, eventOptions);\n  useUnmountEffect(removePointerEndListener);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/process.mjs\nvar defaultEnvironment = \"production\";\nvar env = typeof process === \"undefined\" || process.env === void 0 ? defaultEnvironment : \"development\" || 0;\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs\nvar import_react21 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/utils/warn-once.mjs\nvar warned = /* @__PURE__ */ new Set();\nfunction warnOnce(condition, message, element) {\n  if (condition || warned.has(message))\n    return;\n  console.warn(message);\n  if (element)\n    console.warn(element);\n  warned.add(message);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs\nvar observerCallbacks = /* @__PURE__ */ new WeakMap();\nvar observers = /* @__PURE__ */ new WeakMap();\nvar fireObserverCallback = (entry) => {\n  const callback = observerCallbacks.get(entry.target);\n  callback && callback(entry);\n};\nvar fireAllObserverCallbacks = (entries) => {\n  entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_a) {\n  var _b = _a, { root } = _b, options = __objRest(_b, [\"root\"]);\n  const lookupRoot = root || document;\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n  const rootObservers = observers.get(lookupRoot);\n  const key = JSON.stringify(options);\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __spreadValues({ root }, options));\n  }\n  return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n  const rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return () => {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs\nfunction useViewport({ visualElement, whileInView, onViewportEnter, onViewportLeave, viewport = {} }) {\n  const state = (0, import_react21.useRef)({\n    hasEnteredView: false,\n    isInView: false\n  });\n  let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n  if (viewport.once && state.current.hasEnteredView)\n    shouldObserve = false;\n  const useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n  useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nvar thresholdNames = {\n  some: 0,\n  all: 1\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, { root, margin: rootMargin, amount = \"some\", once }) {\n  (0, import_react21.useEffect)(() => {\n    if (!shouldObserve || !visualElement.current)\n      return;\n    const options = {\n      root: root === null || root === void 0 ? void 0 : root.current,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    const intersectionCallback = (entry) => {\n      const { isIntersecting } = entry;\n      if (state.isInView === isIntersecting)\n        return;\n      state.isInView = isIntersecting;\n      if (once && !isIntersecting && state.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        state.hasEnteredView = true;\n      }\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, isIntersecting);\n      }\n      const props = visualElement.getProps();\n      const callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(visualElement.current, options, intersectionCallback);\n  }, [shouldObserve, root, rootMargin, amount]);\n}\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, { fallback = true }) {\n  (0, import_react21.useEffect)(() => {\n    if (!shouldObserve || !fallback)\n      return;\n    if (env !== \"production\") {\n      warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n    }\n    requestAnimationFrame(() => {\n      state.hasEnteredView = true;\n      const { onViewportEnter } = visualElement.getProps();\n      onViewportEnter && onViewportEnter(null);\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, true);\n      }\n    });\n  }, [shouldObserve]);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/make-renderless-component.mjs\nvar makeRenderlessComponent = (hook) => (props) => {\n  hook(props);\n  return null;\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/gestures.mjs\nvar gestureAnimations = {\n  inView: makeRenderlessComponent(useViewport),\n  tap: makeRenderlessComponent(useTapGesture),\n  focus: makeRenderlessComponent(useFocusGesture),\n  hover: makeRenderlessComponent(useHoverGesture)\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/animations.mjs\nvar import_react23 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs\nvar import_react22 = __webpack_require__(/*! react */ \"react\");\nfunction usePresence() {\n  const context = (0, import_react22.useContext)(PresenceContext);\n  if (context === null)\n    return [true, null];\n  const { isPresent, onExitComplete, register } = context;\n  const id2 = (0, import_react22.useId)();\n  (0, import_react22.useEffect)(() => register(id2), []);\n  const safeToRemove = () => onExitComplete && onExitComplete(id2);\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/shallow-compare.mjs\nfunction shallowCompare(next, prev) {\n  if (!Array.isArray(prev))\n    return false;\n  const prevLength = prev.length;\n  if (prevLength !== next.length)\n    return false;\n  for (let i2 = 0; i2 < prevLength; i2++) {\n    if (prev[i2] !== next[i2])\n      return false;\n  }\n  return true;\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/time-conversion.mjs\nvar secondsToMilliseconds = (seconds) => seconds * 1e3;\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/easing.mjs\nvar easingLookup = {\n  linear,\n  easeIn,\n  easeInOut,\n  easeOut,\n  circIn,\n  circInOut,\n  circOut,\n  backIn,\n  backInOut,\n  backOut,\n  anticipate,\n  bounceIn,\n  bounceInOut,\n  bounceOut\n};\nvar easingDefinitionToFunction = (definition) => {\n  if (Array.isArray(definition)) {\n    invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n    const [x1, y1, x2, y2] = definition;\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);\n    return easingLookup[definition];\n  }\n  return definition;\n};\nvar isEasingArray = (ease) => {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs\nvar isAnimatable = (key, value) => {\n  if (key === \"zIndex\")\n    return false;\n  if (typeof value === \"number\" || Array.isArray(value))\n    return true;\n  if (typeof value === \"string\" && complex.test(value) && !value.startsWith(\"url(\")) {\n    return true;\n  }\n  return false;\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs\nvar underDampedSpring = () => ({\n  type: \"spring\",\n  stiffness: 500,\n  damping: 25,\n  restSpeed: 10\n});\nvar criticallyDampedSpring = (to) => ({\n  type: \"spring\",\n  stiffness: 550,\n  damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n  restSpeed: 10\n});\nvar linearTween = () => ({\n  type: \"keyframes\",\n  ease: \"linear\",\n  duration: 0.3\n});\nvar keyframes2 = (values) => ({\n  type: \"keyframes\",\n  duration: 0.8,\n  values\n});\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: criticallyDampedSpring,\n  scaleY: criticallyDampedSpring,\n  scale: criticallyDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: criticallyDampedSpring\n};\nvar getDefaultTransition = (valueKey, to) => {\n  let transitionFactory;\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes2;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n  return __spreadValues({ to }, transitionFactory(to));\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs\nvar defaultValueTypes = __spreadProps(__spreadValues({}, numberValueTypes), {\n  color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  filter,\n  WebkitFilter: filter\n});\nvar getDefaultValueType = (key) => defaultValueTypes[key];\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs\nfunction getAnimatableNone2(key, value) {\n  var _a;\n  let defaultValueType = getDefaultValueType(key);\n  if (defaultValueType !== filter)\n    defaultValueType = complex;\n  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs\nvar instantAnimationState = {\n  current: false\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/delay.mjs\nfunction delay(callback, timeout) {\n  const start = performance.now();\n  const checkElapsed = ({ timestamp }) => {\n    const elapsed = timestamp - start;\n    if (elapsed >= timeout) {\n      cancelSync.read(checkElapsed);\n      callback(elapsed - timeout);\n    }\n  };\n  es_default.read(checkElapsed, true);\n  return () => cancelSync.read(checkElapsed);\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/transitions.mjs\nfunction isTransitionDefined(_a) {\n  var _b = _a, { when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from } = _b, transition = __objRest(_b, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n  return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\nfunction convertTransitionToAnimationOptions(_a) {\n  var _b = _a, { ease, times, yoyo, flip, loop } = _b, transition = __objRest(_b, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n  const options = __spreadValues({}, transition);\n  if (times)\n    options[\"offset\"] = times;\n  if (transition.duration)\n    options[\"duration\"] = secondsToMilliseconds(transition.duration);\n  if (transition.repeatDelay)\n    options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n  if (ease) {\n    options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  }\n  if (transition.type === \"tween\")\n    options.type = \"keyframes\";\n  if (yoyo || loop || flip) {\n    warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n    legacyRepeatWarning = true;\n    if (yoyo) {\n      options.repeatType = \"reverse\";\n    } else if (loop) {\n      options.repeatType = \"loop\";\n    } else if (flip) {\n      options.repeatType = \"mirror\";\n    }\n    options.repeat = loop || yoyo || flip || transition.repeat;\n  }\n  if (transition.type !== \"spring\")\n    options.type = \"keyframes\";\n  return options;\n}\nfunction getDelayFromTransition(transition, key) {\n  var _a, _b;\n  const valueTransition = getValueTransition(transition, key) || {};\n  return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\nfunction hydrateKeyframes(options) {\n  if (Array.isArray(options.to) && options.to[0] === null) {\n    options.to = [...options.to];\n    options.to[0] = options.from;\n  }\n  return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n  if (Array.isArray(options.to) && transition.duration === void 0) {\n    transition.duration = 0.8;\n  }\n  hydrateKeyframes(options);\n  if (!isTransitionDefined(transition)) {\n    transition = __spreadValues(__spreadValues({}, transition), getDefaultTransition(key, options.to));\n  }\n  return __spreadValues(__spreadValues({}, options), convertTransitionToAnimationOptions(transition));\n}\nfunction getAnimation(key, value, target, transition, onComplete) {\n  const valueTransition = getValueTransition(transition, key) || {};\n  let origin = valueTransition.from !== void 0 ? valueTransition.from : value.get();\n  const isTargetAnimatable = isAnimatable(key, target);\n  if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n    origin = getAnimatableNone2(key, target);\n  } else if (isZero(origin) && typeof target === \"string\") {\n    origin = getZeroUnit(target);\n  } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n    target = getZeroUnit(origin);\n  }\n  const isOriginAnimatable = isAnimatable(key, origin);\n  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${key} from \"${origin}\" to \"${target}\". ${origin} is not an animatable value - to enable this animation set ${origin} to a value animatable to ${target} via the \\`style\\` property.`);\n  function start() {\n    const options = {\n      from: origin,\n      to: target,\n      velocity: value.getVelocity(),\n      onComplete,\n      onUpdate: (v) => value.set(v)\n    };\n    return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? inertia(__spreadValues(__spreadValues({}, options), valueTransition)) : animate(__spreadProps(__spreadValues({}, getPopmotionAnimationOptions(valueTransition, options, key)), {\n      onUpdate: (v) => {\n        options.onUpdate(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: () => {\n        options.onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      }\n    }));\n  }\n  function set() {\n    const finalTarget = resolveFinalValueInKeyframes(target);\n    value.set(finalTarget);\n    onComplete();\n    valueTransition.onUpdate && valueTransition.onUpdate(finalTarget);\n    valueTransition.onComplete && valueTransition.onComplete();\n    return { stop: () => {\n    } };\n  }\n  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\nfunction isZero(value) {\n  return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\nfunction getZeroUnit(potentialUnitType) {\n  return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone2(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\nfunction startAnimation(key, value, target, transition = {}) {\n  if (instantAnimationState.current) {\n    transition = { type: false };\n  }\n  return value.start((onComplete) => {\n    let controls;\n    const animation = getAnimation(key, value, target, transition, onComplete);\n    const delayBy = getDelayFromTransition(transition, key);\n    const start = () => controls = animation();\n    let cancelDelay;\n    if (delayBy) {\n      cancelDelay = delay(start, secondsToMilliseconds(delayBy));\n    } else {\n      start();\n    }\n    return () => {\n      cancelDelay && cancelDelay();\n      controls && controls.stop();\n    };\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs\nvar isNumericalString = (v) => /^\\-?\\d*\\.?\\d+$/.test(v);\n\n// ../../node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs\nvar isZeroValueString = (v) => /^0[^.\\s]+$/.test(v);\n\n// ../../node_modules/framer-motion/dist/es/utils/array.mjs\nfunction addUniqueItem(arr, item) {\n  if (arr.indexOf(item) === -1)\n    arr.push(item);\n}\nfunction removeItem(arr, item) {\n  const index2 = arr.indexOf(item);\n  if (index2 > -1)\n    arr.splice(index2, 1);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/subscription-manager.mjs\nvar SubscriptionManager = class {\n  constructor() {\n    this.subscriptions = [];\n  }\n  add(handler) {\n    addUniqueItem(this.subscriptions, handler);\n    return () => removeItem(this.subscriptions, handler);\n  }\n  notify(a2, b2, c3) {\n    const numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions)\n      return;\n    if (numSubscriptions === 1) {\n      this.subscriptions[0](a2, b2, c3);\n    } else {\n      for (let i2 = 0; i2 < numSubscriptions; i2++) {\n        const handler = this.subscriptions[i2];\n        handler && handler(a2, b2, c3);\n      }\n    }\n  }\n  getSize() {\n    return this.subscriptions.length;\n  }\n  clear() {\n    this.subscriptions.length = 0;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/value/index.mjs\nvar isFloat = (value) => {\n  return !isNaN(parseFloat(value));\n};\nvar MotionValue = class {\n  constructor(init) {\n    this.version = \"7.6.7\";\n    this.timeDelta = 0;\n    this.lastUpdated = 0;\n    this.updateSubscribers = new SubscriptionManager();\n    this.velocityUpdateSubscribers = new SubscriptionManager();\n    this.renderSubscribers = new SubscriptionManager();\n    this.canTrackVelocity = false;\n    this.updateAndNotify = (v, render = true) => {\n      this.prev = this.current;\n      this.current = v;\n      const { delta, timestamp } = getFrameData();\n      if (this.lastUpdated !== timestamp) {\n        this.timeDelta = delta;\n        this.lastUpdated = timestamp;\n        es_default.postRender(this.scheduleVelocityCheck);\n      }\n      if (this.prev !== this.current) {\n        this.updateSubscribers.notify(this.current);\n      }\n      if (this.velocityUpdateSubscribers.getSize()) {\n        this.velocityUpdateSubscribers.notify(this.getVelocity());\n      }\n      if (render) {\n        this.renderSubscribers.notify(this.current);\n      }\n    };\n    this.scheduleVelocityCheck = () => es_default.postRender(this.velocityCheck);\n    this.velocityCheck = ({ timestamp }) => {\n      if (timestamp !== this.lastUpdated) {\n        this.prev = this.current;\n        this.velocityUpdateSubscribers.notify(this.getVelocity());\n      }\n    };\n    this.hasAnimated = false;\n    this.prev = this.current = init;\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  onChange(subscription) {\n    return this.updateSubscribers.add(subscription);\n  }\n  clearListeners() {\n    this.updateSubscribers.clear();\n  }\n  onRenderRequest(subscription) {\n    subscription(this.get());\n    return this.renderSubscribers.add(subscription);\n  }\n  attach(passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  }\n  set(v, render = true) {\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  }\n  get() {\n    return this.current;\n  }\n  getPrevious() {\n    return this.prev;\n  }\n  getVelocity() {\n    return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  }\n  start(animation) {\n    this.stop();\n    return new Promise((resolve) => {\n      this.hasAnimated = true;\n      this.stopAnimation = animation(resolve);\n    }).then(() => this.clearAnimation());\n  }\n  stop() {\n    if (this.stopAnimation)\n      this.stopAnimation();\n    this.clearAnimation();\n  }\n  isAnimating() {\n    return !!this.stopAnimation;\n  }\n  clearAnimation() {\n    this.stopAnimation = null;\n  }\n  destroy() {\n    this.updateSubscribers.clear();\n    this.renderSubscribers.clear();\n    this.stop();\n  }\n};\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs\nvar testValueType = (v) => (type) => type.test(v);\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs\nvar auto = {\n  test: (v) => v === \"auto\",\n  parse: (v) => v\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\nvar findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs\nvar valueTypes = [...dimensionValueTypes, color, complex];\nvar findValueType = (v) => valueTypes.find(testValueType(v));\n\n// ../../node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs\nfunction getCurrent(visualElement) {\n  const current = {};\n  visualElement.values.forEach((value, key) => current[key] = value.get());\n  return current;\n}\nfunction getVelocity(visualElement) {\n  const velocity = {};\n  visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());\n  return velocity;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n  const props = visualElement.getProps();\n  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/setters.mjs\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\nfunction setTarget(visualElement, definition) {\n  const resolved = resolveVariant(visualElement, definition);\n  let _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {}, { transitionEnd = {}, transition = {} } = _a, target = __objRest(_a, [\"transitionEnd\", \"transition\"]);\n  target = __spreadValues(__spreadValues({}, target), transitionEnd);\n  for (const key in target) {\n    const value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b;\n  const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));\n  const numNewValues = newValueKeys.length;\n  if (!numNewValues)\n    return;\n  for (let i2 = 0; i2 < numNewValues; i2++) {\n    const key = newValueKeys[i2];\n    const targetValue = target[key];\n    let value = null;\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    if (value === void 0 || value === null)\n      continue;\n    if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone2(key, targetValue);\n    }\n    visualElement.addValue(key, motionValue(value));\n    if (origin[key] === void 0) {\n      origin[key] = value;\n    }\n    if (value !== null)\n      visualElement.setBaseTarget(key, value);\n  }\n}\nfunction getOriginFromTransition(key, transition) {\n  if (!transition)\n    return;\n  const valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n  var _a;\n  const origin = {};\n  for (const key in target) {\n    const transitionOrigin = getOriginFromTransition(key, transition);\n    origin[key] = transitionOrigin !== void 0 ? transitionOrigin : (_a = visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.get();\n  }\n  return origin;\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-will-change/is.mjs\nfunction isWillChangeMotionValue(value) {\n  return Boolean(isMotionValue(value) && value.add);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/animation.mjs\nfunction animateVisualElement(visualElement, definition, options = {}) {\n  visualElement.notify(\"AnimationStart\", definition);\n  let animation;\n  if (Array.isArray(definition)) {\n    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));\n    animation = Promise.all(animations2);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    const resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n  return animation.then(() => visualElement.notify(\"AnimationComplete\", definition));\n}\nfunction animateVariant(visualElement, variant, options = {}) {\n  var _a;\n  const resolved = resolveVariant(visualElement, variant, options.custom);\n  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  const getAnimation2 = resolved ? () => animateTarget(visualElement, resolved, options) : () => Promise.resolve();\n  const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? (forwardDelay = 0) => {\n    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  const { when } = transition;\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2];\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);\n  }\n}\nfunction animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {\n  var _a;\n  let _a2 = visualElement.makeTargetAnimatable(definition), { transition = visualElement.getDefaultTransition(), transitionEnd } = _a2, target = __objRest(_a2, [\"transition\", \"transitionEnd\"]);\n  const willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride)\n    transition = transitionOverride;\n  const animations2 = [];\n  const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n  for (const key in target) {\n    const value = visualElement.getValue(key);\n    const valueTarget = target[key];\n    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n    let valueTransition = __spreadValues({ delay: delay2 }, transition);\n    if (visualElement.shouldReduceMotion && transformProps.has(key)) {\n      valueTransition = __spreadProps(__spreadValues({}, valueTransition), {\n        type: false,\n        delay: 0\n      });\n    }\n    let animation = startAnimation(key, value, valueTarget, valueTransition);\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation = animation.then(() => willChange.remove(key));\n    }\n    animations2.push(animation);\n  }\n  return Promise.all(animations2).then(() => {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n  const animations2 = [];\n  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {\n    animations2.push(animateVariant(child, variant, __spreadProps(__spreadValues({}, options), {\n      delay: delayChildren + generateStaggerDuration(i2)\n    })).then(() => child.notify(\"AnimationComplete\", variant)));\n  });\n  return Promise.all(animations2);\n}\nfunction sortByTreeOrder(a2, b2) {\n  return a2.sortNodePosition(b2);\n}\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs\nvar variantPriorityOrder = [\n  AnimationType.Animate,\n  AnimationType.InView,\n  AnimationType.Focus,\n  AnimationType.Hover,\n  AnimationType.Tap,\n  AnimationType.Drag,\n  AnimationType.Exit\n];\nvar reversePriorityOrder = [...variantPriorityOrder].reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n  let animate3 = animateList(visualElement);\n  const state = createState();\n  let isInitialRender = true;\n  const buildResolvedTypeValues = (acc, definition) => {\n    const resolved = resolveVariant(visualElement, definition);\n    if (resolved) {\n      const _a = resolved, { transition, transitionEnd } = _a, target = __objRest(_a, [\"transition\", \"transitionEnd\"]);\n      acc = __spreadValues(__spreadValues(__spreadValues({}, acc), target), transitionEnd);\n    }\n    return acc;\n  };\n  function setAnimateFunction(makeAnimator) {\n    animate3 = makeAnimator(visualElement);\n  }\n  function animateChanges(options, changedActiveType) {\n    var _a;\n    const props = visualElement.getProps();\n    const context = visualElement.getVariantContext(true) || {};\n    const animations2 = [];\n    const removedKeys = /* @__PURE__ */ new Set();\n    let encounteredKeys = {};\n    let removedVariantIndex = Infinity;\n    for (let i2 = 0; i2 < numAnimationTypes; i2++) {\n      const type = reversePriorityOrder[i2];\n      const typeState = state[type];\n      const prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      const propIsVariant = isVariantLabel(prop);\n      const activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false)\n        removedVariantIndex = i2;\n      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      typeState.protectedKeys = __spreadValues({}, encounteredKeys);\n      if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop === \"boolean\") {\n        continue;\n      }\n      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n      let shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i2 > removedVariantIndex && propIsVariant;\n      const definitionList = Array.isArray(prop) ? prop : [prop];\n      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false)\n        resolvedValues = {};\n      const { prevResolvedValues = {} } = typeState;\n      const allKeys = __spreadValues(__spreadValues({}, prevResolvedValues), resolvedValues);\n      const markToAnimate = (key) => {\n        shouldAnimateType = true;\n        removedKeys.delete(key);\n        typeState.needsAnimating[key] = true;\n      };\n      for (const key in allKeys) {\n        const next = resolvedValues[key];\n        const prev = prevResolvedValues[key];\n        if (encounteredKeys.hasOwnProperty(key))\n          continue;\n        if (next !== prev) {\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev) || variantDidChange) {\n              markToAnimate(key);\n            } else {\n              typeState.protectedKeys[key] = true;\n            }\n          } else if (next !== void 0) {\n            markToAnimate(key);\n          } else {\n            removedKeys.add(key);\n          }\n        } else if (next !== void 0 && removedKeys.has(key)) {\n          markToAnimate(key);\n        } else {\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      if (typeState.isActive) {\n        encounteredKeys = __spreadValues(__spreadValues({}, encounteredKeys), resolvedValues);\n      }\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      if (shouldAnimateType && !isInherited) {\n        animations2.push(...definitionList.map((animation) => ({\n          animation,\n          options: __spreadValues({ type }, options)\n        })));\n      }\n    }\n    if (removedKeys.size) {\n      const fallbackAnimation = {};\n      removedKeys.forEach((key) => {\n        const fallbackTarget = visualElement.getBaseTarget(key);\n        if (fallbackTarget !== void 0) {\n          fallbackAnimation[key] = fallbackTarget;\n        }\n      });\n      animations2.push({ animation: fallbackAnimation });\n    }\n    let shouldAnimate = Boolean(animations2.length);\n    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n    isInitialRender = false;\n    return shouldAnimate ? animate3(animations2) : Promise.resolve();\n  }\n  function setActive(type, isActive, options) {\n    var _a;\n    if (state[type].isActive === isActive)\n      return Promise.resolve();\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\n      var _a2;\n      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    const animations2 = animateChanges(options, type);\n    for (const key in state) {\n      state[key].protectedKeys = {};\n    }\n    return animations2;\n  }\n  return {\n    animateChanges,\n    setActive,\n    setAnimateFunction,\n    getState: () => state\n  };\n}\nfunction checkVariantsDidChange(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (Array.isArray(next)) {\n    return !shallowCompare(next, prev);\n  }\n  return false;\n}\nfunction createTypeState(isActive = false) {\n  return {\n    isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction createState() {\n  return {\n    [AnimationType.Animate]: createTypeState(true),\n    [AnimationType.InView]: createTypeState(),\n    [AnimationType.Hover]: createTypeState(),\n    [AnimationType.Tap]: createTypeState(),\n    [AnimationType.Drag]: createTypeState(),\n    [AnimationType.Focus]: createTypeState(),\n    [AnimationType.Exit]: createTypeState()\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/animations.mjs\nvar animations = {\n  animation: makeRenderlessComponent(({ visualElement, animate: animate3 }) => {\n    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n    if (isAnimationControls(animate3)) {\n      (0, import_react23.useEffect)(() => animate3.subscribe(visualElement), [animate3]);\n    }\n  }),\n  exit: makeRenderlessComponent((props) => {\n    const { custom, visualElement } = props;\n    const [isPresent, safeToRemove] = usePresence();\n    const presenceContext = (0, import_react23.useContext)(PresenceContext);\n    (0, import_react23.useEffect)(() => {\n      visualElement.isPresent = isPresent;\n      const animation = visualElement.animationState && visualElement.animationState.setActive(AnimationType.Exit, !isPresent, {\n        custom: presenceContext && presenceContext.custom || custom\n      });\n      if (animation && !isPresent) {\n        animation.then(safeToRemove);\n      }\n    }, [isPresent]);\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs\nvar import_react24 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/gestures/PanSession.mjs\nvar PanSession = class {\n  constructor(event, handlers, { transformPagePoint } = {}) {\n    this.startEvent = null;\n    this.lastMoveEvent = null;\n    this.lastMoveEventInfo = null;\n    this.handlers = {};\n    this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n        return;\n      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      const isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold)\n        return;\n      const { point: point3 } = info2;\n      const { timestamp: timestamp2 } = getFrameData();\n      this.history.push(__spreadProps(__spreadValues({}, point3), { timestamp: timestamp2 }));\n      const { onStart, onMove } = this.handlers;\n      if (!isPanStarted) {\n        onStart && onStart(this.lastMoveEvent, info2);\n        this.startEvent = this.lastMoveEvent;\n      }\n      onMove && onMove(this.lastMoveEvent, info2);\n    };\n    this.handlePointerMove = (event2, info2) => {\n      this.lastMoveEvent = event2;\n      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);\n      if (isMouseEvent(event2) && event2.buttons === 0) {\n        this.handlePointerUp(event2, info2);\n        return;\n      }\n      es_default.update(this.updatePoint, true);\n    };\n    this.handlePointerUp = (event2, info2) => {\n      this.end();\n      const { onEnd, onSessionEnd } = this.handlers;\n      const panInfo = getPanInfo(transformPoint(info2, this.transformPagePoint), this.history);\n      if (this.startEvent && onEnd) {\n        onEnd(event2, panInfo);\n      }\n      onSessionEnd && onSessionEnd(event2, panInfo);\n    };\n    if (isTouchEvent(event) && event.touches.length > 1)\n      return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    const info = extractEventInfo(event);\n    const initialInfo = transformPoint(info, this.transformPagePoint);\n    const { point: point2 } = initialInfo;\n    const { timestamp } = getFrameData();\n    this.history = [__spreadProps(__spreadValues({}, point2), { timestamp })];\n    const { onSessionStart } = handlers;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n  }\n};\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a2, b2) {\n  return { x: a2.x - b2.x, y: a2.y - b2.y };\n}\nfunction getPanInfo({ point: point2 }, history) {\n  return {\n    point: point2,\n    delta: subtractPoint(point2, lastDevicePoint(history)),\n    offset: subtractPoint(point2, startDevicePoint(history)),\n    velocity: getVelocity2(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity2(history, timeDelta) {\n  if (history.length < 2) {\n    return { x: 0, y: 0 };\n  }\n  let i2 = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n  while (i2 >= 0) {\n    timestampedPoint = history[i2];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n    i2--;\n  }\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 };\n  }\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n  if (time === 0) {\n    return { x: 0, y: 0 };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\nfunction isNear(value, target = 0, maxDistance = 0.01) {\n  return distance(value, target) < maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n  delta.origin = origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))\n    delta.scale = 1;\n  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate) || isNaN(delta.translate))\n    delta.translate = 0;\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);\n  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n  calcRelativeAxis(target.x, relative.x, parent.x);\n  calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n  target.min = layout.min - parent.min;\n  target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n  calcRelativeAxisPosition(target.x, layout.x, parent.x);\n  calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs\nfunction applyConstraints(point2, { min, max }, elastic) {\n  if (min !== void 0 && point2 < min) {\n    point2 = elastic ? mix(min, point2, elastic.min) : Math.max(point2, min);\n  } else if (max !== void 0 && point2 > max) {\n    point2 = elastic ? mix(max, point2, elastic.max) : Math.min(point2, max);\n  }\n  return point2;\n}\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== void 0 ? axis.min + min : void 0,\n    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0\n  };\n}\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  let min = constraintsAxis.min - layoutAxis.min;\n  let max = constraintsAxis.max - layoutAxis.max;\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    [min, max] = [max, min];\n  }\n  return { min, max };\n}\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\nfunction calcOrigin2(source, target) {\n  let origin = 0.5;\n  const sourceLength = calcLength(source);\n  const targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n  return clamp2(0, 1, origin);\n}\nfunction rebaseAxisConstraints(layout, constraints) {\n  const relativeConstraints = {};\n  if (constraints.min !== void 0) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n  if (constraints.max !== void 0) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n  return relativeConstraints;\n}\nvar defaultElastic = 0.35;\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\nfunction resolvePointElastic(dragElastic, label) {\n  var _a;\n  return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/models.mjs\nvar createAxisDelta = () => ({\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n});\nvar createDelta = () => ({\n  x: createAxisDelta(),\n  y: createAxisDelta()\n});\nvar createAxis = () => ({ min: 0, max: 0 });\nvar createBox = () => ({\n  x: createAxis(),\n  y: createAxis()\n});\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs\nfunction eachAxis(callback) {\n  return [callback(\"x\"), callback(\"y\")];\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs\nfunction convertBoundingBoxToBox({ top, left, right, bottom }) {\n  return {\n    x: { min: left, max: right },\n    y: { min: top, max: bottom }\n  };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n  return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\nfunction transformBoxPoints(point2, transformPoint2) {\n  if (!transformPoint2)\n    return point2;\n  const topLeft = transformPoint2({ x: point2.left, y: point2.top });\n  const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs\nfunction isIdentityScale(scale2) {\n  return scale2 === void 0 || scale2 === 1;\n}\nfunction hasScale({ scale: scale2, scaleX, scaleY }) {\n  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);\n}\nfunction hasTransform(values) {\n  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;\n}\nfunction has2DTranslate(values) {\n  return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n  return value && value !== \"0%\";\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs\nfunction scalePoint(point2, scale2, originPoint) {\n  const distanceFromOrigin = point2 - originPoint;\n  const scaled = scale2 * distanceFromOrigin;\n  return originPoint + scaled;\n}\nfunction applyPointDelta(point2, translate, scale2, originPoint, boxScale) {\n  if (boxScale !== void 0) {\n    point2 = scalePoint(point2, boxScale, originPoint);\n  }\n  return scalePoint(point2, scale2, originPoint) + translate;\n}\nfunction applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {\n  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction applyBoxDelta(box, { x, y }) {\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n  var _a, _b;\n  const treeLength = treePath.length;\n  if (!treeLength)\n    return;\n  treeScale.x = treeScale.y = 1;\n  let node;\n  let delta;\n  for (let i2 = 0; i2 < treeLength; i2++) {\n    node = treePath[i2];\n    delta = node.projectionDelta;\n    if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === \"contents\")\n      continue;\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });\n    }\n    if (delta) {\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale;\n      applyBoxDelta(box, delta);\n    }\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n}\nfunction translateAxis(axis, distance2) {\n  axis.min = axis.min + distance2;\n  axis.max = axis.max + distance2;\n}\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\n  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;\n  const originPoint = mix(axis.min, axis.max, axisOrigin);\n  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform, xKeys);\n  transformAxis(box.y, transform, yKeys);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/measure.mjs\nfunction measureViewportBox(instance, transformPoint2) {\n  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));\n}\nfunction measurePageBox(element, rootProjectionNode2, transformPagePoint) {\n  const viewportBox = measureViewportBox(element, transformPagePoint);\n  const { scroll: scroll2 } = rootProjectionNode2;\n  if (scroll2) {\n    translateAxis(viewportBox.x, scroll2.x);\n    translateAxis(viewportBox.y, scroll2.y);\n  }\n  return viewportBox;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs\nvar elementDragControls = /* @__PURE__ */ new WeakMap();\nvar VisualElementDragControls = class {\n  constructor(visualElement) {\n    this.openGlobalLock = null;\n    this.isDragging = false;\n    this.currentDirection = null;\n    this.originPoint = { x: 0, y: 0 };\n    this.constraints = false;\n    this.hasMutatedConstraints = false;\n    this.elastic = createBox();\n    this.visualElement = visualElement;\n  }\n  start(originEvent, { snapToCursor = false } = {}) {\n    if (this.visualElement.isPresent === false)\n      return;\n    const onSessionStart = (event) => {\n      this.stopAnimation();\n      if (snapToCursor) {\n        this.snapToCursor(extractEventInfo(event, \"page\").point);\n      }\n    };\n    const onStart = (event, info) => {\n      var _a;\n      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();\n      if (drag2 && !dragPropagation) {\n        if (this.openGlobalLock)\n          this.openGlobalLock();\n        this.openGlobalLock = getGlobalLock(drag2);\n        if (!this.openGlobalLock)\n          return;\n      }\n      this.isDragging = true;\n      this.currentDirection = null;\n      this.resolveConstraints();\n      if (this.visualElement.projection) {\n        this.visualElement.projection.isAnimationBlocked = true;\n        this.visualElement.projection.target = void 0;\n      }\n      eachAxis((axis) => {\n        var _a2, _b;\n        let current = this.getAxisMotionValue(axis).get() || 0;\n        if (percent.test(current)) {\n          const measuredAxis = (_b = (_a2 = this.visualElement.projection) === null || _a2 === void 0 ? void 0 : _a2.layout) === null || _b === void 0 ? void 0 : _b.layoutBox[axis];\n          if (measuredAxis) {\n            const length = calcLength(measuredAxis);\n            current = length * (parseFloat(current) / 100);\n          }\n        }\n        this.originPoint[axis] = current;\n      });\n      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);\n      (_a = this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Drag, true);\n    };\n    const onMove = (event, info) => {\n      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();\n      if (!dragPropagation && !this.openGlobalLock)\n        return;\n      const { offset } = info;\n      if (dragDirectionLock && this.currentDirection === null) {\n        this.currentDirection = getCurrentDirection(offset);\n        if (this.currentDirection !== null) {\n          onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(this.currentDirection);\n        }\n        return;\n      }\n      this.updateAxis(\"x\", info.point, offset);\n      this.updateAxis(\"y\", info.point, offset);\n      this.visualElement.render();\n      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);\n    };\n    const onSessionEnd = (event, info) => this.stop(event, info);\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart,\n      onStart,\n      onMove,\n      onSessionEnd\n    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });\n  }\n  stop(event, info) {\n    const isDragging = this.isDragging;\n    this.cancel();\n    if (!isDragging)\n      return;\n    const { velocity } = info;\n    this.startAnimation(velocity);\n    const { onDragEnd } = this.getProps();\n    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n  }\n  cancel() {\n    var _a, _b;\n    this.isDragging = false;\n    if (this.visualElement.projection) {\n      this.visualElement.projection.isAnimationBlocked = false;\n    }\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = void 0;\n    const { dragPropagation } = this.getProps();\n    if (!dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n  }\n  updateAxis(axis, _point, offset) {\n    const { drag: drag2 } = this.getProps();\n    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))\n      return;\n    const axisValue = this.getAxisMotionValue(axis);\n    let next = this.originPoint[axis] + offset[axis];\n    if (this.constraints && this.constraints[axis]) {\n      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n    }\n    axisValue.set(next);\n  }\n  resolveConstraints() {\n    const { dragConstraints, dragElastic } = this.getProps();\n    const { layout } = this.visualElement.projection || {};\n    const prevConstraints = this.constraints;\n    if (dragConstraints && isRefObject(dragConstraints)) {\n      if (!this.constraints) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    } else {\n      if (dragConstraints && layout) {\n        this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n      } else {\n        this.constraints = false;\n      }\n    }\n    this.elastic = resolveDragElastic(dragElastic);\n    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {\n      eachAxis((axis) => {\n        if (this.getAxisMotionValue(axis)) {\n          this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n        }\n      });\n    }\n  }\n  resolveRefConstraints() {\n    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n    if (!constraints || !isRefObject(constraints))\n      return false;\n    const constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    const { projection } = this.visualElement;\n    if (!projection || !projection.layout)\n      return false;\n    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n    if (onMeasureDragConstraints) {\n      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n      this.hasMutatedConstraints = !!userConstraints;\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToBox(userConstraints);\n      }\n    }\n    return measuredConstraints;\n  }\n  startAnimation(velocity) {\n    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();\n    const constraints = this.constraints || {};\n    const momentumAnimations = eachAxis((axis) => {\n      var _a;\n      if (!shouldDrag(axis, drag2, this.currentDirection)) {\n        return;\n      }\n      let transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n      if (dragSnapToOrigin)\n        transition = { min: 0, max: 0 };\n      const bounceStiffness = dragElastic ? 200 : 1e6;\n      const bounceDamping = dragElastic ? 40 : 1e7;\n      const inertia2 = __spreadValues(__spreadValues({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness,\n        bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition);\n      return this.startAxisValueAnimation(axis, inertia2);\n    });\n    return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n  }\n  startAxisValueAnimation(axis, transition) {\n    const axisValue = this.getAxisMotionValue(axis);\n    return startAnimation(axis, axisValue, 0, transition);\n  }\n  stopAnimation() {\n    eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n  }\n  getAxisMotionValue(axis) {\n    var _a, _b;\n    const dragKey = \"_drag\" + axis.toUpperCase();\n    const externalMotionValue = this.visualElement.getProps()[dragKey];\n    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);\n  }\n  snapToCursor(point2) {\n    eachAxis((axis) => {\n      const { drag: drag2 } = this.getProps();\n      if (!shouldDrag(axis, drag2, this.currentDirection))\n        return;\n      const { projection } = this.visualElement;\n      const axisValue = this.getAxisMotionValue(axis);\n      if (projection && projection.layout) {\n        const { min, max } = projection.layout.layoutBox[axis];\n        axisValue.set(point2[axis] - mix(min, max, 0.5));\n      }\n    });\n  }\n  scalePositionWithinConstraints() {\n    var _a;\n    if (!this.visualElement.current)\n      return;\n    const { drag: drag2, dragConstraints } = this.getProps();\n    const { projection } = this.visualElement;\n    if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n      return;\n    this.stopAnimation();\n    const boxProgress = { x: 0, y: 0 };\n    eachAxis((axis) => {\n      const axisValue = this.getAxisMotionValue(axis);\n      if (axisValue) {\n        const latest = axisValue.get();\n        boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);\n      }\n    });\n    const { transformTemplate } = this.visualElement.getProps();\n    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n    (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n    projection.updateLayout();\n    this.resolveConstraints();\n    eachAxis((axis) => {\n      if (!shouldDrag(axis, drag2, null))\n        return;\n      const axisValue = this.getAxisMotionValue(axis);\n      const { min, max } = this.constraints[axis];\n      axisValue.set(mix(min, max, boxProgress[axis]));\n    });\n  }\n  addListeners() {\n    var _a;\n    if (!this.visualElement.current)\n      return;\n    elementDragControls.set(this.visualElement, this);\n    const element = this.visualElement.current;\n    const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\n      const { drag: drag2, dragListener = true } = this.getProps();\n      drag2 && dragListener && this.start(event);\n    });\n    const measureDragConstraints = () => {\n      const { dragConstraints } = this.getProps();\n      if (isRefObject(dragConstraints)) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    };\n    const { projection } = this.visualElement;\n    const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n    if (projection && !projection.layout) {\n      (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n      projection.updateLayout();\n    }\n    measureDragConstraints();\n    const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n    const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged }) => {\n      if (this.isDragging && hasLayoutChanged) {\n        eachAxis((axis) => {\n          const motionValue2 = this.getAxisMotionValue(axis);\n          if (!motionValue2)\n            return;\n          this.originPoint[axis] += delta[axis].translate;\n          motionValue2.set(motionValue2.get() + delta[axis].translate);\n        });\n        this.visualElement.render();\n      }\n    });\n    return () => {\n      stopResizeListener();\n      stopPointerListener();\n      stopMeasureLayoutListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n    };\n  }\n  getProps() {\n    const props = this.visualElement.getProps();\n    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;\n    return __spreadProps(__spreadValues({}, props), {\n      drag: drag2,\n      dragDirectionLock,\n      dragPropagation,\n      dragConstraints,\n      dragElastic,\n      dragMomentum\n    });\n  }\n};\nfunction shouldDrag(direction, drag2, currentDirection) {\n  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);\n}\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n  let direction = null;\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n  return direction;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs\nfunction useDrag(props) {\n  const { dragControls: groupDragControls, visualElement } = props;\n  const dragControls = useConstant(() => new VisualElementDragControls(visualElement));\n  (0, import_react24.useEffect)(() => groupDragControls && groupDragControls.subscribe(dragControls), [dragControls, groupDragControls]);\n  (0, import_react24.useEffect)(() => dragControls.addListeners(), [dragControls]);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-pan-gesture.mjs\nvar import_react25 = __webpack_require__(/*! react */ \"react\");\nfunction usePanGesture({ onPan, onPanStart, onPanEnd, onPanSessionStart, visualElement }) {\n  const hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  const panSession = (0, import_react25.useRef)(null);\n  const { transformPagePoint } = (0, import_react25.useContext)(MotionConfigContext);\n  const handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: (event, info) => {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  (0, import_react25.useEffect)(() => {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint\n    });\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(() => panSession.current && panSession.current.end());\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/drag.mjs\nvar drag = {\n  pan: makeRenderlessComponent(usePanGesture),\n  drag: makeRenderlessComponent(useDrag)\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs\nfunction isCSSVariable2(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n  const match = cssVariableRegex.exec(current);\n  if (!match)\n    return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n  const [token, fallback] = parseCSSVariable(current);\n  if (!token)\n    return;\n  const resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariable2(fallback)) {\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var target = __objRest(_a, []);\n  const element = visualElement.current;\n  if (!(element instanceof Element))\n    return { target, transitionEnd };\n  if (transitionEnd) {\n    transitionEnd = __spreadValues({}, transitionEnd);\n  }\n  visualElement.values.forEach((value) => {\n    const current = value.get();\n    if (!isCSSVariable2(current))\n      return;\n    const resolved = getVariableValue(current, element);\n    if (resolved)\n      value.set(resolved);\n  });\n  for (const key in target) {\n    const current = target[key];\n    if (!isCSSVariable2(current))\n      continue;\n    const resolved = getVariableValue(current, element);\n    if (!resolved)\n      continue;\n    target[key] = resolved;\n    if (transitionEnd && transitionEnd[key] === void 0) {\n      transitionEnd[key] = current;\n    }\n  }\n  return { target, transitionEnd };\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs\nvar positionalKeys = /* @__PURE__ */ new Set([\n  \"width\",\n  \"height\",\n  \"top\",\n  \"left\",\n  \"right\",\n  \"bottom\",\n  \"x\",\n  \"y\"\n]);\nvar isPositionalKey = (key) => positionalKeys.has(key);\nvar hasPositionalKey = (target) => {\n  return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = (value, to) => {\n  value.set(to, false);\n  value.set(to);\n};\nvar isNumOrPxType = (v) => v === number || v === px;\nvar BoundingBoxDimension;\n(function(BoundingBoxDimension2) {\n  BoundingBoxDimension2[\"width\"] = \"width\";\n  BoundingBoxDimension2[\"height\"] = \"height\";\n  BoundingBoxDimension2[\"left\"] = \"left\";\n  BoundingBoxDimension2[\"right\"] = \"right\";\n  BoundingBoxDimension2[\"top\"] = \"top\";\n  BoundingBoxDimension2[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nvar getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n  if (transform === \"none\" || !transform)\n    return 0;\n  const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n  if (matrix3d) {\n    return getPosFromMatrix(matrix3d[1], pos3);\n  } else {\n    const matrix = transform.match(/^matrix\\((.+)\\)$/);\n    if (matrix) {\n      return getPosFromMatrix(matrix[1], pos2);\n    } else {\n      return 0;\n    }\n  }\n};\nvar transformKeys = /* @__PURE__ */ new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n  const removedTransforms = [];\n  nonTranslationalTransformKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    if (value !== void 0) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  if (removedTransforms.length)\n    visualElement.render();\n  return removedTransforms;\n}\nvar positionalValues = {\n  width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n  height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n  top: (_bbox, { top }) => parseFloat(top),\n  left: (_bbox, { left }) => parseFloat(left),\n  bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n  right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\nvar convertChangedValueTypes = (target, visualElement, changedKeys) => {\n  const originBbox = visualElement.measureViewportBox();\n  const element = visualElement.current;\n  const elementComputedStyle = getComputedStyle(element);\n  const { display } = elementComputedStyle;\n  const origin = {};\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  changedKeys.forEach((key) => {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  });\n  visualElement.render();\n  const targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    setAndResetVelocity(value, origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\nvar checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\n  target = __spreadValues({}, target);\n  transitionEnd = __spreadValues({}, transitionEnd);\n  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n  let removedTransformValues = [];\n  let hasAttemptedToRemoveTransformValues = false;\n  const changedValueTypeKeys = [];\n  targetPositionalKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key))\n      return;\n    let from = origin[key];\n    let fromType = findDimensionValueType(from);\n    const to = target[key];\n    let toType;\n    if (isKeyframesTarget(to)) {\n      const numKeyframes = to.length;\n      const fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n      for (let i2 = fromIndex; i2 < numKeyframes; i2++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i2]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i2]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n    if (fromType !== toType) {\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        const current = value.get();\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n  if (changedValueTypeKeys.length) {\n    const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(([key, value]) => {\n        visualElement.getValue(key).set(value);\n      });\n    }\n    visualElement.render();\n    if (isBrowser && scrollY !== null) {\n      window.scrollTo({ top: scrollY });\n    }\n    return { target: convertedTarget, transitionEnd };\n  } else {\n    return { target, transitionEnd };\n  }\n};\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs\nvar parseDomVariant = (visualElement, target, origin, transitionEnd) => {\n  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\n// ../../node_modules/framer-motion/dist/es/render/VisualElement.mjs\nvar import_react26 = __webpack_require__(/*! react */ \"react\");\n\n// ../../node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs\nvar prefersReducedMotion = { current: null };\nvar hasReducedMotionListener = { current: false };\n\n// ../../node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs\nfunction initPrefersReducedMotion() {\n  hasReducedMotionListener.current = true;\n  if (!isBrowser)\n    return;\n  if (window.matchMedia) {\n    const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;\n    motionMediaQuery.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.current = false;\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/motion-values.mjs\nfunction updateMotionValuesFromProps(element, next, prev) {\n  const { willChange } = next;\n  for (const key in next) {\n    const nextValue = next[key];\n    const prevValue = prev[key];\n    if (isMotionValue(nextValue)) {\n      element.addValue(key, nextValue);\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.add(key);\n      }\n      if (true) {\n        warnOnce(nextValue.version === \"7.6.7\", `Attempting to mix Framer Motion versions ${nextValue.version} with 7.6.7 may not work as expected.`);\n      }\n    } else if (isMotionValue(prevValue)) {\n      element.addValue(key, motionValue(nextValue));\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.remove(key);\n      }\n    } else if (prevValue !== nextValue) {\n      if (element.hasValue(key)) {\n        const existingValue = element.getValue(key);\n        !existingValue.hasAnimated && existingValue.set(nextValue);\n      } else {\n        const latestValue = element.getStaticValue(key);\n        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue));\n      }\n    }\n  }\n  for (const key in prev) {\n    if (next[key] === void 0)\n      element.removeValue(key);\n  }\n  return next;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/VisualElement.mjs\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\nvar propEventHandlers = [\n  \"AnimationStart\",\n  \"AnimationComplete\",\n  \"Update\",\n  \"Unmount\",\n  \"BeforeLayoutMeasure\",\n  \"LayoutMeasure\",\n  \"LayoutAnimationStart\",\n  \"LayoutAnimationComplete\"\n];\nvar VisualElement = class {\n  constructor({ parent, props, reducedMotionConfig, visualState }, options = {}) {\n    this.current = null;\n    this.children = /* @__PURE__ */ new Set();\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    this.shouldReduceMotion = null;\n    this.values = /* @__PURE__ */ new Map();\n    this.isPresent = true;\n    this.valueSubscriptions = /* @__PURE__ */ new Map();\n    this.prevMotionValues = {};\n    this.events = {};\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n    this.render = () => {\n      if (!this.current)\n        return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n    this.scheduleRender = () => es_default.render(this.render, false, true);\n    const { latestValues, renderState } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = __spreadValues({}, latestValues);\n    this.initialValues = props.initial ? __spreadValues({}, latestValues) : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.options = options;\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n    if (this.isVariantNode) {\n      this.variantChildren = /* @__PURE__ */ new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    const _a = this.scrapeMotionValuesFromProps(props), { willChange } = _a, initialMotionValues = __objRest(_a, [\"willChange\"]);\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n      if (latestValues[key] !== void 0 && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n        if (isWillChangeMotionValue(willChange)) {\n          willChange.add(key);\n        }\n      }\n    }\n  }\n  scrapeMotionValuesFromProps(_props) {\n    return {};\n  }\n  mount(instance) {\n    var _a;\n    this.current = instance;\n    if (this.projection) {\n      this.projection.mount(instance);\n    }\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.addVariantChild(this);\n    }\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    if (!hasReducedMotionListener.current) {\n      initPrefersReducedMotion();\n    }\n    this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? false : this.reducedMotionConfig === \"always\" ? true : prefersReducedMotion.current;\n    if (this.parent)\n      this.parent.children.add(this);\n    this.setProps(this.props);\n  }\n  unmount() {\n    var _a, _b, _c;\n    (_a = this.projection) === null || _a === void 0 ? void 0 : _a.unmount();\n    cancelSync.update(this.notifyUpdate);\n    cancelSync.render(this.render);\n    this.valueSubscriptions.forEach((remove) => remove());\n    (_b = this.removeFromVariantTree) === null || _b === void 0 ? void 0 : _b.call(this);\n    (_c = this.parent) === null || _c === void 0 ? void 0 : _c.children.delete(this);\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n    this.current = null;\n  }\n  bindToMotionValue(key, value) {\n    const removeOnChange = value.onChange((latestValue) => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && es_default.update(this.notifyUpdate, false, true);\n    });\n    const removeOnRenderRequest = value.onRenderRequest(this.scheduleRender);\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      removeOnRenderRequest();\n    });\n  }\n  sortNodePosition(other) {\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type)\n      return 0;\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n  loadFeatures(renderedProps, isStrict, preloadedFeatures, projectionId, ProjectionNodeConstructor, initialLayoutGroupConfig) {\n    const features = [];\n    if (env !== \"production\" && preloadedFeatures && isStrict) {\n      invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n    }\n    for (let i2 = 0; i2 < numFeatures; i2++) {\n      const name = featureNames[i2];\n      const { isEnabled, Component } = featureDefinitions[name];\n      if (isEnabled(renderedProps) && Component) {\n        features.push((0, import_react26.createElement)(Component, __spreadProps(__spreadValues({\n          key: name\n        }, renderedProps), {\n          visualElement: this\n        })));\n      }\n    }\n    if (!this.projection && ProjectionNodeConstructor) {\n      this.projection = new ProjectionNodeConstructor(projectionId, this.latestValues, this.parent && this.parent.projection);\n      const { layoutId, layout, drag: drag2, dragConstraints, layoutScroll } = renderedProps;\n      this.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),\n        visualElement: this,\n        scheduleRender: () => this.scheduleRender(),\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig: initialLayoutGroupConfig,\n        layoutScroll\n      });\n    }\n    return features;\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.options, this.props);\n  }\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  makeTargetAnimatable(target, canMutate = true) {\n    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);\n  }\n  setProps(props) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n    this.props = props;\n    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {\n      const key = propEventHandlers[i2];\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n      const listener = props[\"on\" + key];\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props), this.prevMotionValues);\n  }\n  getProps() {\n    return this.props;\n  }\n  getVariant(name) {\n    var _a;\n    return (_a = this.props.variants) === null || _a === void 0 ? void 0 : _a[name];\n  }\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    var _a;\n    return this.isVariantNode ? this : (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getClosestVariantNode();\n  }\n  getVariantContext(startAtParent = false) {\n    var _a, _b;\n    if (startAtParent)\n      return (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getVariantContext();\n    if (!this.isControllingVariants) {\n      const context2 = ((_b = this.parent) === null || _b === void 0 ? void 0 : _b.getVariantContext()) || {};\n      if (this.props.initial !== void 0) {\n        context2.initial = this.props.initial;\n      }\n      return context2;\n    }\n    const context = {};\n    for (let i2 = 0; i2 < numVariantProps; i2++) {\n      const name = variantProps2[i2];\n      const prop = this.props[name];\n      if (isVariantLabel(prop) || prop === false) {\n        context[name] = prop;\n      }\n    }\n    return context;\n  }\n  addVariantChild(child) {\n    var _a;\n    const closestVariantNode = this.getClosestVariantNode();\n    if (closestVariantNode) {\n      (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  addValue(key, value) {\n    if (this.hasValue(key))\n      this.removeValue(key);\n    this.values.set(key, value);\n    this.latestValues[key] = value.get();\n    this.bindToMotionValue(key, value);\n  }\n  removeValue(key) {\n    var _a;\n    this.values.delete(key);\n    (_a = this.valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n    this.valueSubscriptions.delete(key);\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  hasValue(key) {\n    return this.values.has(key);\n  }\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n    let value = this.values.get(key);\n    if (value === void 0 && defaultValue !== void 0) {\n      value = motionValue(defaultValue);\n      this.addValue(key, value);\n    }\n    return value;\n  }\n  readValue(key) {\n    return this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.readValueFromInstance(this.current, key, this.options);\n  }\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  getBaseTarget(key) {\n    var _a;\n    const { initial } = this.props;\n    const valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : void 0;\n    if (initial && valueFromInitial !== void 0) {\n      return valueFromInitial;\n    }\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== void 0 && !isMotionValue(target))\n      return target;\n    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    return this.events[eventName].add(callback);\n  }\n  notify(eventName, ...args) {\n    var _a;\n    (_a = this.events[eventName]) === null || _a === void 0 ? void 0 : _a.notify(...args);\n  }\n};\nvar variantProps2 = [\"initial\", ...variantPriorityOrder];\nvar numVariantProps = variantProps2.length;\n\n// ../../node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs\nvar DOMVisualElement = class extends VisualElement {\n  sortInstanceNodePosition(a2, b2) {\n    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;\n  }\n  getBaseTargetFromProps(props, key) {\n    var _a;\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  }\n  removeValueFromRenderState(key, { vars, style }) {\n    delete vars[key];\n    delete style[key];\n  }\n  makeTargetAnimatableFromInstance(_a, { transformValues }, isMounted) {\n    var _b = _a, { transition, transitionEnd } = _b, target = __objRest(_b, [\"transition\", \"transitionEnd\"]);\n    let origin = getOrigin(target, transition || {}, this);\n    if (transformValues) {\n      if (transitionEnd)\n        transitionEnd = transformValues(transitionEnd);\n      if (target)\n        target = transformValues(target);\n      if (origin)\n        origin = transformValues(origin);\n    }\n    if (isMounted) {\n      checkTargetForNewValues(this, target, origin);\n      const parsed = parseDomVariant(this, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n    return __spreadValues({\n      transition,\n      transitionEnd\n    }, target);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs\nfunction getComputedStyle2(element) {\n  return window.getComputedStyle(element);\n}\nvar HTMLVisualElement = class extends DOMVisualElement {\n  readValueFromInstance(instance, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle2(instance);\n      const value = (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  }\n  measureInstanceViewportBox(instance, { transformPagePoint }) {\n    return measureViewportBox(instance, transformPagePoint);\n  }\n  build(renderState, latestValues, options, props) {\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  }\n  scrapeMotionValuesFromProps(props) {\n    return scrapeMotionValuesFromProps(props);\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderHTML(instance, renderState, styleProp, projection);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs\nvar SVGVisualElement = class extends DOMVisualElement {\n  getBaseTargetFromProps(props, key) {\n    return props[key];\n  }\n  readValueFromInstance(instance, key) {\n    var _a;\n    if (transformProps.has(key)) {\n      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n    }\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return instance.getAttribute(key);\n  }\n  measureInstanceViewportBox() {\n    return createBox();\n  }\n  scrapeMotionValuesFromProps(props) {\n    return scrapeMotionValuesFromProps2(props);\n  }\n  build(renderState, latestValues, options, props) {\n    buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderSVG(instance, renderState, styleProp, projection);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs\nvar createDomVisualElement = (Component, options) => {\n  return isSVGComponent(Component) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\nvar import_react27 = __toESM(__webpack_require__(/*! react */ \"react\"), 1);\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs\nfunction pixelsToPercent(pixels, axis) {\n  if (axis.max === axis.min)\n    return 0;\n  return pixels / (axis.max - axis.min) * 100;\n}\nvar correctBorderRadius = {\n  correct: (latest, node) => {\n    if (!node.target)\n      return latest;\n    if (typeof latest === \"string\") {\n      if (px.test(latest)) {\n        latest = parseFloat(latest);\n      } else {\n        return latest;\n      }\n    }\n    const x = pixelsToPercent(latest, node.target.x);\n    const y = pixelsToPercent(latest, node.target.y);\n    return `${x}% ${y}%`;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs\nvar varToken = \"_$css\";\nvar correctBoxShadow = {\n  correct: (latest, { treeScale, projectionDelta }) => {\n    const original = latest;\n    const containsCSSVariables = latest.includes(\"var(\");\n    const cssVariables = [];\n    if (containsCSSVariables) {\n      latest = latest.replace(cssVariableRegex, (match) => {\n        cssVariables.push(match);\n        return varToken;\n      });\n    }\n    const shadow = complex.parse(latest);\n    if (shadow.length > 5)\n      return original;\n    const template = complex.createTransformer(latest);\n    const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    const xScale = projectionDelta.x.scale * treeScale.x;\n    const yScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    const averageScale = mix(xScale, yScale, 0.5);\n    if (typeof shadow[2 + offset] === \"number\")\n      shadow[2 + offset] /= averageScale;\n    if (typeof shadow[3 + offset] === \"number\")\n      shadow[3 + offset] /= averageScale;\n    let output = template(shadow);\n    if (containsCSSVariables) {\n      let i2 = 0;\n      output = output.replace(varToken, () => {\n        const cssVariable = cssVariables[i2];\n        i2++;\n        return cssVariable;\n      });\n    }\n    return output;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\nvar MeasureLayoutWithContext = class extends import_react27.default.Component {\n  componentDidMount() {\n    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n    const { projection } = visualElement;\n    addScaleCorrector(defaultScaleCorrectors);\n    if (projection) {\n      if (layoutGroup.group)\n        layoutGroup.group.add(projection);\n      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n      projection.root.didUpdate();\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions(__spreadProps(__spreadValues({}, projection.options), {\n        onExitComplete: () => this.safeToRemove()\n      }));\n    }\n    globalProjectionState.hasEverUpdated = true;\n  }\n  getSnapshotBeforeUpdate(prevProps) {\n    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;\n    const projection = visualElement.projection;\n    if (!projection)\n      return null;\n    projection.isPresent = isPresent;\n    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        es_default.postRender(() => {\n          var _a;\n          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n    return null;\n  }\n  componentDidUpdate() {\n    const { projection } = this.props.visualElement;\n    if (projection) {\n      projection.root.didUpdate();\n      if (!projection.currentAnimation && projection.isLead()) {\n        this.safeToRemove();\n      }\n    }\n  }\n  componentWillUnmount() {\n    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;\n    const { projection } = visualElement;\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\n        layoutGroup.group.remove(projection);\n      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)\n        promoteContext.deregister(projection);\n    }\n  }\n  safeToRemove() {\n    const { safeToRemove } = this.props;\n    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n  }\n  render() {\n    return null;\n  }\n};\nfunction MeasureLayout(props) {\n  const [isPresent, safeToRemove] = usePresence();\n  const layoutGroup = (0, import_react27.useContext)(LayoutGroupContext);\n  return import_react27.default.createElement(MeasureLayoutWithContext, __spreadProps(__spreadValues({}, props), { layoutGroup, switchLayoutGroup: (0, import_react27.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove }));\n}\nvar defaultScaleCorrectors = {\n  borderRadius: __spreadProps(__spreadValues({}, correctBorderRadius), {\n    applyTo: [\n      \"borderTopLeftRadius\",\n      \"borderTopRightRadius\",\n      \"borderBottomLeftRadius\",\n      \"borderBottomRightRadius\"\n    ]\n  }),\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/index.mjs\nvar layoutFeatures = {\n  measureLayout: MeasureLayout\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/animate.mjs\nfunction animate2(from, to, transition = {}) {\n  const value = isMotionValue(from) ? from : motionValue(from);\n  startAnimation(\"\", value, to, transition);\n  return {\n    stop: () => value.stop(),\n    isAnimating: () => value.isAnimating()\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nvar asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nvar isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress3, shouldCrossfadeOpacity, isOnlyMember) {\n  var _a, _b, _c, _d;\n  if (shouldCrossfadeOpacity) {\n    target.opacity = mix(\n      0,\n      (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1,\n      easeCrossfadeIn(progress3)\n    );\n    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress3));\n  } else if (isOnlyMember) {\n    target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress3);\n  }\n  for (let i2 = 0; i2 < numBorders; i2++) {\n    const borderLabel = `border${borders[i2]}Radius`;\n    let followRadius = getRadius(follow, borderLabel);\n    let leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === void 0 && leadRadius === void 0)\n      continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n    if (canMix) {\n      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress3), 0);\n      if (percent.test(leadRadius) || percent.test(followRadius)) {\n        target[borderLabel] += \"%\";\n      }\n    } else {\n      target[borderLabel] = leadRadius;\n    }\n  }\n  if (follow.rotate || lead.rotate) {\n    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress3);\n  }\n}\nfunction getRadius(values, radiusName) {\n  var _a;\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n  return (p2) => {\n    if (p2 < min)\n      return 0;\n    if (p2 > max)\n      return 1;\n    return easing(progress(min, max, p2));\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/copy.mjs\nfunction copyAxisInto(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\nfunction copyBoxInto(box, originBox) {\n  copyAxisInto(box.x, originBox.x);\n  copyAxisInto(box.y, originBox.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs\nfunction removePointDelta(point2, translate, scale2, originPoint, boxScale) {\n  point2 -= translate;\n  point2 = scalePoint(point2, 1 / scale2, originPoint);\n  if (boxScale !== void 0) {\n    point2 = scalePoint(point2, 1 / boxScale, originPoint);\n  }\n  return point2;\n}\nfunction removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n  if (percent.test(translate)) {\n    translate = parseFloat(translate);\n    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);\n    translate = relativeProgress - sourceAxis.min;\n  }\n  if (typeof translate !== \"number\")\n    return;\n  let originPoint = mix(originAxis.min, originAxis.max, origin);\n  if (axis === originAxis)\n    originPoint -= translate;\n  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\nvar xKeys2 = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys2 = [\"y\", \"scaleY\", \"originY\"];\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n  removeAxisTransforms(box.x, transforms, xKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);\n  removeAxisTransforms(box.y, transforms, yKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/utils.mjs\nfunction isAxisDeltaZero(delta) {\n  return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction boxEquals(a2, b2) {\n  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;\n}\nfunction aspectRatio(box) {\n  return calcLength(box.x) / calcLength(box.y);\n}\nfunction isCloseTo(a2, b2, max = 0.1) {\n  return distance(a2, b2) <= max;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/shared/stack.mjs\nvar NodeStack = class {\n  constructor() {\n    this.members = [];\n  }\n  add(node) {\n    addUniqueItem(this.members, node);\n    node.scheduleRender();\n  }\n  remove(node) {\n    removeItem(this.members, node);\n    if (node === this.prevLead) {\n      this.prevLead = void 0;\n    }\n    if (node === this.lead) {\n      const prevLead = this.members[this.members.length - 1];\n      if (prevLead) {\n        this.promote(prevLead);\n      }\n    }\n  }\n  relegate(node) {\n    const indexOfNode = this.members.findIndex((member) => node === member);\n    if (indexOfNode === 0)\n      return false;\n    let prevLead;\n    for (let i2 = indexOfNode; i2 >= 0; i2--) {\n      const member = this.members[i2];\n      if (member.isPresent !== false) {\n        prevLead = member;\n        break;\n      }\n    }\n    if (prevLead) {\n      this.promote(prevLead);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  promote(node, preserveFollowOpacity) {\n    var _a;\n    const prevLead = this.lead;\n    if (node === prevLead)\n      return;\n    this.prevLead = prevLead;\n    this.lead = node;\n    node.show();\n    if (prevLead) {\n      prevLead.instance && prevLead.scheduleRender();\n      node.scheduleRender();\n      node.resumeFrom = prevLead;\n      if (preserveFollowOpacity) {\n        node.resumeFrom.preserveOpacity = true;\n      }\n      if (prevLead.snapshot) {\n        node.snapshot = prevLead.snapshot;\n        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;\n        node.snapshot.isShared = true;\n      }\n      if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {\n        node.isLayoutDirty = true;\n      }\n      const { crossfade } = node.options;\n      if (crossfade === false) {\n        prevLead.hide();\n      }\n    }\n  }\n  exitAnimationComplete() {\n    this.members.forEach((node) => {\n      var _a, _b, _c, _d, _e;\n      (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n      (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);\n    });\n  }\n  scheduleRender() {\n    this.members.forEach((node) => {\n      node.instance && node.scheduleRender(false);\n    });\n  }\n  removeLeadSnapshot() {\n    if (this.lead && this.lead.snapshot) {\n      this.lead.snapshot = void 0;\n    }\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/transform.mjs\nvar identityProjection = \"translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)\";\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n  const xTranslate = delta.x.translate / treeScale.x;\n  const yTranslate = delta.y.translate / treeScale.y;\n  let transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;\n  transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n  if (latestTransform) {\n    const { rotate, rotateX, rotateY } = latestTransform;\n    if (rotate)\n      transform += `rotate(${rotate}deg) `;\n    if (rotateX)\n      transform += `rotateX(${rotateX}deg) `;\n    if (rotateY)\n      transform += `rotateY(${rotateY}deg) `;\n  }\n  const elementScaleX = delta.x.scale * treeScale.x;\n  const elementScaleY = delta.y.scale * treeScale.y;\n  transform += `scale(${elementScaleX}, ${elementScaleY})`;\n  return transform === identityProjection ? \"none\" : transform;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs\nvar compareByDepth = (a2, b2) => a2.depth - b2.depth;\n\n// ../../node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs\nvar FlatTree = class {\n  constructor() {\n    this.children = [];\n    this.isDirty = false;\n  }\n  add(child) {\n    addUniqueItem(this.children, child);\n    this.isDirty = true;\n  }\n  remove(child) {\n    removeItem(this.children, child);\n    this.isDirty = true;\n  }\n  forEach(callback) {\n    this.isDirty && this.children.sort(compareByDepth);\n    this.isDirty = false;\n    this.children.forEach(callback);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\nvar animationTarget = 1e3;\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {\n  return class ProjectionNode {\n    constructor(elementId, latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\n      this.children = /* @__PURE__ */ new Set();\n      this.options = {};\n      this.isTreeAnimating = false;\n      this.isAnimationBlocked = false;\n      this.isLayoutDirty = false;\n      this.updateManuallyBlocked = false;\n      this.updateBlockedByResize = false;\n      this.isUpdating = false;\n      this.isSVG = false;\n      this.needsReset = false;\n      this.shouldResetTransform = false;\n      this.treeScale = { x: 1, y: 1 };\n      this.eventHandlers = /* @__PURE__ */ new Map();\n      this.potentialNodes = /* @__PURE__ */ new Map();\n      this.checkUpdateFailed = () => {\n        if (this.isUpdating) {\n          this.isUpdating = false;\n          this.clearAllSnapshots();\n        }\n      };\n      this.updateProjection = () => {\n        this.nodes.forEach(resolveTargetDelta);\n        this.nodes.forEach(calcProjection);\n      };\n      this.hasProjected = false;\n      this.isVisible = true;\n      this.animationProgress = 0;\n      this.sharedNodes = /* @__PURE__ */ new Map();\n      this.elementId = elementId;\n      this.latestValues = latestValues;\n      this.root = parent ? parent.root || parent : this;\n      this.path = parent ? [...parent.path, parent] : [];\n      this.parent = parent;\n      this.depth = parent ? parent.depth + 1 : 0;\n      elementId && this.root.registerPotentialNode(elementId, this);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        this.path[i2].shouldResetTransform = true;\n      }\n      if (this.root === this)\n        this.nodes = new FlatTree();\n    }\n    addEventListener(name, handler) {\n      if (!this.eventHandlers.has(name)) {\n        this.eventHandlers.set(name, new SubscriptionManager());\n      }\n      return this.eventHandlers.get(name).add(handler);\n    }\n    notifyListeners(name, ...args) {\n      const subscriptionManager = this.eventHandlers.get(name);\n      subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify(...args);\n    }\n    hasListeners(name) {\n      return this.eventHandlers.has(name);\n    }\n    registerPotentialNode(id2, node) {\n      this.potentialNodes.set(id2, node);\n    }\n    mount(instance, isLayoutDirty = false) {\n      var _a;\n      if (this.instance)\n        return;\n      this.isSVG = instance instanceof SVGElement && instance.tagName !== \"svg\";\n      this.instance = instance;\n      const { layoutId, layout, visualElement } = this.options;\n      if (visualElement && !visualElement.current) {\n        visualElement.mount(instance);\n      }\n      this.root.nodes.add(this);\n      (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);\n      this.elementId && this.root.potentialNodes.delete(this.elementId);\n      if (isLayoutDirty && (layout || layoutId)) {\n        this.isLayoutDirty = true;\n      }\n      if (attachResizeListener) {\n        let cancelDelay;\n        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;\n        attachResizeListener(instance, () => {\n          this.root.updateBlockedByResize = true;\n          cancelDelay && cancelDelay();\n          cancelDelay = delay(resizeUnblockUpdate, 250);\n          if (globalProjectionState.hasAnimatedSinceResize) {\n            globalProjectionState.hasAnimatedSinceResize = false;\n            this.nodes.forEach(finishAnimation);\n          }\n        });\n      }\n      if (layoutId) {\n        this.root.registerSharedNode(layoutId, this);\n      }\n      if (this.options.animate !== false && visualElement && (layoutId || layout)) {\n        this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {\n          var _a2, _b, _c, _d, _e;\n          if (this.isTreeAnimationBlocked()) {\n            this.target = void 0;\n            this.relativeTarget = void 0;\n            return;\n          }\n          const layoutTransition = (_b = (_a2 = this.options.transition) !== null && _a2 !== void 0 ? _a2 : visualElement.getDefaultTransition()) !== null && _b !== void 0 ? _b : defaultLayoutTransition;\n          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();\n          const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;\n          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n          if (((_c = this.resumeFrom) === null || _c === void 0 ? void 0 : _c.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {\n            if (this.resumeFrom) {\n              this.resumingFrom = this.resumeFrom;\n              this.resumingFrom.resumingFrom = void 0;\n            }\n            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n            const animationOptions = __spreadProps(__spreadValues({}, getValueTransition(layoutTransition, \"layout\")), {\n              onPlay: onLayoutAnimationStart,\n              onComplete: onLayoutAnimationComplete\n            });\n            if (visualElement.shouldReduceMotion) {\n              animationOptions.delay = 0;\n              animationOptions.type = false;\n            }\n            this.startAnimation(animationOptions);\n          } else {\n            if (!hasLayoutChanged && this.animationProgress === 0) {\n              finishAnimation(this);\n            }\n            this.isLead() && ((_e = (_d = this.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d));\n          }\n          this.targetLayout = newLayout;\n        });\n      }\n    }\n    unmount() {\n      var _a, _b;\n      this.options.layoutId && this.willUpdate();\n      this.root.nodes.remove(this);\n      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);\n      (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);\n      this.instance = void 0;\n      cancelSync.preRender(this.updateProjection);\n    }\n    blockUpdate() {\n      this.updateManuallyBlocked = true;\n    }\n    unblockUpdate() {\n      this.updateManuallyBlocked = false;\n    }\n    isUpdateBlocked() {\n      return this.updateManuallyBlocked || this.updateBlockedByResize;\n    }\n    isTreeAnimationBlocked() {\n      var _a;\n      return this.isAnimationBlocked || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) || false;\n    }\n    startUpdate() {\n      var _a;\n      if (this.isUpdateBlocked())\n        return;\n      this.isUpdating = true;\n      (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);\n    }\n    willUpdate(shouldNotifyListeners = true) {\n      var _a, _b, _c;\n      if (this.root.isUpdateBlocked()) {\n        (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n        return;\n      }\n      !this.root.isUpdating && this.root.startUpdate();\n      if (this.isLayoutDirty)\n        return;\n      this.isLayoutDirty = true;\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        node.shouldResetTransform = true;\n        node.updateScroll();\n      }\n      const { layoutId, layout } = this.options;\n      if (layoutId === void 0 && !layout)\n        return;\n      const transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;\n      this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n      this.updateSnapshot();\n      shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n    }\n    didUpdate() {\n      const updateWasBlocked = this.isUpdateBlocked();\n      if (updateWasBlocked) {\n        this.unblockUpdate();\n        this.clearAllSnapshots();\n        this.nodes.forEach(clearMeasurements);\n        return;\n      }\n      if (!this.isUpdating)\n        return;\n      this.isUpdating = false;\n      if (this.potentialNodes.size) {\n        this.potentialNodes.forEach(mountNodeEarly);\n        this.potentialNodes.clear();\n      }\n      this.nodes.forEach(resetTransformStyle);\n      this.nodes.forEach(updateLayout);\n      this.nodes.forEach(notifyLayoutUpdate);\n      this.clearAllSnapshots();\n      flushSync.update();\n      flushSync.preRender();\n      flushSync.render();\n    }\n    clearAllSnapshots() {\n      this.nodes.forEach(clearSnapshot);\n      this.sharedNodes.forEach(removeLeadSnapshots);\n    }\n    scheduleUpdateProjection() {\n      es_default.preRender(this.updateProjection, false, true);\n    }\n    scheduleCheckAfterUnmount() {\n      es_default.postRender(() => {\n        if (this.isLayoutDirty) {\n          this.root.didUpdate();\n        } else {\n          this.root.checkUpdateFailed();\n        }\n      });\n    }\n    updateSnapshot() {\n      if (this.snapshot || !this.instance)\n        return;\n      this.snapshot = this.measure();\n    }\n    updateLayout() {\n      var _a;\n      if (!this.instance)\n        return;\n      this.updateScroll();\n      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {\n        return;\n      }\n      if (this.resumeFrom && !this.resumeFrom.instance) {\n        for (let i2 = 0; i2 < this.path.length; i2++) {\n          const node = this.path[i2];\n          node.updateScroll();\n        }\n      }\n      const prevLayout = this.layout;\n      this.layout = this.measure(false);\n      this.layoutCorrected = createBox();\n      this.isLayoutDirty = false;\n      this.projectionDelta = void 0;\n      this.notifyListeners(\"measure\", this.layout.layoutBox);\n      (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.layoutBox);\n    }\n    updateScroll() {\n      if (this.options.layoutScroll && this.instance) {\n        this.isScrollRoot = checkIsScrollRoot(this.instance);\n        this.scroll = measureScroll(this.instance);\n      }\n    }\n    resetTransform() {\n      var _a;\n      if (!resetTransform)\n        return;\n      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;\n      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n      const transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n      const transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {\n        resetTransform(this.instance, transformTemplateValue);\n        this.shouldResetTransform = false;\n        this.scheduleRender();\n      }\n    }\n    measure(removeTransform = true) {\n      const pageBox = this.measurePageBox();\n      let layoutBox = this.removeElementScroll(pageBox);\n      if (removeTransform) {\n        layoutBox = this.removeTransform(layoutBox);\n      }\n      roundBox(layoutBox);\n      return {\n        measuredBox: pageBox,\n        layoutBox,\n        latestValues: {}\n      };\n    }\n    measurePageBox() {\n      const { visualElement } = this.options;\n      if (!visualElement)\n        return createBox();\n      const box = visualElement.measureViewportBox();\n      const { scroll: scroll2 } = this.root;\n      if (scroll2) {\n        translateAxis(box.x, scroll2.x);\n        translateAxis(box.y, scroll2.y);\n      }\n      return box;\n    }\n    removeElementScroll(box) {\n      const boxWithoutScroll = createBox();\n      copyBoxInto(boxWithoutScroll, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        const { scroll: scroll2, options, isScrollRoot } = node;\n        if (node !== this.root && scroll2 && options.layoutScroll) {\n          if (isScrollRoot) {\n            copyBoxInto(boxWithoutScroll, box);\n            const { scroll: rootScroll } = this.root;\n            if (rootScroll) {\n              translateAxis(boxWithoutScroll.x, -rootScroll.x);\n              translateAxis(boxWithoutScroll.y, -rootScroll.y);\n            }\n          }\n          translateAxis(boxWithoutScroll.x, scroll2.x);\n          translateAxis(boxWithoutScroll.y, scroll2.y);\n        }\n      }\n      return boxWithoutScroll;\n    }\n    applyTransform(box, transformOnly = false) {\n      const withTransforms = createBox();\n      copyBoxInto(withTransforms, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {\n          transformBox(withTransforms, {\n            x: -node.scroll.x,\n            y: -node.scroll.y\n          });\n        }\n        if (!hasTransform(node.latestValues))\n          continue;\n        transformBox(withTransforms, node.latestValues);\n      }\n      if (hasTransform(this.latestValues)) {\n        transformBox(withTransforms, this.latestValues);\n      }\n      return withTransforms;\n    }\n    removeTransform(box) {\n      var _a;\n      const boxWithoutTransform = createBox();\n      copyBoxInto(boxWithoutTransform, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        if (!node.instance)\n          continue;\n        if (!hasTransform(node.latestValues))\n          continue;\n        hasScale(node.latestValues) && node.updateSnapshot();\n        const sourceBox = createBox();\n        const nodeBox = node.measurePageBox();\n        copyBoxInto(sourceBox, nodeBox);\n        removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layoutBox, sourceBox);\n      }\n      if (hasTransform(this.latestValues)) {\n        removeBoxTransforms(boxWithoutTransform, this.latestValues);\n      }\n      return boxWithoutTransform;\n    }\n    setTargetDelta(delta) {\n      this.targetDelta = delta;\n      this.root.scheduleUpdateProjection();\n    }\n    setOptions(options) {\n      this.options = __spreadProps(__spreadValues(__spreadValues({}, this.options), options), {\n        crossfade: options.crossfade !== void 0 ? options.crossfade : true\n      });\n    }\n    clearMeasurements() {\n      this.scroll = void 0;\n      this.layout = void 0;\n      this.snapshot = void 0;\n      this.prevTransformTemplateValue = void 0;\n      this.targetDelta = void 0;\n      this.target = void 0;\n      this.isLayoutDirty = false;\n    }\n    resolveTargetDelta() {\n      var _a;\n      const { layout, layoutId } = this.options;\n      if (!this.layout || !(layout || layoutId))\n        return;\n      if (!this.targetDelta && !this.relativeTarget) {\n        const relativeParent = this.getClosestProjectingParent();\n        if (relativeParent && relativeParent.layout) {\n          this.relativeParent = relativeParent;\n          this.relativeTarget = createBox();\n          this.relativeTargetOrigin = createBox();\n          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n        } else {\n          this.relativeParent = this.relativeTarget = void 0;\n        }\n      }\n      if (!this.relativeTarget && !this.targetDelta)\n        return;\n      if (!this.target) {\n        this.target = createBox();\n        this.targetWithTransforms = createBox();\n      }\n      if (this.relativeTarget && this.relativeTargetOrigin && ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {\n        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n      } else if (this.targetDelta) {\n        if (Boolean(this.resumingFrom)) {\n          this.target = this.applyTransform(this.layout.layoutBox);\n        } else {\n          copyBoxInto(this.target, this.layout.layoutBox);\n        }\n        applyBoxDelta(this.target, this.targetDelta);\n      } else {\n        copyBoxInto(this.target, this.layout.layoutBox);\n      }\n      if (this.attemptToResolveRelativeTarget) {\n        this.attemptToResolveRelativeTarget = false;\n        const relativeParent = this.getClosestProjectingParent();\n        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target) {\n          this.relativeParent = relativeParent;\n          this.relativeTarget = createBox();\n          this.relativeTargetOrigin = createBox();\n          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n        } else {\n          this.relativeParent = this.relativeTarget = void 0;\n        }\n      }\n    }\n    getClosestProjectingParent() {\n      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues))\n        return void 0;\n      if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {\n        return this.parent;\n      } else {\n        return this.parent.getClosestProjectingParent();\n      }\n    }\n    calcProjection() {\n      var _a;\n      const { layout, layoutId } = this.options;\n      this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);\n      if (!this.isTreeAnimating) {\n        this.targetDelta = this.relativeTarget = void 0;\n      }\n      if (!this.layout || !(layout || layoutId))\n        return;\n      const lead = this.getLead();\n      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);\n      const { target } = lead;\n      if (!target)\n        return;\n      if (!this.projectionDelta) {\n        this.projectionDelta = createDelta();\n        this.projectionDeltaWithTransform = createDelta();\n      }\n      const prevTreeScaleX = this.treeScale.x;\n      const prevTreeScaleY = this.treeScale.y;\n      const prevProjectionTransform = this.projectionTransform;\n      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);\n      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {\n        this.hasProjected = true;\n        this.scheduleRender();\n        this.notifyListeners(\"projectionUpdate\", target);\n      }\n    }\n    hide() {\n      this.isVisible = false;\n    }\n    show() {\n      this.isVisible = true;\n    }\n    scheduleRender(notifyAll2 = true) {\n      var _a, _b, _c;\n      (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);\n      notifyAll2 && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());\n      if (this.resumingFrom && !this.resumingFrom.instance) {\n        this.resumingFrom = void 0;\n      }\n    }\n    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n      var _a;\n      const snapshot = this.snapshot;\n      const snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};\n      const mixedValues = __spreadValues({}, this.latestValues);\n      const targetDelta = createDelta();\n      this.relativeTarget = this.relativeTargetOrigin = void 0;\n      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n      const relativeLayout = createBox();\n      const isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;\n      const isOnlyMember = (((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.members.length) || 0) <= 1;\n      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));\n      this.animationProgress = 0;\n      this.mixTargetDelta = (latest) => {\n        var _a2;\n        const progress3 = latest / 1e3;\n        mixAxisDelta(targetDelta.x, delta.x, progress3);\n        mixAxisDelta(targetDelta.y, delta.y, progress3);\n        this.setTargetDelta(targetDelta);\n        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && ((_a2 = this.relativeParent) === null || _a2 === void 0 ? void 0 : _a2.layout)) {\n          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress3);\n        }\n        if (isSharedLayoutAnimation) {\n          this.animationValues = mixedValues;\n          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress3, shouldCrossfadeOpacity, isOnlyMember);\n        }\n        this.root.scheduleUpdateProjection();\n        this.scheduleRender();\n        this.animationProgress = progress3;\n      };\n      this.mixTargetDelta(0);\n    }\n    startAnimation(options) {\n      var _a, _b;\n      this.notifyListeners(\"animationStart\");\n      (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n      if (this.resumingFrom) {\n        (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();\n      }\n      if (this.pendingAnimation) {\n        cancelSync.update(this.pendingAnimation);\n        this.pendingAnimation = void 0;\n      }\n      this.pendingAnimation = es_default.update(() => {\n        globalProjectionState.hasAnimatedSinceResize = true;\n        this.currentAnimation = animate2(0, animationTarget, __spreadProps(__spreadValues({}, options), {\n          onUpdate: (latest) => {\n            var _a2;\n            this.mixTargetDelta(latest);\n            (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, latest);\n          },\n          onComplete: () => {\n            var _a2;\n            (_a2 = options.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(options);\n            this.completeAnimation();\n          }\n        }));\n        if (this.resumingFrom) {\n          this.resumingFrom.currentAnimation = this.currentAnimation;\n        }\n        this.pendingAnimation = void 0;\n      });\n    }\n    completeAnimation() {\n      var _a;\n      if (this.resumingFrom) {\n        this.resumingFrom.currentAnimation = void 0;\n        this.resumingFrom.preserveOpacity = void 0;\n      }\n      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();\n      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;\n      this.notifyListeners(\"animationComplete\");\n    }\n    finishAnimation() {\n      var _a;\n      if (this.currentAnimation) {\n        (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);\n        this.currentAnimation.stop();\n      }\n      this.completeAnimation();\n    }\n    applyTransformsToTarget() {\n      const lead = this.getLead();\n      let { targetWithTransforms, target, layout, latestValues } = lead;\n      if (!targetWithTransforms || !target || !layout)\n        return;\n      if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n        target = this.target || createBox();\n        const xLength = calcLength(this.layout.layoutBox.x);\n        target.x.min = lead.target.x.min;\n        target.x.max = target.x.min + xLength;\n        const yLength = calcLength(this.layout.layoutBox.y);\n        target.y.min = lead.target.y.min;\n        target.y.max = target.y.min + yLength;\n      }\n      copyBoxInto(targetWithTransforms, target);\n      transformBox(targetWithTransforms, latestValues);\n      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n    }\n    registerSharedNode(layoutId, node) {\n      var _a, _b, _c;\n      if (!this.sharedNodes.has(layoutId)) {\n        this.sharedNodes.set(layoutId, new NodeStack());\n      }\n      const stack = this.sharedNodes.get(layoutId);\n      stack.add(node);\n      node.promote({\n        transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,\n        preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)\n      });\n    }\n    isLead() {\n      const stack = this.getStack();\n      return stack ? stack.lead === this : true;\n    }\n    getLead() {\n      var _a;\n      const { layoutId } = this.options;\n      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n    }\n    getPrevLead() {\n      var _a;\n      const { layoutId } = this.options;\n      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;\n    }\n    getStack() {\n      const { layoutId } = this.options;\n      if (layoutId)\n        return this.root.sharedNodes.get(layoutId);\n    }\n    promote({ needsReset, transition, preserveFollowOpacity } = {}) {\n      const stack = this.getStack();\n      if (stack)\n        stack.promote(this, preserveFollowOpacity);\n      if (needsReset) {\n        this.projectionDelta = void 0;\n        this.needsReset = true;\n      }\n      if (transition)\n        this.setOptions({ transition });\n    }\n    relegate() {\n      const stack = this.getStack();\n      if (stack) {\n        return stack.relegate(this);\n      } else {\n        return false;\n      }\n    }\n    resetRotation() {\n      const { visualElement } = this.options;\n      if (!visualElement)\n        return;\n      let hasRotate = false;\n      const resetValues = {};\n      for (let i2 = 0; i2 < transformAxes.length; i2++) {\n        const axis = transformAxes[i2];\n        const key = \"rotate\" + axis;\n        if (!visualElement.getStaticValue(key)) {\n          continue;\n        }\n        hasRotate = true;\n        resetValues[key] = visualElement.getStaticValue(key);\n        visualElement.setStaticValue(key, 0);\n      }\n      if (!hasRotate)\n        return;\n      visualElement === null || visualElement === void 0 ? void 0 : visualElement.render();\n      for (const key in resetValues) {\n        visualElement.setStaticValue(key, resetValues[key]);\n      }\n      visualElement.scheduleRender();\n    }\n    getProjectionStyles(styleProp = {}) {\n      var _a, _b, _c;\n      const styles = {};\n      if (!this.instance || this.isSVG)\n        return styles;\n      if (!this.isVisible) {\n        return { visibility: \"hidden\" };\n      } else {\n        styles.visibility = \"\";\n      }\n      const transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n      if (this.needsReset) {\n        this.needsReset = false;\n        styles.opacity = \"\";\n        styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n        styles.transform = transformTemplate ? transformTemplate(this.latestValues, \"\") : \"none\";\n        return styles;\n      }\n      const lead = this.getLead();\n      if (!this.projectionDelta || !this.layout || !lead.target) {\n        const emptyStyles = {};\n        if (this.options.layoutId) {\n          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;\n          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n        }\n        if (this.hasProjected && !hasTransform(this.latestValues)) {\n          emptyStyles.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n          this.hasProjected = false;\n        }\n        return emptyStyles;\n      }\n      const valuesToRender = lead.animationValues || lead.latestValues;\n      this.applyTransformsToTarget();\n      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n      if (transformTemplate) {\n        styles.transform = transformTemplate(valuesToRender, styles.transform);\n      }\n      const { x, y } = this.projectionDelta;\n      styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n      if (lead.animationValues) {\n        styles.opacity = lead === this ? (_c = (_b = valuesToRender.opacity) !== null && _b !== void 0 ? _b : this.latestValues.opacity) !== null && _c !== void 0 ? _c : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;\n      } else {\n        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : \"\" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;\n      }\n      for (const key in scaleCorrectors) {\n        if (valuesToRender[key] === void 0)\n          continue;\n        const { correct, applyTo } = scaleCorrectors[key];\n        const corrected = correct(valuesToRender[key], lead);\n        if (applyTo) {\n          const num = applyTo.length;\n          for (let i2 = 0; i2 < num; i2++) {\n            styles[applyTo[i2]] = corrected;\n          }\n        } else {\n          styles[key] = corrected;\n        }\n      }\n      if (this.options.layoutId) {\n        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || \"\" : \"none\";\n      }\n      return styles;\n    }\n    clearSnapshot() {\n      this.resumeFrom = this.snapshot = void 0;\n    }\n    resetTree() {\n      this.root.nodes.forEach((node) => {\n        var _a;\n        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n      });\n      this.root.nodes.forEach(clearMeasurements);\n      this.root.sharedNodes.clear();\n    }\n  };\n}\nfunction updateLayout(node) {\n  node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n  var _a, _b, _c;\n  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\n  if (node.isLead() && node.layout && snapshot && node.hasListeners(\"didUpdate\")) {\n    const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\n    const { animationType } = node.options;\n    if (animationType === \"size\") {\n      eachAxis((axis) => {\n        const axisSnapshot = snapshot.isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n        const length = calcLength(axisSnapshot);\n        axisSnapshot.min = layout[axis].min;\n        axisSnapshot.max = axisSnapshot.min + length;\n      });\n    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\n      eachAxis((axis) => {\n        const axisSnapshot = snapshot.isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n        const length = calcLength(layout[axis]);\n        axisSnapshot.max = axisSnapshot.min + length;\n      });\n    }\n    const layoutDelta = createDelta();\n    calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\n    const visualDelta = createDelta();\n    if (snapshot.isShared) {\n      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n    } else {\n      calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n    }\n    const hasLayoutChanged = !isDeltaZero(layoutDelta);\n    let hasRelativeTargetChanged = false;\n    if (!node.resumeFrom) {\n      const relativeParent = node.getClosestProjectingParent();\n      if (relativeParent && !relativeParent.resumeFrom) {\n        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n        if (parentSnapshot && parentLayout) {\n          const relativeSnapshot = createBox();\n          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n          const relativeLayout = createBox();\n          calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n          if (!boxEquals(relativeSnapshot, relativeLayout)) {\n            hasRelativeTargetChanged = true;\n          }\n        }\n      }\n    }\n    node.notifyListeners(\"didUpdate\", {\n      layout,\n      snapshot,\n      delta: visualDelta,\n      layoutDelta,\n      hasLayoutChanged,\n      hasRelativeTargetChanged\n    });\n  } else if (node.isLead()) {\n    (_c = (_b = node.options).onExitComplete) === null || _c === void 0 ? void 0 : _c.call(_b);\n  }\n  node.options.transition = void 0;\n}\nfunction clearSnapshot(node) {\n  node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n  node.clearMeasurements();\n}\nfunction resetTransformStyle(node) {\n  const { visualElement } = node.options;\n  if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {\n    visualElement.notify(\"BeforeLayoutMeasure\");\n  }\n  node.resetTransform();\n}\nfunction finishAnimation(node) {\n  node.finishAnimation();\n  node.targetDelta = node.relativeTarget = node.target = void 0;\n}\nfunction resolveTargetDelta(node) {\n  node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n  node.calcProjection();\n}\nfunction resetRotation(node) {\n  node.resetRotation();\n}\nfunction removeLeadSnapshots(stack) {\n  stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p2) {\n  output.translate = mix(delta.translate, 0, p2);\n  output.scale = mix(delta.scale, 1, p2);\n  output.origin = delta.origin;\n  output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p2) {\n  output.min = mix(from.min, to.min, p2);\n  output.max = mix(from.max, to.max, p2);\n}\nfunction mixBox(output, from, to, p2) {\n  mixAxis(output.x, from.x, to.x, p2);\n  mixAxis(output.y, from.y, to.y, p2);\n}\nfunction hasOpacityCrossfade(node) {\n  return node.animationValues && node.animationValues.opacityExit !== void 0;\n}\nvar defaultLayoutTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\nfunction mountNodeEarly(node, id2) {\n  let searchNode = node.root;\n  for (let i2 = node.path.length - 1; i2 >= 0; i2--) {\n    if (Boolean(node.path[i2].instance)) {\n      searchNode = node.path[i2];\n      break;\n    }\n  }\n  const searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;\n  const element = searchElement.querySelector(`[data-projection-id=\"${id2}\"]`);\n  if (element)\n    node.mount(element, true);\n}\nfunction roundAxis(axis) {\n  axis.min = Math.round(axis.min);\n  axis.max = Math.round(axis.max);\n}\nfunction roundBox(box) {\n  roundAxis(box.x);\n  roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\n  return animationType === \"position\" || animationType === \"preserve-aspect\" && !isCloseTo(aspectRatio(snapshot), aspectRatio(layout), 0.2);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs\nvar DocumentProjectionNode = createProjectionNode({\n  attachResizeListener: (ref, notify) => addDomEvent(ref, \"resize\", notify),\n  measureScroll: () => ({\n    x: document.documentElement.scrollLeft || document.body.scrollLeft,\n    y: document.documentElement.scrollTop || document.body.scrollTop\n  }),\n  checkIsScrollRoot: () => true\n});\n\n// ../../node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs\nvar rootProjectionNode = {\n  current: void 0\n};\nvar HTMLProjectionNode = createProjectionNode({\n  measureScroll: (instance) => ({\n    x: instance.scrollLeft,\n    y: instance.scrollTop\n  }),\n  defaultParent: () => {\n    if (!rootProjectionNode.current) {\n      const documentNode = new DocumentProjectionNode(0, {});\n      documentNode.mount(window);\n      documentNode.setOptions({ layoutScroll: true });\n      rootProjectionNode.current = documentNode;\n    }\n    return rootProjectionNode.current;\n  },\n  resetTransform: (instance, value) => {\n    instance.style.transform = value !== void 0 ? value : \"none\";\n  },\n  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \"fixed\")\n});\n\n// ../../node_modules/framer-motion/dist/es/render/dom/motion.mjs\nvar featureBundle = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, animations), gestureAnimations), drag), layoutFeatures);\nvar motion = /* @__PURE__ */ createMotionProxy((Component, config) => createDomMotionConfig(Component, config, featureBundle, createDomVisualElement, HTMLProjectionNode));\n\n// ../../node_modules/@motionone/utils/dist/clamp.es.js\nvar clamp3 = (min, max, v) => Math.min(Math.max(v, min), max);\n\n// ../../node_modules/@motionone/utils/dist/is-number.es.js\nvar isNumber = (value) => typeof value === \"number\";\n\n// ../../node_modules/@motionone/utils/dist/is-easing-list.es.js\nvar isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\n\n// ../../node_modules/@motionone/utils/dist/wrap.es.js\nvar wrap = (min, max, v) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\n// ../../node_modules/@motionone/utils/dist/easing.es.js\nfunction getEasingForSegment(easing, i2) {\n  return isEasingList(easing) ? easing[wrap(0, easing.length, i2)] : easing;\n}\n\n// ../../node_modules/@motionone/utils/dist/mix.es.js\nvar mix2 = (min, max, progress3) => -progress3 * min + progress3 * max + min;\n\n// ../../node_modules/@motionone/utils/dist/noop.es.js\nvar noopReturn = (v) => v;\n\n// ../../node_modules/@motionone/utils/dist/progress.es.js\nvar progress2 = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\n// ../../node_modules/@motionone/utils/dist/offset.es.js\nfunction fillOffset(offset, remaining) {\n  const min = offset[offset.length - 1];\n  for (let i2 = 1; i2 <= remaining; i2++) {\n    const offsetProgress = progress2(0, remaining, i2);\n    offset.push(mix2(min, 1, offsetProgress));\n  }\n}\nfunction defaultOffset2(length) {\n  const offset = [0];\n  fillOffset(offset, length - 1);\n  return offset;\n}\n\n// ../../node_modules/@motionone/utils/dist/interpolate.es.js\nfunction interpolate2(output, input = defaultOffset2(output.length), easing = noopReturn) {\n  const length = output.length;\n  const remainder = length - input.length;\n  remainder > 0 && fillOffset(input, remainder);\n  return (t) => {\n    let i2 = 0;\n    for (; i2 < length - 2; i2++) {\n      if (t < input[i2 + 1])\n        break;\n    }\n    let progressInRange = clamp3(0, 1, progress2(input[i2], input[i2 + 1], t));\n    const segmentEasing = getEasingForSegment(easing, i2);\n    progressInRange = segmentEasing(progressInRange);\n    return mix2(output[i2], output[i2 + 1], progressInRange);\n  };\n}\n\n// ../../node_modules/@motionone/utils/dist/is-function.es.js\nvar isFunction = (value) => typeof value === \"function\";\n\n// ../../node_modules/@motionone/utils/dist/is-string.es.js\nvar isString2 = (value) => typeof value === \"string\";\n\n// ../../node_modules/@motionone/utils/dist/velocity.es.js\nfunction velocityPerSecond2(velocity, frameDuration) {\n  return frameDuration ? velocity * (1e3 / frameDuration) : 0;\n}\n\n// ../../node_modules/@motionone/dom/dist/utils/resolve-elements.es.js\nfunction resolveElements(elements, selectorCache) {\n  var _a;\n  if (typeof elements === \"string\") {\n    if (selectorCache) {\n      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = document.querySelectorAll(elements);\n      elements = selectorCache[elements];\n    } else {\n      elements = document.querySelectorAll(elements);\n    }\n  } else if (elements instanceof Element) {\n    elements = [elements];\n  }\n  return Array.from(elements || []);\n}\n\n// ../../node_modules/tslib/modules/index.js\nvar import_tslib4 = __toESM(require_tslib2(), 1);\nvar {\n  __extends: __extends2,\n  __assign: __assign2,\n  __rest: __rest2,\n  __decorate: __decorate2,\n  __param: __param2,\n  __metadata: __metadata2,\n  __awaiter: __awaiter2,\n  __generator: __generator2,\n  __exportStar: __exportStar2,\n  __createBinding: __createBinding2,\n  __values: __values2,\n  __read: __read2,\n  __spread: __spread2,\n  __spreadArrays: __spreadArrays2,\n  __spreadArray: __spreadArray2,\n  __await: __await2,\n  __asyncGenerator: __asyncGenerator2,\n  __asyncDelegator: __asyncDelegator2,\n  __asyncValues: __asyncValues2,\n  __makeTemplateObject: __makeTemplateObject2,\n  __importStar: __importStar2,\n  __importDefault: __importDefault2,\n  __classPrivateFieldGet: __classPrivateFieldGet2,\n  __classPrivateFieldSet: __classPrivateFieldSet2,\n  __classPrivateFieldIn: __classPrivateFieldIn2\n} = import_tslib4.default;\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/handle-element.es.js\nvar resizeHandlers = /* @__PURE__ */ new WeakMap();\nvar observer;\nfunction getElementSize(target, borderBoxSize) {\n  if (borderBoxSize) {\n    const { inlineSize, blockSize } = borderBoxSize[0];\n    return { width: inlineSize, height: blockSize };\n  } else if (target instanceof SVGElement && \"getBBox\" in target) {\n    return target.getBBox();\n  } else {\n    return {\n      width: target.offsetWidth,\n      height: target.offsetHeight\n    };\n  }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize }) {\n  var _a;\n  (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n    handler({\n      target,\n      contentSize: contentRect,\n      get size() {\n        return getElementSize(target, borderBoxSize);\n      }\n    });\n  });\n}\nfunction notifyAll(entries) {\n  entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n  if (typeof ResizeObserver === \"undefined\")\n    return;\n  observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n  if (!observer)\n    createResizeObserver();\n  const elements = resolveElements(target);\n  elements.forEach((element) => {\n    let elementHandlers = resizeHandlers.get(element);\n    if (!elementHandlers) {\n      elementHandlers = /* @__PURE__ */ new Set();\n      resizeHandlers.set(element, elementHandlers);\n    }\n    elementHandlers.add(handler);\n    observer === null || observer === void 0 ? void 0 : observer.observe(element);\n  });\n  return () => {\n    elements.forEach((element) => {\n      const elementHandlers = resizeHandlers.get(element);\n      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n        observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n      }\n    });\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/handle-window.es.js\nvar windowCallbacks = /* @__PURE__ */ new Set();\nvar windowResizeHandler;\nfunction createWindowResizeHandler() {\n  windowResizeHandler = () => {\n    const size = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n    const info = {\n      target: window,\n      size,\n      contentSize: size\n    };\n    windowCallbacks.forEach((callback) => callback(info));\n  };\n  window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n  windowCallbacks.add(callback);\n  if (!windowResizeHandler)\n    createWindowResizeHandler();\n  return () => {\n    windowCallbacks.delete(callback);\n    if (!windowCallbacks.size && windowResizeHandler) {\n      windowResizeHandler = void 0;\n    }\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/index.es.js\nfunction resize(a2, b2) {\n  return isFunction(a2) ? resizeWindow(a2) : resizeElement(a2, b2);\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/info.es.js\nvar maxElapsed2 = 50;\nvar createAxisInfo = () => ({\n  current: 0,\n  offset: [],\n  progress: 0,\n  scrollLength: 0,\n  targetOffset: 0,\n  targetLength: 0,\n  containerLength: 0,\n  velocity: 0\n});\nvar createScrollInfo = () => ({\n  time: 0,\n  x: createAxisInfo(),\n  y: createAxisInfo()\n});\nvar keys = {\n  x: {\n    length: \"Width\",\n    position: \"Left\"\n  },\n  y: {\n    length: \"Height\",\n    position: \"Top\"\n  }\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n  const axis = info[axisName];\n  const { length, position } = keys[axisName];\n  const prev = axis.current;\n  const prevTime = info.time;\n  axis.current = element[\"scroll\" + position];\n  axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n  axis.offset.length = 0;\n  axis.offset[0] = 0;\n  axis.offset[1] = axis.scrollLength;\n  axis.progress = progress2(0, axis.scrollLength, axis.current);\n  const elapsed = time - prevTime;\n  axis.velocity = elapsed > maxElapsed2 ? 0 : velocityPerSecond2(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n  updateAxisInfo(element, \"x\", info, time);\n  updateAxisInfo(element, \"y\", info, time);\n  info.time = time;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/inset.es.js\nfunction calcInset(element, container) {\n  let inset = { x: 0, y: 0 };\n  let current = element;\n  while (current && current !== container) {\n    if (current instanceof HTMLElement) {\n      inset.x += current.offsetLeft;\n      inset.y += current.offsetTop;\n      current = current.offsetParent;\n    } else if (current instanceof SVGGraphicsElement && \"getBBox\" in current) {\n      const { top, left } = current.getBBox();\n      inset.x += left;\n      inset.y += top;\n      while (current && current.tagName !== \"svg\") {\n        current = current.parentNode;\n      }\n    }\n  }\n  return inset;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/presets.es.js\nvar ScrollOffset = {\n  Enter: [\n    [0, 1],\n    [1, 1]\n  ],\n  Exit: [\n    [0, 0],\n    [1, 0]\n  ],\n  Any: [\n    [1, 0],\n    [0, 1]\n  ],\n  All: [\n    [0, 0],\n    [1, 1]\n  ]\n};\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/edge.es.js\nvar namedEdges = {\n  start: 0,\n  center: 0.5,\n  end: 1\n};\nfunction resolveEdge(edge, length, inset = 0) {\n  let delta = 0;\n  if (namedEdges[edge] !== void 0) {\n    edge = namedEdges[edge];\n  }\n  if (isString2(edge)) {\n    const asNumber2 = parseFloat(edge);\n    if (edge.endsWith(\"px\")) {\n      delta = asNumber2;\n    } else if (edge.endsWith(\"%\")) {\n      edge = asNumber2 / 100;\n    } else if (edge.endsWith(\"vw\")) {\n      delta = asNumber2 / 100 * document.documentElement.clientWidth;\n    } else if (edge.endsWith(\"vh\")) {\n      delta = asNumber2 / 100 * document.documentElement.clientHeight;\n    } else {\n      edge = asNumber2;\n    }\n  }\n  if (isNumber(edge)) {\n    delta = length * edge;\n  }\n  return inset + delta;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/offset.es.js\nvar defaultOffset3 = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset3;\n  let targetPoint = 0;\n  let containerPoint = 0;\n  if (isNumber(offset)) {\n    offsetDefinition = [offset, offset];\n  } else if (isString2(offset)) {\n    offset = offset.trim();\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n    }\n  }\n  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/index.es.js\nvar point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n  let { offset: offsetDefinition = ScrollOffset.All } = options;\n  const { target = container, axis = \"y\" } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset = target !== container ? calcInset(target, container) : point;\n  const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight } : { width: target.clientWidth, height: target.clientHeight };\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  info[axis].offset.length = 0;\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n  for (let i2 = 0; i2 < numOffsets; i2++) {\n    const offset = resolveOffset(offsetDefinition[i2], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i2]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i2] = offset;\n  }\n  if (hasChanged) {\n    info[axis].interpolate = interpolate2(defaultOffset2(numOffsets), info[axis].offset);\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/on-scroll-handler.es.js\nfunction measure(container, target = container, info) {\n  info.x.targetOffset = 0;\n  info.y.targetOffset = 0;\n  if (target !== container) {\n    let node = target;\n    while (node && node != container) {\n      info.x.targetOffset += node.offsetLeft;\n      info.y.targetOffset += node.offsetTop;\n      node = node.offsetParent;\n    }\n  }\n  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;\n  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;\n  info.x.containerLength = container.clientWidth;\n  info.y.containerLength = container.clientHeight;\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n  const axis = options.axis || \"y\";\n  return {\n    measure: () => measure(element, options.target, info),\n    update: (time) => {\n      updateScrollInfo(element, info, time);\n      if (options.offset || options.target) {\n        resolveOffsets(element, info, options);\n      }\n    },\n    notify: isFunction(onScroll) ? () => onScroll(info) : scrubAnimation(onScroll, info[axis])\n  };\n}\nfunction scrubAnimation(controls, axisInfo) {\n  controls.pause();\n  controls.forEachNative((animation, { easing }) => {\n    var _a, _b;\n    if (animation.updateDuration) {\n      if (!easing)\n        animation.easing = noopReturn;\n      animation.updateDuration(1);\n    } else {\n      const timingOptions = { duration: 1e3 };\n      if (!easing)\n        timingOptions.easing = \"linear\";\n      (_b = (_a = animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming) === null || _b === void 0 ? void 0 : _b.call(_a, timingOptions);\n    }\n  });\n  return () => {\n    controls.currentTime = axisInfo.progress;\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/index.es.js\nvar scrollListeners = /* @__PURE__ */ new WeakMap();\nvar resizeListeners = /* @__PURE__ */ new WeakMap();\nvar onScrollHandlers = /* @__PURE__ */ new WeakMap();\nvar getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction scroll(onScroll, _a = {}) {\n  var { container = document.documentElement } = _a, options = __rest2(_a, [\"container\"]);\n  let containerHandlers = onScrollHandlers.get(container);\n  if (!containerHandlers) {\n    containerHandlers = /* @__PURE__ */ new Set();\n    onScrollHandlers.set(container, containerHandlers);\n  }\n  const info = createScrollInfo();\n  const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n  containerHandlers.add(containerHandler);\n  if (!scrollListeners.has(container)) {\n    const listener2 = () => {\n      const time = performance.now();\n      for (const handler of containerHandlers)\n        handler.measure();\n      for (const handler of containerHandlers)\n        handler.update(time);\n      for (const handler of containerHandlers)\n        handler.notify();\n    };\n    scrollListeners.set(container, listener2);\n    const target = getEventTarget(container);\n    window.addEventListener(\"resize\", listener2, { passive: true });\n    if (container !== document.documentElement) {\n      resizeListeners.set(container, resize(container, listener2));\n    }\n    target.addEventListener(\"scroll\", listener2, { passive: true });\n  }\n  const listener = scrollListeners.get(container);\n  const onLoadProcesss = requestAnimationFrame(listener);\n  return () => {\n    var _a2;\n    if (typeof onScroll !== \"function\")\n      onScroll.stop();\n    cancelAnimationFrame(onLoadProcesss);\n    const containerHandlers2 = onScrollHandlers.get(container);\n    if (!containerHandlers2)\n      return;\n    containerHandlers2.delete(containerHandler);\n    if (containerHandlers2.size)\n      return;\n    const listener2 = scrollListeners.get(container);\n    scrollListeners.delete(container);\n    if (listener2) {\n      getEventTarget(container).removeEventListener(\"scroll\", listener2);\n      (_a2 = resizeListeners.get(container)) === null || _a2 === void 0 ? void 0 : _a2();\n      window.removeEventListener(\"resize\", listener2);\n    }\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-scroll.mjs\nvar import_react28 = __webpack_require__(/*! react */ \"react\");\nvar createScrollMotionValues = () => ({\n  scrollX: motionValue(0),\n  scrollY: motionValue(0),\n  scrollXProgress: motionValue(0),\n  scrollYProgress: motionValue(0)\n});\nfunction useScroll(_a = {}) {\n  var _b = _a, { container, target, layoutEffect = true } = _b, options = __objRest(_b, [\"container\", \"target\", \"layoutEffect\"]);\n  const values = useConstant(createScrollMotionValues);\n  const useLifecycleEffect = layoutEffect ? useIsomorphicLayoutEffect : import_react28.useEffect;\n  useLifecycleEffect(() => {\n    return scroll(({ x, y }) => {\n      values.scrollX.set(x.current);\n      values.scrollXProgress.set(x.progress);\n      values.scrollY.set(y.current);\n      values.scrollYProgress.set(y.progress);\n    }, __spreadProps(__spreadValues({}, options), {\n      container: (container === null || container === void 0 ? void 0 : container.current) || void 0,\n      target: (target === null || target === void 0 ? void 0 : target.current) || void 0\n    }));\n  }, []);\n  return values;\n}\n\n// src/Menu.tsx\nvar import_jsx_runtime2 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar Menu = () => {\n  const { scrollYProgress } = useScroll();\n  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(\"div\", {\n    className: \"hidden sm:block\",\n    children: [\n      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(motion.div, {\n        className: \"progress-bar\",\n        style: { scaleX: scrollYProgress }\n      }),\n      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(\"div\", {\n        className: \"flex flex-row items-center justify-between bg-gradient-to-r from-blue-400 to-blue-500\",\n        children: [\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n              href: \"/\",\n              children: \"Pylar\\u2122 AI\"\n            })\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n              href: \"/blog\",\n              children: \"Daily Work\"\n            })\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n              href: \"/what-is-pylar\",\n              children: \"About\"\n            })\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n              href: \"/pylar-license\",\n              children: \"The License\"\n            })\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n              href: \"https://pencil.domains\",\n              target: \"_blank\",\n              rel: \"noreferrer\",\n              children: \"Pencil Domains\"\n            })\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(\"div\", {\n            className: \"hidden py-2 px-4 font-bold text-white md:block\",\n            style: {\n              display: \"flex\",\n              justifyContent: \"center\",\n              alignItems: \"center\"\n            },\n            children: [\n              \" \",\n              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"button\", {\n                className: \"hidden py-2 px-4 font-bold text-white md:block\",\n                children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n                  href: \"http://twitter.com/superdatas\",\n                  target: \"_blank\",\n                  rel: \"noopener noreferrer\",\n                  children: \"Twitter\"\n                })\n              }),\n              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"a\", {\n                href: \"http://github.com/miguelgargallo/next13-gallery-image-turbo\",\n                target: \"_blank\",\n                rel: \"noopener noreferrer\",\n                className: \"hidden py-2 px-4 font-bold text-white md:block\",\n                children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"picture\", {\n                  children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"img\", {\n                    src: \"https://img.shields.io/github/stars/miguelgargallo/Next13-gallery-image-turbo?style=social\",\n                    alt: \"Landscape picture\",\n                    width: 100,\n                    height: 20\n                  })\n                })\n              }),\n              \" \",\n              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Version, {})\n            ]\n          })\n        ]\n      })\n    ]\n  });\n};\n\n// src/MenuPylar.tsx\nvar import_jsx_runtime3 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar MenuPylar = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"div\", {\n    className: \"flex hidden flex-row items-center justify-between bg-gradient-to-r from-blue-400 to-blue-500 sm:block\",\n    children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(\"div\", {\n      className: \"flex flex-row\",\n      children: [\n        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"a\", {\n            href: \"/blog\",\n            children: \"Our Daily Work\"\n          })\n        }),\n        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"a\", {\n            href: \"/what-is-pylar\",\n            children: \"What is Pylar AI\"\n          })\n        }),\n        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\"a\", {\n            href: \"/pylar-license\",\n            children: \"License\"\n          })\n        })\n      ]\n    })\n  });\n};\n\n// src/TitlePylar.tsx\nvar import_jsx_runtime4 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar TitlePylar = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(\"div\", {\n    children: [\n      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(\"h1\", {\n        className: \"py-8 text-center text-5xl font-bold\",\n        children: [\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.5, duration: 1.5 },\n            children: \"P\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.6, duration: 1.5 },\n            children: \"y\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.7, duration: 1.5 },\n            children: \"l\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.8, duration: 1.5 },\n            children: \"a\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.9, duration: 1.5 },\n            children: \"r\\u2122\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1, duration: 1.5 },\n            children: \"\\xA0\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1.1, duration: 1.5 },\n            children: \"A\"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1.2, duration: 1.5 },\n            children: \"I\"\n          })\n        ]\n      }),\n      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(motion.h2, {\n        className: \"py-8 text-center text-4xl font-bold\",\n        initial: { opacity: 0 },\n        animate: { opacity: 1 },\n        transition: { delay: 1.4, duration: 1.5 },\n        children: [\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"Py\"\n          }),\n          \"thon\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"L\"\n          }),\n          \"earning\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"A\"\n          }),\n          \"rtificial\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"R\"\n          }),\n          \"esearch\\u2122\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-black\",\n            children: \" \"\n          }),\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"A\"\n          }),\n          \"rtificial\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"I\"\n          }),\n          \"ntelligence\",\n          \" \"\n        ]\n      })\n    ]\n  });\n};\n\n// src/ListPylar.tsx\nvar import_jsx_runtime5 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar ListPylar = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"div\", {\n    className: \"mt-8 flex flex-row justify-center\",\n    children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(\"div\", {\n      className: \"flex w-3/4 flex-col\",\n      children: [\n        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"h2\", {\n          className: \"text-2xl font-bold\",\n          children: \"Welcome to the Pylar AI Blog\"\n        }),\n        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(\"p\", {\n          className: \"mt-4 text-lg\",\n          children: [\n            \"Pylar AI is:\",\n            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(\"ul\", {\n              className: \"list-inside list-disc\",\n              children: [\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"li\", {\n                  children: \"Generative art results\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"a\", {\n                  children: \"What is generative art? Generative art is a form of art that uses a computer to create art. The computer is programmed to create art based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"li\", {\n                  children: \"Promt Engineering design\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"a\", {\n                  children: \"Promt Engineering is a form of engineering that uses a computer to create engineering. The computer is programmed to create engineering based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"li\", {\n                  children: \"StableDiffusion 2.0 modified\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"a\", {\n                  children: \"StableDiffusion 2.0 is a computer program that is used to create art based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                })\n              ]\n            })\n          ]\n        })\n      ]\n    })\n  });\n};\n\n// src/Footer.tsx\nvar import_jsx_runtime6 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar Footer = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(\"footer\", {\n    className: \"bg-white py-8 text-center\",\n    children: [\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"div\", {\n        children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(\"a\", {\n          children: [\n            \"Made with \\u2764\\uFE0F by\",\n            \" \",\n            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"a\", {\n              href: \"https://twitter.com/miguelgargallo\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hover:text-blue text-indigo-600\",\n              children: \"Miguel Gargallo\"\n            }),\n            \".\"\n          ]\n        })\n      }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"div\", {\n        children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(\"a\", {\n          children: [\n            \"2022 \\xA9\",\n            \" \",\n            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"a\", {\n              href: \"https://huggingface.co/spaces/superdatas/LICENSE\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hover:text-blue text-indigo-600\",\n              children: \"Pylar\\u2122 AI creative ML license\"\n            }),\n            \".\"\n          ]\n        })\n      }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"div\", {\n        className: \"hidden sm:block\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(\"div\", {\n          className: \"flex w-full items-center justify-center\",\n          children: [\n            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"a\", {\n              href: \"https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fmiguelgargallo%2FNext13-Fetch-Data-turbo&project-name=miguelgargallo-next13-fetch-data-turbo&repo-name=miguelgargallo-next13-fetch-data-turbo\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hidden p-2 md:block\",\n              children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"picture\", {\n                children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"img\", {\n                  src: \"https://vercel.com/button\",\n                  alt: \"Landscape picture\",\n                  width: 75,\n                  height: 20\n                })\n              })\n            }),\n            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"a\", {\n              href: \"https://huggingface.co/spaces/superdatas/LICENSE\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hidden p-2 md:block\",\n              children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"picture\", {\n                children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"img\", {\n                  src: \"https://huggingface.co/front/assets/huggingface_logo.svg\",\n                  alt: \"Landscape picture\",\n                  width: 40,\n                  height: 20\n                })\n              })\n            })\n          ]\n        })\n      }),\n      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(\"p\", {\n        children: \"Please do not consider the score as investment advice.\"\n      })\n    ]\n  });\n};\n\n// src/Scrollable.tsx\nvar import_jsx_runtime7 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar Scrollable = () => {\n  const { scrollYProgress } = useScroll();\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(motion.div, {\n    className: \"progress-bar\",\n    style: { scaleX: scrollYProgress }\n  });\n};\n\n// src/BlogPylar/blog.tsx\nvar import_jsx_runtime8 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar ELEMENTS2 = 5;\nvar blog = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(\"div\", {\n    children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: \"95\",\n      height: \"95\",\n      stroke: \"#FFF\",\n      \"stroke-width\": \"0\",\n      viewBox: \"0 0 95 95\",\n      className: \"m-2 rounded-xl py-2 shadow-md hover:shadow-xl\",\n      style: k(ELEMENTS2),\n      children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(\"path\", {\n        d: \"M32.816,12.95,30.349,8.568h4.78a.439.439,0,0,1,.346.2l.931,1.534c.558.92,1.225,2.02,1.607,2.648ZM23.975,39.495a.339.339,0,0,1-.315.207H18.772l7.595-13.635a.731.731,0,0,0-.636-1.087h0L12.787,25l-2.574-4.456H29.076c.011,0,.02,0,.031,0a.677.677,0,0,0,.217-.045l.047-.02a.722.722,0,0,0,.346-.313l3.108-5.745h5.13Zm-6.468-.518-.613-1.009c-.785-1.3-1.791-2.955-1.9-3.137a.385.385,0,0,1,.024-.355l4.457-8.027,5.019-.006ZM8.948,30.444,6.453,26.011,8.968,21.3l2.522,4.367C10.706,27.14,9.483,29.442,8.948,30.444Zm-3.348.69H2.881a.443.443,0,0,1-.343-.2L1.726,29.6C1.147,28.641.409,27.425,0,26.752H5.2l2.466,4.383ZM14.037.208A.338.338,0,0,1,14.351,0h4.91L11.646,13.636c-.006.011-.01.023-.016.035s-.021.046-.03.07-.015.046-.021.069-.011.044-.014.066a.648.648,0,0,0-.008.081c0,.012,0,.023,0,.036s0,.018,0,.027a.591.591,0,0,0,.008.079.538.538,0,0,0,.012.066c.006.023.013.045.021.068s.016.045.025.066.021.041.033.062.023.04.037.059a.644.644,0,0,0,.045.055c.016.017.031.035.048.051s.035.029.053.043a.634.634,0,0,0,.063.045l.023.016c.008,0,.018.006.027.011a.729.729,0,0,0,.119.048c.015,0,.029.01.044.013a.7.7,0,0,0,.164.021h.33l12.619-.017c.334.58.957,1.673,1.489,2.6q.612,1.072,1.01,1.768H8.949c-.008,0-.016,0-.024,0a.725.725,0,0,0-.631.382L5.185,25.29H.059Zm6.479.534.456.75c.8,1.321,1.932,3.185,2.052,3.379A.383.383,0,0,1,23,5.227l-4.457,8.027-5.017.006Zm8.546,8.511,2.5,4.435-2.545,4.7c-.3-.529-.68-1.189-1.034-1.808-.7-1.224-1.208-2.115-1.495-2.613C27.028,12.977,28.462,10.349,29.062,9.253Z\",\n        id: \"Fill-1\",\n        className: \"fill-yellow-500\"\n      })\n    })\n  });\n};\n\n// src/BlogPylar/post12032022.tsx\nvar import_jsx_runtime9 = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar ELEMENTS3 = 5;\nvar post12032022 = () => {\n  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\"div\", {\n    children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: \"95\",\n      height: \"95\",\n      stroke: \"#FFF\",\n      \"stroke-width\": \"0\",\n      viewBox: \"0 0 95 95\",\n      className: \"m-2 rounded-xl py-2 shadow-md hover:shadow-xl\",\n      style: k(ELEMENTS3),\n      children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\"path\", {\n        d: \"M32.816,12.95,30.349,8.568h4.78a.439.439,0,0,1,.346.2l.931,1.534c.558.92,1.225,2.02,1.607,2.648ZM23.975,39.495a.339.339,0,0,1-.315.207H18.772l7.595-13.635a.731.731,0,0,0-.636-1.087h0L12.787,25l-2.574-4.456H29.076c.011,0,.02,0,.031,0a.677.677,0,0,0,.217-.045l.047-.02a.722.722,0,0,0,.346-.313l3.108-5.745h5.13Zm-6.468-.518-.613-1.009c-.785-1.3-1.791-2.955-1.9-3.137a.385.385,0,0,1,.024-.355l4.457-8.027,5.019-.006ZM8.948,30.444,6.453,26.011,8.968,21.3l2.522,4.367C10.706,27.14,9.483,29.442,8.948,30.444Zm-3.348.69H2.881a.443.443,0,0,1-.343-.2L1.726,29.6C1.147,28.641.409,27.425,0,26.752H5.2l2.466,4.383ZM14.037.208A.338.338,0,0,1,14.351,0h4.91L11.646,13.636c-.006.011-.01.023-.016.035s-.021.046-.03.07-.015.046-.021.069-.011.044-.014.066a.648.648,0,0,0-.008.081c0,.012,0,.023,0,.036s0,.018,0,.027a.591.591,0,0,0,.008.079.538.538,0,0,0,.012.066c.006.023.013.045.021.068s.016.045.025.066.021.041.033.062.023.04.037.059a.644.644,0,0,0,.045.055c.016.017.031.035.048.051s.035.029.053.043a.634.634,0,0,0,.063.045l.023.016c.008,0,.018.006.027.011a.729.729,0,0,0,.119.048c.015,0,.029.01.044.013a.7.7,0,0,0,.164.021h.33l12.619-.017c.334.58.957,1.673,1.489,2.6q.612,1.072,1.01,1.768H8.949c-.008,0-.016,0-.024,0a.725.725,0,0,0-.631.382L5.185,25.29H.059Zm6.479.534.456.75c.8,1.321,1.932,3.185,2.052,3.379A.383.383,0,0,1,23,5.227l-4.457,8.027-5.017.006Zm8.546,8.511,2.5,4.435-2.545,4.7c-.3-.529-.68-1.189-1.034-1.808-.7-1.224-1.208-2.115-1.495-2.613C27.028,12.977,28.462,10.349,29.062,9.253Z\",\n        id: \"Fill-1\",\n        className: \"fill-yellow-500\"\n      })\n    })\n  });\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzS0FBc0s7QUFDOUssUUFBUSxLQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQSxjQUFjLCtEQUErRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtB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TTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Iiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL3BhY2thZ2VzL3VpL2Rpc3QvaW5kZXguanM/YmU1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhMiwgYjIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiMiB8fCAoYjIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIyLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhMiwgcHJvcCwgYjJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYjIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYjIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYTIsIHByb3AsIGIyW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhMjtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhMiwgYjIpID0+IF9fZGVmUHJvcHMoYTIsIF9fZ2V0T3duUHJvcERlc2NzKGIyKSk7XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX2VzbSA9IChmbiwgcmVzKSA9PiBmdW5jdGlvbiBfX2luaXQoKSB7XG4gIHJldHVybiBmbiAmJiAocmVzID0gKDAsIGZuW19fZ2V0T3duUHJvcE5hbWVzKGZuKVswXV0pKGZuID0gMCkpLCByZXM7XG59O1xudmFyIF9fY29tbW9uSlMgPSAoY2IyLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHtcbiAgcmV0dXJuIG1vZCB8fCAoMCwgY2IyW19fZ2V0T3duUHJvcE5hbWVzKGNiMilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vbWVtb2l6ZS9kaXN0L21lbW9pemUuZXNtLmpzXG5mdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKGNhY2hlW2FyZ10gPT09IHZvaWQgMClcbiAgICAgIGNhY2hlW2FyZ10gPSBmbihhcmcpO1xuICAgIHJldHVybiBjYWNoZVthcmddO1xuICB9O1xufVxudmFyIG1lbW9pemVfZXNtX2RlZmF1bHQ7XG52YXIgaW5pdF9tZW1vaXplX2VzbSA9IF9fZXNtKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vbWVtb2l6ZS9kaXN0L21lbW9pemUuZXNtLmpzXCIoKSB7XG4gICAgbWVtb2l6ZV9lc21fZGVmYXVsdCA9IG1lbW9pemU7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vaXMtcHJvcC12YWxpZC9kaXN0L2lzLXByb3AtdmFsaWQuZXNtLmpzXG52YXIgaXNfcHJvcF92YWxpZF9lc21fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaXNfcHJvcF92YWxpZF9lc21fZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBpc19wcm9wX3ZhbGlkX2VzbV9kZWZhdWx0XG59KTtcbnZhciByZWFjdFByb3BzUmVnZXgsIGluZGV4LCBpc19wcm9wX3ZhbGlkX2VzbV9kZWZhdWx0O1xudmFyIGluaXRfaXNfcHJvcF92YWxpZF9lc20gPSBfX2VzbSh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL2lzLXByb3AtdmFsaWQvZGlzdC9pcy1wcm9wLXZhbGlkLmVzbS5qc1wiKCkge1xuICAgIGluaXRfbWVtb2l6ZV9lc20oKTtcbiAgICByZWFjdFByb3BzUmVnZXggPSAvXigoY2hpbGRyZW58ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUx8a2V5fHJlZnxhdXRvRm9jdXN8ZGVmYXVsdFZhbHVlfGRlZmF1bHRDaGVja2VkfGlubmVySFRNTHxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmd8c3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nfHZhbHVlTGlua3xhY2NlcHR8YWNjZXB0Q2hhcnNldHxhY2Nlc3NLZXl8YWN0aW9ufGFsbG93fGFsbG93VXNlck1lZGlhfGFsbG93UGF5bWVudFJlcXVlc3R8YWxsb3dGdWxsU2NyZWVufGFsbG93VHJhbnNwYXJlbmN5fGFsdHxhc3luY3xhdXRvQ29tcGxldGV8YXV0b1BsYXl8Y2FwdHVyZXxjZWxsUGFkZGluZ3xjZWxsU3BhY2luZ3xjaGFsbGVuZ2V8Y2hhclNldHxjaGVja2VkfGNpdGV8Y2xhc3NJRHxjbGFzc05hbWV8Y29sc3xjb2xTcGFufGNvbnRlbnR8Y29udGVudEVkaXRhYmxlfGNvbnRleHRNZW51fGNvbnRyb2xzfGNvbnRyb2xzTGlzdHxjb29yZHN8Y3Jvc3NPcmlnaW58ZGF0YXxkYXRlVGltZXxkZWNvZGluZ3xkZWZhdWx0fGRlZmVyfGRpcnxkaXNhYmxlZHxkaXNhYmxlUGljdHVyZUluUGljdHVyZXxkb3dubG9hZHxkcmFnZ2FibGV8ZW5jVHlwZXxmb3JtfGZvcm1BY3Rpb258Zm9ybUVuY1R5cGV8Zm9ybU1ldGhvZHxmb3JtTm9WYWxpZGF0ZXxmb3JtVGFyZ2V0fGZyYW1lQm9yZGVyfGhlYWRlcnN8aGVpZ2h0fGhpZGRlbnxoaWdofGhyZWZ8aHJlZkxhbmd8aHRtbEZvcnxodHRwRXF1aXZ8aWR8aW5wdXRNb2RlfGludGVncml0eXxpc3xrZXlQYXJhbXN8a2V5VHlwZXxraW5kfGxhYmVsfGxhbmd8bGlzdHxsb2FkaW5nfGxvb3B8bG93fG1hcmdpbkhlaWdodHxtYXJnaW5XaWR0aHxtYXh8bWF4TGVuZ3RofG1lZGlhfG1lZGlhR3JvdXB8bWV0aG9kfG1pbnxtaW5MZW5ndGh8bXVsdGlwbGV8bXV0ZWR8bmFtZXxub25jZXxub1ZhbGlkYXRlfG9wZW58b3B0aW11bXxwYXR0ZXJufHBsYWNlaG9sZGVyfHBsYXlzSW5saW5lfHBvc3RlcnxwcmVsb2FkfHByb2ZpbGV8cmFkaW9Hcm91cHxyZWFkT25seXxyZWZlcnJlclBvbGljeXxyZWx8cmVxdWlyZWR8cmV2ZXJzZWR8cm9sZXxyb3dzfHJvd1NwYW58c2FuZGJveHxzY29wZXxzY29wZWR8c2Nyb2xsaW5nfHNlYW1sZXNzfHNlbGVjdGVkfHNoYXBlfHNpemV8c2l6ZXN8c2xvdHxzcGFufHNwZWxsQ2hlY2t8c3JjfHNyY0RvY3xzcmNMYW5nfHNyY1NldHxzdGFydHxzdGVwfHN0eWxlfHN1bW1hcnl8dGFiSW5kZXh8dGFyZ2V0fHRpdGxlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufHJlc3VsdHN8c2VjdXJpdHl8dW5zZWxlY3RhYmxlfGFjY2VudEhlaWdodHxhY2N1bXVsYXRlfGFkZGl0aXZlfGFsaWdubWVudEJhc2VsaW5lfGFsbG93UmVvcmRlcnxhbHBoYWJldGljfGFtcGxpdHVkZXxhcmFiaWNGb3JtfGFzY2VudHxhdHRyaWJ1dGVOYW1lfGF0dHJpYnV0ZVR5cGV8YXV0b1JldmVyc2V8YXppbXV0aHxiYXNlRnJlcXVlbmN5fGJhc2VsaW5lU2hpZnR8YmFzZVByb2ZpbGV8YmJveHxiZWdpbnxiaWFzfGJ5fGNhbGNNb2RlfGNhcEhlaWdodHxjbGlwfGNsaXBQYXRoVW5pdHN8Y2xpcFBhdGh8Y2xpcFJ1bGV8Y29sb3JJbnRlcnBvbGF0aW9ufGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnN8Y29sb3JQcm9maWxlfGNvbG9yUmVuZGVyaW5nfGNvbnRlbnRTY3JpcHRUeXBlfGNvbnRlbnRTdHlsZVR5cGV8Y3Vyc29yfGN4fGN5fGR8ZGVjZWxlcmF0ZXxkZXNjZW50fGRpZmZ1c2VDb25zdGFudHxkaXJlY3Rpb258ZGlzcGxheXxkaXZpc29yfGRvbWluYW50QmFzZWxpbmV8ZHVyfGR4fGR5fGVkZ2VNb2RlfGVsZXZhdGlvbnxlbmFibGVCYWNrZ3JvdW5kfGVuZHxleHBvbmVudHxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkfGZpbGx8ZmlsbE9wYWNpdHl8ZmlsbFJ1bGV8ZmlsdGVyfGZpbHRlclJlc3xmaWx0ZXJVbml0c3xmbG9vZENvbG9yfGZsb29kT3BhY2l0eXxmb2N1c2FibGV8Zm9udEZhbWlseXxmb250U2l6ZXxmb250U2l6ZUFkanVzdHxmb250U3RyZXRjaHxmb250U3R5bGV8Zm9udFZhcmlhbnR8Zm9udFdlaWdodHxmb3JtYXR8ZnJvbXxmcnxmeHxmeXxnMXxnMnxnbHlwaE5hbWV8Z2x5cGhPcmllbnRhdGlvbkhvcml6b250YWx8Z2x5cGhPcmllbnRhdGlvblZlcnRpY2FsfGdseXBoUmVmfGdyYWRpZW50VHJhbnNmb3JtfGdyYWRpZW50VW5pdHN8aGFuZ2luZ3xob3JpekFkdlh8aG9yaXpPcmlnaW5YfGlkZW9ncmFwaGljfGltYWdlUmVuZGVyaW5nfGlufGluMnxpbnRlcmNlcHR8a3xrMXxrMnxrM3xrNHxrZXJuZWxNYXRyaXh8a2VybmVsVW5pdExlbmd0aHxrZXJuaW5nfGtleVBvaW50c3xrZXlTcGxpbmVzfGtleVRpbWVzfGxlbmd0aEFkanVzdHxsZXR0ZXJTcGFjaW5nfGxpZ2h0aW5nQ29sb3J8bGltaXRpbmdDb25lQW5nbGV8bG9jYWx8bWFya2VyRW5kfG1hcmtlck1pZHxtYXJrZXJTdGFydHxtYXJrZXJIZWlnaHR8bWFya2VyVW5pdHN8bWFya2VyV2lkdGh8bWFza3xtYXNrQ29udGVudFVuaXRzfG1hc2tVbml0c3xtYXRoZW1hdGljYWx8bW9kZXxudW1PY3RhdmVzfG9mZnNldHxvcGFjaXR5fG9wZXJhdG9yfG9yZGVyfG9yaWVudHxvcmllbnRhdGlvbnxvcmlnaW58b3ZlcmZsb3d8b3ZlcmxpbmVQb3NpdGlvbnxvdmVybGluZVRoaWNrbmVzc3xwYW5vc2UxfHBhaW50T3JkZXJ8cGF0aExlbmd0aHxwYXR0ZXJuQ29udGVudFVuaXRzfHBhdHRlcm5UcmFuc2Zvcm18cGF0dGVyblVuaXRzfHBvaW50ZXJFdmVudHN8cG9pbnRzfHBvaW50c0F0WHxwb2ludHNBdFl8cG9pbnRzQXRafHByZXNlcnZlQWxwaGF8cHJlc2VydmVBc3BlY3RSYXRpb3xwcmltaXRpdmVVbml0c3xyfHJhZGl1c3xyZWZYfHJlZll8cmVuZGVyaW5nSW50ZW50fHJlcGVhdENvdW50fHJlcGVhdER1cnxyZXF1aXJlZEV4dGVuc2lvbnN8cmVxdWlyZWRGZWF0dXJlc3xyZXN0YXJ0fHJlc3VsdHxyb3RhdGV8cnh8cnl8c2NhbGV8c2VlZHxzaGFwZVJlbmRlcmluZ3xzbG9wZXxzcGFjaW5nfHNwZWN1bGFyQ29uc3RhbnR8c3BlY3VsYXJFeHBvbmVudHxzcGVlZHxzcHJlYWRNZXRob2R8c3RhcnRPZmZzZXR8c3RkRGV2aWF0aW9ufHN0ZW1ofHN0ZW12fHN0aXRjaFRpbGVzfHN0b3BDb2xvcnxzdG9wT3BhY2l0eXxzdHJpa2V0aHJvdWdoUG9zaXRpb258c3RyaWtldGhyb3VnaFRoaWNrbmVzc3xzdHJpbmd8c3Ryb2tlfHN0cm9rZURhc2hhcnJheXxzdHJva2VEYXNob2Zmc2V0fHN0cm9rZUxpbmVjYXB8c3Ryb2tlTGluZWpvaW58c3Ryb2tlTWl0ZXJsaW1pdHxzdHJva2VPcGFjaXR5fHN0cm9rZVdpZHRofHN1cmZhY2VTY2FsZXxzeXN0ZW1MYW5ndWFnZXx0YWJsZVZhbHVlc3x0YXJnZXRYfHRhcmdldFl8dGV4dEFuY2hvcnx0ZXh0RGVjb3JhdGlvbnx0ZXh0UmVuZGVyaW5nfHRleHRMZW5ndGh8dG98dHJhbnNmb3JtfHUxfHUyfHVuZGVybGluZVBvc2l0aW9ufHVuZGVybGluZVRoaWNrbmVzc3x1bmljb2RlfHVuaWNvZGVCaWRpfHVuaWNvZGVSYW5nZXx1bml0c1BlckVtfHZBbHBoYWJldGljfHZIYW5naW5nfHZJZGVvZ3JhcGhpY3x2TWF0aGVtYXRpY2FsfHZhbHVlc3x2ZWN0b3JFZmZlY3R8dmVyc2lvbnx2ZXJ0QWR2WXx2ZXJ0T3JpZ2luWHx2ZXJ0T3JpZ2luWXx2aWV3Qm94fHZpZXdUYXJnZXR8dmlzaWJpbGl0eXx3aWR0aHN8d29yZFNwYWNpbmd8d3JpdGluZ01vZGV8eHx4SGVpZ2h0fHgxfHgyfHhDaGFubmVsU2VsZWN0b3J8eGxpbmtBY3R1YXRlfHhsaW5rQXJjcm9sZXx4bGlua0hyZWZ8eGxpbmtSb2xlfHhsaW5rU2hvd3x4bGlua1RpdGxlfHhsaW5rVHlwZXx4bWxCYXNlfHhtbG5zfHhtbG5zWGxpbmt8eG1sTGFuZ3x4bWxTcGFjZXx5fHkxfHkyfHlDaGFubmVsU2VsZWN0b3J8enx6b29tQW5kUGFufGZvcnxjbGFzc3xhdXRvZm9jdXMpfCgoW0RkXVtBYV1bVHRdW0FhXXxbQWFdW1JyXVtJaV1bQWFdfHgpLS4qKSkkLztcbiAgICBpbmRleCA9IG1lbW9pemVfZXNtX2RlZmF1bHQoXG4gICAgICBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiByZWFjdFByb3BzUmVnZXgudGVzdChwcm9wKSB8fCBwcm9wLmNoYXJDb2RlQXQoMCkgPT09IDExMSAmJiBwcm9wLmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiBwcm9wLmNoYXJDb2RlQXQoMikgPCA5MTtcbiAgICAgIH1cbiAgICApO1xuICAgIGlzX3Byb3BfdmFsaWRfZXNtX2RlZmF1bHQgPSBpbmRleDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzXG52YXIgcmVxdWlyZV90c2xpYiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBfX2V4dGVuZHMzO1xuICAgIHZhciBfX2Fzc2lnbjM7XG4gICAgdmFyIF9fcmVzdDM7XG4gICAgdmFyIF9fZGVjb3JhdGUzO1xuICAgIHZhciBfX3BhcmFtMztcbiAgICB2YXIgX19tZXRhZGF0YTM7XG4gICAgdmFyIF9fYXdhaXRlcjM7XG4gICAgdmFyIF9fZ2VuZXJhdG9yMztcbiAgICB2YXIgX19leHBvcnRTdGFyMztcbiAgICB2YXIgX192YWx1ZXMzO1xuICAgIHZhciBfX3JlYWQzO1xuICAgIHZhciBfX3NwcmVhZDM7XG4gICAgdmFyIF9fc3ByZWFkQXJyYXlzMztcbiAgICB2YXIgX19zcHJlYWRBcnJheTM7XG4gICAgdmFyIF9fYXdhaXQzO1xuICAgIHZhciBfX2FzeW5jR2VuZXJhdG9yMztcbiAgICB2YXIgX19hc3luY0RlbGVnYXRvcjM7XG4gICAgdmFyIF9fYXN5bmNWYWx1ZXMzO1xuICAgIHZhciBfX21ha2VUZW1wbGF0ZU9iamVjdDM7XG4gICAgdmFyIF9faW1wb3J0U3RhcjM7XG4gICAgdmFyIF9faW1wb3J0RGVmYXVsdDM7XG4gICAgdmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQzO1xuICAgIHZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MztcbiAgICB2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEluMztcbiAgICB2YXIgX19jcmVhdGVCaW5kaW5nMztcbiAgICAoZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XG4gICAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFwidHNsaWJcIiwgW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24oZXhwb3J0czIpIHtcbiAgICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMyKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZTIuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZTIuZXhwb3J0cykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlRXhwb3J0ZXIoZXhwb3J0czIsIHByZXZpb3VzKSB7XG4gICAgICAgIGlmIChleHBvcnRzMiAhPT0gcm9vdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBvcnRzMi5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGlkMiwgdikge1xuICAgICAgICAgIHJldHVybiBleHBvcnRzMltpZDJdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZDIsIHYpIDogdjtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KShmdW5jdGlvbihleHBvcnRlcikge1xuICAgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgICAgZDIuX19wcm90b19fID0gYjI7XG4gICAgICB9IHx8IGZ1bmN0aW9uKGQyLCBiMikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBiMilcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIyLCBwMikpXG4gICAgICAgICAgICBkMltwMl0gPSBiMltwMl07XG4gICAgICB9O1xuICAgICAgX19leHRlbmRzMyA9IGZ1bmN0aW9uKGQyLCBiMikge1xuICAgICAgICBpZiAodHlwZW9mIGIyICE9PSBcImZ1bmN0aW9uXCIgJiYgYjIgIT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYjIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkMiwgYjIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDI7XG4gICAgICAgIH1cbiAgICAgICAgZDIucHJvdG90eXBlID0gYjIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIyKSA6IChfXy5wcm90b3R5cGUgPSBiMi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICAgIH07XG4gICAgICBfX2Fzc2lnbjMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaTIgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaTIgPCBuOyBpMisrKSB7XG4gICAgICAgICAgcyA9IGFyZ3VtZW50c1tpMl07XG4gICAgICAgICAgZm9yICh2YXIgcDIgaW4gcylcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcDIpKVxuICAgICAgICAgICAgICB0W3AyXSA9IHNbcDJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfTtcbiAgICAgIF9fcmVzdDMgPSBmdW5jdGlvbihzLCBlKSB7XG4gICAgICAgIHZhciB0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAyIGluIHMpXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwMikgJiYgZS5pbmRleE9mKHAyKSA8IDApXG4gICAgICAgICAgICB0W3AyXSA9IHNbcDJdO1xuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwLCBwMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkyIDwgcDIubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHAyW2kyXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwMltpMl0pKVxuICAgICAgICAgICAgICB0W3AyW2kyXV0gPSBzW3AyW2kyXV07XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH07XG4gICAgICBfX2RlY29yYXRlMyA9IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgICAgIHZhciBjMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjMyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDI7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAodmFyIGkyID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKVxuICAgICAgICAgICAgaWYgKGQyID0gZGVjb3JhdG9yc1tpMl0pXG4gICAgICAgICAgICAgIHIgPSAoYzMgPCAzID8gZDIocikgOiBjMyA+IDMgPyBkMih0YXJnZXQsIGtleSwgcikgOiBkMih0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgICAgIHJldHVybiBjMyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICAgICAgfTtcbiAgICAgIF9fcGFyYW0zID0gZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgX19tZXRhZGF0YTMgPSBmdW5jdGlvbihtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG4gICAgICB9O1xuICAgICAgX19hd2FpdGVyMyA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgX19nZW5lcmF0b3IzID0gZnVuY3Rpb24odGhpc0FyZywgYm9keSkge1xuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0WzBdICYgMSlcbiAgICAgICAgICAgIHRocm93IHRbMV07XG4gICAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICAgIH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYyLCB5LCB0LCBnMjtcbiAgICAgICAgcmV0dXJuIGcyID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnMltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pLCBnMjtcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgICAgaWYgKGYyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgICAgd2hpbGUgKF8pXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoZjIgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgIGlmICh5ID0gMCwgdClcbiAgICAgICAgICAgICAgICBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICBvcCA9IFswXTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKVxuICAgICAgICAgICAgICAgICAgICBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBvcCA9IFs2LCBlXTtcbiAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBmMiA9IHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcFswXSAmIDUpXG4gICAgICAgICAgICB0aHJvdyBvcFsxXTtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19leHBvcnRTdGFyMyA9IGZ1bmN0aW9uKG0sIG8pIHtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gbSlcbiAgICAgICAgICBpZiAocDIgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcDIpKVxuICAgICAgICAgICAgX19jcmVhdGVCaW5kaW5nMyhvLCBtLCBwMik7XG4gICAgICB9O1xuICAgICAgX19jcmVhdGVCaW5kaW5nMyA9IE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbihvLCBtLCBrMiwgazIyKSB7XG4gICAgICAgIGlmIChrMjIgPT09IHZvaWQgMClcbiAgICAgICAgICBrMjIgPSBrMjtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGsyKTtcbiAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1bazJdO1xuICAgICAgICAgIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIyLCBkZXNjKTtcbiAgICAgIH0gOiBmdW5jdGlvbihvLCBtLCBrMiwgazIyKSB7XG4gICAgICAgIGlmIChrMjIgPT09IHZvaWQgMClcbiAgICAgICAgICBrMjIgPSBrMjtcbiAgICAgICAgb1trMjJdID0gbVtrMl07XG4gICAgICB9O1xuICAgICAgX192YWx1ZXMzID0gZnVuY3Rpb24obykge1xuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkyID0gMDtcbiAgICAgICAgaWYgKG0pXG4gICAgICAgICAgcmV0dXJuIG0uY2FsbChvKTtcbiAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKG8gJiYgaTIgPj0gby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpMisrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICB9O1xuICAgICAgX19yZWFkMyA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIHZhciBpMiA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpMi5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGUgPSB7IGVycm9yIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpMltcInJldHVyblwiXSkpXG4gICAgICAgICAgICAgIG0uY2FsbChpMik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXI7XG4gICAgICB9O1xuICAgICAgX19zcHJlYWQzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGFyID0gW10sIGkyID0gMDsgaTIgPCBhcmd1bWVudHMubGVuZ3RoOyBpMisrKVxuICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZDMoYXJndW1lbnRzW2kyXSkpO1xuICAgICAgICByZXR1cm4gYXI7XG4gICAgICB9O1xuICAgICAgX19zcHJlYWRBcnJheXMzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBpMiA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaTIgPCBpbDsgaTIrKylcbiAgICAgICAgICBzICs9IGFyZ3VtZW50c1tpMl0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsyID0gMCwgaTIgPSAwOyBpMiA8IGlsOyBpMisrKVxuICAgICAgICAgIGZvciAodmFyIGEyID0gYXJndW1lbnRzW2kyXSwgaiA9IDAsIGpsID0gYTIubGVuZ3RoOyBqIDwgamw7IGorKywgazIrKylcbiAgICAgICAgICAgIHJbazJdID0gYTJbal07XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICAgIF9fc3ByZWFkQXJyYXkzID0gZnVuY3Rpb24odG8sIGZyb20sIHBhY2spIHtcbiAgICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkyIDwgbDsgaTIrKykge1xuICAgICAgICAgICAgaWYgKGFyIHx8ICEoaTIgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFhcilcbiAgICAgICAgICAgICAgICBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkyKTtcbiAgICAgICAgICAgICAgYXJbaTJdID0gZnJvbVtpMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbiAgICAgIH07XG4gICAgICBfX2F3YWl0MyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0MyA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0Myh2KTtcbiAgICAgIH07XG4gICAgICBfX2FzeW5jR2VuZXJhdG9yMyA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIHZhciBnMiA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaTIsIHEgPSBbXTtcbiAgICAgICAgcmV0dXJuIGkyID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGkyW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBpMjtcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgICAgaWYgKGcyW25dKVxuICAgICAgICAgICAgaTJbbl0gPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihhMiwgYjIpIHtcbiAgICAgICAgICAgICAgICBxLnB1c2goW24sIHYsIGEyLCBiMl0pID4gMSB8fCByZXN1bWUobiwgdik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwKGcyW25dKHYpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZXR0bGUocVswXVszXSwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikge1xuICAgICAgICAgIHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0MyA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmMiwgdikge1xuICAgICAgICAgIGlmIChmMih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aClcbiAgICAgICAgICAgIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fYXN5bmNEZWxlZ2F0b3IzID0gZnVuY3Rpb24obykge1xuICAgICAgICB2YXIgaTIsIHAyO1xuICAgICAgICByZXR1cm4gaTIgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSksIHZlcmIoXCJyZXR1cm5cIiksIGkyW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgaTI7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZjIpIHtcbiAgICAgICAgICBpMltuXSA9IG9bbl0gPyBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gKHAyID0gIXAyKSA/IHsgdmFsdWU6IF9fYXdhaXQzKG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmMiA/IGYyKHYpIDogdjtcbiAgICAgICAgICB9IDogZjI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX2FzeW5jVmFsdWVzMyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpMjtcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlczMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzMyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpMiA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpMltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgaTIpO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICBpMltuXSA9IG9bbl0gJiYgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZDIsIHYpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2Mikge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB2MiwgZG9uZTogZDIgfSk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0MyA9IGZ1bmN0aW9uKGNvb2tlZCwgcmF3KSB7XG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29va2VkLnJhdyA9IHJhdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29va2VkO1xuICAgICAgfTtcbiAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24obywgdikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG4gICAgICB9IDogZnVuY3Rpb24obywgdikge1xuICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICB9O1xuICAgICAgX19pbXBvcnRTdGFyMyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgazIgaW4gbW9kKVxuICAgICAgICAgICAgaWYgKGsyICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrMikpXG4gICAgICAgICAgICAgIF9fY3JlYXRlQmluZGluZzMocmVzdWx0LCBtb2QsIGsyKTtcbiAgICAgICAgfVxuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9faW1wb3J0RGVmYXVsdDMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xuICAgICAgfTtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQzID0gZnVuY3Rpb24ocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmMikge1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYyKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZjIgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgICAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmMiA6IGtpbmQgPT09IFwiYVwiID8gZjIuY2FsbChyZWNlaXZlcikgOiBmMiA/IGYyLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbiAgICAgIH07XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MyA9IGZ1bmN0aW9uKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYyKSB7XG4gICAgICAgIGlmIChraW5kID09PSBcIm1cIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYyKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZjIgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgICAgIHJldHVybiBraW5kID09PSBcImFcIiA/IGYyLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYyID8gZjIudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpLCB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4zID0gZnVuY3Rpb24oc3RhdGUsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCB0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xuICAgICAgfTtcbiAgICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kczMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2Fzc2lnblwiLCBfX2Fzc2lnbjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0Myk7XG4gICAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZTMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3BhcmFtXCIsIF9fcGFyYW0zKTtcbiAgICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhMyk7XG4gICAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19nZW5lcmF0b3JcIiwgX19nZW5lcmF0b3IzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3RhcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NyZWF0ZUJpbmRpbmdcIiwgX19jcmVhdGVCaW5kaW5nMyk7XG4gICAgICBleHBvcnRlcihcIl9fdmFsdWVzXCIsIF9fdmFsdWVzMyk7XG4gICAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheXNcIiwgX19zcHJlYWRBcnJheXMzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5Myk7XG4gICAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIF9fYXN5bmNHZW5lcmF0b3IzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yMyk7XG4gICAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlczMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBfX21ha2VUZW1wbGF0ZU9iamVjdDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyMyk7XG4gICAgICBleHBvcnRlcihcIl9faW1wb3J0RGVmYXVsdFwiLCBfX2ltcG9ydERlZmF1bHQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZEdldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0Myk7XG4gICAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkSW5cIiwgX19jbGFzc1ByaXZhdGVGaWVsZEluMyk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanNcbnZhciByZXF1aXJlX3RzbGliMiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgX19leHRlbmRzMztcbiAgICB2YXIgX19hc3NpZ24zO1xuICAgIHZhciBfX3Jlc3QzO1xuICAgIHZhciBfX2RlY29yYXRlMztcbiAgICB2YXIgX19wYXJhbTM7XG4gICAgdmFyIF9fbWV0YWRhdGEzO1xuICAgIHZhciBfX2F3YWl0ZXIzO1xuICAgIHZhciBfX2dlbmVyYXRvcjM7XG4gICAgdmFyIF9fZXhwb3J0U3RhcjM7XG4gICAgdmFyIF9fdmFsdWVzMztcbiAgICB2YXIgX19yZWFkMztcbiAgICB2YXIgX19zcHJlYWQzO1xuICAgIHZhciBfX3NwcmVhZEFycmF5czM7XG4gICAgdmFyIF9fc3ByZWFkQXJyYXkzO1xuICAgIHZhciBfX2F3YWl0MztcbiAgICB2YXIgX19hc3luY0dlbmVyYXRvcjM7XG4gICAgdmFyIF9fYXN5bmNEZWxlZ2F0b3IzO1xuICAgIHZhciBfX2FzeW5jVmFsdWVzMztcbiAgICB2YXIgX19tYWtlVGVtcGxhdGVPYmplY3QzO1xuICAgIHZhciBfX2ltcG9ydFN0YXIzO1xuICAgIHZhciBfX2ltcG9ydERlZmF1bHQzO1xuICAgIHZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MztcbiAgICB2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDM7XG4gICAgdmFyIF9fY2xhc3NQcml2YXRlRmllbGRJbjM7XG4gICAgdmFyIF9fY3JlYXRlQmluZGluZzM7XG4gICAgKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xuICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uKGV4cG9ydHMyKSB7XG4gICAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzMikpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUyLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihtb2R1bGUyLmV4cG9ydHMpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMyLCBwcmV2aW91cykge1xuICAgICAgICBpZiAoZXhwb3J0czIgIT09IHJvb3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwb3J0czIuX19lc01vZHVsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpZDIsIHYpIHtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0czJbaWQyXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQyLCB2KSA6IHY7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSkoZnVuY3Rpb24oZXhwb3J0ZXIpIHtcbiAgICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgIGQyLl9fcHJvdG9fXyA9IGIyO1xuICAgICAgfSB8fCBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gYjIpXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiMiwgcDIpKVxuICAgICAgICAgICAgZDJbcDJdID0gYjJbcDJdO1xuICAgICAgfTtcbiAgICAgIF9fZXh0ZW5kczMgPSBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiMiAhPT0gXCJmdW5jdGlvblwiICYmIGIyICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIyKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZDIsIGIyKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQyO1xuICAgICAgICB9XG4gICAgICAgIGQyLnByb3RvdHlwZSA9IGIyID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiMikgOiAoX18ucHJvdG90eXBlID0gYjIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgICB9O1xuICAgICAgX19hc3NpZ24zID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkyID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkyIDwgbjsgaTIrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaTJdO1xuICAgICAgICAgIGZvciAodmFyIHAyIGluIHMpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHAyKSlcbiAgICAgICAgICAgICAgdFtwMl0gPSBzW3AyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH07XG4gICAgICBfX3Jlc3QzID0gZnVuY3Rpb24ocywgZSkge1xuICAgICAgICB2YXIgdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBzKVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcDIpICYmIGUuaW5kZXhPZihwMikgPCAwKVxuICAgICAgICAgICAgdFtwMl0gPSBzW3AyXTtcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIGZvciAodmFyIGkyID0gMCwgcDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpMiA8IHAyLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwMltpMl0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcDJbaTJdKSlcbiAgICAgICAgICAgICAgdFtwMltpMl1dID0gc1twMltpMl1dO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9O1xuICAgICAgX19kZWNvcmF0ZTMgPSBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgICAgICB2YXIgYzMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYzMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQyO1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSlcbiAgICAgICAgICAgIGlmIChkMiA9IGRlY29yYXRvcnNbaTJdKVxuICAgICAgICAgICAgICByID0gKGMzIDwgMyA/IGQyKHIpIDogYzMgPiAzID8gZDIodGFyZ2V0LCBrZXksIHIpIDogZDIodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgICAgICByZXR1cm4gYzMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgICAgIH07XG4gICAgICBfX3BhcmFtMyA9IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIF9fbWV0YWRhdGEzID0gZnVuY3Rpb24obWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xuICAgICAgfTtcbiAgICAgIF9fYXdhaXRlcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIF9fZ2VuZXJhdG9yMyA9IGZ1bmN0aW9uKHRoaXNBcmcsIGJvZHkpIHtcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodFswXSAmIDEpXG4gICAgICAgICAgICB0aHJvdyB0WzFdO1xuICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmMiwgeSwgdCwgZzI7XG4gICAgICAgIHJldHVybiBnMiA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZzJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KSwgZzI7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICAgIGlmIChmMilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICAgIHdoaWxlIChnMiAmJiAoZzIgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXylcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChmMiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KVxuICAgICAgICAgICAgICAgIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pXG4gICAgICAgICAgICAgICAgICAgIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGYyID0gdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wWzBdICYgNSlcbiAgICAgICAgICAgIHRocm93IG9wWzFdO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX2V4cG9ydFN0YXIzID0gZnVuY3Rpb24obSwgbykge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBtKVxuICAgICAgICAgIGlmIChwMiAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwMikpXG4gICAgICAgICAgICBfX2NyZWF0ZUJpbmRpbmczKG8sIG0sIHAyKTtcbiAgICAgIH07XG4gICAgICBfX2NyZWF0ZUJpbmRpbmczID0gT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uKG8sIG0sIGsyLCBrMjIpIHtcbiAgICAgICAgaWYgKGsyMiA9PT0gdm9pZCAwKVxuICAgICAgICAgIGsyMiA9IGsyO1xuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgazIpO1xuICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbVtrMl07XG4gICAgICAgICAgfSB9O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMjIsIGRlc2MpO1xuICAgICAgfSA6IGZ1bmN0aW9uKG8sIG0sIGsyLCBrMjIpIHtcbiAgICAgICAgaWYgKGsyMiA9PT0gdm9pZCAwKVxuICAgICAgICAgIGsyMiA9IGsyO1xuICAgICAgICBvW2syMl0gPSBtW2syXTtcbiAgICAgIH07XG4gICAgICBfX3ZhbHVlczMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaTIgPSAwO1xuICAgICAgICBpZiAobSlcbiAgICAgICAgICByZXR1cm4gbS5jYWxsKG8pO1xuICAgICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAobyAmJiBpMiA+PSBvLmxlbmd0aClcbiAgICAgICAgICAgICAgICBvID0gdm9pZCAwO1xuICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2kyKytdLCBkb25lOiAhbyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIH07XG4gICAgICBfX3JlYWQzID0gZnVuY3Rpb24obywgbikge1xuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICAgIGlmICghbSlcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgdmFyIGkyID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkyLm5leHQoKSkuZG9uZSlcbiAgICAgICAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgZSA9IHsgZXJyb3IgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGkyW1wicmV0dXJuXCJdKSlcbiAgICAgICAgICAgICAgbS5jYWxsKGkyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcjtcbiAgICAgIH07XG4gICAgICBfX3NwcmVhZDMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaTIgPSAwOyBpMiA8IGFyZ3VtZW50cy5sZW5ndGg7IGkyKyspXG4gICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkMyhhcmd1bWVudHNbaTJdKSk7XG4gICAgICAgIHJldHVybiBhcjtcbiAgICAgIH07XG4gICAgICBfX3NwcmVhZEFycmF5czMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkyID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpMiA8IGlsOyBpMisrKVxuICAgICAgICAgIHMgKz0gYXJndW1lbnRzW2kyXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgazIgPSAwLCBpMiA9IDA7IGkyIDwgaWw7IGkyKyspXG4gICAgICAgICAgZm9yICh2YXIgYTIgPSBhcmd1bWVudHNbaTJdLCBqID0gMCwgamwgPSBhMi5sZW5ndGg7IGogPCBqbDsgaisrLCBrMisrKVxuICAgICAgICAgICAgcltrMl0gPSBhMltqXTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgICAgX19zcHJlYWRBcnJheTMgPSBmdW5jdGlvbih0bywgZnJvbSwgcGFjaykge1xuICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgICAgIGZvciAodmFyIGkyID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaTIgPCBsOyBpMisrKSB7XG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpMiBpbiBmcm9tKSkge1xuICAgICAgICAgICAgICBpZiAoIWFyKVxuICAgICAgICAgICAgICAgIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaTIpO1xuICAgICAgICAgICAgICBhcltpMl0gPSBmcm9tW2kyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xuICAgICAgfTtcbiAgICAgIF9fYXdhaXQzID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQzID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQzKHYpO1xuICAgICAgfTtcbiAgICAgIF9fYXN5bmNHZW5lcmF0b3IzID0gZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgdmFyIGcyID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpMiwgcSA9IFtdO1xuICAgICAgICByZXR1cm4gaTIgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaTJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGkyO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICBpZiAoZzJbbl0pXG4gICAgICAgICAgICBpMltuXSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGEyLCBiMikge1xuICAgICAgICAgICAgICAgIHEucHVzaChbbiwgdiwgYTIsIGIyXSkgPiAxIHx8IHJlc3VtZShuLCB2KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZzJbbl0odikpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHNldHRsZShxWzBdWzNdLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7XG4gICAgICAgICAgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQzID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICAgICAgICByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHtcbiAgICAgICAgICByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYyLCB2KSB7XG4gICAgICAgICAgaWYgKGYyKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKVxuICAgICAgICAgICAgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19hc3luY0RlbGVnYXRvcjMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBpMiwgcDI7XG4gICAgICAgIHJldHVybiBpMiA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KSwgdmVyYihcInJldHVyblwiKSwgaTJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBpMjtcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmMikge1xuICAgICAgICAgIGkyW25dID0gb1tuXSA/IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiAocDIgPSAhcDIpID8geyB2YWx1ZTogX19hd2FpdDMob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYyID8gZjIodikgOiB2O1xuICAgICAgICAgIH0gOiBmMjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fYXN5bmNWYWx1ZXMzID0gZnVuY3Rpb24obykge1xuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGkyO1xuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzMyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkyID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGkyW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBpMik7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICAgIGkyW25dID0gb1tuXSAmJiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkMiwgdikge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYyKSB7XG4gICAgICAgICAgICByZXNvbHZlKHsgdmFsdWU6IHYyLCBkb25lOiBkMiB9KTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19tYWtlVGVtcGxhdGVPYmplY3QzID0gZnVuY3Rpb24oY29va2VkLCByYXcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb29rZWQucmF3ID0gcmF3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29rZWQ7XG4gICAgICB9O1xuICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbihvLCB2KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbiAgICAgIH0gOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgIH07XG4gICAgICBfX2ltcG9ydFN0YXIzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBrMiBpbiBtb2QpXG4gICAgICAgICAgICBpZiAoazIgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGsyKSlcbiAgICAgICAgICAgICAgX19jcmVhdGVCaW5kaW5nMyhyZXN1bHQsIG1vZCwgazIpO1xuICAgICAgICB9XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX19pbXBvcnREZWZhdWx0MyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG4gICAgICB9O1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldDMgPSBmdW5jdGlvbihyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYyKSB7XG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZjIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmMiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYyIDoga2luZCA9PT0gXCJhXCIgPyBmMi5jYWxsKHJlY2VpdmVyKSA6IGYyID8gZjIudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xuICAgICAgfTtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQzID0gZnVuY3Rpb24ocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZjIpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwibVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZjIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmMiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwiYVwiID8gZjIuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZjIgPyBmMi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSksIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRJbjMgPSBmdW5jdGlvbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8IHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG4gICAgICB9O1xuICAgICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzMyk7XG4gICAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduMyk7XG4gICAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlMyk7XG4gICAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbTMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyMyk7XG4gICAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmczKTtcbiAgICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19yZWFkXCIsIF9fcmVhZDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5c1wiLCBfX3NwcmVhZEFycmF5czMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5XCIsIF9fc3ByZWFkQXJyYXkzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0Myk7XG4gICAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzMyk7XG4gICAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0Myk7XG4gICAgICBleHBvcnRlcihcIl9faW1wb3J0U3RhclwiLCBfX2ltcG9ydFN0YXIzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZFNldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0Myk7XG4gICAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRJblwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4zKTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c3hcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgRm9vdGVyOiAoKSA9PiBGb290ZXIsXG4gIExpc3RQeWxhcjogKCkgPT4gTGlzdFB5bGFyLFxuICBNZW51OiAoKSA9PiBNZW51LFxuICBNZW51UHlsYXI6ICgpID0+IE1lbnVQeWxhcixcbiAgU2Nyb2xsYWJsZTogKCkgPT4gU2Nyb2xsYWJsZSxcbiAgVGl0bGVQeWxhcjogKCkgPT4gVGl0bGVQeWxhcixcbiAgVmVyc2lvbjogKCkgPT4gVmVyc2lvbixcbiAgYmxvZzogKCkgPT4gYmxvZyxcbiAgcG9zdDEyMDMyMDIyOiAoKSA9PiBwb3N0MTIwMzIwMjJcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbWVzaGdyYWQvZGlzdC9pbmRleC5tanNcbnZhciBpID0gKCkgPT4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMzYwKTtcbnZhciBjID0gKG4pID0+IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChuICogMTAwKSAlIDEwMCk7XG52YXIgZyA9IChuLCB0LCBlKSA9PiBNYXRoLnJvdW5kKHQgLyBlICogKG4gKiAxMDApICUgMTAwKTtcbnZhciBkID0gKG4pID0+IHtcbiAgaWYgKCEhbikge1xuICAgIG4gPSBuLnJlcGxhY2UoLyMvZywgXCJcIiksIG4ubGVuZ3RoID09PSAzICYmIChuID0gbi5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24oYjIpIHtcbiAgICAgIHJldHVybiBiMiArIGIyO1xuICAgIH0pLmpvaW4oXCJcIikpO1xuICAgIHZhciB0ID0gL14oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSlbXFxkYS16XXswLDB9JC9pLmV4ZWMobik7XG4gICAgaWYgKCEhdCkge1xuICAgICAgdmFyIGUgPSBwYXJzZUludCh0WzFdLCAxNiksIHIgPSBwYXJzZUludCh0WzJdLCAxNiksIGEyID0gcGFyc2VJbnQodFszXSwgMTYpO1xuICAgICAgZSAvPSAyNTUsIHIgLz0gMjU1LCBhMiAvPSAyNTU7XG4gICAgICB2YXIgbyA9IE1hdGgubWF4KGUsIHIsIGEyKSwgcyA9IE1hdGgubWluKGUsIHIsIGEyKSwgdSA9IChvICsgcykgLyAyO1xuICAgICAgaWYgKG8gPT0gcylcbiAgICAgICAgdSA9IDA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIG0gPSBvIC0gcztcbiAgICAgICAgc3dpdGNoIChvKSB7XG4gICAgICAgICAgY2FzZSBlOlxuICAgICAgICAgICAgdSA9IChyIC0gYTIpIC8gbSArIChyIDwgYTIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICB1ID0gKGEyIC0gZSkgLyBtICsgMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYTI6XG4gICAgICAgICAgICB1ID0gKGUgLSByKSAvIG0gKyA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdSAvPSA2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHUgPSBNYXRoLnJvdW5kKDM2MCAqIHUpLCB1O1xuICAgIH1cbiAgfVxufTtcbnZhciBwID0gKG4sIHQpID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IG4gfSwgKGUsIHIpID0+IHIgPT09IDAgPyBgaHNsKCR7dH0sIDEwMCUsIDgwJSlgIDogciA8IG4gLyAxLjQgPyBgaHNsKCR7dCAtIDMwICogKDEgLSAyICogKHIgJSAyKSkgKiAociA+IDIgPyByIC8gMiA6IHIpfSwgMTAwJSwgJHs3NiAtIHIgKiAoMSAtIDIgKiAociAlIDIpKSAqIDEuNzV9JSlgIDogYGhzbCgke3QgLSAxNTAgKiAoMSAtIDIgKiAociAlIDIpKX0sIDEwMCUsICR7NzYgLSByICogKDEgLSAyICogKHIgJSAyKSkgKiAxLjI1fSUpYCk7XG52YXIgTSA9IChuLCB0LCBlKSA9PiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sIChyLCBhMikgPT4gYHJhZGlhbC1ncmFkaWVudChhdCAke2UgPyBnKGEyLCBlLCBuKSA6IGMoYTIpfSUgJHtlID8gZyhhMiAqIDEwLCBlLCBuKSA6IGMoYTIgKiAxMCl9JSwgJHt0W2EyXX0gMHB4LCB0cmFuc3BhcmVudCA1MCUpXG5gKTtcbnZhciBmID0gKG4sIHQsIGUpID0+IHtcbiAgbGV0IHIgPSBwKG4sIHQgfHwgaSgpKSwgYTIgPSBNKG4sIHIsIGUgfHwgdm9pZCAwKTtcbiAgcmV0dXJuIFtyWzBdLCBhMi5qb2luKFwiLFwiKV07XG59O1xudmFyIGsgPSAobiwgdCwgZSkgPT4ge1xuICBsZXQgW3IsIGEyXSA9IGYobiwgZCh0KSA/IGQodCkgOiB2b2lkIDAsIGUgfHwgdm9pZCAwKTtcbiAgcmV0dXJuIHsgYmFja2dyb3VuZENvbG9yOiByLCBiYWNrZ3JvdW5kSW1hZ2U6IGEyIH07XG59O1xuXG4vLyBzcmMvVmVyc2lvbi50c3hcbnZhciBpbXBvcnRfanN4X3J1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgRUxFTUVOVFMgPSA4O1xudmFyIFZlcnNpb24gPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZS5qc3gpKFwiYnV0dG9uXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibS0yIGhpZGRlbiByb3VuZGVkLWZ1bGwgcHktMiBweC00IHRleHQteHMgZm9udC1ib2xkIHRleHQtYmxhY2sgc2hhZG93LW1kIGhvdmVyOnNoYWRvdy14bCBtZDpibG9ja1wiLFxuICAgIHN0eWxlOiBrKEVMRU1FTlRTKSxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUuanN4KShcImFcIiwge1xuICAgICAgaHJlZjogXCJodHRwOi8vZ2l0aHViLmNvbS9taWd1ZWxnYXJnYWxsby9uZXh0MTMtZ2FsbGVyeS1pbWFnZS10dXJib1wiLFxuICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgIGNoaWxkcmVuOiBcInYxLjAuMVwiXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9pbmRleC5tanNcbnZhciBSZWFjdCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpLCAxKTtcbnZhciBpbXBvcnRfcmVhY3QxMyA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzXG52YXIgaW1wb3J0X3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIE1vdGlvbkNvbmZpZ0NvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0LmNyZWF0ZUNvbnRleHQpKHtcbiAgdHJhbnNmb3JtUGFnZVBvaW50OiAocDIpID0+IHAyLFxuICBpc1N0YXRpYzogZmFsc2UsXG4gIHJlZHVjZWRNb3Rpb246IFwibmV2ZXJcIlxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qc1xudmFyIGltcG9ydF9yZWFjdDIgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgTW90aW9uQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QyLmNyZWF0ZUNvbnRleHQpKHt9KTtcbmZ1bmN0aW9uIHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0KCkge1xuICByZXR1cm4gKDAsIGltcG9ydF9yZWFjdDIudXNlQ29udGV4dCkoTW90aW9uQ29udGV4dCkudmlzdWFsRWxlbWVudDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1lbGVtZW50Lm1qc1xudmFyIGltcG9ydF9yZWFjdDYgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzXG52YXIgaW1wb3J0X3JlYWN0MyA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBQcmVzZW5jZUNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0My5jcmVhdGVDb250ZXh0KShudWxsKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtaXNvbW9ycGhpYy1lZmZlY3QubWpzXG52YXIgaW1wb3J0X3JlYWN0NCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pcy1icm93c2VyLm1qc1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtaXNvbW9ycGhpYy1lZmZlY3QubWpzXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGlzQnJvd3NlciA/IGltcG9ydF9yZWFjdDQudXNlTGF5b3V0RWZmZWN0IDogaW1wb3J0X3JlYWN0NC51c2VFZmZlY3Q7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9MYXp5Q29udGV4dC5tanNcbnZhciBpbXBvcnRfcmVhY3Q1ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIExhenlDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDUuY3JlYXRlQ29udGV4dCkoeyBzdHJpY3Q6IGZhbHNlIH0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLWVsZW1lbnQubWpzXG5mdW5jdGlvbiB1c2VWaXN1YWxFbGVtZW50KENvbXBvbmVudCwgdmlzdWFsU3RhdGUsIHByb3BzLCBjcmVhdGVWaXN1YWxFbGVtZW50KSB7XG4gIGNvbnN0IHBhcmVudCA9IHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0KCk7XG4gIGNvbnN0IGxhenlDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDYudXNlQ29udGV4dCkoTGF6eUNvbnRleHQpO1xuICBjb25zdCBwcmVzZW5jZUNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0Ni51c2VDb250ZXh0KShQcmVzZW5jZUNvbnRleHQpO1xuICBjb25zdCByZWR1Y2VkTW90aW9uQ29uZmlnID0gKDAsIGltcG9ydF9yZWFjdDYudXNlQ29udGV4dCkoTW90aW9uQ29uZmlnQ29udGV4dCkucmVkdWNlZE1vdGlvbjtcbiAgY29uc3QgdmlzdWFsRWxlbWVudFJlZiA9ICgwLCBpbXBvcnRfcmVhY3Q2LnVzZVJlZikoKTtcbiAgY3JlYXRlVmlzdWFsRWxlbWVudCA9IGNyZWF0ZVZpc3VhbEVsZW1lbnQgfHwgbGF6eUNvbnRleHQucmVuZGVyZXI7XG4gIGlmICghdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50ICYmIGNyZWF0ZVZpc3VhbEVsZW1lbnQpIHtcbiAgICB2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQgPSBjcmVhdGVWaXN1YWxFbGVtZW50KENvbXBvbmVudCwge1xuICAgICAgdmlzdWFsU3RhdGUsXG4gICAgICBwYXJlbnQsXG4gICAgICBwcm9wcyxcbiAgICAgIHByZXNlbmNlSWQ6IHByZXNlbmNlQ29udGV4dCA/IHByZXNlbmNlQ29udGV4dC5pZCA6IHZvaWQgMCxcbiAgICAgIGJsb2NrSW5pdGlhbEFuaW1hdGlvbjogcHJlc2VuY2VDb250ZXh0ID8gcHJlc2VuY2VDb250ZXh0LmluaXRpYWwgPT09IGZhbHNlIDogZmFsc2UsXG4gICAgICByZWR1Y2VkTW90aW9uQ29uZmlnXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnRSZWYuY3VycmVudDtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmlzdWFsRWxlbWVudCAmJiB2aXN1YWxFbGVtZW50LnJlbmRlcigpO1xuICB9KTtcbiAgKDAsIGltcG9ydF9yZWFjdDYudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgaWYgKHZpc3VhbEVsZW1lbnQgJiYgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkge1xuICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5hbmltYXRlQ2hhbmdlcygpO1xuICAgIH1cbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gKCkgPT4gdmlzdWFsRWxlbWVudCAmJiB2aXN1YWxFbGVtZW50Lm5vdGlmeShcIlVubW91bnRcIiksIFtdKTtcbiAgcmV0dXJuIHZpc3VhbEVsZW1lbnQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3VzZS1tb3Rpb24tcmVmLm1qc1xudmFyIGltcG9ydF9yZWFjdDcgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtcmVmLW9iamVjdC5tanNcbmZ1bmN0aW9uIGlzUmVmT2JqZWN0KHJlZikge1xuICByZXR1cm4gdHlwZW9mIHJlZiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVmLCBcImN1cnJlbnRcIik7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3VzZS1tb3Rpb24tcmVmLm1qc1xuZnVuY3Rpb24gdXNlTW90aW9uUmVmKHZpc3VhbFN0YXRlLCB2aXN1YWxFbGVtZW50LCBleHRlcm5hbFJlZikge1xuICByZXR1cm4gKDAsIGltcG9ydF9yZWFjdDcudXNlQ2FsbGJhY2spKFxuICAgIChpbnN0YW5jZSkgPT4ge1xuICAgICAgaW5zdGFuY2UgJiYgdmlzdWFsU3RhdGUubW91bnQgJiYgdmlzdWFsU3RhdGUubW91bnQoaW5zdGFuY2UpO1xuICAgICAgaWYgKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgaW5zdGFuY2UgPyB2aXN1YWxFbGVtZW50Lm1vdW50KGluc3RhbmNlKSA6IHZpc3VhbEVsZW1lbnQudW5tb3VudCgpO1xuICAgICAgfVxuICAgICAgaWYgKGV4dGVybmFsUmVmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXh0ZXJuYWxSZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGV4dGVybmFsUmVmKGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlZk9iamVjdChleHRlcm5hbFJlZikpIHtcbiAgICAgICAgICBleHRlcm5hbFJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFt2aXN1YWxFbGVtZW50XVxuICApO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29udGV4dC9jcmVhdGUubWpzXG52YXIgaW1wb3J0X3JlYWN0OCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvaXMtdmFyaWFudC1sYWJlbC5tanNcbmZ1bmN0aW9uIGlzVmFyaWFudExhYmVsKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkodik7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGlvbi1jb250cm9scy5tanNcbmZ1bmN0aW9uIGlzQW5pbWF0aW9uQ29udHJvbHModikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHYuc3RhcnQgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvaXMtY29udHJvbGxpbmctdmFyaWFudHMubWpzXG52YXIgdmFyaWFudFByb3BzID0gW1xuICBcImluaXRpYWxcIixcbiAgXCJhbmltYXRlXCIsXG4gIFwiZXhpdFwiLFxuICBcIndoaWxlSG92ZXJcIixcbiAgXCJ3aGlsZURyYWdcIixcbiAgXCJ3aGlsZVRhcFwiLFxuICBcIndoaWxlRm9jdXNcIixcbiAgXCJ3aGlsZUluVmlld1wiXG5dO1xuZnVuY3Rpb24gaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSB7XG4gIHJldHVybiBpc0FuaW1hdGlvbkNvbnRyb2xzKHByb3BzLmFuaW1hdGUpIHx8IHZhcmlhbnRQcm9wcy5zb21lKChuYW1lKSA9PiBpc1ZhcmlhbnRMYWJlbChwcm9wc1tuYW1lXSkpO1xufVxuZnVuY3Rpb24gaXNWYXJpYW50Tm9kZShwcm9wcykge1xuICByZXR1cm4gQm9vbGVhbihpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpIHx8IHByb3BzLnZhcmlhbnRzKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbnRleHQvdXRpbHMubWpzXG5mdW5jdGlvbiBnZXRDdXJyZW50VHJlZVZhcmlhbnRzKHByb3BzLCBjb250ZXh0KSB7XG4gIGlmIChpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpKSB7XG4gICAgY29uc3QgeyBpbml0aWFsLCBhbmltYXRlOiBhbmltYXRlMyB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXRpYWw6IGluaXRpYWwgPT09IGZhbHNlIHx8IGlzVmFyaWFudExhYmVsKGluaXRpYWwpID8gaW5pdGlhbCA6IHZvaWQgMCxcbiAgICAgIGFuaW1hdGU6IGlzVmFyaWFudExhYmVsKGFuaW1hdGUzKSA/IGFuaW1hdGUzIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcHJvcHMuaW5oZXJpdCAhPT0gZmFsc2UgPyBjb250ZXh0IDoge307XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db250ZXh0L2NyZWF0ZS5tanNcbmZ1bmN0aW9uIHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQocHJvcHMpIHtcbiAgY29uc3QgeyBpbml0aWFsLCBhbmltYXRlOiBhbmltYXRlMyB9ID0gZ2V0Q3VycmVudFRyZWVWYXJpYW50cyhwcm9wcywgKDAsIGltcG9ydF9yZWFjdDgudXNlQ29udGV4dCkoTW90aW9uQ29udGV4dCkpO1xuICByZXR1cm4gKDAsIGltcG9ydF9yZWFjdDgudXNlTWVtbykoKCkgPT4gKHsgaW5pdGlhbCwgYW5pbWF0ZTogYW5pbWF0ZTMgfSksIFt2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KGluaXRpYWwpLCB2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KGFuaW1hdGUzKV0pO1xufVxuZnVuY3Rpb24gdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShwcm9wKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHByb3ApID8gcHJvcC5qb2luKFwiIFwiKSA6IHByb3A7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2RlZmluaXRpb25zLm1qc1xudmFyIGNyZWF0ZURlZmluaXRpb24gPSAocHJvcE5hbWVzKSA9PiAoe1xuICBpc0VuYWJsZWQ6IChwcm9wcykgPT4gcHJvcE5hbWVzLnNvbWUoKG5hbWUpID0+ICEhcHJvcHNbbmFtZV0pXG59KTtcbnZhciBmZWF0dXJlRGVmaW5pdGlvbnMgPSB7XG4gIG1lYXN1cmVMYXlvdXQ6IGNyZWF0ZURlZmluaXRpb24oW1wibGF5b3V0XCIsIFwibGF5b3V0SWRcIiwgXCJkcmFnXCJdKSxcbiAgYW5pbWF0aW9uOiBjcmVhdGVEZWZpbml0aW9uKFtcbiAgICBcImFuaW1hdGVcIixcbiAgICBcImV4aXRcIixcbiAgICBcInZhcmlhbnRzXCIsXG4gICAgXCJ3aGlsZUhvdmVyXCIsXG4gICAgXCJ3aGlsZVRhcFwiLFxuICAgIFwid2hpbGVGb2N1c1wiLFxuICAgIFwid2hpbGVEcmFnXCIsXG4gICAgXCJ3aGlsZUluVmlld1wiXG4gIF0pLFxuICBleGl0OiBjcmVhdGVEZWZpbml0aW9uKFtcImV4aXRcIl0pLFxuICBkcmFnOiBjcmVhdGVEZWZpbml0aW9uKFtcImRyYWdcIiwgXCJkcmFnQ29udHJvbHNcIl0pLFxuICBmb2N1czogY3JlYXRlRGVmaW5pdGlvbihbXCJ3aGlsZUZvY3VzXCJdKSxcbiAgaG92ZXI6IGNyZWF0ZURlZmluaXRpb24oW1wid2hpbGVIb3ZlclwiLCBcIm9uSG92ZXJTdGFydFwiLCBcIm9uSG92ZXJFbmRcIl0pLFxuICB0YXA6IGNyZWF0ZURlZmluaXRpb24oW1wid2hpbGVUYXBcIiwgXCJvblRhcFwiLCBcIm9uVGFwU3RhcnRcIiwgXCJvblRhcENhbmNlbFwiXSksXG4gIHBhbjogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgXCJvblBhblwiLFxuICAgIFwib25QYW5TdGFydFwiLFxuICAgIFwib25QYW5TZXNzaW9uU3RhcnRcIixcbiAgICBcIm9uUGFuRW5kXCJcbiAgXSksXG4gIGluVmlldzogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgXCJ3aGlsZUluVmlld1wiLFxuICAgIFwib25WaWV3cG9ydEVudGVyXCIsXG4gICAgXCJvblZpZXdwb3J0TGVhdmVcIlxuICBdKVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvbG9hZC1mZWF0dXJlcy5tanNcbmZ1bmN0aW9uIGxvYWRGZWF0dXJlcyhmZWF0dXJlcykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBmZWF0dXJlcykge1xuICAgIGlmIChrZXkgPT09IFwicHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvclwiKSB7XG4gICAgICBmZWF0dXJlRGVmaW5pdGlvbnMucHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciA9IGZlYXR1cmVzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZlYXR1cmVEZWZpbml0aW9uc1trZXldLkNvbXBvbmVudCA9IGZlYXR1cmVzW2tleV07XG4gICAgfVxuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWNvbnN0YW50Lm1qc1xudmFyIGltcG9ydF9yZWFjdDkgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiB1c2VDb25zdGFudChpbml0KSB7XG4gIGNvbnN0IHJlZiA9ICgwLCBpbXBvcnRfcmVhY3Q5LnVzZVJlZikobnVsbCk7XG4gIGlmIChyZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHJlZi5jdXJyZW50ID0gaW5pdCgpO1xuICB9XG4gIHJldHVybiByZWYuY3VycmVudDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvc3RhdGUubWpzXG52YXIgZ2xvYmFsUHJvamVjdGlvblN0YXRlID0ge1xuICBoYXNBbmltYXRlZFNpbmNlUmVzaXplOiB0cnVlLFxuICBoYXNFdmVyVXBkYXRlZDogZmFsc2Vcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL2lkLm1qc1xudmFyIGlkID0gMTtcbmZ1bmN0aW9uIHVzZVByb2plY3Rpb25JZCgpIHtcbiAgcmV0dXJuIHVzZUNvbnN0YW50KCgpID0+IHtcbiAgICBpZiAoZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0V2ZXJVcGRhdGVkKSB7XG4gICAgICByZXR1cm4gaWQrKztcbiAgICB9XG4gIH0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTGF5b3V0R3JvdXBDb250ZXh0Lm1qc1xudmFyIGltcG9ydF9yZWFjdDEwID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIExheW91dEdyb3VwQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QxMC5jcmVhdGVDb250ZXh0KSh7fSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL1Zpc3VhbEVsZW1lbnRIYW5kbGVyLm1qc1xudmFyIGltcG9ydF9yZWFjdDExID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIiksIDEpO1xudmFyIFZpc3VhbEVsZW1lbnRIYW5kbGVyID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfcmVhY3QxMS5kZWZhdWx0LkNvbXBvbmVudCB7XG4gIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkge1xuICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCwgcHJvcHMgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHZpc3VhbEVsZW1lbnQpXG4gICAgICB2aXN1YWxFbGVtZW50LnNldFByb3BzKHByb3BzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0Lm1qc1xudmFyIGltcG9ydF9yZWFjdDEyID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIFN3aXRjaExheW91dEdyb3VwQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QxMi5jcmVhdGVDb250ZXh0KSh7fSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3N5bWJvbC5tanNcbnZhciBtb3Rpb25Db21wb25lbnRTeW1ib2wgPSBTeW1ib2wuZm9yKFwibW90aW9uQ29tcG9uZW50U3ltYm9sXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9pbmRleC5tanNcbmZ1bmN0aW9uIGNyZWF0ZU1vdGlvbkNvbXBvbmVudCh7IHByZWxvYWRlZEZlYXR1cmVzLCBjcmVhdGVWaXN1YWxFbGVtZW50LCBwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yLCB1c2VSZW5kZXIsIHVzZVZpc3VhbFN0YXRlLCBDb21wb25lbnQgfSkge1xuICBwcmVsb2FkZWRGZWF0dXJlcyAmJiBsb2FkRmVhdHVyZXMocHJlbG9hZGVkRmVhdHVyZXMpO1xuICBmdW5jdGlvbiBNb3Rpb25Db21wb25lbnQocHJvcHMsIGV4dGVybmFsUmVmKSB7XG4gICAgY29uc3QgY29uZmlnQW5kUHJvcHMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCAoMCwgaW1wb3J0X3JlYWN0MTMudXNlQ29udGV4dCkoTW90aW9uQ29uZmlnQ29udGV4dCkpLCBwcm9wcyksIHtcbiAgICAgIGxheW91dElkOiB1c2VMYXlvdXRJZChwcm9wcylcbiAgICB9KTtcbiAgICBjb25zdCB7IGlzU3RhdGljIH0gPSBjb25maWdBbmRQcm9wcztcbiAgICBsZXQgZmVhdHVyZXMgPSBudWxsO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDcmVhdGVNb3Rpb25Db250ZXh0KHByb3BzKTtcbiAgICBjb25zdCBwcm9qZWN0aW9uSWQgPSBpc1N0YXRpYyA/IHZvaWQgMCA6IHVzZVByb2plY3Rpb25JZCgpO1xuICAgIGNvbnN0IHZpc3VhbFN0YXRlID0gdXNlVmlzdWFsU3RhdGUocHJvcHMsIGlzU3RhdGljKTtcbiAgICBpZiAoIWlzU3RhdGljICYmIGlzQnJvd3Nlcikge1xuICAgICAgY29udGV4dC52aXN1YWxFbGVtZW50ID0gdXNlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHZpc3VhbFN0YXRlLCBjb25maWdBbmRQcm9wcywgY3JlYXRlVmlzdWFsRWxlbWVudCk7XG4gICAgICBjb25zdCBsYXp5U3RyaWN0TW9kZSA9ICgwLCBpbXBvcnRfcmVhY3QxMy51c2VDb250ZXh0KShMYXp5Q29udGV4dCkuc3RyaWN0O1xuICAgICAgY29uc3QgaW5pdGlhbExheW91dEdyb3VwQ29uZmlnID0gKDAsIGltcG9ydF9yZWFjdDEzLnVzZUNvbnRleHQpKFN3aXRjaExheW91dEdyb3VwQ29udGV4dCk7XG4gICAgICBpZiAoY29udGV4dC52aXN1YWxFbGVtZW50KSB7XG4gICAgICAgIGZlYXR1cmVzID0gY29udGV4dC52aXN1YWxFbGVtZW50LmxvYWRGZWF0dXJlcyhcbiAgICAgICAgICBjb25maWdBbmRQcm9wcyxcbiAgICAgICAgICBsYXp5U3RyaWN0TW9kZSxcbiAgICAgICAgICBwcmVsb2FkZWRGZWF0dXJlcyxcbiAgICAgICAgICBwcm9qZWN0aW9uSWQsXG4gICAgICAgICAgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciB8fCBmZWF0dXJlRGVmaW5pdGlvbnMucHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvcixcbiAgICAgICAgICBpbml0aWFsTGF5b3V0R3JvdXBDb25maWdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBWaXN1YWxFbGVtZW50SGFuZGxlcixcbiAgICAgIHsgdmlzdWFsRWxlbWVudDogY29udGV4dC52aXN1YWxFbGVtZW50LCBwcm9wczogY29uZmlnQW5kUHJvcHMgfSxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNb3Rpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIHVzZVJlbmRlcihDb21wb25lbnQsIHByb3BzLCBwcm9qZWN0aW9uSWQsIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgY29udGV4dC52aXN1YWxFbGVtZW50LCBleHRlcm5hbFJlZiksIHZpc3VhbFN0YXRlLCBpc1N0YXRpYywgY29udGV4dC52aXN1YWxFbGVtZW50KSlcbiAgICApO1xuICB9XG4gIGNvbnN0IEZvcndhcmRSZWZDb21wb25lbnQgPSAoMCwgaW1wb3J0X3JlYWN0MTMuZm9yd2FyZFJlZikoTW90aW9uQ29tcG9uZW50KTtcbiAgRm9yd2FyZFJlZkNvbXBvbmVudFttb3Rpb25Db21wb25lbnRTeW1ib2xdID0gQ29tcG9uZW50O1xuICByZXR1cm4gRm9yd2FyZFJlZkNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dElkKHsgbGF5b3V0SWQgfSkge1xuICBjb25zdCBsYXlvdXRHcm91cElkID0gKDAsIGltcG9ydF9yZWFjdDEzLnVzZUNvbnRleHQpKExheW91dEdyb3VwQ29udGV4dCkuaWQ7XG4gIHJldHVybiBsYXlvdXRHcm91cElkICYmIGxheW91dElkICE9PSB2b2lkIDAgPyBsYXlvdXRHcm91cElkICsgXCItXCIgKyBsYXlvdXRJZCA6IGxheW91dElkO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vbW90aW9uLXByb3h5Lm1qc1xuZnVuY3Rpb24gY3JlYXRlTW90aW9uUHJveHkoY3JlYXRlQ29uZmlnKSB7XG4gIGZ1bmN0aW9uIGN1c3RvbShDb21wb25lbnQsIGN1c3RvbU1vdGlvbkNvbXBvbmVudENvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU1vdGlvbkNvbXBvbmVudChjcmVhdGVDb25maWcoQ29tcG9uZW50LCBjdXN0b21Nb3Rpb25Db21wb25lbnRDb25maWcpKTtcbiAgfVxuICBpZiAodHlwZW9mIFByb3h5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGN1c3RvbTtcbiAgfVxuICBjb25zdCBjb21wb25lbnRDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiBuZXcgUHJveHkoY3VzdG9tLCB7XG4gICAgZ2V0OiAoX3RhcmdldCwga2V5KSA9PiB7XG4gICAgICBpZiAoIWNvbXBvbmVudENhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbXBvbmVudENhY2hlLnNldChrZXksIGN1c3RvbShrZXkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wb25lbnRDYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvbG93ZXJjYXNlLWVsZW1lbnRzLm1qc1xudmFyIGxvd2VyY2FzZVNWR0VsZW1lbnRzID0gW1xuICBcImFuaW1hdGVcIixcbiAgXCJjaXJjbGVcIixcbiAgXCJkZWZzXCIsXG4gIFwiZGVzY1wiLFxuICBcImVsbGlwc2VcIixcbiAgXCJnXCIsXG4gIFwiaW1hZ2VcIixcbiAgXCJsaW5lXCIsXG4gIFwiZmlsdGVyXCIsXG4gIFwibWFya2VyXCIsXG4gIFwibWFza1wiLFxuICBcIm1ldGFkYXRhXCIsXG4gIFwicGF0aFwiLFxuICBcInBhdHRlcm5cIixcbiAgXCJwb2x5Z29uXCIsXG4gIFwicG9seWxpbmVcIixcbiAgXCJyZWN0XCIsXG4gIFwic3RvcFwiLFxuICBcInN2Z1wiLFxuICBcInN3aXRjaFwiLFxuICBcInN5bWJvbFwiLFxuICBcInRleHRcIixcbiAgXCJ0c3BhblwiLFxuICBcInVzZVwiLFxuICBcInZpZXdcIlxuXTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2lzLXN2Zy1jb21wb25lbnQubWpzXG5mdW5jdGlvbiBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgIT09IFwic3RyaW5nXCIgfHwgQ29tcG9uZW50LmluY2x1ZGVzKFwiLVwiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChsb3dlcmNhc2VTVkdFbGVtZW50cy5pbmRleE9mKENvbXBvbmVudCkgPiAtMSB8fCAvW0EtWl0vLnRlc3QoQ29tcG9uZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3VzZS1yZW5kZXIubWpzXG52YXIgaW1wb3J0X3JlYWN0MTYgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXNlLXByb3BzLm1qc1xudmFyIGltcG9ydF9yZWFjdDE0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWNvcnJlY3Rpb24ubWpzXG52YXIgc2NhbGVDb3JyZWN0b3JzID0ge307XG5mdW5jdGlvbiBhZGRTY2FsZUNvcnJlY3Rvcihjb3JyZWN0b3JzKSB7XG4gIE9iamVjdC5hc3NpZ24oc2NhbGVDb3JyZWN0b3JzLCBjb3JyZWN0b3JzKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy90cmFuc2Zvcm0ubWpzXG52YXIgdHJhbnNmb3JtUHJvcE9yZGVyID0gW1xuICBcInRyYW5zZm9ybVBlcnNwZWN0aXZlXCIsXG4gIFwieFwiLFxuICBcInlcIixcbiAgXCJ6XCIsXG4gIFwidHJhbnNsYXRlWFwiLFxuICBcInRyYW5zbGF0ZVlcIixcbiAgXCJ0cmFuc2xhdGVaXCIsXG4gIFwic2NhbGVcIixcbiAgXCJzY2FsZVhcIixcbiAgXCJzY2FsZVlcIixcbiAgXCJyb3RhdGVcIixcbiAgXCJyb3RhdGVYXCIsXG4gIFwicm90YXRlWVwiLFxuICBcInJvdGF0ZVpcIixcbiAgXCJza2V3XCIsXG4gIFwic2tld1hcIixcbiAgXCJza2V3WVwiXG5dO1xudmFyIHRyYW5zZm9ybVByb3BzID0gbmV3IFNldCh0cmFuc2Zvcm1Qcm9wT3JkZXIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9pcy1mb3JjZWQtbW90aW9uLXZhbHVlLm1qc1xuZnVuY3Rpb24gaXNGb3JjZWRNb3Rpb25WYWx1ZShrZXksIHsgbGF5b3V0LCBsYXlvdXRJZCB9KSB7XG4gIHJldHVybiB0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSB8fCBrZXkuc3RhcnRzV2l0aChcIm9yaWdpblwiKSB8fCAobGF5b3V0IHx8IGxheW91dElkICE9PSB2b2lkIDApICYmICghIXNjYWxlQ29ycmVjdG9yc1trZXldIHx8IGtleSA9PT0gXCJvcGFjaXR5XCIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanNcbnZhciBpc01vdGlvblZhbHVlID0gKHZhbHVlKSA9PiAhISh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuZ2V0VmVsb2NpdHkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL2J1aWxkLXRyYW5zZm9ybS5tanNcbnZhciB0cmFuc2xhdGVBbGlhcyA9IHtcbiAgeDogXCJ0cmFuc2xhdGVYXCIsXG4gIHk6IFwidHJhbnNsYXRlWVwiLFxuICB6OiBcInRyYW5zbGF0ZVpcIixcbiAgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IFwicGVyc3BlY3RpdmVcIlxufTtcbnZhciBzb3J0VHJhbnNmb3JtUHJvcHMgPSAoYTIsIGIyKSA9PiB0cmFuc2Zvcm1Qcm9wT3JkZXIuaW5kZXhPZihhMikgLSB0cmFuc2Zvcm1Qcm9wT3JkZXIuaW5kZXhPZihiMik7XG5mdW5jdGlvbiBidWlsZFRyYW5zZm9ybSh7IHRyYW5zZm9ybSwgdHJhbnNmb3JtS2V5czogdHJhbnNmb3JtS2V5czIgfSwgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbiA9IHRydWUsIGFsbG93VHJhbnNmb3JtTm9uZSA9IHRydWUgfSwgdHJhbnNmb3JtSXNEZWZhdWx0LCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICBsZXQgdHJhbnNmb3JtU3RyaW5nID0gXCJcIjtcbiAgdHJhbnNmb3JtS2V5czIuc29ydChzb3J0VHJhbnNmb3JtUHJvcHMpO1xuICBmb3IgKGNvbnN0IGtleSBvZiB0cmFuc2Zvcm1LZXlzMikge1xuICAgIHRyYW5zZm9ybVN0cmluZyArPSBgJHt0cmFuc2xhdGVBbGlhc1trZXldIHx8IGtleX0oJHt0cmFuc2Zvcm1ba2V5XX0pIGA7XG4gIH1cbiAgaWYgKGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uICYmICF0cmFuc2Zvcm0ueikge1xuICAgIHRyYW5zZm9ybVN0cmluZyArPSBcInRyYW5zbGF0ZVooMClcIjtcbiAgfVxuICB0cmFuc2Zvcm1TdHJpbmcgPSB0cmFuc2Zvcm1TdHJpbmcudHJpbSgpO1xuICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICB0cmFuc2Zvcm1TdHJpbmcgPSB0cmFuc2Zvcm1UZW1wbGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybUlzRGVmYXVsdCA/IFwiXCIgOiB0cmFuc2Zvcm1TdHJpbmcpO1xuICB9IGVsc2UgaWYgKGFsbG93VHJhbnNmb3JtTm9uZSAmJiB0cmFuc2Zvcm1Jc0RlZmF1bHQpIHtcbiAgICB0cmFuc2Zvcm1TdHJpbmcgPSBcIm5vbmVcIjtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtU3RyaW5nO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvaXMtY3NzLXZhcmlhYmxlLm1qc1xuZnVuY3Rpb24gaXNDU1NWYXJpYWJsZShrZXkpIHtcbiAgcmV0dXJuIGtleS5zdGFydHNXaXRoKFwiLS1cIik7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9nZXQtYXMtdHlwZS5tanNcbnZhciBnZXRWYWx1ZUFzVHlwZSA9ICh2YWx1ZSwgdHlwZSkgPT4ge1xuICByZXR1cm4gdHlwZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB0eXBlLnRyYW5zZm9ybSh2YWx1ZSkgOiB2YWx1ZTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL3V0aWxzLm1qc1xudmFyIGNsYW1wID0gKG1pbiwgbWF4KSA9PiAodikgPT4gTWF0aC5tYXgoTWF0aC5taW4odiwgbWF4KSwgbWluKTtcbnZhciBzYW5pdGl6ZSA9ICh2KSA9PiB2ICUgMSA/IE51bWJlcih2LnRvRml4ZWQoNSkpIDogdjtcbnZhciBmbG9hdFJlZ2V4ID0gLygtKT8oW1xcZF0qXFwuP1tcXGRdKSsvZztcbnZhciBjb2xvclJlZ2V4ID0gLygjWzAtOWEtZl17Nn18I1swLTlhLWZdezN9fCMoPzpbMC05YS1mXXsyfSl7Miw0fXwocmdifGhzbClhP1xcKCgtP1tcXGRcXC5dKyU/WyxcXHNdKyl7Mn0oLT9bXFxkXFwuXSslPylcXHMqW1xcLFxcL10/XFxzKltcXGRcXC5dKiU/XFwpKS9naTtcbnZhciBzaW5nbGVDb2xvclJlZ2V4ID0gL14oI1swLTlhLWZdezN9fCMoPzpbMC05YS1mXXsyfSl7Miw0fXwocmdifGhzbClhP1xcKCgtP1tcXGRcXC5dKyU/WyxcXHNdKyl7Mn0oLT9bXFxkXFwuXSslPylcXHMqW1xcLFxcL10/XFxzKltcXGRcXC5dKiU/XFwpKSQvaTtcbmZ1bmN0aW9uIGlzU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9udW1iZXJzL2luZGV4Lm1qc1xudmFyIG51bWJlciA9IHtcbiAgdGVzdDogKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiLFxuICBwYXJzZTogcGFyc2VGbG9hdCxcbiAgdHJhbnNmb3JtOiAodikgPT4gdlxufTtcbnZhciBhbHBoYSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyKSwgeyB0cmFuc2Zvcm06IGNsYW1wKDAsIDEpIH0pO1xudmFyIHNjYWxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBudW1iZXIpLCB7IGRlZmF1bHQ6IDEgfSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL251bWJlcnMvdW5pdHMubWpzXG52YXIgY3JlYXRlVW5pdFR5cGUgPSAodW5pdCkgPT4gKHtcbiAgdGVzdDogKHYpID0+IGlzU3RyaW5nKHYpICYmIHYuZW5kc1dpdGgodW5pdCkgJiYgdi5zcGxpdChcIiBcIikubGVuZ3RoID09PSAxLFxuICBwYXJzZTogcGFyc2VGbG9hdCxcbiAgdHJhbnNmb3JtOiAodikgPT4gYCR7dn0ke3VuaXR9YFxufSk7XG52YXIgZGVncmVlcyA9IGNyZWF0ZVVuaXRUeXBlKFwiZGVnXCIpO1xudmFyIHBlcmNlbnQgPSBjcmVhdGVVbml0VHlwZShcIiVcIik7XG52YXIgcHggPSBjcmVhdGVVbml0VHlwZShcInB4XCIpO1xudmFyIHZoID0gY3JlYXRlVW5pdFR5cGUoXCJ2aFwiKTtcbnZhciB2dyA9IGNyZWF0ZVVuaXRUeXBlKFwidndcIik7XG52YXIgcHJvZ3Jlc3NQZXJjZW50YWdlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwZXJjZW50KSwgeyBwYXJzZTogKHYpID0+IHBlcmNlbnQucGFyc2UodikgLyAxMDAsIHRyYW5zZm9ybTogKHYpID0+IHBlcmNlbnQudHJhbnNmb3JtKHYgKiAxMDApIH0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci91dGlscy5tanNcbnZhciBpc0NvbG9yU3RyaW5nID0gKHR5cGUsIHRlc3RQcm9wKSA9PiAodikgPT4ge1xuICByZXR1cm4gQm9vbGVhbihpc1N0cmluZyh2KSAmJiBzaW5nbGVDb2xvclJlZ2V4LnRlc3QodikgJiYgdi5zdGFydHNXaXRoKHR5cGUpIHx8IHRlc3RQcm9wICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2LCB0ZXN0UHJvcCkpO1xufTtcbnZhciBzcGxpdENvbG9yID0gKGFOYW1lLCBiTmFtZSwgY05hbWUpID0+ICh2KSA9PiB7XG4gIGlmICghaXNTdHJpbmcodikpXG4gICAgcmV0dXJuIHY7XG4gIGNvbnN0IFthMiwgYjIsIGMzLCBhbHBoYTJdID0gdi5tYXRjaChmbG9hdFJlZ2V4KTtcbiAgcmV0dXJuIHtcbiAgICBbYU5hbWVdOiBwYXJzZUZsb2F0KGEyKSxcbiAgICBbYk5hbWVdOiBwYXJzZUZsb2F0KGIyKSxcbiAgICBbY05hbWVdOiBwYXJzZUZsb2F0KGMzKSxcbiAgICBhbHBoYTogYWxwaGEyICE9PSB2b2lkIDAgPyBwYXJzZUZsb2F0KGFscGhhMikgOiAxXG4gIH07XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9oc2xhLm1qc1xudmFyIGhzbGEgPSB7XG4gIHRlc3Q6IGlzQ29sb3JTdHJpbmcoXCJoc2xcIiwgXCJodWVcIiksXG4gIHBhcnNlOiBzcGxpdENvbG9yKFwiaHVlXCIsIFwic2F0dXJhdGlvblwiLCBcImxpZ2h0bmVzc1wiKSxcbiAgdHJhbnNmb3JtOiAoeyBodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgYWxwaGE6IGFscGhhJDEgPSAxIH0pID0+IHtcbiAgICByZXR1cm4gXCJoc2xhKFwiICsgTWF0aC5yb3VuZChodWUpICsgXCIsIFwiICsgcGVyY2VudC50cmFuc2Zvcm0oc2FuaXRpemUoc2F0dXJhdGlvbikpICsgXCIsIFwiICsgcGVyY2VudC50cmFuc2Zvcm0oc2FuaXRpemUobGlnaHRuZXNzKSkgKyBcIiwgXCIgKyBzYW5pdGl6ZShhbHBoYS50cmFuc2Zvcm0oYWxwaGEkMSkpICsgXCIpXCI7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbG9yL3JnYmEubWpzXG52YXIgY2xhbXBSZ2JVbml0ID0gY2xhbXAoMCwgMjU1KTtcbnZhciByZ2JVbml0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBudW1iZXIpLCB7IHRyYW5zZm9ybTogKHYpID0+IE1hdGgucm91bmQoY2xhbXBSZ2JVbml0KHYpKSB9KTtcbnZhciByZ2JhID0ge1xuICB0ZXN0OiBpc0NvbG9yU3RyaW5nKFwicmdiXCIsIFwicmVkXCIpLFxuICBwYXJzZTogc3BsaXRDb2xvcihcInJlZFwiLCBcImdyZWVuXCIsIFwiYmx1ZVwiKSxcbiAgdHJhbnNmb3JtOiAoeyByZWQsIGdyZWVuLCBibHVlLCBhbHBoYTogYWxwaGEkMSA9IDEgfSkgPT4gXCJyZ2JhKFwiICsgcmdiVW5pdC50cmFuc2Zvcm0ocmVkKSArIFwiLCBcIiArIHJnYlVuaXQudHJhbnNmb3JtKGdyZWVuKSArIFwiLCBcIiArIHJnYlVuaXQudHJhbnNmb3JtKGJsdWUpICsgXCIsIFwiICsgc2FuaXRpemUoYWxwaGEudHJhbnNmb3JtKGFscGhhJDEpKSArIFwiKVwiXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9oZXgubWpzXG5mdW5jdGlvbiBwYXJzZUhleCh2KSB7XG4gIGxldCByID0gXCJcIjtcbiAgbGV0IGcyID0gXCJcIjtcbiAgbGV0IGIyID0gXCJcIjtcbiAgbGV0IGEyID0gXCJcIjtcbiAgaWYgKHYubGVuZ3RoID4gNSkge1xuICAgIHIgPSB2LnN1YnN0cigxLCAyKTtcbiAgICBnMiA9IHYuc3Vic3RyKDMsIDIpO1xuICAgIGIyID0gdi5zdWJzdHIoNSwgMik7XG4gICAgYTIgPSB2LnN1YnN0cig3LCAyKTtcbiAgfSBlbHNlIHtcbiAgICByID0gdi5zdWJzdHIoMSwgMSk7XG4gICAgZzIgPSB2LnN1YnN0cigyLCAxKTtcbiAgICBiMiA9IHYuc3Vic3RyKDMsIDEpO1xuICAgIGEyID0gdi5zdWJzdHIoNCwgMSk7XG4gICAgciArPSByO1xuICAgIGcyICs9IGcyO1xuICAgIGIyICs9IGIyO1xuICAgIGEyICs9IGEyO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVkOiBwYXJzZUludChyLCAxNiksXG4gICAgZ3JlZW46IHBhcnNlSW50KGcyLCAxNiksXG4gICAgYmx1ZTogcGFyc2VJbnQoYjIsIDE2KSxcbiAgICBhbHBoYTogYTIgPyBwYXJzZUludChhMiwgMTYpIC8gMjU1IDogMVxuICB9O1xufVxudmFyIGhleCA9IHtcbiAgdGVzdDogaXNDb2xvclN0cmluZyhcIiNcIiksXG4gIHBhcnNlOiBwYXJzZUhleCxcbiAgdHJhbnNmb3JtOiByZ2JhLnRyYW5zZm9ybVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvY29sb3IvaW5kZXgubWpzXG52YXIgY29sb3IgPSB7XG4gIHRlc3Q6ICh2KSA9PiByZ2JhLnRlc3QodikgfHwgaGV4LnRlc3QodikgfHwgaHNsYS50ZXN0KHYpLFxuICBwYXJzZTogKHYpID0+IHtcbiAgICBpZiAocmdiYS50ZXN0KHYpKSB7XG4gICAgICByZXR1cm4gcmdiYS5wYXJzZSh2KTtcbiAgICB9IGVsc2UgaWYgKGhzbGEudGVzdCh2KSkge1xuICAgICAgcmV0dXJuIGhzbGEucGFyc2Uodik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBoZXgucGFyc2Uodik7XG4gICAgfVxuICB9LFxuICB0cmFuc2Zvcm06ICh2KSA9PiB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHYpID8gdiA6IHYuaGFzT3duUHJvcGVydHkoXCJyZWRcIikgPyByZ2JhLnRyYW5zZm9ybSh2KSA6IGhzbGEudHJhbnNmb3JtKHYpO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb21wbGV4L2luZGV4Lm1qc1xudmFyIGNvbG9yVG9rZW4gPSBcIiR7Y31cIjtcbnZhciBudW1iZXJUb2tlbiA9IFwiJHtufVwiO1xuZnVuY3Rpb24gdGVzdCh2KSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgcmV0dXJuIGlzTmFOKHYpICYmIGlzU3RyaW5nKHYpICYmICgoX2IgPSAoX2EgPSB2Lm1hdGNoKGZsb2F0UmVnZXgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSArICgoX2QgPSAoX2MgPSB2Lm1hdGNoKGNvbG9yUmVnZXgpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKSA+IDA7XG59XG5mdW5jdGlvbiBhbmFseXNlKHYpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKVxuICAgIHYgPSBgJHt2fWA7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBsZXQgbnVtQ29sb3JzID0gMDtcbiAgY29uc3QgY29sb3JzID0gdi5tYXRjaChjb2xvclJlZ2V4KTtcbiAgaWYgKGNvbG9ycykge1xuICAgIG51bUNvbG9ycyA9IGNvbG9ycy5sZW5ndGg7XG4gICAgdiA9IHYucmVwbGFjZShjb2xvclJlZ2V4LCBjb2xvclRva2VuKTtcbiAgICB2YWx1ZXMucHVzaCguLi5jb2xvcnMubWFwKGNvbG9yLnBhcnNlKSk7XG4gIH1cbiAgY29uc3QgbnVtYmVycyA9IHYubWF0Y2goZmxvYXRSZWdleCk7XG4gIGlmIChudW1iZXJzKSB7XG4gICAgdiA9IHYucmVwbGFjZShmbG9hdFJlZ2V4LCBudW1iZXJUb2tlbik7XG4gICAgdmFsdWVzLnB1c2goLi4ubnVtYmVycy5tYXAobnVtYmVyLnBhcnNlKSk7XG4gIH1cbiAgcmV0dXJuIHsgdmFsdWVzLCBudW1Db2xvcnMsIHRva2VuaXNlZDogdiB9O1xufVxuZnVuY3Rpb24gcGFyc2Uodikge1xuICByZXR1cm4gYW5hbHlzZSh2KS52YWx1ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1lcih2KSB7XG4gIGNvbnN0IHsgdmFsdWVzLCBudW1Db2xvcnMsIHRva2VuaXNlZCB9ID0gYW5hbHlzZSh2KTtcbiAgY29uc3QgbnVtVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuICh2MikgPT4ge1xuICAgIGxldCBvdXRwdXQgPSB0b2tlbmlzZWQ7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bVZhbHVlczsgaTIrKykge1xuICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoaTIgPCBudW1Db2xvcnMgPyBjb2xvclRva2VuIDogbnVtYmVyVG9rZW4sIGkyIDwgbnVtQ29sb3JzID8gY29sb3IudHJhbnNmb3JtKHYyW2kyXSkgOiBzYW5pdGl6ZSh2MltpMl0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cbnZhciBjb252ZXJ0TnVtYmVyc1RvWmVybyA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiA/IDAgOiB2O1xuZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZU5vbmUodikge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2KTtcbiAgY29uc3QgdHJhbnNmb3JtZXIgPSBjcmVhdGVUcmFuc2Zvcm1lcih2KTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKHBhcnNlZC5tYXAoY29udmVydE51bWJlcnNUb1plcm8pKTtcbn1cbnZhciBjb21wbGV4ID0geyB0ZXN0LCBwYXJzZSwgY3JlYXRlVHJhbnNmb3JtZXIsIGdldEFuaW1hdGFibGVOb25lIH07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbXBsZXgvZmlsdGVyLm1qc1xudmFyIG1heERlZmF1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiYnJpZ2h0bmVzc1wiLCBcImNvbnRyYXN0XCIsIFwic2F0dXJhdGVcIiwgXCJvcGFjaXR5XCJdKTtcbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdEZpbHRlcih2KSB7XG4gIGxldCBbbmFtZSwgdmFsdWVdID0gdi5zbGljZSgwLCAtMSkuc3BsaXQoXCIoXCIpO1xuICBpZiAobmFtZSA9PT0gXCJkcm9wLXNoYWRvd1wiKVxuICAgIHJldHVybiB2O1xuICBjb25zdCBbbnVtYmVyMl0gPSB2YWx1ZS5tYXRjaChmbG9hdFJlZ2V4KSB8fCBbXTtcbiAgaWYgKCFudW1iZXIyKVxuICAgIHJldHVybiB2O1xuICBjb25zdCB1bml0ID0gdmFsdWUucmVwbGFjZShudW1iZXIyLCBcIlwiKTtcbiAgbGV0IGRlZmF1bHRWYWx1ZSA9IG1heERlZmF1bHRzLmhhcyhuYW1lKSA/IDEgOiAwO1xuICBpZiAobnVtYmVyMiAhPT0gdmFsdWUpXG4gICAgZGVmYXVsdFZhbHVlICo9IDEwMDtcbiAgcmV0dXJuIG5hbWUgKyBcIihcIiArIGRlZmF1bHRWYWx1ZSArIHVuaXQgKyBcIilcIjtcbn1cbnZhciBmdW5jdGlvblJlZ2V4ID0gLyhbYS16LV0qKVxcKC4qP1xcKS9nO1xudmFyIGZpbHRlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tcGxleCksIHsgZ2V0QW5pbWF0YWJsZU5vbmU6ICh2KSA9PiB7XG4gIGNvbnN0IGZ1bmN0aW9ucyA9IHYubWF0Y2goZnVuY3Rpb25SZWdleCk7XG4gIHJldHVybiBmdW5jdGlvbnMgPyBmdW5jdGlvbnMubWFwKGFwcGx5RGVmYXVsdEZpbHRlcikuam9pbihcIiBcIikgOiB2O1xufSB9KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3R5cGUtaW50Lm1qc1xudmFyIGludCA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG51bWJlciksIHtcbiAgdHJhbnNmb3JtOiBNYXRoLnJvdW5kXG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL251bWJlci5tanNcbnZhciBudW1iZXJWYWx1ZVR5cGVzID0ge1xuICBib3JkZXJXaWR0aDogcHgsXG4gIGJvcmRlclRvcFdpZHRoOiBweCxcbiAgYm9yZGVyUmlnaHRXaWR0aDogcHgsXG4gIGJvcmRlckJvdHRvbVdpZHRoOiBweCxcbiAgYm9yZGVyTGVmdFdpZHRoOiBweCxcbiAgYm9yZGVyUmFkaXVzOiBweCxcbiAgcmFkaXVzOiBweCxcbiAgYm9yZGVyVG9wTGVmdFJhZGl1czogcHgsXG4gIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBweCxcbiAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IHB4LFxuICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBweCxcbiAgd2lkdGg6IHB4LFxuICBtYXhXaWR0aDogcHgsXG4gIGhlaWdodDogcHgsXG4gIG1heEhlaWdodDogcHgsXG4gIHNpemU6IHB4LFxuICB0b3A6IHB4LFxuICByaWdodDogcHgsXG4gIGJvdHRvbTogcHgsXG4gIGxlZnQ6IHB4LFxuICBwYWRkaW5nOiBweCxcbiAgcGFkZGluZ1RvcDogcHgsXG4gIHBhZGRpbmdSaWdodDogcHgsXG4gIHBhZGRpbmdCb3R0b206IHB4LFxuICBwYWRkaW5nTGVmdDogcHgsXG4gIG1hcmdpbjogcHgsXG4gIG1hcmdpblRvcDogcHgsXG4gIG1hcmdpblJpZ2h0OiBweCxcbiAgbWFyZ2luQm90dG9tOiBweCxcbiAgbWFyZ2luTGVmdDogcHgsXG4gIHJvdGF0ZTogZGVncmVlcyxcbiAgcm90YXRlWDogZGVncmVlcyxcbiAgcm90YXRlWTogZGVncmVlcyxcbiAgcm90YXRlWjogZGVncmVlcyxcbiAgc2NhbGUsXG4gIHNjYWxlWDogc2NhbGUsXG4gIHNjYWxlWTogc2NhbGUsXG4gIHNjYWxlWjogc2NhbGUsXG4gIHNrZXc6IGRlZ3JlZXMsXG4gIHNrZXdYOiBkZWdyZWVzLFxuICBza2V3WTogZGVncmVlcyxcbiAgZGlzdGFuY2U6IHB4LFxuICB0cmFuc2xhdGVYOiBweCxcbiAgdHJhbnNsYXRlWTogcHgsXG4gIHRyYW5zbGF0ZVo6IHB4LFxuICB4OiBweCxcbiAgeTogcHgsXG4gIHo6IHB4LFxuICBwZXJzcGVjdGl2ZTogcHgsXG4gIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBweCxcbiAgb3BhY2l0eTogYWxwaGEsXG4gIG9yaWdpblg6IHByb2dyZXNzUGVyY2VudGFnZSxcbiAgb3JpZ2luWTogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICBvcmlnaW5aOiBweCxcbiAgekluZGV4OiBpbnQsXG4gIGZpbGxPcGFjaXR5OiBhbHBoYSxcbiAgc3Ryb2tlT3BhY2l0eTogYWxwaGEsXG4gIG51bU9jdGF2ZXM6IGludFxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9idWlsZC1zdHlsZXMubWpzXG5mdW5jdGlvbiBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgY29uc3QgeyBzdHlsZSwgdmFycywgdHJhbnNmb3JtLCB0cmFuc2Zvcm1LZXlzOiB0cmFuc2Zvcm1LZXlzMiwgdHJhbnNmb3JtT3JpZ2luIH0gPSBzdGF0ZTtcbiAgdHJhbnNmb3JtS2V5czIubGVuZ3RoID0gMDtcbiAgbGV0IGhhc1RyYW5zZm9ybTIgPSBmYWxzZTtcbiAgbGV0IGhhc1RyYW5zZm9ybU9yaWdpbiA9IGZhbHNlO1xuICBsZXQgdHJhbnNmb3JtSXNOb25lID0gdHJ1ZTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbGF0ZXN0VmFsdWVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBsYXRlc3RWYWx1ZXNba2V5XTtcbiAgICBpZiAoaXNDU1NWYXJpYWJsZShrZXkpKSB7XG4gICAgICB2YXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZVR5cGUgPSBudW1iZXJWYWx1ZVR5cGVzW2tleV07XG4gICAgY29uc3QgdmFsdWVBc1R5cGUgPSBnZXRWYWx1ZUFzVHlwZSh2YWx1ZSwgdmFsdWVUeXBlKTtcbiAgICBpZiAodHJhbnNmb3JtUHJvcHMuaGFzKGtleSkpIHtcbiAgICAgIGhhc1RyYW5zZm9ybTIgPSB0cnVlO1xuICAgICAgdHJhbnNmb3JtW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgIHRyYW5zZm9ybUtleXMyLnB1c2goa2V5KTtcbiAgICAgIGlmICghdHJhbnNmb3JtSXNOb25lKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gKHZhbHVlVHlwZS5kZWZhdWx0IHx8IDApKVxuICAgICAgICB0cmFuc2Zvcm1Jc05vbmUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGtleS5zdGFydHNXaXRoKFwib3JpZ2luXCIpKSB7XG4gICAgICBoYXNUcmFuc2Zvcm1PcmlnaW4gPSB0cnVlO1xuICAgICAgdHJhbnNmb3JtT3JpZ2luW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVba2V5XSA9IHZhbHVlQXNUeXBlO1xuICAgIH1cbiAgfVxuICBpZiAoIWxhdGVzdFZhbHVlcy50cmFuc2Zvcm0pIHtcbiAgICBpZiAoaGFzVHJhbnNmb3JtMiB8fCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgc3R5bGUudHJhbnNmb3JtID0gYnVpbGRUcmFuc2Zvcm0oc3RhdGUsIG9wdGlvbnMsIHRyYW5zZm9ybUlzTm9uZSwgdHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUudHJhbnNmb3JtKSB7XG4gICAgICBzdHlsZS50cmFuc2Zvcm0gPSBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1RyYW5zZm9ybU9yaWdpbikge1xuICAgIGNvbnN0IHsgb3JpZ2luWCA9IFwiNTAlXCIsIG9yaWdpblkgPSBcIjUwJVwiLCBvcmlnaW5aID0gMCB9ID0gdHJhbnNmb3JtT3JpZ2luO1xuICAgIHN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGAke29yaWdpblh9ICR7b3JpZ2luWX0gJHtvcmlnaW5afWA7XG4gIH1cbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qc1xudmFyIGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSA9ICgpID0+ICh7XG4gIHN0eWxlOiB7fSxcbiAgdHJhbnNmb3JtOiB7fSxcbiAgdHJhbnNmb3JtS2V5czogW10sXG4gIHRyYW5zZm9ybU9yaWdpbjoge30sXG4gIHZhcnM6IHt9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91c2UtcHJvcHMubWpzXG5mdW5jdGlvbiBjb3B5UmF3VmFsdWVzT25seSh0YXJnZXQsIHNvdXJjZSwgcHJvcHMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKCFpc01vdGlvblZhbHVlKHNvdXJjZVtrZXldKSAmJiAhaXNGb3JjZWRNb3Rpb25WYWx1ZShrZXksIHByb3BzKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUluaXRpYWxNb3Rpb25WYWx1ZXMoeyB0cmFuc2Zvcm1UZW1wbGF0ZSB9LCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfcmVhY3QxNC51c2VNZW1vKSgoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVIdG1sUmVuZGVyU3RhdGUoKTtcbiAgICBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIHZpc3VhbFN0YXRlLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiAhaXNTdGF0aWMgfSwgdHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS52YXJzLCBzdGF0ZS5zdHlsZSk7XG4gIH0sIFt2aXN1YWxTdGF0ZV0pO1xufVxuZnVuY3Rpb24gdXNlU3R5bGUocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykge1xuICBjb25zdCBzdHlsZVByb3AgPSBwcm9wcy5zdHlsZSB8fCB7fTtcbiAgY29uc3Qgc3R5bGUgPSB7fTtcbiAgY29weVJhd1ZhbHVlc09ubHkoc3R5bGUsIHN0eWxlUHJvcCwgcHJvcHMpO1xuICBPYmplY3QuYXNzaWduKHN0eWxlLCB1c2VJbml0aWFsTW90aW9uVmFsdWVzKHByb3BzLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpKTtcbiAgcmV0dXJuIHByb3BzLnRyYW5zZm9ybVZhbHVlcyA/IHByb3BzLnRyYW5zZm9ybVZhbHVlcyhzdHlsZSkgOiBzdHlsZTtcbn1cbmZ1bmN0aW9uIHVzZUhUTUxQcm9wcyhwcm9wcywgdmlzdWFsU3RhdGUsIGlzU3RhdGljKSB7XG4gIGNvbnN0IGh0bWxQcm9wcyA9IHt9O1xuICBjb25zdCBzdHlsZSA9IHVzZVN0eWxlKHByb3BzLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpO1xuICBpZiAocHJvcHMuZHJhZyAmJiBwcm9wcy5kcmFnTGlzdGVuZXIgIT09IGZhbHNlKSB7XG4gICAgaHRtbFByb3BzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHN0eWxlLnVzZXJTZWxlY3QgPSBzdHlsZS5XZWJraXRVc2VyU2VsZWN0ID0gc3R5bGUuV2Via2l0VG91Y2hDYWxsb3V0ID0gXCJub25lXCI7XG4gICAgc3R5bGUudG91Y2hBY3Rpb24gPSBwcm9wcy5kcmFnID09PSB0cnVlID8gXCJub25lXCIgOiBgcGFuLSR7cHJvcHMuZHJhZyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwifWA7XG4gIH1cbiAgaHRtbFByb3BzLnN0eWxlID0gc3R5bGU7XG4gIHJldHVybiBodG1sUHJvcHM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3ZhbGlkLXByb3AubWpzXG52YXIgYW5pbWF0aW9uUHJvcHMgPSBbXG4gIFwiYW5pbWF0ZVwiLFxuICBcImV4aXRcIixcbiAgXCJ2YXJpYW50c1wiLFxuICBcIndoaWxlSG92ZXJcIixcbiAgXCJ3aGlsZVRhcFwiLFxuICBcIndoaWxlRm9jdXNcIixcbiAgXCJ3aGlsZURyYWdcIixcbiAgXCJ3aGlsZUluVmlld1wiXG5dO1xudmFyIHRhcFByb3BzID0gW1wid2hpbGVUYXBcIiwgXCJvblRhcFwiLCBcIm9uVGFwU3RhcnRcIiwgXCJvblRhcENhbmNlbFwiXTtcbnZhciBwYW5Qcm9wcyA9IFtcIm9uUGFuXCIsIFwib25QYW5TdGFydFwiLCBcIm9uUGFuU2Vzc2lvblN0YXJ0XCIsIFwib25QYW5FbmRcIl07XG52YXIgaW5WaWV3UHJvcHMgPSBbXG4gIFwid2hpbGVJblZpZXdcIixcbiAgXCJvblZpZXdwb3J0RW50ZXJcIixcbiAgXCJvblZpZXdwb3J0TGVhdmVcIixcbiAgXCJ2aWV3cG9ydFwiXG5dO1xudmFyIHZhbGlkTW90aW9uUHJvcHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiaW5pdGlhbFwiLFxuICBcInN0eWxlXCIsXG4gIFwidmFsdWVzXCIsXG4gIFwidmFyaWFudHNcIixcbiAgXCJ0cmFuc2l0aW9uXCIsXG4gIFwidHJhbnNmb3JtVGVtcGxhdGVcIixcbiAgXCJ0cmFuc2Zvcm1WYWx1ZXNcIixcbiAgXCJjdXN0b21cIixcbiAgXCJpbmhlcml0XCIsXG4gIFwibGF5b3V0XCIsXG4gIFwibGF5b3V0SWRcIixcbiAgXCJsYXlvdXREZXBlbmRlbmN5XCIsXG4gIFwib25MYXlvdXRBbmltYXRpb25TdGFydFwiLFxuICBcIm9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGVcIixcbiAgXCJvbkxheW91dE1lYXN1cmVcIixcbiAgXCJvbkJlZm9yZUxheW91dE1lYXN1cmVcIixcbiAgXCJvbkFuaW1hdGlvblN0YXJ0XCIsXG4gIFwib25BbmltYXRpb25Db21wbGV0ZVwiLFxuICBcIm9uVXBkYXRlXCIsXG4gIFwib25EcmFnU3RhcnRcIixcbiAgXCJvbkRyYWdcIixcbiAgXCJvbkRyYWdFbmRcIixcbiAgXCJvbk1lYXN1cmVEcmFnQ29uc3RyYWludHNcIixcbiAgXCJvbkRpcmVjdGlvbkxvY2tcIixcbiAgXCJvbkRyYWdUcmFuc2l0aW9uRW5kXCIsXG4gIFwiZHJhZ1wiLFxuICBcImRyYWdDb250cm9sc1wiLFxuICBcImRyYWdMaXN0ZW5lclwiLFxuICBcImRyYWdDb25zdHJhaW50c1wiLFxuICBcImRyYWdEaXJlY3Rpb25Mb2NrXCIsXG4gIFwiZHJhZ1NuYXBUb09yaWdpblwiLFxuICBcIl9kcmFnWFwiLFxuICBcIl9kcmFnWVwiLFxuICBcImRyYWdFbGFzdGljXCIsXG4gIFwiZHJhZ01vbWVudHVtXCIsXG4gIFwiZHJhZ1Byb3BhZ2F0aW9uXCIsXG4gIFwiZHJhZ1RyYW5zaXRpb25cIixcbiAgXCJvbkhvdmVyU3RhcnRcIixcbiAgXCJvbkhvdmVyRW5kXCIsXG4gIFwibGF5b3V0U2Nyb2xsXCIsXG4gIC4uLmluVmlld1Byb3BzLFxuICAuLi50YXBQcm9wcyxcbiAgLi4uYW5pbWF0aW9uUHJvcHMsXG4gIC4uLnBhblByb3BzXG5dKTtcbmZ1bmN0aW9uIGlzVmFsaWRNb3Rpb25Qcm9wKGtleSkge1xuICByZXR1cm4gdmFsaWRNb3Rpb25Qcm9wcy5oYXMoa2V5KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2ZpbHRlci1wcm9wcy5tanNcbnZhciBzaG91bGRGb3J3YXJkID0gKGtleSkgPT4gIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSk7XG5mdW5jdGlvbiBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcChpc1ZhbGlkUHJvcCkge1xuICBpZiAoIWlzVmFsaWRQcm9wKVxuICAgIHJldHVybjtcbiAgc2hvdWxkRm9yd2FyZCA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwib25cIikgPyAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KSA6IGlzVmFsaWRQcm9wKGtleSk7XG59XG50cnkge1xuICBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcCgoaW5pdF9pc19wcm9wX3ZhbGlkX2VzbSgpLCBfX3RvQ29tbW9uSlMoaXNfcHJvcF92YWxpZF9lc21fZXhwb3J0cykpLmRlZmF1bHQpO1xufSBjYXRjaCAoX2EpIHtcbn1cbmZ1bmN0aW9uIGZpbHRlclByb3BzKHByb3BzLCBpc0RvbSwgZm9yd2FyZE1vdGlvblByb3BzKSB7XG4gIGNvbnN0IGZpbHRlcmVkUHJvcHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoc2hvdWxkRm9yd2FyZChrZXkpIHx8IGZvcndhcmRNb3Rpb25Qcm9wcyA9PT0gdHJ1ZSAmJiBpc1ZhbGlkTW90aW9uUHJvcChrZXkpIHx8ICFpc0RvbSAmJiAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KSB8fCBwcm9wc1tcImRyYWdnYWJsZVwiXSAmJiBrZXkuc3RhcnRzV2l0aChcIm9uRHJhZ1wiKSkge1xuICAgICAgZmlsdGVyZWRQcm9wc1trZXldID0gcHJvcHNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkUHJvcHM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91c2UtcHJvcHMubWpzXG52YXIgaW1wb3J0X3JlYWN0MTUgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy90cmFuc2Zvcm0tb3JpZ2luLm1qc1xuZnVuY3Rpb24gY2FsY09yaWdpbihvcmlnaW4sIG9mZnNldCwgc2l6ZSkge1xuICByZXR1cm4gdHlwZW9mIG9yaWdpbiA9PT0gXCJzdHJpbmdcIiA/IG9yaWdpbiA6IHB4LnRyYW5zZm9ybShvZmZzZXQgKyBzaXplICogb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGNhbGNTVkdUcmFuc2Zvcm1PcmlnaW4oZGltZW5zaW9ucywgb3JpZ2luWCwgb3JpZ2luWSkge1xuICBjb25zdCBweE9yaWdpblggPSBjYWxjT3JpZ2luKG9yaWdpblgsIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy53aWR0aCk7XG4gIGNvbnN0IHB4T3JpZ2luWSA9IGNhbGNPcmlnaW4ob3JpZ2luWSwgZGltZW5zaW9ucy55LCBkaW1lbnNpb25zLmhlaWdodCk7XG4gIHJldHVybiBgJHtweE9yaWdpblh9ICR7cHhPcmlnaW5ZfWA7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9wYXRoLm1qc1xudmFyIGRhc2hLZXlzID0ge1xuICBvZmZzZXQ6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgYXJyYXk6IFwic3Ryb2tlLWRhc2hhcnJheVwiXG59O1xudmFyIGNhbWVsS2V5cyA9IHtcbiAgb2Zmc2V0OiBcInN0cm9rZURhc2hvZmZzZXRcIixcbiAgYXJyYXk6IFwic3Ryb2tlRGFzaGFycmF5XCJcbn07XG5mdW5jdGlvbiBidWlsZFNWR1BhdGgoYXR0cnMsIGxlbmd0aCwgc3BhY2luZyA9IDEsIG9mZnNldCA9IDAsIHVzZURhc2hDYXNlID0gdHJ1ZSkge1xuICBhdHRycy5wYXRoTGVuZ3RoID0gMTtcbiAgY29uc3Qga2V5czIgPSB1c2VEYXNoQ2FzZSA/IGRhc2hLZXlzIDogY2FtZWxLZXlzO1xuICBhdHRyc1trZXlzMi5vZmZzZXRdID0gcHgudHJhbnNmb3JtKC1vZmZzZXQpO1xuICBjb25zdCBwYXRoTGVuZ3RoID0gcHgudHJhbnNmb3JtKGxlbmd0aCk7XG4gIGNvbnN0IHBhdGhTcGFjaW5nID0gcHgudHJhbnNmb3JtKHNwYWNpbmcpO1xuICBhdHRyc1trZXlzMi5hcnJheV0gPSBgJHtwYXRoTGVuZ3RofSAke3BhdGhTcGFjaW5nfWA7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9idWlsZC1hdHRycy5tanNcbmZ1bmN0aW9uIGJ1aWxkU1ZHQXR0cnMoc3RhdGUsIF9hLCBvcHRpb25zLCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICB2YXIgX2IgPSBfYSwge1xuICAgIGF0dHJYLFxuICAgIGF0dHJZLFxuICAgIG9yaWdpblgsXG4gICAgb3JpZ2luWSxcbiAgICBwYXRoTGVuZ3RoLFxuICAgIHBhdGhTcGFjaW5nID0gMSxcbiAgICBwYXRoT2Zmc2V0ID0gMFxuICB9ID0gX2IsIGxhdGVzdCA9IF9fb2JqUmVzdChfYiwgW1xuICAgIFwiYXR0clhcIixcbiAgICBcImF0dHJZXCIsXG4gICAgXCJvcmlnaW5YXCIsXG4gICAgXCJvcmlnaW5ZXCIsXG4gICAgXCJwYXRoTGVuZ3RoXCIsXG4gICAgXCJwYXRoU3BhY2luZ1wiLFxuICAgIFwicGF0aE9mZnNldFwiXG4gIF0pO1xuICBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIGxhdGVzdCwgb3B0aW9ucywgdHJhbnNmb3JtVGVtcGxhdGUpO1xuICBzdGF0ZS5hdHRycyA9IHN0YXRlLnN0eWxlO1xuICBzdGF0ZS5zdHlsZSA9IHt9O1xuICBjb25zdCB7IGF0dHJzLCBzdHlsZSwgZGltZW5zaW9ucyB9ID0gc3RhdGU7XG4gIGlmIChhdHRycy50cmFuc2Zvcm0pIHtcbiAgICBpZiAoZGltZW5zaW9ucylcbiAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGF0dHJzLnRyYW5zZm9ybTtcbiAgICBkZWxldGUgYXR0cnMudHJhbnNmb3JtO1xuICB9XG4gIGlmIChkaW1lbnNpb25zICYmIChvcmlnaW5YICE9PSB2b2lkIDAgfHwgb3JpZ2luWSAhPT0gdm9pZCAwIHx8IHN0eWxlLnRyYW5zZm9ybSkpIHtcbiAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luKGRpbWVuc2lvbnMsIG9yaWdpblggIT09IHZvaWQgMCA/IG9yaWdpblggOiAwLjUsIG9yaWdpblkgIT09IHZvaWQgMCA/IG9yaWdpblkgOiAwLjUpO1xuICB9XG4gIGlmIChhdHRyWCAhPT0gdm9pZCAwKVxuICAgIGF0dHJzLnggPSBhdHRyWDtcbiAgaWYgKGF0dHJZICE9PSB2b2lkIDApXG4gICAgYXR0cnMueSA9IGF0dHJZO1xuICBpZiAocGF0aExlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgYnVpbGRTVkdQYXRoKGF0dHJzLCBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZywgcGF0aE9mZnNldCwgZmFsc2UpO1xuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qc1xudmFyIGNyZWF0ZVN2Z1JlbmRlclN0YXRlID0gKCkgPT4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgY3JlYXRlSHRtbFJlbmRlclN0YXRlKCkpLCB7XG4gIGF0dHJzOiB7fVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91c2UtcHJvcHMubWpzXG5mdW5jdGlvbiB1c2VTVkdQcm9wcyhwcm9wcywgdmlzdWFsU3RhdGUpIHtcbiAgY29uc3QgdmlzdWFsUHJvcHMgPSAoMCwgaW1wb3J0X3JlYWN0MTUudXNlTWVtbykoKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlU3ZnUmVuZGVyU3RhdGUoKTtcbiAgICBidWlsZFNWR0F0dHJzKHN0YXRlLCB2aXN1YWxTdGF0ZSwgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogZmFsc2UgfSwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBzdGF0ZS5hdHRycyksIHtcbiAgICAgIHN0eWxlOiBfX3NwcmVhZFZhbHVlcyh7fSwgc3RhdGUuc3R5bGUpXG4gICAgfSk7XG4gIH0sIFt2aXN1YWxTdGF0ZV0pO1xuICBpZiAocHJvcHMuc3R5bGUpIHtcbiAgICBjb25zdCByYXdTdHlsZXMgPSB7fTtcbiAgICBjb3B5UmF3VmFsdWVzT25seShyYXdTdHlsZXMsIHByb3BzLnN0eWxlLCBwcm9wcyk7XG4gICAgdmlzdWFsUHJvcHMuc3R5bGUgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgcmF3U3R5bGVzKSwgdmlzdWFsUHJvcHMuc3R5bGUpO1xuICB9XG4gIHJldHVybiB2aXN1YWxQcm9wcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3VzZS1yZW5kZXIubWpzXG5mdW5jdGlvbiBjcmVhdGVVc2VSZW5kZXIoZm9yd2FyZE1vdGlvblByb3BzID0gZmFsc2UpIHtcbiAgY29uc3QgdXNlUmVuZGVyID0gKENvbXBvbmVudCwgcHJvcHMsIHByb2plY3Rpb25JZCwgcmVmLCB7IGxhdGVzdFZhbHVlcyB9LCBpc1N0YXRpYykgPT4ge1xuICAgIGNvbnN0IHVzZVZpc3VhbFByb3BzID0gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KSA/IHVzZVNWR1Byb3BzIDogdXNlSFRNTFByb3BzO1xuICAgIGNvbnN0IHZpc3VhbFByb3BzID0gdXNlVmlzdWFsUHJvcHMocHJvcHMsIGxhdGVzdFZhbHVlcywgaXNTdGF0aWMpO1xuICAgIGNvbnN0IGZpbHRlcmVkUHJvcHMgPSBmaWx0ZXJQcm9wcyhwcm9wcywgdHlwZW9mIENvbXBvbmVudCA9PT0gXCJzdHJpbmdcIiwgZm9yd2FyZE1vdGlvblByb3BzKTtcbiAgICBjb25zdCBlbGVtZW50UHJvcHMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBmaWx0ZXJlZFByb3BzKSwgdmlzdWFsUHJvcHMpLCB7XG4gICAgICByZWZcbiAgICB9KTtcbiAgICBpZiAocHJvamVjdGlvbklkKSB7XG4gICAgICBlbGVtZW50UHJvcHNbXCJkYXRhLXByb2plY3Rpb24taWRcIl0gPSBwcm9qZWN0aW9uSWQ7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW1wb3J0X3JlYWN0MTYuY3JlYXRlRWxlbWVudCkoQ29tcG9uZW50LCBlbGVtZW50UHJvcHMpO1xuICB9O1xuICByZXR1cm4gdXNlUmVuZGVyO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvY2FtZWwtdG8tZGFzaC5tanNcbnZhciBjYW1lbFRvRGFzaCA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvcmVuZGVyLm1qc1xuZnVuY3Rpb24gcmVuZGVySFRNTChlbGVtZW50LCB7IHN0eWxlLCB2YXJzIH0sIHN0eWxlUHJvcCwgcHJvamVjdGlvbikge1xuICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlLCBwcm9qZWN0aW9uICYmIHByb2plY3Rpb24uZ2V0UHJvamVjdGlvblN0eWxlcyhzdHlsZVByb3ApKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YXJzW2tleV0pO1xuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9jYW1lbC1jYXNlLWF0dHJzLm1qc1xudmFyIGNhbWVsQ2FzZUF0dHJpYnV0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYmFzZUZyZXF1ZW5jeVwiLFxuICBcImRpZmZ1c2VDb25zdGFudFwiLFxuICBcImtlcm5lbE1hdHJpeFwiLFxuICBcImtlcm5lbFVuaXRMZW5ndGhcIixcbiAgXCJrZXlTcGxpbmVzXCIsXG4gIFwia2V5VGltZXNcIixcbiAgXCJsaW1pdGluZ0NvbmVBbmdsZVwiLFxuICBcIm1hcmtlckhlaWdodFwiLFxuICBcIm1hcmtlcldpZHRoXCIsXG4gIFwibnVtT2N0YXZlc1wiLFxuICBcInRhcmdldFhcIixcbiAgXCJ0YXJnZXRZXCIsXG4gIFwic3VyZmFjZVNjYWxlXCIsXG4gIFwic3BlY3VsYXJDb25zdGFudFwiLFxuICBcInNwZWN1bGFyRXhwb25lbnRcIixcbiAgXCJzdGREZXZpYXRpb25cIixcbiAgXCJ0YWJsZVZhbHVlc1wiLFxuICBcInZpZXdCb3hcIixcbiAgXCJncmFkaWVudFRyYW5zZm9ybVwiLFxuICBcInBhdGhMZW5ndGhcIlxuXSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9yZW5kZXIubWpzXG5mdW5jdGlvbiByZW5kZXJTVkcoZWxlbWVudCwgcmVuZGVyU3RhdGUsIF9zdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgcmVuZGVySFRNTChlbGVtZW50LCByZW5kZXJTdGF0ZSwgdm9pZCAwLCBwcm9qZWN0aW9uKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmVuZGVyU3RhdGUuYXR0cnMpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSghY2FtZWxDYXNlQXR0cmlidXRlcy5oYXMoa2V5KSA/IGNhbWVsVG9EYXNoKGtleSkgOiBrZXksIHJlbmRlclN0YXRlLmF0dHJzW2tleV0pO1xuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvc2NyYXBlLW1vdGlvbi12YWx1ZXMubWpzXG5mdW5jdGlvbiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpIHtcbiAgY29uc3QgeyBzdHlsZSB9ID0gcHJvcHM7XG4gIGNvbnN0IG5ld1ZhbHVlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZSkge1xuICAgIGlmIChpc01vdGlvblZhbHVlKHN0eWxlW2tleV0pIHx8IGlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykpIHtcbiAgICAgIG5ld1ZhbHVlc1trZXldID0gc3R5bGVba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1ZhbHVlcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qc1xuZnVuY3Rpb24gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMihwcm9wcykge1xuICBjb25zdCBuZXdWYWx1ZXMgPSBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIGlmIChpc01vdGlvblZhbHVlKHByb3BzW2tleV0pKSB7XG4gICAgICBjb25zdCB0YXJnZXRLZXkgPSBrZXkgPT09IFwieFwiIHx8IGtleSA9PT0gXCJ5XCIgPyBcImF0dHJcIiArIGtleS50b1VwcGVyQ2FzZSgpIDoga2V5O1xuICAgICAgbmV3VmFsdWVzW3RhcmdldEtleV0gPSBwcm9wc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3VmFsdWVzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLXN0YXRlLm1qc1xudmFyIGltcG9ydF9yZWFjdDE3ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9yZXNvbHZlLXZhcmlhbnRzLm1qc1xuZnVuY3Rpb24gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24sIGN1c3RvbSwgY3VycmVudFZhbHVlcyA9IHt9LCBjdXJyZW50VmVsb2NpdHkgPSB7fSkge1xuICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uKGN1c3RvbSAhPT0gdm9pZCAwID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBjdXJyZW50VmFsdWVzLCBjdXJyZW50VmVsb2NpdHkpO1xuICB9XG4gIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgIGRlZmluaXRpb24gPSBwcm9wcy52YXJpYW50cyAmJiBwcm9wcy52YXJpYW50c1tkZWZpbml0aW9uXTtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uKGN1c3RvbSAhPT0gdm9pZCAwID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBjdXJyZW50VmFsdWVzLCBjdXJyZW50VmVsb2NpdHkpO1xuICB9XG4gIHJldHVybiBkZWZpbml0aW9uO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy1rZXlmcmFtZXMtdGFyZ2V0Lm1qc1xudmFyIGlzS2V5ZnJhbWVzVGFyZ2V0ID0gKHYpID0+IHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3Jlc29sdmUtdmFsdWUubWpzXG52YXIgaXNDdXN0b21WYWx1ZSA9ICh2KSA9PiB7XG4gIHJldHVybiBCb29sZWFuKHYgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdi5taXggJiYgdi50b1ZhbHVlKTtcbn07XG52YXIgcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyA9ICh2KSA9PiB7XG4gIHJldHVybiBpc0tleWZyYW1lc1RhcmdldCh2KSA/IHZbdi5sZW5ndGggLSAxXSB8fCAwIDogdjtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXRpbHMvcmVzb2x2ZS1tb3Rpb24tdmFsdWUubWpzXG5mdW5jdGlvbiByZXNvbHZlTW90aW9uVmFsdWUodmFsdWUpIHtcbiAgY29uc3QgdW53cmFwcGVkVmFsdWUgPSBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlLmdldCgpIDogdmFsdWU7XG4gIHJldHVybiBpc0N1c3RvbVZhbHVlKHVud3JhcHBlZFZhbHVlKSA/IHVud3JhcHBlZFZhbHVlLnRvVmFsdWUoKSA6IHVud3JhcHBlZFZhbHVlO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLXN0YXRlLm1qc1xuZnVuY3Rpb24gbWFrZVN0YXRlKHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMzLCBjcmVhdGVSZW5kZXJTdGF0ZSwgb25Nb3VudCB9LCBwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0KSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGxhdGVzdFZhbHVlczogbWFrZUxhdGVzdFZhbHVlcyhwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0LCBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMzKSxcbiAgICByZW5kZXJTdGF0ZTogY3JlYXRlUmVuZGVyU3RhdGUoKVxuICB9O1xuICBpZiAob25Nb3VudCkge1xuICAgIHN0YXRlLm1vdW50ID0gKGluc3RhbmNlKSA9PiBvbk1vdW50KHByb3BzLCBpbnN0YW5jZSwgc3RhdGUpO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbnZhciBtYWtlVXNlVmlzdWFsU3RhdGUgPSAoY29uZmlnKSA9PiAocHJvcHMsIGlzU3RhdGljKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MTcudXNlQ29udGV4dCkoTW90aW9uQ29udGV4dCk7XG4gIGNvbnN0IHByZXNlbmNlQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QxNy51c2VDb250ZXh0KShQcmVzZW5jZUNvbnRleHQpO1xuICBjb25zdCBtYWtlID0gKCkgPT4gbWFrZVN0YXRlKGNvbmZpZywgcHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCk7XG4gIHJldHVybiBpc1N0YXRpYyA/IG1ha2UoKSA6IHVzZUNvbnN0YW50KG1ha2UpO1xufTtcbmZ1bmN0aW9uIG1ha2VMYXRlc3RWYWx1ZXMocHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCwgc2NyYXBlTW90aW9uVmFsdWVzKSB7XG4gIGNvbnN0IHZhbHVlcyA9IHt9O1xuICBjb25zdCBtb3Rpb25WYWx1ZXMgPSBzY3JhcGVNb3Rpb25WYWx1ZXMocHJvcHMpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBtb3Rpb25WYWx1ZXMpIHtcbiAgICB2YWx1ZXNba2V5XSA9IHJlc29sdmVNb3Rpb25WYWx1ZShtb3Rpb25WYWx1ZXNba2V5XSk7XG4gIH1cbiAgbGV0IHsgaW5pdGlhbCwgYW5pbWF0ZTogYW5pbWF0ZTMgfSA9IHByb3BzO1xuICBjb25zdCBpc0NvbnRyb2xsaW5nVmFyaWFudHMkMSA9IGlzQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcyk7XG4gIGNvbnN0IGlzVmFyaWFudE5vZGUkMSA9IGlzVmFyaWFudE5vZGUocHJvcHMpO1xuICBpZiAoY29udGV4dCAmJiBpc1ZhcmlhbnROb2RlJDEgJiYgIWlzQ29udHJvbGxpbmdWYXJpYW50cyQxICYmIHByb3BzLmluaGVyaXQgIT09IGZhbHNlKSB7XG4gICAgaWYgKGluaXRpYWwgPT09IHZvaWQgMClcbiAgICAgIGluaXRpYWwgPSBjb250ZXh0LmluaXRpYWw7XG4gICAgaWYgKGFuaW1hdGUzID09PSB2b2lkIDApXG4gICAgICBhbmltYXRlMyA9IGNvbnRleHQuYW5pbWF0ZTtcbiAgfVxuICBsZXQgaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZCA9IHByZXNlbmNlQ29udGV4dCA/IHByZXNlbmNlQ29udGV4dC5pbml0aWFsID09PSBmYWxzZSA6IGZhbHNlO1xuICBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkID0gaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZCB8fCBpbml0aWFsID09PSBmYWxzZTtcbiAgY29uc3QgdmFyaWFudFRvU2V0ID0gaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZCA/IGFuaW1hdGUzIDogaW5pdGlhbDtcbiAgaWYgKHZhcmlhbnRUb1NldCAmJiB0eXBlb2YgdmFyaWFudFRvU2V0ICE9PSBcImJvb2xlYW5cIiAmJiAhaXNBbmltYXRpb25Db250cm9scyh2YXJpYW50VG9TZXQpKSB7XG4gICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkodmFyaWFudFRvU2V0KSA/IHZhcmlhbnRUb1NldCA6IFt2YXJpYW50VG9TZXRdO1xuICAgIGxpc3QuZm9yRWFjaCgoZGVmaW5pdGlvbikgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyhwcm9wcywgZGVmaW5pdGlvbik7XG4gICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBfYSA9IHJlc29sdmVkLCB7IHRyYW5zaXRpb25FbmQsIHRyYW5zaXRpb24gfSA9IF9hLCB0YXJnZXQgPSBfX29ialJlc3QoX2EsIFtcInRyYW5zaXRpb25FbmRcIiwgXCJ0cmFuc2l0aW9uXCJdKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgICAgICBsZXQgdmFsdWVUYXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVUYXJnZXQpKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXgyID0gaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZCA/IHZhbHVlVGFyZ2V0Lmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICAgIHZhbHVlVGFyZ2V0ID0gdmFsdWVUYXJnZXRbaW5kZXgyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZXNba2V5XSA9IHZhbHVlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0cmFuc2l0aW9uRW5kKVxuICAgICAgICB2YWx1ZXNba2V5XSA9IHRyYW5zaXRpb25FbmRba2V5XTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvY29uZmlnLW1vdGlvbi5tanNcbnZhciBzdmdNb3Rpb25Db25maWcgPSB7XG4gIHVzZVZpc3VhbFN0YXRlOiBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMixcbiAgICBjcmVhdGVSZW5kZXJTdGF0ZTogY3JlYXRlU3ZnUmVuZGVyU3RhdGUsXG4gICAgb25Nb3VudDogKHByb3BzLCBpbnN0YW5jZSwgeyByZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzIH0pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlbmRlclN0YXRlLmRpbWVuc2lvbnMgPSB0eXBlb2YgaW5zdGFuY2UuZ2V0QkJveCA9PT0gXCJmdW5jdGlvblwiID8gaW5zdGFuY2UuZ2V0QkJveCgpIDogaW5zdGFuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlbmRlclN0YXRlLmRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnVpbGRTVkdBdHRycyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiBmYWxzZSB9LCBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgICByZW5kZXJTVkcoaW5zdGFuY2UsIHJlbmRlclN0YXRlKTtcbiAgICB9XG4gIH0pXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL2NvbmZpZy1tb3Rpb24ubWpzXG52YXIgaHRtbE1vdGlvbkNvbmZpZyA9IHtcbiAgdXNlVmlzdWFsU3RhdGU6IG1ha2VVc2VWaXN1YWxTdGF0ZSh7XG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLFxuICAgIGNyZWF0ZVJlbmRlclN0YXRlOiBjcmVhdGVIdG1sUmVuZGVyU3RhdGVcbiAgfSlcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9jcmVhdGUtY29uZmlnLm1qc1xuZnVuY3Rpb24gY3JlYXRlRG9tTW90aW9uQ29uZmlnKENvbXBvbmVudCwgeyBmb3J3YXJkTW90aW9uUHJvcHMgPSBmYWxzZSB9LCBwcmVsb2FkZWRGZWF0dXJlcywgY3JlYXRlVmlzdWFsRWxlbWVudCwgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3Rvcikge1xuICBjb25zdCBiYXNlQ29uZmlnID0gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KSA/IHN2Z01vdGlvbkNvbmZpZyA6IGh0bWxNb3Rpb25Db25maWc7XG4gIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBiYXNlQ29uZmlnKSwge1xuICAgIHByZWxvYWRlZEZlYXR1cmVzLFxuICAgIHVzZVJlbmRlcjogY3JlYXRlVXNlUmVuZGVyKGZvcndhcmRNb3Rpb25Qcm9wcyksXG4gICAgY3JlYXRlVmlzdWFsRWxlbWVudCxcbiAgICBwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yLFxuICAgIENvbXBvbmVudFxuICB9KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvdHlwZXMubWpzXG52YXIgQW5pbWF0aW9uVHlwZTtcbihmdW5jdGlvbihBbmltYXRpb25UeXBlMikge1xuICBBbmltYXRpb25UeXBlMltcIkFuaW1hdGVcIl0gPSBcImFuaW1hdGVcIjtcbiAgQW5pbWF0aW9uVHlwZTJbXCJIb3ZlclwiXSA9IFwid2hpbGVIb3ZlclwiO1xuICBBbmltYXRpb25UeXBlMltcIlRhcFwiXSA9IFwid2hpbGVUYXBcIjtcbiAgQW5pbWF0aW9uVHlwZTJbXCJEcmFnXCJdID0gXCJ3aGlsZURyYWdcIjtcbiAgQW5pbWF0aW9uVHlwZTJbXCJGb2N1c1wiXSA9IFwid2hpbGVGb2N1c1wiO1xuICBBbmltYXRpb25UeXBlMltcIkluVmlld1wiXSA9IFwid2hpbGVJblZpZXdcIjtcbiAgQW5pbWF0aW9uVHlwZTJbXCJFeGl0XCJdID0gXCJleGl0XCI7XG59KShBbmltYXRpb25UeXBlIHx8IChBbmltYXRpb25UeXBlID0ge30pKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9ldmVudHMvdXNlLWRvbS1ldmVudC5tanNcbnZhciBpbXBvcnRfcmVhY3QxOCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIGFkZERvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH0pIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG59XG5mdW5jdGlvbiB1c2VEb21FdmVudChyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAoMCwgaW1wb3J0X3JlYWN0MTgudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xuICAgIGlmIChoYW5kbGVyICYmIGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBhZGREb21FdmVudChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwgW3JlZiwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zXSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLWZvY3VzLWdlc3R1cmUubWpzXG5mdW5jdGlvbiB1c2VGb2N1c0dlc3R1cmUoeyB3aGlsZUZvY3VzLCB2aXN1YWxFbGVtZW50IH0pIHtcbiAgY29uc3QgeyBhbmltYXRpb25TdGF0ZSB9ID0gdmlzdWFsRWxlbWVudDtcbiAgY29uc3Qgb25Gb2N1cyA9ICgpID0+IHtcbiAgICBhbmltYXRpb25TdGF0ZSAmJiBhbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5Gb2N1cywgdHJ1ZSk7XG4gIH07XG4gIGNvbnN0IG9uQmx1ciA9ICgpID0+IHtcbiAgICBhbmltYXRpb25TdGF0ZSAmJiBhbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5Gb2N1cywgZmFsc2UpO1xuICB9O1xuICB1c2VEb21FdmVudCh2aXN1YWxFbGVtZW50LCBcImZvY3VzXCIsIHdoaWxlRm9jdXMgPyBvbkZvY3VzIDogdm9pZCAwKTtcbiAgdXNlRG9tRXZlbnQodmlzdWFsRWxlbWVudCwgXCJibHVyXCIsIHdoaWxlRm9jdXMgPyBvbkJsdXIgOiB2b2lkIDApO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3V0aWxzL2V2ZW50LXR5cGUubWpzXG5mdW5jdGlvbiBpc01vdXNlRXZlbnQoZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZXZlbnQgaW5zdGFuY2VvZiBQb2ludGVyRXZlbnQpIHtcbiAgICByZXR1cm4gISEoZXZlbnQucG9pbnRlclR5cGUgPT09IFwibW91c2VcIik7XG4gIH1cbiAgcmV0dXJuIGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudDtcbn1cbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xuICBjb25zdCBoYXNUb3VjaGVzID0gISFldmVudC50b3VjaGVzO1xuICByZXR1cm4gaGFzVG91Y2hlcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9ldmVudHMvZXZlbnQtaW5mby5tanNcbmZ1bmN0aW9uIGZpbHRlclByaW1hcnlQb2ludGVyKGV2ZW50SGFuZGxlcikge1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgaXNNb3VzZUV2ZW50MiA9IGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudDtcbiAgICBjb25zdCBpc1ByaW1hcnlQb2ludGVyID0gIWlzTW91c2VFdmVudDIgfHwgaXNNb3VzZUV2ZW50MiAmJiBldmVudC5idXR0b24gPT09IDA7XG4gICAgaWYgKGlzUHJpbWFyeVBvaW50ZXIpIHtcbiAgICAgIGV2ZW50SGFuZGxlcihldmVudCk7XG4gICAgfVxuICB9O1xufVxudmFyIGRlZmF1bHRQYWdlUG9pbnQgPSB7IHBhZ2VYOiAwLCBwYWdlWTogMCB9O1xuZnVuY3Rpb24gcG9pbnRGcm9tVG91Y2goZSwgcG9pbnRUeXBlID0gXCJwYWdlXCIpIHtcbiAgY29uc3QgcHJpbWFyeVRvdWNoID0gZS50b3VjaGVzWzBdIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gIGNvbnN0IHBvaW50MiA9IHByaW1hcnlUb3VjaCB8fCBkZWZhdWx0UGFnZVBvaW50O1xuICByZXR1cm4ge1xuICAgIHg6IHBvaW50Mltwb2ludFR5cGUgKyBcIlhcIl0sXG4gICAgeTogcG9pbnQyW3BvaW50VHlwZSArIFwiWVwiXVxuICB9O1xufVxuZnVuY3Rpb24gcG9pbnRGcm9tTW91c2UocG9pbnQyLCBwb2ludFR5cGUgPSBcInBhZ2VcIikge1xuICByZXR1cm4ge1xuICAgIHg6IHBvaW50Mltwb2ludFR5cGUgKyBcIlhcIl0sXG4gICAgeTogcG9pbnQyW3BvaW50VHlwZSArIFwiWVwiXVxuICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50SW5mbyhldmVudCwgcG9pbnRUeXBlID0gXCJwYWdlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICBwb2ludDogaXNUb3VjaEV2ZW50KGV2ZW50KSA/IHBvaW50RnJvbVRvdWNoKGV2ZW50LCBwb2ludFR5cGUpIDogcG9pbnRGcm9tTW91c2UoZXZlbnQsIHBvaW50VHlwZSlcbiAgfTtcbn1cbnZhciB3cmFwSGFuZGxlciA9IChoYW5kbGVyLCBzaG91bGRGaWx0ZXJQcmltYXJ5UG9pbnRlciA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50KSA9PiBoYW5kbGVyKGV2ZW50LCBleHRyYWN0RXZlbnRJbmZvKGV2ZW50KSk7XG4gIHJldHVybiBzaG91bGRGaWx0ZXJQcmltYXJ5UG9pbnRlciA/IGZpbHRlclByaW1hcnlQb2ludGVyKGxpc3RlbmVyKSA6IGxpc3RlbmVyO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9ldmVudHMvdXRpbHMubWpzXG52YXIgc3VwcG9ydHNQb2ludGVyRXZlbnRzID0gKCkgPT4gaXNCcm93c2VyICYmIHdpbmRvdy5vbnBvaW50ZXJkb3duID09PSBudWxsO1xudmFyIHN1cHBvcnRzVG91Y2hFdmVudHMgPSAoKSA9PiBpc0Jyb3dzZXIgJiYgd2luZG93Lm9udG91Y2hzdGFydCA9PT0gbnVsbDtcbnZhciBzdXBwb3J0c01vdXNlRXZlbnRzID0gKCkgPT4gaXNCcm93c2VyICYmIHdpbmRvdy5vbm1vdXNlZG93biA9PT0gbnVsbDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9ldmVudHMvdXNlLXBvaW50ZXItZXZlbnQubWpzXG52YXIgbW91c2VFdmVudE5hbWVzID0ge1xuICBwb2ludGVyZG93bjogXCJtb3VzZWRvd25cIixcbiAgcG9pbnRlcm1vdmU6IFwibW91c2Vtb3ZlXCIsXG4gIHBvaW50ZXJ1cDogXCJtb3VzZXVwXCIsXG4gIHBvaW50ZXJjYW5jZWw6IFwibW91c2VjYW5jZWxcIixcbiAgcG9pbnRlcm92ZXI6IFwibW91c2VvdmVyXCIsXG4gIHBvaW50ZXJvdXQ6IFwibW91c2VvdXRcIixcbiAgcG9pbnRlcmVudGVyOiBcIm1vdXNlZW50ZXJcIixcbiAgcG9pbnRlcmxlYXZlOiBcIm1vdXNlbGVhdmVcIlxufTtcbnZhciB0b3VjaEV2ZW50TmFtZXMgPSB7XG4gIHBvaW50ZXJkb3duOiBcInRvdWNoc3RhcnRcIixcbiAgcG9pbnRlcm1vdmU6IFwidG91Y2htb3ZlXCIsXG4gIHBvaW50ZXJ1cDogXCJ0b3VjaGVuZFwiLFxuICBwb2ludGVyY2FuY2VsOiBcInRvdWNoY2FuY2VsXCJcbn07XG5mdW5jdGlvbiBnZXRQb2ludGVyRXZlbnROYW1lKG5hbWUpIHtcbiAgaWYgKHN1cHBvcnRzUG9pbnRlckV2ZW50cygpKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH0gZWxzZSBpZiAoc3VwcG9ydHNUb3VjaEV2ZW50cygpKSB7XG4gICAgcmV0dXJuIHRvdWNoRXZlbnROYW1lc1tuYW1lXTtcbiAgfSBlbHNlIGlmIChzdXBwb3J0c01vdXNlRXZlbnRzKCkpIHtcbiAgICByZXR1cm4gbW91c2VFdmVudE5hbWVzW25hbWVdO1xuICB9XG4gIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gYWRkUG9pbnRlckV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBhZGREb21FdmVudCh0YXJnZXQsIGdldFBvaW50ZXJFdmVudE5hbWUoZXZlbnROYW1lKSwgd3JhcEhhbmRsZXIoaGFuZGxlciwgZXZlbnROYW1lID09PSBcInBvaW50ZXJkb3duXCIpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHVzZVBvaW50ZXJFdmVudChyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICByZXR1cm4gdXNlRG9tRXZlbnQocmVmLCBnZXRQb2ludGVyRXZlbnROYW1lKGV2ZW50TmFtZSksIGhhbmRsZXIgJiYgd3JhcEhhbmRsZXIoaGFuZGxlciwgZXZlbnROYW1lID09PSBcInBvaW50ZXJkb3duXCIpLCBvcHRpb25zKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3V0aWxzL2xvY2subWpzXG5mdW5jdGlvbiBjcmVhdGVMb2NrKG5hbWUpIHtcbiAgbGV0IGxvY2sgPSBudWxsO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IG9wZW5Mb2NrID0gKCkgPT4ge1xuICAgICAgbG9jayA9IG51bGw7XG4gICAgfTtcbiAgICBpZiAobG9jayA9PT0gbnVsbCkge1xuICAgICAgbG9jayA9IG5hbWU7XG4gICAgICByZXR1cm4gb3BlbkxvY2s7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cbnZhciBnbG9iYWxIb3Jpem9udGFsTG9jayA9IGNyZWF0ZUxvY2soXCJkcmFnSG9yaXpvbnRhbFwiKTtcbnZhciBnbG9iYWxWZXJ0aWNhbExvY2sgPSBjcmVhdGVMb2NrKFwiZHJhZ1ZlcnRpY2FsXCIpO1xuZnVuY3Rpb24gZ2V0R2xvYmFsTG9jayhkcmFnMikge1xuICBsZXQgbG9jayA9IGZhbHNlO1xuICBpZiAoZHJhZzIgPT09IFwieVwiKSB7XG4gICAgbG9jayA9IGdsb2JhbFZlcnRpY2FsTG9jaygpO1xuICB9IGVsc2UgaWYgKGRyYWcyID09PSBcInhcIikge1xuICAgIGxvY2sgPSBnbG9iYWxIb3Jpem9udGFsTG9jaygpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG9wZW5Ib3Jpem9udGFsID0gZ2xvYmFsSG9yaXpvbnRhbExvY2soKTtcbiAgICBjb25zdCBvcGVuVmVydGljYWwgPSBnbG9iYWxWZXJ0aWNhbExvY2soKTtcbiAgICBpZiAob3Blbkhvcml6b250YWwgJiYgb3BlblZlcnRpY2FsKSB7XG4gICAgICBsb2NrID0gKCkgPT4ge1xuICAgICAgICBvcGVuSG9yaXpvbnRhbCgpO1xuICAgICAgICBvcGVuVmVydGljYWwoKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcGVuSG9yaXpvbnRhbClcbiAgICAgICAgb3Blbkhvcml6b250YWwoKTtcbiAgICAgIGlmIChvcGVuVmVydGljYWwpXG4gICAgICAgIG9wZW5WZXJ0aWNhbCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG9jaztcbn1cbmZ1bmN0aW9uIGlzRHJhZ0FjdGl2ZSgpIHtcbiAgY29uc3Qgb3Blbkdlc3R1cmVMb2NrID0gZ2V0R2xvYmFsTG9jayh0cnVlKTtcbiAgaWYgKCFvcGVuR2VzdHVyZUxvY2spXG4gICAgcmV0dXJuIHRydWU7XG4gIG9wZW5HZXN0dXJlTG9jaygpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLWhvdmVyLWdlc3R1cmUubWpzXG5mdW5jdGlvbiBjcmVhdGVIb3ZlckV2ZW50KHZpc3VhbEVsZW1lbnQsIGlzQWN0aXZlLCBjYWxsYmFjaykge1xuICByZXR1cm4gKGV2ZW50LCBpbmZvKSA9PiB7XG4gICAgaWYgKCFpc01vdXNlRXZlbnQoZXZlbnQpIHx8IGlzRHJhZ0FjdGl2ZSgpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSB7XG4gICAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkhvdmVyLCBpc0FjdGl2ZSk7XG4gICAgfVxuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGV2ZW50LCBpbmZvKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUhvdmVyR2VzdHVyZSh7IG9uSG92ZXJTdGFydCwgb25Ib3ZlckVuZCwgd2hpbGVIb3ZlciwgdmlzdWFsRWxlbWVudCB9KSB7XG4gIHVzZVBvaW50ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBcInBvaW50ZXJlbnRlclwiLCBvbkhvdmVyU3RhcnQgfHwgd2hpbGVIb3ZlciA/IGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudCwgdHJ1ZSwgb25Ib3ZlclN0YXJ0KSA6IHZvaWQgMCwgeyBwYXNzaXZlOiAhb25Ib3ZlclN0YXJ0IH0pO1xuICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudCwgXCJwb2ludGVybGVhdmVcIiwgb25Ib3ZlckVuZCB8fCB3aGlsZUhvdmVyID8gY3JlYXRlSG92ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBmYWxzZSwgb25Ib3ZlckVuZCkgOiB2b2lkIDAsIHsgcGFzc2l2ZTogIW9uSG92ZXJFbmQgfSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLXRhcC1nZXN0dXJlLm1qc1xudmFyIGltcG9ydF9yZWFjdDIwID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3V0aWxzL2lzLW5vZGUtb3ItY2hpbGQubWpzXG52YXIgaXNOb2RlT3JDaGlsZCA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIGlmICghY2hpbGQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAocGFyZW50ID09PSBjaGlsZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpc05vZGVPckNoaWxkKHBhcmVudCwgY2hpbGQucGFyZW50RWxlbWVudCk7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLXVubW91bnQtZWZmZWN0Lm1qc1xudmFyIGltcG9ydF9yZWFjdDE5ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gdXNlVW5tb3VudEVmZmVjdChjYWxsYmFjaykge1xuICByZXR1cm4gKDAsIGltcG9ydF9yZWFjdDE5LnVzZUVmZmVjdCkoKCkgPT4gKCkgPT4gY2FsbGJhY2soKSwgW10pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL25vZGVfbW9kdWxlcy90c2xpYi9tb2R1bGVzL2luZGV4LmpzXG52YXIgaW1wb3J0X3RzbGliID0gX190b0VTTShyZXF1aXJlX3RzbGliKCksIDEpO1xudmFyIHtcbiAgX19leHRlbmRzLFxuICBfX2Fzc2lnbixcbiAgX19yZXN0LFxuICBfX2RlY29yYXRlLFxuICBfX3BhcmFtLFxuICBfX21ldGFkYXRhLFxuICBfX2F3YWl0ZXIsXG4gIF9fZ2VuZXJhdG9yLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fY3JlYXRlQmluZGluZyxcbiAgX192YWx1ZXMsXG4gIF9fcmVhZCxcbiAgX19zcHJlYWQsXG4gIF9fc3ByZWFkQXJyYXlzLFxuICBfX3NwcmVhZEFycmF5LFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yLFxuICBfX2FzeW5jRGVsZWdhdG9yLFxuICBfX2FzeW5jVmFsdWVzLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgX19pbXBvcnRTdGFyLFxuICBfX2ltcG9ydERlZmF1bHQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJblxufSA9IGltcG9ydF90c2xpYi5kZWZhdWx0O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvaGV5LWxpc3Rlbi9kaXN0L2hleS1saXN0ZW4uZXMuanNcbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7XG59O1xudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKCkge1xufTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjaGVjayAmJiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbiAgaW52YXJpYW50ID0gZnVuY3Rpb24oY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvY2xhbXAubWpzXG52YXIgY2xhbXAyID0gKG1pbiwgbWF4LCB2KSA9PiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy91dGlscy9maW5kLXNwcmluZy5tanNcbnZhciBzYWZlTWluID0gMWUtMztcbnZhciBtaW5EdXJhdGlvbiA9IDAuMDE7XG52YXIgbWF4RHVyYXRpb24gPSAxMDtcbnZhciBtaW5EYW1waW5nID0gMC4wNTtcbnZhciBtYXhEYW1waW5nID0gMTtcbmZ1bmN0aW9uIGZpbmRTcHJpbmcoeyBkdXJhdGlvbiA9IDgwMCwgYm91bmNlID0gMC4yNSwgdmVsb2NpdHkgPSAwLCBtYXNzID0gMSB9KSB7XG4gIGxldCBlbnZlbG9wZTtcbiAgbGV0IGRlcml2YXRpdmU7XG4gIHdhcm5pbmcoZHVyYXRpb24gPD0gbWF4RHVyYXRpb24gKiAxZTMsIFwiU3ByaW5nIGR1cmF0aW9uIG11c3QgYmUgMTAgc2Vjb25kcyBvciBsZXNzXCIpO1xuICBsZXQgZGFtcGluZ1JhdGlvID0gMSAtIGJvdW5jZTtcbiAgZGFtcGluZ1JhdGlvID0gY2xhbXAyKG1pbkRhbXBpbmcsIG1heERhbXBpbmcsIGRhbXBpbmdSYXRpbyk7XG4gIGR1cmF0aW9uID0gY2xhbXAyKG1pbkR1cmF0aW9uLCBtYXhEdXJhdGlvbiwgZHVyYXRpb24gLyAxZTMpO1xuICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgIGVudmVsb3BlID0gKHVuZGFtcGVkRnJlcTIpID0+IHtcbiAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVjYXkgPSB1bmRhbXBlZEZyZXEyICogZGFtcGluZ1JhdGlvO1xuICAgICAgY29uc3QgZGVsdGEgPSBleHBvbmVudGlhbERlY2F5ICogZHVyYXRpb247XG4gICAgICBjb25zdCBhMiA9IGV4cG9uZW50aWFsRGVjYXkgLSB2ZWxvY2l0eTtcbiAgICAgIGNvbnN0IGIyID0gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcTIsIGRhbXBpbmdSYXRpbyk7XG4gICAgICBjb25zdCBjMyA9IE1hdGguZXhwKC1kZWx0YSk7XG4gICAgICByZXR1cm4gc2FmZU1pbiAtIGEyIC8gYjIgKiBjMztcbiAgICB9O1xuICAgIGRlcml2YXRpdmUgPSAodW5kYW1wZWRGcmVxMikgPT4ge1xuICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWNheSA9IHVuZGFtcGVkRnJlcTIgKiBkYW1waW5nUmF0aW87XG4gICAgICBjb25zdCBkZWx0YSA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgIGNvbnN0IGQyID0gZGVsdGEgKiB2ZWxvY2l0eSArIHZlbG9jaXR5O1xuICAgICAgY29uc3QgZSA9IE1hdGgucG93KGRhbXBpbmdSYXRpbywgMikgKiBNYXRoLnBvdyh1bmRhbXBlZEZyZXEyLCAyKSAqIGR1cmF0aW9uO1xuICAgICAgY29uc3QgZjIgPSBNYXRoLmV4cCgtZGVsdGEpO1xuICAgICAgY29uc3QgZzIgPSBjYWxjQW5ndWxhckZyZXEoTWF0aC5wb3codW5kYW1wZWRGcmVxMiwgMiksIGRhbXBpbmdSYXRpbyk7XG4gICAgICBjb25zdCBmYWN0b3IgPSAtZW52ZWxvcGUodW5kYW1wZWRGcmVxMikgKyBzYWZlTWluID4gMCA/IC0xIDogMTtcbiAgICAgIHJldHVybiBmYWN0b3IgKiAoKGQyIC0gZSkgKiBmMikgLyBnMjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGVudmVsb3BlID0gKHVuZGFtcGVkRnJlcTIpID0+IHtcbiAgICAgIGNvbnN0IGEyID0gTWF0aC5leHAoLXVuZGFtcGVkRnJlcTIgKiBkdXJhdGlvbik7XG4gICAgICBjb25zdCBiMiA9ICh1bmRhbXBlZEZyZXEyIC0gdmVsb2NpdHkpICogZHVyYXRpb24gKyAxO1xuICAgICAgcmV0dXJuIC1zYWZlTWluICsgYTIgKiBiMjtcbiAgICB9O1xuICAgIGRlcml2YXRpdmUgPSAodW5kYW1wZWRGcmVxMikgPT4ge1xuICAgICAgY29uc3QgYTIgPSBNYXRoLmV4cCgtdW5kYW1wZWRGcmVxMiAqIGR1cmF0aW9uKTtcbiAgICAgIGNvbnN0IGIyID0gKHZlbG9jaXR5IC0gdW5kYW1wZWRGcmVxMikgKiAoZHVyYXRpb24gKiBkdXJhdGlvbik7XG4gICAgICByZXR1cm4gYTIgKiBiMjtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGluaXRpYWxHdWVzcyA9IDUgLyBkdXJhdGlvbjtcbiAgY29uc3QgdW5kYW1wZWRGcmVxID0gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpO1xuICBkdXJhdGlvbiA9IGR1cmF0aW9uICogMWUzO1xuICBpZiAoaXNOYU4odW5kYW1wZWRGcmVxKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGlmZm5lc3M6IDEwMCxcbiAgICAgIGRhbXBpbmc6IDEwLFxuICAgICAgZHVyYXRpb25cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0aWZmbmVzcyA9IE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMikgKiBtYXNzO1xuICAgIHJldHVybiB7XG4gICAgICBzdGlmZm5lc3MsXG4gICAgICBkYW1waW5nOiBkYW1waW5nUmF0aW8gKiAyICogTWF0aC5zcXJ0KG1hc3MgKiBzdGlmZm5lc3MpLFxuICAgICAgZHVyYXRpb25cbiAgICB9O1xuICB9XG59XG52YXIgcm9vdEl0ZXJhdGlvbnMgPSAxMjtcbmZ1bmN0aW9uIGFwcHJveGltYXRlUm9vdChlbnZlbG9wZSwgZGVyaXZhdGl2ZSwgaW5pdGlhbEd1ZXNzKSB7XG4gIGxldCByZXN1bHQgPSBpbml0aWFsR3Vlc3M7XG4gIGZvciAobGV0IGkyID0gMTsgaTIgPCByb290SXRlcmF0aW9uczsgaTIrKykge1xuICAgIHJlc3VsdCA9IHJlc3VsdCAtIGVudmVsb3BlKHJlc3VsdCkgLyBkZXJpdmF0aXZlKHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhbGNBbmd1bGFyRnJlcSh1bmRhbXBlZEZyZXEsIGRhbXBpbmdSYXRpbykge1xuICByZXR1cm4gdW5kYW1wZWRGcmVxICogTWF0aC5zcXJ0KDEgLSBkYW1waW5nUmF0aW8gKiBkYW1waW5nUmF0aW8pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy9nZW5lcmF0b3JzL3NwcmluZy5tanNcbnZhciBkdXJhdGlvbktleXMgPSBbXCJkdXJhdGlvblwiLCBcImJvdW5jZVwiXTtcbnZhciBwaHlzaWNzS2V5cyA9IFtcInN0aWZmbmVzc1wiLCBcImRhbXBpbmdcIiwgXCJtYXNzXCJdO1xuZnVuY3Rpb24gaXNTcHJpbmdUeXBlKG9wdGlvbnMsIGtleXMyKSB7XG4gIHJldHVybiBrZXlzMi5zb21lKChrZXkpID0+IG9wdGlvbnNba2V5XSAhPT0gdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIGdldFNwcmluZ09wdGlvbnMob3B0aW9ucykge1xuICBsZXQgc3ByaW5nT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB2ZWxvY2l0eTogMCwgc3RpZmZuZXNzOiAxMDAsIGRhbXBpbmc6IDEwLCBtYXNzOiAxLCBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgaWYgKCFpc1NwcmluZ1R5cGUob3B0aW9ucywgcGh5c2ljc0tleXMpICYmIGlzU3ByaW5nVHlwZShvcHRpb25zLCBkdXJhdGlvbktleXMpKSB7XG4gICAgY29uc3QgZGVyaXZlZCA9IGZpbmRTcHJpbmcob3B0aW9ucyk7XG4gICAgc3ByaW5nT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzcHJpbmdPcHRpb25zKSwgZGVyaXZlZCksIHsgdmVsb2NpdHk6IDAsIG1hc3M6IDEgfSk7XG4gICAgc3ByaW5nT3B0aW9ucy5pc1Jlc29sdmVkRnJvbUR1cmF0aW9uID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gc3ByaW5nT3B0aW9ucztcbn1cbmZ1bmN0aW9uIHNwcmluZyhfYSkge1xuICB2YXIgeyBmcm9tID0gMCwgdG8gPSAxLCByZXN0U3BlZWQgPSAyLCByZXN0RGVsdGEgfSA9IF9hLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJmcm9tXCIsIFwidG9cIiwgXCJyZXN0U3BlZWRcIiwgXCJyZXN0RGVsdGFcIl0pO1xuICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmcm9tIH07XG4gIGxldCB7IHN0aWZmbmVzcywgZGFtcGluZywgbWFzcywgdmVsb2NpdHksIGR1cmF0aW9uLCBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uIH0gPSBnZXRTcHJpbmdPcHRpb25zKG9wdGlvbnMpO1xuICBsZXQgcmVzb2x2ZVNwcmluZyA9IHplcm87XG4gIGxldCByZXNvbHZlVmVsb2NpdHkgPSB6ZXJvO1xuICBmdW5jdGlvbiBjcmVhdGVTcHJpbmcoKSB7XG4gICAgY29uc3QgaW5pdGlhbFZlbG9jaXR5ID0gdmVsb2NpdHkgPyAtKHZlbG9jaXR5IC8gMWUzKSA6IDA7XG4gICAgY29uc3QgaW5pdGlhbERlbHRhID0gdG8gLSBmcm9tO1xuICAgIGNvbnN0IGRhbXBpbmdSYXRpbyA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gICAgY29uc3QgdW5kYW1wZWRBbmd1bGFyRnJlcSA9IE1hdGguc3FydChzdGlmZm5lc3MgLyBtYXNzKSAvIDFlMztcbiAgICBpZiAocmVzdERlbHRhID09PSB2b2lkIDApIHtcbiAgICAgIHJlc3REZWx0YSA9IE1hdGgubWluKE1hdGguYWJzKHRvIC0gZnJvbSkgLyAxMDAsIDAuNCk7XG4gICAgfVxuICAgIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgICBjb25zdCBhbmd1bGFyRnJlcSA9IGNhbGNBbmd1bGFyRnJlcSh1bmRhbXBlZEFuZ3VsYXJGcmVxLCBkYW1waW5nUmF0aW8pO1xuICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgcmV0dXJuIHRvIC0gZW52ZWxvcGUgKiAoKGluaXRpYWxWZWxvY2l0eSArIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpIC8gYW5ndWxhckZyZXEgKiBNYXRoLnNpbihhbmd1bGFyRnJlcSAqIHQpICsgaW5pdGlhbERlbHRhICogTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSk7XG4gICAgICB9O1xuICAgICAgcmVzb2x2ZVZlbG9jaXR5ID0gKHQpID0+IHtcbiAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICByZXR1cm4gZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGVudmVsb3BlICogKE1hdGguc2luKGFuZ3VsYXJGcmVxICogdCkgKiAoaW5pdGlhbFZlbG9jaXR5ICsgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgLyBhbmd1bGFyRnJlcSArIGluaXRpYWxEZWx0YSAqIE1hdGguY29zKGFuZ3VsYXJGcmVxICogdCkpIC0gZW52ZWxvcGUgKiAoTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSAqIChpbml0aWFsVmVsb2NpdHkgKyBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAtIGFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhICogTWF0aC5zaW4oYW5ndWxhckZyZXEgKiB0KSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGFtcGluZ1JhdGlvID09PSAxKSB7XG4gICAgICByZXNvbHZlU3ByaW5nID0gKHQpID0+IHRvIC0gTWF0aC5leHAoLXVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KSAqIChpbml0aWFsRGVsdGEgKyAoaW5pdGlhbFZlbG9jaXR5ICsgdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgKiB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGFtcGVkQW5ndWxhckZyZXEgPSB1bmRhbXBlZEFuZ3VsYXJGcmVxICogTWF0aC5zcXJ0KGRhbXBpbmdSYXRpbyAqIGRhbXBpbmdSYXRpbyAtIDEpO1xuICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgY29uc3QgZnJlcUZvclQgPSBNYXRoLm1pbihkYW1wZWRBbmd1bGFyRnJlcSAqIHQsIDMwMCk7XG4gICAgICAgIHJldHVybiB0byAtIGVudmVsb3BlICogKChpbml0aWFsVmVsb2NpdHkgKyBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAqIE1hdGguc2luaChmcmVxRm9yVCkgKyBkYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSAqIE1hdGguY29zaChmcmVxRm9yVCkpIC8gZGFtcGVkQW5ndWxhckZyZXE7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBjcmVhdGVTcHJpbmcoKTtcbiAgcmV0dXJuIHtcbiAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IHJlc29sdmVTcHJpbmcodCk7XG4gICAgICBpZiAoIWlzUmVzb2x2ZWRGcm9tRHVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgY3VycmVudFZlbG9jaXR5ID0gcmVzb2x2ZVZlbG9jaXR5KHQpICogMWUzO1xuICAgICAgICBjb25zdCBpc0JlbG93VmVsb2NpdHlUaHJlc2hvbGQgPSBNYXRoLmFicyhjdXJyZW50VmVsb2NpdHkpIDw9IHJlc3RTcGVlZDtcbiAgICAgICAgY29uc3QgaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZCA9IE1hdGguYWJzKHRvIC0gY3VycmVudCkgPD0gcmVzdERlbHRhO1xuICAgICAgICBzdGF0ZS5kb25lID0gaXNCZWxvd1ZlbG9jaXR5VGhyZXNob2xkICYmIGlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5kb25lID0gdCA+PSBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnZhbHVlID0gc3RhdGUuZG9uZSA/IHRvIDogY3VycmVudDtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGZsaXBUYXJnZXQ6ICgpID0+IHtcbiAgICAgIHZlbG9jaXR5ID0gLXZlbG9jaXR5O1xuICAgICAgW2Zyb20sIHRvXSA9IFt0bywgZnJvbV07XG4gICAgICBjcmVhdGVTcHJpbmcoKTtcbiAgICB9XG4gIH07XG59XG5zcHJpbmcubmVlZHNJbnRlcnBvbGF0aW9uID0gKGEyLCBiMikgPT4gdHlwZW9mIGEyID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBiMiA9PT0gXCJzdHJpbmdcIjtcbnZhciB6ZXJvID0gKF90KSA9PiAwO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvcHJvZ3Jlc3MubWpzXG52YXIgcHJvZ3Jlc3MgPSAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gIGNvbnN0IHRvRnJvbURpZmZlcmVuY2UgPSB0byAtIGZyb207XG4gIHJldHVybiB0b0Zyb21EaWZmZXJlbmNlID09PSAwID8gMSA6ICh2YWx1ZSAtIGZyb20pIC8gdG9Gcm9tRGlmZmVyZW5jZTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9taXgubWpzXG52YXIgbWl4ID0gKGZyb20sIHRvLCBwcm9ncmVzczMpID0+IC1wcm9ncmVzczMgKiBmcm9tICsgcHJvZ3Jlc3MzICogdG8gKyBmcm9tO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaHNsYS10by1yZ2JhLm1qc1xuZnVuY3Rpb24gaHVlVG9SZ2IocDIsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKVxuICAgIHQgKz0gMTtcbiAgaWYgKHQgPiAxKVxuICAgIHQgLT0gMTtcbiAgaWYgKHQgPCAxIC8gNilcbiAgICByZXR1cm4gcDIgKyAocSAtIHAyKSAqIDYgKiB0O1xuICBpZiAodCA8IDEgLyAyKVxuICAgIHJldHVybiBxO1xuICBpZiAodCA8IDIgLyAzKVxuICAgIHJldHVybiBwMiArIChxIC0gcDIpICogKDIgLyAzIC0gdCkgKiA2O1xuICByZXR1cm4gcDI7XG59XG5mdW5jdGlvbiBoc2xhVG9SZ2JhKHsgaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhOiBhbHBoYTIgfSkge1xuICBodWUgLz0gMzYwO1xuICBzYXR1cmF0aW9uIC89IDEwMDtcbiAgbGlnaHRuZXNzIC89IDEwMDtcbiAgbGV0IHJlZCA9IDA7XG4gIGxldCBncmVlbiA9IDA7XG4gIGxldCBibHVlID0gMDtcbiAgaWYgKCFzYXR1cmF0aW9uKSB7XG4gICAgcmVkID0gZ3JlZW4gPSBibHVlID0gbGlnaHRuZXNzO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHEgPSBsaWdodG5lc3MgPCAwLjUgPyBsaWdodG5lc3MgKiAoMSArIHNhdHVyYXRpb24pIDogbGlnaHRuZXNzICsgc2F0dXJhdGlvbiAtIGxpZ2h0bmVzcyAqIHNhdHVyYXRpb247XG4gICAgY29uc3QgcDIgPSAyICogbGlnaHRuZXNzIC0gcTtcbiAgICByZWQgPSBodWVUb1JnYihwMiwgcSwgaHVlICsgMSAvIDMpO1xuICAgIGdyZWVuID0gaHVlVG9SZ2IocDIsIHEsIGh1ZSk7XG4gICAgYmx1ZSA9IGh1ZVRvUmdiKHAyLCBxLCBodWUgLSAxIC8gMyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZWQ6IE1hdGgucm91bmQocmVkICogMjU1KSxcbiAgICBncmVlbjogTWF0aC5yb3VuZChncmVlbiAqIDI1NSksXG4gICAgYmx1ZTogTWF0aC5yb3VuZChibHVlICogMjU1KSxcbiAgICBhbHBoYTogYWxwaGEyXG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9taXgtY29sb3IubWpzXG52YXIgbWl4TGluZWFyQ29sb3IgPSAoZnJvbSwgdG8sIHYpID0+IHtcbiAgY29uc3QgZnJvbUV4cG8gPSBmcm9tICogZnJvbTtcbiAgY29uc3QgdG9FeHBvID0gdG8gKiB0bztcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLm1heCgwLCB2ICogKHRvRXhwbyAtIGZyb21FeHBvKSArIGZyb21FeHBvKSk7XG59O1xudmFyIGNvbG9yVHlwZXMgPSBbaGV4LCByZ2JhLCBoc2xhXTtcbnZhciBnZXRDb2xvclR5cGUgPSAodikgPT4gY29sb3JUeXBlcy5maW5kKCh0eXBlKSA9PiB0eXBlLnRlc3QodikpO1xudmFyIG5vdEFuaW1hdGFibGUgPSAoY29sb3IyKSA9PiBgJyR7Y29sb3IyfScgaXMgbm90IGFuIGFuaW1hdGFibGUgY29sb3IuIFVzZSB0aGUgZXF1aXZhbGVudCBjb2xvciBjb2RlIGluc3RlYWQuYDtcbnZhciBtaXhDb2xvciA9IChmcm9tLCB0bykgPT4ge1xuICBsZXQgZnJvbUNvbG9yVHlwZSA9IGdldENvbG9yVHlwZShmcm9tKTtcbiAgbGV0IHRvQ29sb3JUeXBlID0gZ2V0Q29sb3JUeXBlKHRvKTtcbiAgaW52YXJpYW50KCEhZnJvbUNvbG9yVHlwZSwgbm90QW5pbWF0YWJsZShmcm9tKSk7XG4gIGludmFyaWFudCghIXRvQ29sb3JUeXBlLCBub3RBbmltYXRhYmxlKHRvKSk7XG4gIGxldCBmcm9tQ29sb3IgPSBmcm9tQ29sb3JUeXBlLnBhcnNlKGZyb20pO1xuICBsZXQgdG9Db2xvciA9IHRvQ29sb3JUeXBlLnBhcnNlKHRvKTtcbiAgaWYgKGZyb21Db2xvclR5cGUgPT09IGhzbGEpIHtcbiAgICBmcm9tQ29sb3IgPSBoc2xhVG9SZ2JhKGZyb21Db2xvcik7XG4gICAgZnJvbUNvbG9yVHlwZSA9IHJnYmE7XG4gIH1cbiAgaWYgKHRvQ29sb3JUeXBlID09PSBoc2xhKSB7XG4gICAgdG9Db2xvciA9IGhzbGFUb1JnYmEodG9Db2xvcik7XG4gICAgdG9Db2xvclR5cGUgPSByZ2JhO1xuICB9XG4gIGNvbnN0IGJsZW5kZWQgPSBPYmplY3QuYXNzaWduKHt9LCBmcm9tQ29sb3IpO1xuICByZXR1cm4gKHYpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBibGVuZGVkKSB7XG4gICAgICBpZiAoa2V5ICE9PSBcImFscGhhXCIpIHtcbiAgICAgICAgYmxlbmRlZFtrZXldID0gbWl4TGluZWFyQ29sb3IoZnJvbUNvbG9yW2tleV0sIHRvQ29sb3Jba2V5XSwgdik7XG4gICAgICB9XG4gICAgfVxuICAgIGJsZW5kZWQuYWxwaGEgPSBtaXgoZnJvbUNvbG9yLmFscGhhLCB0b0NvbG9yLmFscGhhLCB2KTtcbiAgICByZXR1cm4gZnJvbUNvbG9yVHlwZS50cmFuc2Zvcm0oYmxlbmRlZCk7XG4gIH07XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaW5jLm1qc1xudmFyIGlzTnVtID0gKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvcGlwZS5tanNcbnZhciBjb21iaW5lRnVuY3Rpb25zID0gKGEyLCBiMikgPT4gKHYpID0+IGIyKGEyKHYpKTtcbnZhciBwaXBlID0gKC4uLnRyYW5zZm9ybWVycykgPT4gdHJhbnNmb3JtZXJzLnJlZHVjZShjb21iaW5lRnVuY3Rpb25zKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC1jb21wbGV4Lm1qc1xuZnVuY3Rpb24gZ2V0TWl4ZXIob3JpZ2luLCB0YXJnZXQpIHtcbiAgaWYgKGlzTnVtKG9yaWdpbikpIHtcbiAgICByZXR1cm4gKHYpID0+IG1peChvcmlnaW4sIHRhcmdldCwgdik7XG4gIH0gZWxzZSBpZiAoY29sb3IudGVzdChvcmlnaW4pKSB7XG4gICAgcmV0dXJuIG1peENvbG9yKG9yaWdpbiwgdGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWl4Q29tcGxleChvcmlnaW4sIHRhcmdldCk7XG4gIH1cbn1cbnZhciBtaXhBcnJheSA9IChmcm9tLCB0bykgPT4ge1xuICBjb25zdCBvdXRwdXQgPSBbLi4uZnJvbV07XG4gIGNvbnN0IG51bVZhbHVlcyA9IG91dHB1dC5sZW5ndGg7XG4gIGNvbnN0IGJsZW5kVmFsdWUgPSBmcm9tLm1hcCgoZnJvbVRoaXMsIGkyKSA9PiBnZXRNaXhlcihmcm9tVGhpcywgdG9baTJdKSk7XG4gIHJldHVybiAodikgPT4ge1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1WYWx1ZXM7IGkyKyspIHtcbiAgICAgIG91dHB1dFtpMl0gPSBibGVuZFZhbHVlW2kyXSh2KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn07XG52YXIgbWl4T2JqZWN0ID0gKG9yaWdpbiwgdGFyZ2V0KSA9PiB7XG4gIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luKSwgdGFyZ2V0KTtcbiAgY29uc3QgYmxlbmRWYWx1ZSA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvdXRwdXQpIHtcbiAgICBpZiAob3JpZ2luW2tleV0gIT09IHZvaWQgMCAmJiB0YXJnZXRba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICBibGVuZFZhbHVlW2tleV0gPSBnZXRNaXhlcihvcmlnaW5ba2V5XSwgdGFyZ2V0W2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKHYpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBibGVuZFZhbHVlKSB7XG4gICAgICBvdXRwdXRba2V5XSA9IGJsZW5kVmFsdWVba2V5XSh2KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn07XG5mdW5jdGlvbiBhbmFseXNlMih2YWx1ZSkge1xuICBjb25zdCBwYXJzZWQgPSBjb21wbGV4LnBhcnNlKHZhbHVlKTtcbiAgY29uc3QgbnVtVmFsdWVzID0gcGFyc2VkLmxlbmd0aDtcbiAgbGV0IG51bU51bWJlcnMgPSAwO1xuICBsZXQgbnVtUkdCID0gMDtcbiAgbGV0IG51bUhTTCA9IDA7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1WYWx1ZXM7IGkyKyspIHtcbiAgICBpZiAobnVtTnVtYmVycyB8fCB0eXBlb2YgcGFyc2VkW2kyXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbnVtTnVtYmVycysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyc2VkW2kyXS5odWUgIT09IHZvaWQgMCkge1xuICAgICAgICBudW1IU0wrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG51bVJHQisrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4geyBwYXJzZWQsIG51bU51bWJlcnMsIG51bVJHQiwgbnVtSFNMIH07XG59XG52YXIgbWl4Q29tcGxleCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICBjb25zdCB0ZW1wbGF0ZSA9IGNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIodGFyZ2V0KTtcbiAgY29uc3Qgb3JpZ2luU3RhdHMgPSBhbmFseXNlMihvcmlnaW4pO1xuICBjb25zdCB0YXJnZXRTdGF0cyA9IGFuYWx5c2UyKHRhcmdldCk7XG4gIGNvbnN0IGNhbkludGVycG9sYXRlID0gb3JpZ2luU3RhdHMubnVtSFNMID09PSB0YXJnZXRTdGF0cy5udW1IU0wgJiYgb3JpZ2luU3RhdHMubnVtUkdCID09PSB0YXJnZXRTdGF0cy5udW1SR0IgJiYgb3JpZ2luU3RhdHMubnVtTnVtYmVycyA+PSB0YXJnZXRTdGF0cy5udW1OdW1iZXJzO1xuICBpZiAoY2FuSW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gcGlwZShtaXhBcnJheShvcmlnaW5TdGF0cy5wYXJzZWQsIHRhcmdldFN0YXRzLnBhcnNlZCksIHRlbXBsYXRlKTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuaW5nKHRydWUsIGBDb21wbGV4IHZhbHVlcyAnJHtvcmlnaW59JyBhbmQgJyR7dGFyZ2V0fScgdG9vIGRpZmZlcmVudCB0byBtaXguIEVuc3VyZSBhbGwgY29sb3JzIGFyZSBvZiB0aGUgc2FtZSB0eXBlLCBhbmQgdGhhdCBlYWNoIGNvbnRhaW5zIHRoZSBzYW1lIHF1YW50aXR5IG9mIG51bWJlciBhbmQgY29sb3IgdmFsdWVzLiBGYWxsaW5nIGJhY2sgdG8gaW5zdGFudCB0cmFuc2l0aW9uLmApO1xuICAgIHJldHVybiAocDIpID0+IGAke3AyID4gMCA/IHRhcmdldCA6IG9yaWdpbn1gO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaW50ZXJwb2xhdGUubWpzXG52YXIgbWl4TnVtYmVyID0gKGZyb20sIHRvKSA9PiAocDIpID0+IG1peChmcm9tLCB0bywgcDIpO1xuZnVuY3Rpb24gZGV0ZWN0TWl4ZXJGYWN0b3J5KHYpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG1peE51bWJlcjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChjb2xvci50ZXN0KHYpKSB7XG4gICAgICByZXR1cm4gbWl4Q29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaXhDb21wbGV4O1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIG1peEFycmF5O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG1peE9iamVjdDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTWl4ZXJzKG91dHB1dCwgZWFzZSwgY3VzdG9tTWl4ZXIpIHtcbiAgY29uc3QgbWl4ZXJzID0gW107XG4gIGNvbnN0IG1peGVyRmFjdG9yeSA9IGN1c3RvbU1peGVyIHx8IGRldGVjdE1peGVyRmFjdG9yeShvdXRwdXRbMF0pO1xuICBjb25zdCBudW1NaXhlcnMgPSBvdXRwdXQubGVuZ3RoIC0gMTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bU1peGVyczsgaTIrKykge1xuICAgIGxldCBtaXhlciA9IG1peGVyRmFjdG9yeShvdXRwdXRbaTJdLCBvdXRwdXRbaTIgKyAxXSk7XG4gICAgaWYgKGVhc2UpIHtcbiAgICAgIGNvbnN0IGVhc2luZ0Z1bmN0aW9uID0gQXJyYXkuaXNBcnJheShlYXNlKSA/IGVhc2VbaTJdIDogZWFzZTtcbiAgICAgIG1peGVyID0gcGlwZShlYXNpbmdGdW5jdGlvbiwgbWl4ZXIpO1xuICAgIH1cbiAgICBtaXhlcnMucHVzaChtaXhlcik7XG4gIH1cbiAgcmV0dXJuIG1peGVycztcbn1cbmZ1bmN0aW9uIGZhc3RJbnRlcnBvbGF0ZShbZnJvbSwgdG9dLCBbbWl4ZXJdKSB7XG4gIHJldHVybiAodikgPT4gbWl4ZXIocHJvZ3Jlc3MoZnJvbSwgdG8sIHYpKTtcbn1cbmZ1bmN0aW9uIHNsb3dJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKSB7XG4gIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBjb25zdCBsYXN0SW5wdXRJbmRleCA9IGlucHV0TGVuZ3RoIC0gMTtcbiAgcmV0dXJuICh2KSA9PiB7XG4gICAgbGV0IG1peGVySW5kZXggPSAwO1xuICAgIGxldCBmb3VuZE1peGVySW5kZXggPSBmYWxzZTtcbiAgICBpZiAodiA8PSBpbnB1dFswXSkge1xuICAgICAgZm91bmRNaXhlckluZGV4ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gaW5wdXRbbGFzdElucHV0SW5kZXhdKSB7XG4gICAgICBtaXhlckluZGV4ID0gbGFzdElucHV0SW5kZXggLSAxO1xuICAgICAgZm91bmRNaXhlckluZGV4ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFmb3VuZE1peGVySW5kZXgpIHtcbiAgICAgIGxldCBpMiA9IDE7XG4gICAgICBmb3IgKDsgaTIgPCBpbnB1dExlbmd0aDsgaTIrKykge1xuICAgICAgICBpZiAoaW5wdXRbaTJdID4gdiB8fCBpMiA9PT0gbGFzdElucHV0SW5kZXgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWl4ZXJJbmRleCA9IGkyIC0gMTtcbiAgICB9XG4gICAgY29uc3QgcHJvZ3Jlc3NJblJhbmdlID0gcHJvZ3Jlc3MoaW5wdXRbbWl4ZXJJbmRleF0sIGlucHV0W21peGVySW5kZXggKyAxXSwgdik7XG4gICAgcmV0dXJuIG1peGVyc1ttaXhlckluZGV4XShwcm9ncmVzc0luUmFuZ2UpO1xuICB9O1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIG91dHB1dCwgeyBjbGFtcDogaXNDbGFtcCA9IHRydWUsIGVhc2UsIG1peGVyIH0gPSB7fSkge1xuICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgaW52YXJpYW50KGlucHV0TGVuZ3RoID09PSBvdXRwdXQubGVuZ3RoLCBcIkJvdGggaW5wdXQgYW5kIG91dHB1dCByYW5nZXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gIGludmFyaWFudCghZWFzZSB8fCAhQXJyYXkuaXNBcnJheShlYXNlKSB8fCBlYXNlLmxlbmd0aCA9PT0gaW5wdXRMZW5ndGggLSAxLCBcIkFycmF5IG9mIGVhc2luZyBmdW5jdGlvbnMgbXVzdCBiZSBvZiBsZW5ndGggYGlucHV0Lmxlbmd0aCAtIDFgLCBhcyBpdCBhcHBsaWVzIHRvIHRoZSB0cmFuc2l0aW9ucyAqKmJldHdlZW4qKiB0aGUgZGVmaW5lZCB2YWx1ZXMuXCIpO1xuICBpZiAoaW5wdXRbMF0gPiBpbnB1dFtpbnB1dExlbmd0aCAtIDFdKSB7XG4gICAgaW5wdXQgPSBbXS5jb25jYXQoaW5wdXQpO1xuICAgIG91dHB1dCA9IFtdLmNvbmNhdChvdXRwdXQpO1xuICAgIGlucHV0LnJldmVyc2UoKTtcbiAgICBvdXRwdXQucmV2ZXJzZSgpO1xuICB9XG4gIGNvbnN0IG1peGVycyA9IGNyZWF0ZU1peGVycyhvdXRwdXQsIGVhc2UsIG1peGVyKTtcbiAgY29uc3QgaW50ZXJwb2xhdG9yID0gaW5wdXRMZW5ndGggPT09IDIgPyBmYXN0SW50ZXJwb2xhdGUoaW5wdXQsIG1peGVycykgOiBzbG93SW50ZXJwb2xhdGUoaW5wdXQsIG1peGVycyk7XG4gIHJldHVybiBpc0NsYW1wID8gKHYpID0+IGludGVycG9sYXRvcihjbGFtcDIoaW5wdXRbMF0sIGlucHV0W2lucHV0TGVuZ3RoIC0gMV0sIHYpKSA6IGludGVycG9sYXRvcjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2Vhc2luZy91dGlscy5tanNcbnZhciByZXZlcnNlRWFzaW5nID0gKGVhc2luZykgPT4gKHAyKSA9PiAxIC0gZWFzaW5nKDEgLSBwMik7XG52YXIgbWlycm9yRWFzaW5nID0gKGVhc2luZykgPT4gKHAyKSA9PiBwMiA8PSAwLjUgPyBlYXNpbmcoMiAqIHAyKSAvIDIgOiAoMiAtIGVhc2luZygyICogKDEgLSBwMikpKSAvIDI7XG52YXIgY3JlYXRlRXhwb0luID0gKHBvd2VyKSA9PiAocDIpID0+IE1hdGgucG93KHAyLCBwb3dlcik7XG52YXIgY3JlYXRlQmFja0luID0gKHBvd2VyKSA9PiAocDIpID0+IHAyICogcDIgKiAoKHBvd2VyICsgMSkgKiBwMiAtIHBvd2VyKTtcbnZhciBjcmVhdGVBbnRpY2lwYXRlID0gKHBvd2VyKSA9PiB7XG4gIGNvbnN0IGJhY2tFYXNpbmcgPSBjcmVhdGVCYWNrSW4ocG93ZXIpO1xuICByZXR1cm4gKHAyKSA9PiAocDIgKj0gMikgPCAxID8gMC41ICogYmFja0Vhc2luZyhwMikgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwMiAtIDEpKSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvZWFzaW5nL2luZGV4Lm1qc1xudmFyIERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIID0gMS41MjU7XG52YXIgQk9VTkNFX0ZJUlNUX1RIUkVTSE9MRCA9IDQgLyAxMTtcbnZhciBCT1VOQ0VfU0VDT05EX1RIUkVTSE9MRCA9IDggLyAxMTtcbnZhciBCT1VOQ0VfVEhJUkRfVEhSRVNIT0xEID0gOSAvIDEwO1xudmFyIGxpbmVhciA9IChwMikgPT4gcDI7XG52YXIgZWFzZUluID0gY3JlYXRlRXhwb0luKDIpO1xudmFyIGVhc2VPdXQgPSByZXZlcnNlRWFzaW5nKGVhc2VJbik7XG52YXIgZWFzZUluT3V0ID0gbWlycm9yRWFzaW5nKGVhc2VJbik7XG52YXIgY2lyY0luID0gKHAyKSA9PiAxIC0gTWF0aC5zaW4oTWF0aC5hY29zKHAyKSk7XG52YXIgY2lyY091dCA9IHJldmVyc2VFYXNpbmcoY2lyY0luKTtcbnZhciBjaXJjSW5PdXQgPSBtaXJyb3JFYXNpbmcoY2lyY091dCk7XG52YXIgYmFja0luID0gY3JlYXRlQmFja0luKERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIKTtcbnZhciBiYWNrT3V0ID0gcmV2ZXJzZUVhc2luZyhiYWNrSW4pO1xudmFyIGJhY2tJbk91dCA9IG1pcnJvckVhc2luZyhiYWNrSW4pO1xudmFyIGFudGljaXBhdGUgPSBjcmVhdGVBbnRpY2lwYXRlKERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIKTtcbnZhciBjYSA9IDQzNTYgLyAzNjE7XG52YXIgY2IgPSAzNTQ0MiAvIDE4MDU7XG52YXIgY2MgPSAxNjA2MSAvIDE4MDU7XG52YXIgYm91bmNlT3V0ID0gKHAyKSA9PiB7XG4gIGlmIChwMiA9PT0gMSB8fCBwMiA9PT0gMClcbiAgICByZXR1cm4gcDI7XG4gIGNvbnN0IHAyMiA9IHAyICogcDI7XG4gIHJldHVybiBwMiA8IEJPVU5DRV9GSVJTVF9USFJFU0hPTEQgPyA3LjU2MjUgKiBwMjIgOiBwMiA8IEJPVU5DRV9TRUNPTkRfVEhSRVNIT0xEID8gOS4wNzUgKiBwMjIgLSA5LjkgKiBwMiArIDMuNCA6IHAyIDwgQk9VTkNFX1RISVJEX1RIUkVTSE9MRCA/IGNhICogcDIyIC0gY2IgKiBwMiArIGNjIDogMTAuOCAqIHAyICogcDIgLSAyMC41MiAqIHAyICsgMTAuNzI7XG59O1xudmFyIGJvdW5jZUluID0gcmV2ZXJzZUVhc2luZyhib3VuY2VPdXQpO1xudmFyIGJvdW5jZUluT3V0ID0gKHAyKSA9PiBwMiA8IDAuNSA/IDAuNSAqICgxIC0gYm91bmNlT3V0KDEgLSBwMiAqIDIpKSA6IDAuNSAqIGJvdW5jZU91dChwMiAqIDIgLSAxKSArIDAuNTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvZ2VuZXJhdG9ycy9rZXlmcmFtZXMubWpzXG5mdW5jdGlvbiBkZWZhdWx0RWFzaW5nKHZhbHVlcywgZWFzaW5nKSB7XG4gIHJldHVybiB2YWx1ZXMubWFwKCgpID0+IGVhc2luZyB8fCBlYXNlSW5PdXQpLnNwbGljZSgwLCB2YWx1ZXMubGVuZ3RoIC0gMSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T2Zmc2V0KHZhbHVlcykge1xuICBjb25zdCBudW1WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuICByZXR1cm4gdmFsdWVzLm1hcCgoX3ZhbHVlLCBpMikgPT4gaTIgIT09IDAgPyBpMiAvIChudW1WYWx1ZXMgLSAxKSA6IDApO1xufVxuZnVuY3Rpb24gY29udmVydE9mZnNldFRvVGltZXMob2Zmc2V0LCBkdXJhdGlvbikge1xuICByZXR1cm4gb2Zmc2V0Lm1hcCgobykgPT4gbyAqIGR1cmF0aW9uKTtcbn1cbmZ1bmN0aW9uIGtleWZyYW1lcyh7IGZyb20gPSAwLCB0byA9IDEsIGVhc2UsIG9mZnNldCwgZHVyYXRpb24gPSAzMDAgfSkge1xuICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmcm9tIH07XG4gIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodG8pID8gdG8gOiBbZnJvbSwgdG9dO1xuICBjb25zdCB0aW1lcyA9IGNvbnZlcnRPZmZzZXRUb1RpbWVzKG9mZnNldCAmJiBvZmZzZXQubGVuZ3RoID09PSB2YWx1ZXMubGVuZ3RoID8gb2Zmc2V0IDogZGVmYXVsdE9mZnNldCh2YWx1ZXMpLCBkdXJhdGlvbik7XG4gIGZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRvcigpIHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUodGltZXMsIHZhbHVlcywge1xuICAgICAgZWFzZTogQXJyYXkuaXNBcnJheShlYXNlKSA/IGVhc2UgOiBkZWZhdWx0RWFzaW5nKHZhbHVlcywgZWFzZSlcbiAgICB9KTtcbiAgfVxuICBsZXQgaW50ZXJwb2xhdG9yID0gY3JlYXRlSW50ZXJwb2xhdG9yKCk7XG4gIHJldHVybiB7XG4gICAgbmV4dDogKHQpID0+IHtcbiAgICAgIHN0YXRlLnZhbHVlID0gaW50ZXJwb2xhdG9yKHQpO1xuICAgICAgc3RhdGUuZG9uZSA9IHQgPj0gZHVyYXRpb247XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBmbGlwVGFyZ2V0OiAoKSA9PiB7XG4gICAgICB2YWx1ZXMucmV2ZXJzZSgpO1xuICAgICAgaW50ZXJwb2xhdG9yID0gY3JlYXRlSW50ZXJwb2xhdG9yKCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy9nZW5lcmF0b3JzL2RlY2F5Lm1qc1xuZnVuY3Rpb24gZGVjYXkoeyB2ZWxvY2l0eSA9IDAsIGZyb20gPSAwLCBwb3dlciA9IDAuOCwgdGltZUNvbnN0YW50ID0gMzUwLCByZXN0RGVsdGEgPSAwLjUsIG1vZGlmeVRhcmdldCB9KSB7XG4gIGNvbnN0IHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IGZyb20gfTtcbiAgbGV0IGFtcGxpdHVkZSA9IHBvd2VyICogdmVsb2NpdHk7XG4gIGNvbnN0IGlkZWFsID0gZnJvbSArIGFtcGxpdHVkZTtcbiAgY29uc3QgdGFyZ2V0ID0gbW9kaWZ5VGFyZ2V0ID09PSB2b2lkIDAgPyBpZGVhbCA6IG1vZGlmeVRhcmdldChpZGVhbCk7XG4gIGlmICh0YXJnZXQgIT09IGlkZWFsKVxuICAgIGFtcGxpdHVkZSA9IHRhcmdldCAtIGZyb207XG4gIHJldHVybiB7XG4gICAgbmV4dDogKHQpID0+IHtcbiAgICAgIGNvbnN0IGRlbHRhID0gLWFtcGxpdHVkZSAqIE1hdGguZXhwKC10IC8gdGltZUNvbnN0YW50KTtcbiAgICAgIHN0YXRlLmRvbmUgPSAhKGRlbHRhID4gcmVzdERlbHRhIHx8IGRlbHRhIDwgLXJlc3REZWx0YSk7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHN0YXRlLmRvbmUgPyB0YXJnZXQgOiB0YXJnZXQgKyBkZWx0YTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGZsaXBUYXJnZXQ6ICgpID0+IHtcbiAgICB9XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL3V0aWxzL2RldGVjdC1hbmltYXRpb24tZnJvbS1vcHRpb25zLm1qc1xudmFyIHR5cGVzID0geyBrZXlmcmFtZXMsIHNwcmluZywgZGVjYXkgfTtcbmZ1bmN0aW9uIGRldGVjdEFuaW1hdGlvbkZyb21PcHRpb25zKGNvbmZpZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcudG8pKSB7XG4gICAgcmV0dXJuIGtleWZyYW1lcztcbiAgfSBlbHNlIGlmICh0eXBlc1tjb25maWcudHlwZV0pIHtcbiAgICByZXR1cm4gdHlwZXNbY29uZmlnLnR5cGVdO1xuICB9XG4gIGNvbnN0IGtleXMyID0gbmV3IFNldChPYmplY3Qua2V5cyhjb25maWcpKTtcbiAgaWYgKGtleXMyLmhhcyhcImVhc2VcIikgfHwga2V5czIuaGFzKFwiZHVyYXRpb25cIikgJiYgIWtleXMyLmhhcyhcImRhbXBpbmdSYXRpb1wiKSkge1xuICAgIHJldHVybiBrZXlmcmFtZXM7XG4gIH0gZWxzZSBpZiAoa2V5czIuaGFzKFwiZGFtcGluZ1JhdGlvXCIpIHx8IGtleXMyLmhhcyhcInN0aWZmbmVzc1wiKSB8fCBrZXlzMi5oYXMoXCJtYXNzXCIpIHx8IGtleXMyLmhhcyhcImRhbXBpbmdcIikgfHwga2V5czIuaGFzKFwicmVzdFNwZWVkXCIpIHx8IGtleXMyLmhhcyhcInJlc3REZWx0YVwiKSkge1xuICAgIHJldHVybiBzcHJpbmc7XG4gIH1cbiAgcmV0dXJuIGtleWZyYW1lcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lc3luYy9kaXN0L2VzL29uLW5leHQtZnJhbWUubWpzXG52YXIgZGVmYXVsdFRpbWVzdGVwID0gMSAvIDYwICogMWUzO1xudmFyIGdldEN1cnJlbnRUaW1lID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSBcInVuZGVmaW5lZFwiID8gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCkgOiAoKSA9PiBEYXRlLm5vdygpO1xudmFyIG9uTmV4dEZyYW1lID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IChjYWxsYmFjaykgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykgOiAoY2FsbGJhY2spID0+IHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soZ2V0Q3VycmVudFRpbWUoKSksIGRlZmF1bHRUaW1lc3RlcCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXN5bmMvZGlzdC9lcy9jcmVhdGUtcmVuZGVyLXN0ZXAubWpzXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJTdGVwKHJ1bk5leHRGcmFtZTIpIHtcbiAgbGV0IHRvUnVuID0gW107XG4gIGxldCB0b1J1bk5leHRGcmFtZSA9IFtdO1xuICBsZXQgbnVtVG9SdW4gPSAwO1xuICBsZXQgaXNQcm9jZXNzaW5nMiA9IGZhbHNlO1xuICBsZXQgZmx1c2hOZXh0RnJhbWUgPSBmYWxzZTtcbiAgY29uc3QgdG9LZWVwQWxpdmUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgY29uc3Qgc3RlcCA9IHtcbiAgICBzY2hlZHVsZTogKGNhbGxiYWNrLCBrZWVwQWxpdmUgPSBmYWxzZSwgaW1tZWRpYXRlID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IGFkZFRvQ3VycmVudEZyYW1lID0gaW1tZWRpYXRlICYmIGlzUHJvY2Vzc2luZzI7XG4gICAgICBjb25zdCBidWZmZXIgPSBhZGRUb0N1cnJlbnRGcmFtZSA/IHRvUnVuIDogdG9SdW5OZXh0RnJhbWU7XG4gICAgICBpZiAoa2VlcEFsaXZlKVxuICAgICAgICB0b0tlZXBBbGl2ZS5hZGQoY2FsbGJhY2spO1xuICAgICAgaWYgKGJ1ZmZlci5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTEpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goY2FsbGJhY2spO1xuICAgICAgICBpZiAoYWRkVG9DdXJyZW50RnJhbWUgJiYgaXNQcm9jZXNzaW5nMilcbiAgICAgICAgICBudW1Ub1J1biA9IHRvUnVuLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9LFxuICAgIGNhbmNlbDogKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBpbmRleDIgPSB0b1J1bk5leHRGcmFtZS5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgIGlmIChpbmRleDIgIT09IC0xKVxuICAgICAgICB0b1J1bk5leHRGcmFtZS5zcGxpY2UoaW5kZXgyLCAxKTtcbiAgICAgIHRvS2VlcEFsaXZlLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfSxcbiAgICBwcm9jZXNzOiAoZnJhbWVEYXRhKSA9PiB7XG4gICAgICBpZiAoaXNQcm9jZXNzaW5nMikge1xuICAgICAgICBmbHVzaE5leHRGcmFtZSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlzUHJvY2Vzc2luZzIgPSB0cnVlO1xuICAgICAgW3RvUnVuLCB0b1J1bk5leHRGcmFtZV0gPSBbdG9SdW5OZXh0RnJhbWUsIHRvUnVuXTtcbiAgICAgIHRvUnVuTmV4dEZyYW1lLmxlbmd0aCA9IDA7XG4gICAgICBudW1Ub1J1biA9IHRvUnVuLmxlbmd0aDtcbiAgICAgIGlmIChudW1Ub1J1bikge1xuICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtVG9SdW47IGkyKyspIHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRvUnVuW2kyXTtcbiAgICAgICAgICBjYWxsYmFjayhmcmFtZURhdGEpO1xuICAgICAgICAgIGlmICh0b0tlZXBBbGl2ZS5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBzdGVwLnNjaGVkdWxlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJ1bk5leHRGcmFtZTIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzUHJvY2Vzc2luZzIgPSBmYWxzZTtcbiAgICAgIGlmIChmbHVzaE5leHRGcmFtZSkge1xuICAgICAgICBmbHVzaE5leHRGcmFtZSA9IGZhbHNlO1xuICAgICAgICBzdGVwLnByb2Nlc3MoZnJhbWVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBzdGVwO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVzeW5jL2Rpc3QvZXMvaW5kZXgubWpzXG52YXIgbWF4RWxhcHNlZCA9IDQwO1xudmFyIHVzZURlZmF1bHRFbGFwc2VkID0gdHJ1ZTtcbnZhciBydW5OZXh0RnJhbWUgPSBmYWxzZTtcbnZhciBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbnZhciBmcmFtZSA9IHtcbiAgZGVsdGE6IDAsXG4gIHRpbWVzdGFtcDogMFxufTtcbnZhciBzdGVwc09yZGVyID0gW1xuICBcInJlYWRcIixcbiAgXCJ1cGRhdGVcIixcbiAgXCJwcmVSZW5kZXJcIixcbiAgXCJyZW5kZXJcIixcbiAgXCJwb3N0UmVuZGVyXCJcbl07XG52YXIgc3RlcHMgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgYWNjW2tleV0gPSBjcmVhdGVSZW5kZXJTdGVwKCgpID0+IHJ1bk5leHRGcmFtZSA9IHRydWUpO1xuICByZXR1cm4gYWNjO1xufSwge30pO1xudmFyIHN5bmMgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgY29uc3Qgc3RlcCA9IHN0ZXBzW2tleV07XG4gIGFjY1trZXldID0gKHByb2Nlc3MyLCBrZWVwQWxpdmUgPSBmYWxzZSwgaW1tZWRpYXRlID0gZmFsc2UpID0+IHtcbiAgICBpZiAoIXJ1bk5leHRGcmFtZSlcbiAgICAgIHN0YXJ0TG9vcCgpO1xuICAgIHJldHVybiBzdGVwLnNjaGVkdWxlKHByb2Nlc3MyLCBrZWVwQWxpdmUsIGltbWVkaWF0ZSk7XG4gIH07XG4gIHJldHVybiBhY2M7XG59LCB7fSk7XG52YXIgY2FuY2VsU3luYyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICBhY2Nba2V5XSA9IHN0ZXBzW2tleV0uY2FuY2VsO1xuICByZXR1cm4gYWNjO1xufSwge30pO1xudmFyIGZsdXNoU3luYyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICBhY2Nba2V5XSA9ICgpID0+IHN0ZXBzW2tleV0ucHJvY2VzcyhmcmFtZSk7XG4gIHJldHVybiBhY2M7XG59LCB7fSk7XG52YXIgcHJvY2Vzc1N0ZXAgPSAoc3RlcElkKSA9PiBzdGVwc1tzdGVwSWRdLnByb2Nlc3MoZnJhbWUpO1xudmFyIHByb2Nlc3NGcmFtZSA9ICh0aW1lc3RhbXApID0+IHtcbiAgcnVuTmV4dEZyYW1lID0gZmFsc2U7XG4gIGZyYW1lLmRlbHRhID0gdXNlRGVmYXVsdEVsYXBzZWQgPyBkZWZhdWx0VGltZXN0ZXAgOiBNYXRoLm1heChNYXRoLm1pbih0aW1lc3RhbXAgLSBmcmFtZS50aW1lc3RhbXAsIG1heEVsYXBzZWQpLCAxKTtcbiAgZnJhbWUudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICBpc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICBzdGVwc09yZGVyLmZvckVhY2gocHJvY2Vzc1N0ZXApO1xuICBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgaWYgKHJ1bk5leHRGcmFtZSkge1xuICAgIHVzZURlZmF1bHRFbGFwc2VkID0gZmFsc2U7XG4gICAgb25OZXh0RnJhbWUocHJvY2Vzc0ZyYW1lKTtcbiAgfVxufTtcbnZhciBzdGFydExvb3AgPSAoKSA9PiB7XG4gIHJ1bk5leHRGcmFtZSA9IHRydWU7XG4gIHVzZURlZmF1bHRFbGFwc2VkID0gdHJ1ZTtcbiAgaWYgKCFpc1Byb2Nlc3NpbmcpXG4gICAgb25OZXh0RnJhbWUocHJvY2Vzc0ZyYW1lKTtcbn07XG52YXIgZ2V0RnJhbWVEYXRhID0gKCkgPT4gZnJhbWU7XG52YXIgZXNfZGVmYXVsdCA9IHN5bmM7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL3V0aWxzL2VsYXBzZWQubWpzXG5mdW5jdGlvbiBsb29wRWxhcHNlZChlbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkyID0gMCkge1xuICByZXR1cm4gZWxhcHNlZCAtIGR1cmF0aW9uIC0gZGVsYXkyO1xufVxuZnVuY3Rpb24gcmV2ZXJzZUVsYXBzZWQoZWxhcHNlZCwgZHVyYXRpb24sIGRlbGF5MiA9IDAsIGlzRm9yd2FyZFBsYXliYWNrID0gdHJ1ZSkge1xuICByZXR1cm4gaXNGb3J3YXJkUGxheWJhY2sgPyBsb29wRWxhcHNlZChkdXJhdGlvbiArIC1lbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkyKSA6IGR1cmF0aW9uIC0gKGVsYXBzZWQgLSBkdXJhdGlvbikgKyBkZWxheTI7XG59XG5mdW5jdGlvbiBoYXNSZXBlYXREZWxheUVsYXBzZWQoZWxhcHNlZCwgZHVyYXRpb24sIGRlbGF5MiwgaXNGb3J3YXJkUGxheWJhY2spIHtcbiAgcmV0dXJuIGlzRm9yd2FyZFBsYXliYWNrID8gZWxhcHNlZCA+PSBkdXJhdGlvbiArIGRlbGF5MiA6IGVsYXBzZWQgPD0gLWRlbGF5Mjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvaW5kZXgubWpzXG52YXIgZnJhbWVzeW5jID0gKHVwZGF0ZSkgPT4ge1xuICBjb25zdCBwYXNzVGltZXN0YW1wID0gKHsgZGVsdGEgfSkgPT4gdXBkYXRlKGRlbHRhKTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogKCkgPT4gZXNfZGVmYXVsdC51cGRhdGUocGFzc1RpbWVzdGFtcCwgdHJ1ZSksXG4gICAgc3RvcDogKCkgPT4gY2FuY2VsU3luYy51cGRhdGUocGFzc1RpbWVzdGFtcClcbiAgfTtcbn07XG5mdW5jdGlvbiBhbmltYXRlKF9hKSB7XG4gIHZhciBfYiwgX2M7XG4gIHZhciB7IGZyb20sIGF1dG9wbGF5ID0gdHJ1ZSwgZHJpdmVyID0gZnJhbWVzeW5jLCBlbGFwc2VkID0gMCwgcmVwZWF0OiByZXBlYXRNYXggPSAwLCByZXBlYXRUeXBlID0gXCJsb29wXCIsIHJlcGVhdERlbGF5ID0gMCwgb25QbGF5LCBvblN0b3AsIG9uQ29tcGxldGUsIG9uUmVwZWF0LCBvblVwZGF0ZSB9ID0gX2EsIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcImZyb21cIiwgXCJhdXRvcGxheVwiLCBcImRyaXZlclwiLCBcImVsYXBzZWRcIiwgXCJyZXBlYXRcIiwgXCJyZXBlYXRUeXBlXCIsIFwicmVwZWF0RGVsYXlcIiwgXCJvblBsYXlcIiwgXCJvblN0b3BcIiwgXCJvbkNvbXBsZXRlXCIsIFwib25SZXBlYXRcIiwgXCJvblVwZGF0ZVwiXSk7XG4gIGxldCB7IHRvIH0gPSBvcHRpb25zO1xuICBsZXQgZHJpdmVyQ29udHJvbHM7XG4gIGxldCByZXBlYXRDb3VudCA9IDA7XG4gIGxldCBjb21wdXRlZER1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgbGV0IGxhdGVzdDtcbiAgbGV0IGlzQ29tcGxldGUgPSBmYWxzZTtcbiAgbGV0IGlzRm9yd2FyZFBsYXliYWNrID0gdHJ1ZTtcbiAgbGV0IGludGVycG9sYXRlRnJvbU51bWJlcjtcbiAgY29uc3QgYW5pbWF0b3IgPSBkZXRlY3RBbmltYXRpb25Gcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgaWYgKChfYyA9IChfYiA9IGFuaW1hdG9yKS5uZWVkc0ludGVycG9sYXRpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCBmcm9tLCB0bykpIHtcbiAgICBpbnRlcnBvbGF0ZUZyb21OdW1iZXIgPSBpbnRlcnBvbGF0ZShbMCwgMTAwXSwgW2Zyb20sIHRvXSwge1xuICAgICAgY2xhbXA6IGZhbHNlXG4gICAgfSk7XG4gICAgZnJvbSA9IDA7XG4gICAgdG8gPSAxMDA7XG4gIH1cbiAgY29uc3QgYW5pbWF0aW9uID0gYW5pbWF0b3IoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmcm9tLCB0byB9KSk7XG4gIGZ1bmN0aW9uIHJlcGVhdCgpIHtcbiAgICByZXBlYXRDb3VudCsrO1xuICAgIGlmIChyZXBlYXRUeXBlID09PSBcInJldmVyc2VcIikge1xuICAgICAgaXNGb3J3YXJkUGxheWJhY2sgPSByZXBlYXRDb3VudCAlIDIgPT09IDA7XG4gICAgICBlbGFwc2VkID0gcmV2ZXJzZUVsYXBzZWQoZWxhcHNlZCwgY29tcHV0ZWREdXJhdGlvbiwgcmVwZWF0RGVsYXksIGlzRm9yd2FyZFBsYXliYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxhcHNlZCA9IGxvb3BFbGFwc2VkKGVsYXBzZWQsIGNvbXB1dGVkRHVyYXRpb24sIHJlcGVhdERlbGF5KTtcbiAgICAgIGlmIChyZXBlYXRUeXBlID09PSBcIm1pcnJvclwiKVxuICAgICAgICBhbmltYXRpb24uZmxpcFRhcmdldCgpO1xuICAgIH1cbiAgICBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgb25SZXBlYXQgJiYgb25SZXBlYXQoKTtcbiAgfVxuICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICBkcml2ZXJDb250cm9scy5zdG9wKCk7XG4gICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKCk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKGRlbHRhKSB7XG4gICAgaWYgKCFpc0ZvcndhcmRQbGF5YmFjaylcbiAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgIGVsYXBzZWQgKz0gZGVsdGE7XG4gICAgaWYgKCFpc0NvbXBsZXRlKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGFuaW1hdGlvbi5uZXh0KE1hdGgubWF4KDAsIGVsYXBzZWQpKTtcbiAgICAgIGxhdGVzdCA9IHN0YXRlLnZhbHVlO1xuICAgICAgaWYgKGludGVycG9sYXRlRnJvbU51bWJlcilcbiAgICAgICAgbGF0ZXN0ID0gaW50ZXJwb2xhdGVGcm9tTnVtYmVyKGxhdGVzdCk7XG4gICAgICBpc0NvbXBsZXRlID0gaXNGb3J3YXJkUGxheWJhY2sgPyBzdGF0ZS5kb25lIDogZWxhcHNlZCA8PSAwO1xuICAgIH1cbiAgICBvblVwZGF0ZSA9PT0gbnVsbCB8fCBvblVwZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25VcGRhdGUobGF0ZXN0KTtcbiAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgaWYgKHJlcGVhdENvdW50ID09PSAwKVxuICAgICAgICBjb21wdXRlZER1cmF0aW9uICE9PSBudWxsICYmIGNvbXB1dGVkRHVyYXRpb24gIT09IHZvaWQgMCA/IGNvbXB1dGVkRHVyYXRpb24gOiBjb21wdXRlZER1cmF0aW9uID0gZWxhcHNlZDtcbiAgICAgIGlmIChyZXBlYXRDb3VudCA8IHJlcGVhdE1heCkge1xuICAgICAgICBoYXNSZXBlYXREZWxheUVsYXBzZWQoZWxhcHNlZCwgY29tcHV0ZWREdXJhdGlvbiwgcmVwZWF0RGVsYXksIGlzRm9yd2FyZFBsYXliYWNrKSAmJiByZXBlYXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgb25QbGF5ID09PSBudWxsIHx8IG9uUGxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25QbGF5KCk7XG4gICAgZHJpdmVyQ29udHJvbHMgPSBkcml2ZXIodXBkYXRlKTtcbiAgICBkcml2ZXJDb250cm9scy5zdGFydCgpO1xuICB9XG4gIGF1dG9wbGF5ICYmIHBsYXkoKTtcbiAgcmV0dXJuIHtcbiAgICBzdG9wOiAoKSA9PiB7XG4gICAgICBvblN0b3AgPT09IG51bGwgfHwgb25TdG9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblN0b3AoKTtcbiAgICAgIGRyaXZlckNvbnRyb2xzLnN0b3AoKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy92ZWxvY2l0eS1wZXItc2Vjb25kLm1qc1xuZnVuY3Rpb24gdmVsb2NpdHlQZXJTZWNvbmQodmVsb2NpdHksIGZyYW1lRHVyYXRpb24pIHtcbiAgcmV0dXJuIGZyYW1lRHVyYXRpb24gPyB2ZWxvY2l0eSAqICgxZTMgLyBmcmFtZUR1cmF0aW9uKSA6IDA7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL2luZXJ0aWEubWpzXG5mdW5jdGlvbiBpbmVydGlhKHsgZnJvbSA9IDAsIHZlbG9jaXR5ID0gMCwgbWluLCBtYXgsIHBvd2VyID0gMC44LCB0aW1lQ29uc3RhbnQgPSA3NTAsIGJvdW5jZVN0aWZmbmVzcyA9IDUwMCwgYm91bmNlRGFtcGluZyA9IDEwLCByZXN0RGVsdGEgPSAxLCBtb2RpZnlUYXJnZXQsIGRyaXZlciwgb25VcGRhdGUsIG9uQ29tcGxldGUsIG9uU3RvcCB9KSB7XG4gIGxldCBjdXJyZW50QW5pbWF0aW9uO1xuICBmdW5jdGlvbiBpc091dE9mQm91bmRzKHYpIHtcbiAgICByZXR1cm4gbWluICE9PSB2b2lkIDAgJiYgdiA8IG1pbiB8fCBtYXggIT09IHZvaWQgMCAmJiB2ID4gbWF4O1xuICB9XG4gIGZ1bmN0aW9uIGJvdW5kYXJ5TmVhcmVzdCh2KSB7XG4gICAgaWYgKG1pbiA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG1heDtcbiAgICBpZiAobWF4ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbWluO1xuICAgIHJldHVybiBNYXRoLmFicyhtaW4gLSB2KSA8IE1hdGguYWJzKG1heCAtIHYpID8gbWluIDogbWF4O1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uMihvcHRpb25zKSB7XG4gICAgY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICBjdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICBkcml2ZXIsXG4gICAgICBvblVwZGF0ZTogKHYpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBvblVwZGF0ZSA9PT0gbnVsbCB8fCBvblVwZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25VcGRhdGUodik7XG4gICAgICAgIChfYSA9IG9wdGlvbnMub25VcGRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIHYpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGUsXG4gICAgICBvblN0b3BcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRTcHJpbmcob3B0aW9ucykge1xuICAgIHN0YXJ0QW5pbWF0aW9uMihPYmplY3QuYXNzaWduKHsgdHlwZTogXCJzcHJpbmdcIiwgc3RpZmZuZXNzOiBib3VuY2VTdGlmZm5lc3MsIGRhbXBpbmc6IGJvdW5jZURhbXBpbmcsIHJlc3REZWx0YSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgaWYgKGlzT3V0T2ZCb3VuZHMoZnJvbSkpIHtcbiAgICBzdGFydFNwcmluZyh7IGZyb20sIHZlbG9jaXR5LCB0bzogYm91bmRhcnlOZWFyZXN0KGZyb20pIH0pO1xuICB9IGVsc2Uge1xuICAgIGxldCB0YXJnZXQgPSBwb3dlciAqIHZlbG9jaXR5ICsgZnJvbTtcbiAgICBpZiAodHlwZW9mIG1vZGlmeVRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIHRhcmdldCA9IG1vZGlmeVRhcmdldCh0YXJnZXQpO1xuICAgIGNvbnN0IGJvdW5kYXJ5ID0gYm91bmRhcnlOZWFyZXN0KHRhcmdldCk7XG4gICAgY29uc3QgaGVhZGluZyA9IGJvdW5kYXJ5ID09PSBtaW4gPyAtMSA6IDE7XG4gICAgbGV0IHByZXY7XG4gICAgbGV0IGN1cnJlbnQ7XG4gICAgY29uc3QgY2hlY2tCb3VuZGFyeSA9ICh2KSA9PiB7XG4gICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgIGN1cnJlbnQgPSB2O1xuICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eVBlclNlY29uZCh2IC0gcHJldiwgZ2V0RnJhbWVEYXRhKCkuZGVsdGEpO1xuICAgICAgaWYgKGhlYWRpbmcgPT09IDEgJiYgdiA+IGJvdW5kYXJ5IHx8IGhlYWRpbmcgPT09IC0xICYmIHYgPCBib3VuZGFyeSkge1xuICAgICAgICBzdGFydFNwcmluZyh7IGZyb206IHYsIHRvOiBib3VuZGFyeSwgdmVsb2NpdHkgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzdGFydEFuaW1hdGlvbjIoe1xuICAgICAgdHlwZTogXCJkZWNheVwiLFxuICAgICAgZnJvbSxcbiAgICAgIHZlbG9jaXR5LFxuICAgICAgdGltZUNvbnN0YW50LFxuICAgICAgcG93ZXIsXG4gICAgICByZXN0RGVsdGEsXG4gICAgICBtb2RpZnlUYXJnZXQsXG4gICAgICBvblVwZGF0ZTogaXNPdXRPZkJvdW5kcyh0YXJnZXQpID8gY2hlY2tCb3VuZGFyeSA6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RvcDogKCkgPT4gY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50QW5pbWF0aW9uLnN0b3AoKVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtcG9pbnQubWpzXG52YXIgaXNQb2ludCA9IChwb2ludDIpID0+IHBvaW50Mi5oYXNPd25Qcm9wZXJ0eShcInhcIikgJiYgcG9pbnQyLmhhc093blByb3BlcnR5KFwieVwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLXBvaW50LTNkLm1qc1xudmFyIGlzUG9pbnQzRCA9IChwb2ludDIpID0+IGlzUG9pbnQocG9pbnQyKSAmJiBwb2ludDIuaGFzT3duUHJvcGVydHkoXCJ6XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvZGlzdGFuY2UubWpzXG52YXIgZGlzdGFuY2UxRCA9IChhMiwgYjIpID0+IE1hdGguYWJzKGEyIC0gYjIpO1xuZnVuY3Rpb24gZGlzdGFuY2UoYTIsIGIyKSB7XG4gIGlmIChpc051bShhMikgJiYgaXNOdW0oYjIpKSB7XG4gICAgcmV0dXJuIGRpc3RhbmNlMUQoYTIsIGIyKTtcbiAgfSBlbHNlIGlmIChpc1BvaW50KGEyKSAmJiBpc1BvaW50KGIyKSkge1xuICAgIGNvbnN0IHhEZWx0YSA9IGRpc3RhbmNlMUQoYTIueCwgYjIueCk7XG4gICAgY29uc3QgeURlbHRhID0gZGlzdGFuY2UxRChhMi55LCBiMi55KTtcbiAgICBjb25zdCB6RGVsdGEgPSBpc1BvaW50M0QoYTIpICYmIGlzUG9pbnQzRChiMikgPyBkaXN0YW5jZTFEKGEyLnosIGIyLnopIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHhEZWx0YSwgMikgKyBNYXRoLnBvdyh5RGVsdGEsIDIpICsgTWF0aC5wb3coekRlbHRhLCAyKSk7XG4gIH1cbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2Vhc2luZy9jdWJpYy1iZXppZXIubWpzXG52YXIgYSA9IChhMSwgYTIpID0+IDEgLSAzICogYTIgKyAzICogYTE7XG52YXIgYiA9IChhMSwgYTIpID0+IDMgKiBhMiAtIDYgKiBhMTtcbnZhciBjMiA9IChhMSkgPT4gMyAqIGExO1xudmFyIGNhbGNCZXppZXIgPSAodCwgYTEsIGEyKSA9PiAoKGEoYTEsIGEyKSAqIHQgKyBiKGExLCBhMikpICogdCArIGMyKGExKSkgKiB0O1xudmFyIGdldFNsb3BlID0gKHQsIGExLCBhMikgPT4gMyAqIGEoYTEsIGEyKSAqIHQgKiB0ICsgMiAqIGIoYTEsIGEyKSAqIHQgKyBjMihhMSk7XG52YXIgc3ViZGl2aXNpb25QcmVjaXNpb24gPSAxZS03O1xudmFyIHN1YmRpdmlzaW9uTWF4SXRlcmF0aW9ucyA9IDEwO1xuZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gIGxldCBjdXJyZW50WDtcbiAgbGV0IGN1cnJlbnRUO1xuICBsZXQgaTIgPSAwO1xuICBkbyB7XG4gICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDI7XG4gICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICBpZiAoY3VycmVudFggPiAwKSB7XG4gICAgICBhQiA9IGN1cnJlbnRUO1xuICAgIH0gZWxzZSB7XG4gICAgICBhQSA9IGN1cnJlbnRUO1xuICAgIH1cbiAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gc3ViZGl2aXNpb25QcmVjaXNpb24gJiYgKytpMiA8IHN1YmRpdmlzaW9uTWF4SXRlcmF0aW9ucyk7XG4gIHJldHVybiBjdXJyZW50VDtcbn1cbnZhciBuZXd0b25JdGVyYXRpb25zID0gODtcbnZhciBuZXd0b25NaW5TbG9wZSA9IDFlLTM7XG5mdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG5ld3Rvbkl0ZXJhdGlvbnM7ICsraTIpIHtcbiAgICBjb25zdCBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICB9XG4gIHJldHVybiBhR3Vlc3NUO1xufVxudmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbnZhciBrU2FtcGxlU3RlcFNpemUgPSAxIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxKTtcbmZ1bmN0aW9uIGN1YmljQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpXG4gICAgcmV0dXJuIGxpbmVhcjtcbiAgY29uc3Qgc2FtcGxlVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGtTcGxpbmVUYWJsZVNpemU7ICsraTIpIHtcbiAgICBzYW1wbGVWYWx1ZXNbaTJdID0gY2FsY0JlemllcihpMiAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG4gICAgbGV0IGludGVydmFsU3RhcnQgPSAwO1xuICAgIGxldCBjdXJyZW50U2FtcGxlID0gMTtcbiAgICBjb25zdCBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG4gICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgIH1cbiAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgY29uc3QgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgY29uc3QgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgY29uc3QgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBuZXd0b25NaW5TbG9wZSkge1xuICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKHQpID0+IHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiBjYWxjQmV6aWVyKGdldFRGb3JYKHQpLCBtWTEsIG1ZMik7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLXRhcC1nZXN0dXJlLm1qc1xuZnVuY3Rpb24gdXNlVGFwR2VzdHVyZSh7IG9uVGFwLCBvblRhcFN0YXJ0LCBvblRhcENhbmNlbCwgd2hpbGVUYXAsIHZpc3VhbEVsZW1lbnQgfSkge1xuICBjb25zdCBoYXNQcmVzc0xpc3RlbmVycyA9IG9uVGFwIHx8IG9uVGFwU3RhcnQgfHwgb25UYXBDYW5jZWwgfHwgd2hpbGVUYXA7XG4gIGNvbnN0IGlzUHJlc3NpbmcgPSAoMCwgaW1wb3J0X3JlYWN0MjAudXNlUmVmKShmYWxzZSk7XG4gIGNvbnN0IGNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMgPSAoMCwgaW1wb3J0X3JlYWN0MjAudXNlUmVmKShudWxsKTtcbiAgY29uc3QgZXZlbnRPcHRpb25zID0ge1xuICAgIHBhc3NpdmU6ICEob25UYXBTdGFydCB8fCBvblRhcCB8fCBvblRhcENhbmNlbCB8fCBvblBvaW50ZXJEb3duKVxuICB9O1xuICBmdW5jdGlvbiByZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIoKSB7XG4gICAgY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50ICYmIGNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMuY3VycmVudCgpO1xuICAgIGNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMuY3VycmVudCA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tQb2ludGVyRW5kKCkge1xuICAgIHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcigpO1xuICAgIGlzUHJlc3NpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUgJiYgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5UYXAsIGZhbHNlKTtcbiAgICByZXR1cm4gIWlzRHJhZ0FjdGl2ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50LCBpbmZvKSB7XG4gICAgaWYgKCFjaGVja1BvaW50ZXJFbmQoKSlcbiAgICAgIHJldHVybjtcbiAgICAhaXNOb2RlT3JDaGlsZCh2aXN1YWxFbGVtZW50LmN1cnJlbnQsIGV2ZW50LnRhcmdldCkgPyBvblRhcENhbmNlbCAmJiBvblRhcENhbmNlbChldmVudCwgaW5mbykgOiBvblRhcCAmJiBvblRhcChldmVudCwgaW5mbyk7XG4gIH1cbiAgZnVuY3Rpb24gb25Qb2ludGVyQ2FuY2VsKGV2ZW50LCBpbmZvKSB7XG4gICAgaWYgKCFjaGVja1BvaW50ZXJFbmQoKSlcbiAgICAgIHJldHVybjtcbiAgICBvblRhcENhbmNlbCAmJiBvblRhcENhbmNlbChldmVudCwgaW5mbyk7XG4gIH1cbiAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCwgaW5mbykge1xuICAgIHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcigpO1xuICAgIGlmIChpc1ByZXNzaW5nLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgaXNQcmVzc2luZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzLmN1cnJlbnQgPSBwaXBlKGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCBldmVudE9wdGlvbnMpLCBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyQ2FuY2VsLCBldmVudE9wdGlvbnMpKTtcbiAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlICYmIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuVGFwLCB0cnVlKTtcbiAgICBvblRhcFN0YXJ0ICYmIG9uVGFwU3RhcnQoZXZlbnQsIGluZm8pO1xuICB9XG4gIHVzZVBvaW50ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIGhhc1ByZXNzTGlzdGVuZXJzID8gb25Qb2ludGVyRG93biA6IHZvaWQgMCwgZXZlbnRPcHRpb25zKTtcbiAgdXNlVW5tb3VudEVmZmVjdChyZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3Byb2Nlc3MubWpzXG52YXIgZGVmYXVsdEVudmlyb25tZW50ID0gXCJwcm9kdWN0aW9uXCI7XG52YXIgZW52ID0gdHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYgPT09IHZvaWQgMCA/IGRlZmF1bHRFbnZpcm9ubWVudCA6IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8IGRlZmF1bHRFbnZpcm9ubWVudDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvdmlld3BvcnQvdXNlLXZpZXdwb3J0Lm1qc1xudmFyIGltcG9ydF9yZWFjdDIxID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3dhcm4tb25jZS5tanNcbnZhciB3YXJuZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gd2Fybk9uY2UoY29uZGl0aW9uLCBtZXNzYWdlLCBlbGVtZW50KSB7XG4gIGlmIChjb25kaXRpb24gfHwgd2FybmVkLmhhcyhtZXNzYWdlKSlcbiAgICByZXR1cm47XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgaWYgKGVsZW1lbnQpXG4gICAgY29uc29sZS53YXJuKGVsZW1lbnQpO1xuICB3YXJuZWQuYWRkKG1lc3NhZ2UpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy92aWV3cG9ydC9vYnNlcnZlcnMubWpzXG52YXIgb2JzZXJ2ZXJDYWxsYmFja3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBvYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBmaXJlT2JzZXJ2ZXJDYWxsYmFjayA9IChlbnRyeSkgPT4ge1xuICBjb25zdCBjYWxsYmFjayA9IG9ic2VydmVyQ2FsbGJhY2tzLmdldChlbnRyeS50YXJnZXQpO1xuICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbnRyeSk7XG59O1xudmFyIGZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcyA9IChlbnRyaWVzKSA9PiB7XG4gIGVudHJpZXMuZm9yRWFjaChmaXJlT2JzZXJ2ZXJDYWxsYmFjayk7XG59O1xuZnVuY3Rpb24gaW5pdEludGVyc2VjdGlvbk9ic2VydmVyKF9hKSB7XG4gIHZhciBfYiA9IF9hLCB7IHJvb3QgfSA9IF9iLCBvcHRpb25zID0gX19vYmpSZXN0KF9iLCBbXCJyb290XCJdKTtcbiAgY29uc3QgbG9va3VwUm9vdCA9IHJvb3QgfHwgZG9jdW1lbnQ7XG4gIGlmICghb2JzZXJ2ZXJzLmhhcyhsb29rdXBSb290KSkge1xuICAgIG9ic2VydmVycy5zZXQobG9va3VwUm9vdCwge30pO1xuICB9XG4gIGNvbnN0IHJvb3RPYnNlcnZlcnMgPSBvYnNlcnZlcnMuZ2V0KGxvb2t1cFJvb3QpO1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgaWYgKCFyb290T2JzZXJ2ZXJzW2tleV0pIHtcbiAgICByb290T2JzZXJ2ZXJzW2tleV0gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZmlyZUFsbE9ic2VydmVyQ2FsbGJhY2tzLCBfX3NwcmVhZFZhbHVlcyh7IHJvb3QgfSwgb3B0aW9ucykpO1xuICB9XG4gIHJldHVybiByb290T2JzZXJ2ZXJzW2tleV07XG59XG5mdW5jdGlvbiBvYnNlcnZlSW50ZXJzZWN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIgPSBpbml0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIob3B0aW9ucyk7XG4gIG9ic2VydmVyQ2FsbGJhY2tzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBvYnNlcnZlckNhbGxiYWNrcy5kZWxldGUoZWxlbWVudCk7XG4gICAgcm9vdEludGVyZXNlY3Rpb25PYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL3ZpZXdwb3J0L3VzZS12aWV3cG9ydC5tanNcbmZ1bmN0aW9uIHVzZVZpZXdwb3J0KHsgdmlzdWFsRWxlbWVudCwgd2hpbGVJblZpZXcsIG9uVmlld3BvcnRFbnRlciwgb25WaWV3cG9ydExlYXZlLCB2aWV3cG9ydCA9IHt9IH0pIHtcbiAgY29uc3Qgc3RhdGUgPSAoMCwgaW1wb3J0X3JlYWN0MjEudXNlUmVmKSh7XG4gICAgaGFzRW50ZXJlZFZpZXc6IGZhbHNlLFxuICAgIGlzSW5WaWV3OiBmYWxzZVxuICB9KTtcbiAgbGV0IHNob3VsZE9ic2VydmUgPSBCb29sZWFuKHdoaWxlSW5WaWV3IHx8IG9uVmlld3BvcnRFbnRlciB8fCBvblZpZXdwb3J0TGVhdmUpO1xuICBpZiAodmlld3BvcnQub25jZSAmJiBzdGF0ZS5jdXJyZW50Lmhhc0VudGVyZWRWaWV3KVxuICAgIHNob3VsZE9ic2VydmUgPSBmYWxzZTtcbiAgY29uc3QgdXNlT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIgPyB1c2VNaXNzaW5nSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgOiB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgdXNlT2JzZXJ2ZXIoc2hvdWxkT2JzZXJ2ZSwgc3RhdGUuY3VycmVudCwgdmlzdWFsRWxlbWVudCwgdmlld3BvcnQpO1xufVxudmFyIHRocmVzaG9sZE5hbWVzID0ge1xuICBzb21lOiAwLFxuICBhbGw6IDFcbn07XG5mdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcihzaG91bGRPYnNlcnZlLCBzdGF0ZSwgdmlzdWFsRWxlbWVudCwgeyByb290LCBtYXJnaW46IHJvb3RNYXJnaW4sIGFtb3VudCA9IFwic29tZVwiLCBvbmNlIH0pIHtcbiAgKDAsIGltcG9ydF9yZWFjdDIxLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGlmICghc2hvdWxkT2JzZXJ2ZSB8fCAhdmlzdWFsRWxlbWVudC5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByb290OiByb290ID09PSBudWxsIHx8IHJvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvb3QuY3VycmVudCxcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIgPyBhbW91bnQgOiB0aHJlc2hvbGROYW1lc1thbW91bnRdXG4gICAgfTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25DYWxsYmFjayA9IChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgeyBpc0ludGVyc2VjdGluZyB9ID0gZW50cnk7XG4gICAgICBpZiAoc3RhdGUuaXNJblZpZXcgPT09IGlzSW50ZXJzZWN0aW5nKVxuICAgICAgICByZXR1cm47XG4gICAgICBzdGF0ZS5pc0luVmlldyA9IGlzSW50ZXJzZWN0aW5nO1xuICAgICAgaWYgKG9uY2UgJiYgIWlzSW50ZXJzZWN0aW5nICYmIHN0YXRlLmhhc0VudGVyZWRWaWV3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgc3RhdGUuaGFzRW50ZXJlZFZpZXcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5JblZpZXcsIGlzSW50ZXJzZWN0aW5nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BzID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBpc0ludGVyc2VjdGluZyA/IHByb3BzLm9uVmlld3BvcnRFbnRlciA6IHByb3BzLm9uVmlld3BvcnRMZWF2ZTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVudHJ5KTtcbiAgICB9O1xuICAgIHJldHVybiBvYnNlcnZlSW50ZXJzZWN0aW9uKHZpc3VhbEVsZW1lbnQuY3VycmVudCwgb3B0aW9ucywgaW50ZXJzZWN0aW9uQ2FsbGJhY2spO1xuICB9LCBbc2hvdWxkT2JzZXJ2ZSwgcm9vdCwgcm9vdE1hcmdpbiwgYW1vdW50XSk7XG59XG5mdW5jdGlvbiB1c2VNaXNzaW5nSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoc2hvdWxkT2JzZXJ2ZSwgc3RhdGUsIHZpc3VhbEVsZW1lbnQsIHsgZmFsbGJhY2sgPSB0cnVlIH0pIHtcbiAgKDAsIGltcG9ydF9yZWFjdDIxLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGlmICghc2hvdWxkT2JzZXJ2ZSB8fCAhZmFsbGJhY2spXG4gICAgICByZXR1cm47XG4gICAgaWYgKGVudiAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5PbmNlKGZhbHNlLCBcIkludGVyc2VjdGlvbk9ic2VydmVyIG5vdCBhdmFpbGFibGUgb24gdGhpcyBkZXZpY2UuIHdoaWxlSW5WaWV3IGFuaW1hdGlvbnMgd2lsbCB0cmlnZ2VyIG9uIG1vdW50LlwiKTtcbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHN0YXRlLmhhc0VudGVyZWRWaWV3ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHsgb25WaWV3cG9ydEVudGVyIH0gPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgICBvblZpZXdwb3J0RW50ZXIgJiYgb25WaWV3cG9ydEVudGVyKG51bGwpO1xuICAgICAgaWYgKHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5JblZpZXcsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbc2hvdWxkT2JzZXJ2ZV0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9tYWtlLXJlbmRlcmxlc3MtY29tcG9uZW50Lm1qc1xudmFyIG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50ID0gKGhvb2spID0+IChwcm9wcykgPT4ge1xuICBob29rKHByb3BzKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9nZXN0dXJlcy5tanNcbnZhciBnZXN0dXJlQW5pbWF0aW9ucyA9IHtcbiAgaW5WaWV3OiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VWaWV3cG9ydCksXG4gIHRhcDogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlVGFwR2VzdHVyZSksXG4gIGZvY3VzOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VGb2N1c0dlc3R1cmUpLFxuICBob3ZlcjogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlSG92ZXJHZXN0dXJlKVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvYW5pbWF0aW9ucy5tanNcbnZhciBpbXBvcnRfcmVhY3QyMyA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0FuaW1hdGVQcmVzZW5jZS91c2UtcHJlc2VuY2UubWpzXG52YXIgaW1wb3J0X3JlYWN0MjIgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiB1c2VQcmVzZW5jZSgpIHtcbiAgY29uc3QgY29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QyMi51c2VDb250ZXh0KShQcmVzZW5jZUNvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gbnVsbClcbiAgICByZXR1cm4gW3RydWUsIG51bGxdO1xuICBjb25zdCB7IGlzUHJlc2VudCwgb25FeGl0Q29tcGxldGUsIHJlZ2lzdGVyIH0gPSBjb250ZXh0O1xuICBjb25zdCBpZDIgPSAoMCwgaW1wb3J0X3JlYWN0MjIudXNlSWQpKCk7XG4gICgwLCBpbXBvcnRfcmVhY3QyMi51c2VFZmZlY3QpKCgpID0+IHJlZ2lzdGVyKGlkMiksIFtdKTtcbiAgY29uc3Qgc2FmZVRvUmVtb3ZlID0gKCkgPT4gb25FeGl0Q29tcGxldGUgJiYgb25FeGl0Q29tcGxldGUoaWQyKTtcbiAgcmV0dXJuICFpc1ByZXNlbnQgJiYgb25FeGl0Q29tcGxldGUgPyBbZmFsc2UsIHNhZmVUb1JlbW92ZV0gOiBbdHJ1ZV07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvc2hhbGxvdy1jb21wYXJlLm1qc1xuZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmUobmV4dCwgcHJldikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocHJldikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcmV2TGVuZ3RoID0gcHJldi5sZW5ndGg7XG4gIGlmIChwcmV2TGVuZ3RoICE9PSBuZXh0Lmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBwcmV2TGVuZ3RoOyBpMisrKSB7XG4gICAgaWYgKHByZXZbaTJdICE9PSBuZXh0W2kyXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy90aW1lLWNvbnZlcnNpb24ubWpzXG52YXIgc2Vjb25kc1RvTWlsbGlzZWNvbmRzID0gKHNlY29uZHMpID0+IHNlY29uZHMgKiAxZTM7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2Vhc2luZy5tanNcbnZhciBlYXNpbmdMb29rdXAgPSB7XG4gIGxpbmVhcixcbiAgZWFzZUluLFxuICBlYXNlSW5PdXQsXG4gIGVhc2VPdXQsXG4gIGNpcmNJbixcbiAgY2lyY0luT3V0LFxuICBjaXJjT3V0LFxuICBiYWNrSW4sXG4gIGJhY2tJbk91dCxcbiAgYmFja091dCxcbiAgYW50aWNpcGF0ZSxcbiAgYm91bmNlSW4sXG4gIGJvdW5jZUluT3V0LFxuICBib3VuY2VPdXRcbn07XG52YXIgZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24gPSAoZGVmaW5pdGlvbikgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgIGludmFyaWFudChkZWZpbml0aW9uLmxlbmd0aCA9PT0gNCwgYEN1YmljIGJlemllciBhcnJheXMgbXVzdCBjb250YWluIGZvdXIgbnVtZXJpY2FsIHZhbHVlcy5gKTtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gZGVmaW5pdGlvbjtcbiAgICByZXR1cm4gY3ViaWNCZXppZXIoeDEsIHkxLCB4MiwgeTIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgaW52YXJpYW50KGVhc2luZ0xvb2t1cFtkZWZpbml0aW9uXSAhPT0gdm9pZCAwLCBgSW52YWxpZCBlYXNpbmcgdHlwZSAnJHtkZWZpbml0aW9ufSdgKTtcbiAgICByZXR1cm4gZWFzaW5nTG9va3VwW2RlZmluaXRpb25dO1xuICB9XG4gIHJldHVybiBkZWZpbml0aW9uO1xufTtcbnZhciBpc0Vhc2luZ0FycmF5ID0gKGVhc2UpID0+IHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZWFzZSkgJiYgdHlwZW9mIGVhc2VbMF0gIT09IFwibnVtYmVyXCI7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRhYmxlLm1qc1xudmFyIGlzQW5pbWF0YWJsZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gIGlmIChrZXkgPT09IFwiekluZGV4XCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIGNvbXBsZXgudGVzdCh2YWx1ZSkgJiYgIXZhbHVlLnN0YXJ0c1dpdGgoXCJ1cmwoXCIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvZGVmYXVsdC10cmFuc2l0aW9ucy5tanNcbnZhciB1bmRlckRhbXBlZFNwcmluZyA9ICgpID0+ICh7XG4gIHR5cGU6IFwic3ByaW5nXCIsXG4gIHN0aWZmbmVzczogNTAwLFxuICBkYW1waW5nOiAyNSxcbiAgcmVzdFNwZWVkOiAxMFxufSk7XG52YXIgY3JpdGljYWxseURhbXBlZFNwcmluZyA9ICh0bykgPT4gKHtcbiAgdHlwZTogXCJzcHJpbmdcIixcbiAgc3RpZmZuZXNzOiA1NTAsXG4gIGRhbXBpbmc6IHRvID09PSAwID8gMiAqIE1hdGguc3FydCg1NTApIDogMzAsXG4gIHJlc3RTcGVlZDogMTBcbn0pO1xudmFyIGxpbmVhclR3ZWVuID0gKCkgPT4gKHtcbiAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgZWFzZTogXCJsaW5lYXJcIixcbiAgZHVyYXRpb246IDAuM1xufSk7XG52YXIga2V5ZnJhbWVzMiA9ICh2YWx1ZXMpID0+ICh7XG4gIHR5cGU6IFwia2V5ZnJhbWVzXCIsXG4gIGR1cmF0aW9uOiAwLjgsXG4gIHZhbHVlc1xufSk7XG52YXIgZGVmYXVsdFRyYW5zaXRpb25zID0ge1xuICB4OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgeTogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHo6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICByb3RhdGU6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICByb3RhdGVYOiB1bmRlckRhbXBlZFNwcmluZyxcbiAgcm90YXRlWTogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHJvdGF0ZVo6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICBzY2FsZVg6IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsXG4gIHNjYWxlWTogY3JpdGljYWxseURhbXBlZFNwcmluZyxcbiAgc2NhbGU6IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsXG4gIG9wYWNpdHk6IGxpbmVhclR3ZWVuLFxuICBiYWNrZ3JvdW5kQ29sb3I6IGxpbmVhclR3ZWVuLFxuICBjb2xvcjogbGluZWFyVHdlZW4sXG4gIGRlZmF1bHQ6IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmdcbn07XG52YXIgZ2V0RGVmYXVsdFRyYW5zaXRpb24gPSAodmFsdWVLZXksIHRvKSA9PiB7XG4gIGxldCB0cmFuc2l0aW9uRmFjdG9yeTtcbiAgaWYgKGlzS2V5ZnJhbWVzVGFyZ2V0KHRvKSkge1xuICAgIHRyYW5zaXRpb25GYWN0b3J5ID0ga2V5ZnJhbWVzMjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2l0aW9uRmFjdG9yeSA9IGRlZmF1bHRUcmFuc2l0aW9uc1t2YWx1ZUtleV0gfHwgZGVmYXVsdFRyYW5zaXRpb25zLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHsgdG8gfSwgdHJhbnNpdGlvbkZhY3RvcnkodG8pKTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9kZWZhdWx0cy5tanNcbnZhciBkZWZhdWx0VmFsdWVUeXBlcyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG51bWJlclZhbHVlVHlwZXMpLCB7XG4gIGNvbG9yLFxuICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLFxuICBvdXRsaW5lQ29sb3I6IGNvbG9yLFxuICBmaWxsOiBjb2xvcixcbiAgc3Ryb2tlOiBjb2xvcixcbiAgYm9yZGVyQ29sb3I6IGNvbG9yLFxuICBib3JkZXJUb3BDb2xvcjogY29sb3IsXG4gIGJvcmRlclJpZ2h0Q29sb3I6IGNvbG9yLFxuICBib3JkZXJCb3R0b21Db2xvcjogY29sb3IsXG4gIGJvcmRlckxlZnRDb2xvcjogY29sb3IsXG4gIGZpbHRlcixcbiAgV2Via2l0RmlsdGVyOiBmaWx0ZXJcbn0pO1xudmFyIGdldERlZmF1bHRWYWx1ZVR5cGUgPSAoa2V5KSA9PiBkZWZhdWx0VmFsdWVUeXBlc1trZXldO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvYW5pbWF0YWJsZS1ub25lLm1qc1xuZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZU5vbmUyKGtleSwgdmFsdWUpIHtcbiAgdmFyIF9hO1xuICBsZXQgZGVmYXVsdFZhbHVlVHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgaWYgKGRlZmF1bHRWYWx1ZVR5cGUgIT09IGZpbHRlcilcbiAgICBkZWZhdWx0VmFsdWVUeXBlID0gY29tcGxleDtcbiAgcmV0dXJuIChfYSA9IGRlZmF1bHRWYWx1ZVR5cGUuZ2V0QW5pbWF0YWJsZU5vbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGRlZmF1bHRWYWx1ZVR5cGUsIHZhbHVlKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtaW5zdGFudC10cmFuc2l0aW9uLXN0YXRlLm1qc1xudmFyIGluc3RhbnRBbmltYXRpb25TdGF0ZSA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvZGVsYXkubWpzXG5mdW5jdGlvbiBkZWxheShjYWxsYmFjaywgdGltZW91dCkge1xuICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBjb25zdCBjaGVja0VsYXBzZWQgPSAoeyB0aW1lc3RhbXAgfSkgPT4ge1xuICAgIGNvbnN0IGVsYXBzZWQgPSB0aW1lc3RhbXAgLSBzdGFydDtcbiAgICBpZiAoZWxhcHNlZCA+PSB0aW1lb3V0KSB7XG4gICAgICBjYW5jZWxTeW5jLnJlYWQoY2hlY2tFbGFwc2VkKTtcbiAgICAgIGNhbGxiYWNrKGVsYXBzZWQgLSB0aW1lb3V0KTtcbiAgICB9XG4gIH07XG4gIGVzX2RlZmF1bHQucmVhZChjaGVja0VsYXBzZWQsIHRydWUpO1xuICByZXR1cm4gKCkgPT4gY2FuY2VsU3luYy5yZWFkKGNoZWNrRWxhcHNlZCk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL3RyYW5zaXRpb25zLm1qc1xuZnVuY3Rpb24gaXNUcmFuc2l0aW9uRGVmaW5lZChfYSkge1xuICB2YXIgX2IgPSBfYSwgeyB3aGVuLCBkZWxheTogX2RlbGF5LCBkZWxheUNoaWxkcmVuLCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24sIHJlcGVhdCwgcmVwZWF0VHlwZSwgcmVwZWF0RGVsYXksIGZyb20gfSA9IF9iLCB0cmFuc2l0aW9uID0gX19vYmpSZXN0KF9iLCBbXCJ3aGVuXCIsIFwiZGVsYXlcIiwgXCJkZWxheUNoaWxkcmVuXCIsIFwic3RhZ2dlckNoaWxkcmVuXCIsIFwic3RhZ2dlckRpcmVjdGlvblwiLCBcInJlcGVhdFwiLCBcInJlcGVhdFR5cGVcIiwgXCJyZXBlYXREZWxheVwiLCBcImZyb21cIl0pO1xuICByZXR1cm4gISFPYmplY3Qua2V5cyh0cmFuc2l0aW9uKS5sZW5ndGg7XG59XG52YXIgbGVnYWN5UmVwZWF0V2FybmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gY29udmVydFRyYW5zaXRpb25Ub0FuaW1hdGlvbk9wdGlvbnMoX2EpIHtcbiAgdmFyIF9iID0gX2EsIHsgZWFzZSwgdGltZXMsIHlveW8sIGZsaXAsIGxvb3AgfSA9IF9iLCB0cmFuc2l0aW9uID0gX19vYmpSZXN0KF9iLCBbXCJlYXNlXCIsIFwidGltZXNcIiwgXCJ5b3lvXCIsIFwiZmxpcFwiLCBcImxvb3BcIl0pO1xuICBjb25zdCBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIHRyYW5zaXRpb24pO1xuICBpZiAodGltZXMpXG4gICAgb3B0aW9uc1tcIm9mZnNldFwiXSA9IHRpbWVzO1xuICBpZiAodHJhbnNpdGlvbi5kdXJhdGlvbilcbiAgICBvcHRpb25zW1wiZHVyYXRpb25cIl0gPSBzZWNvbmRzVG9NaWxsaXNlY29uZHModHJhbnNpdGlvbi5kdXJhdGlvbik7XG4gIGlmICh0cmFuc2l0aW9uLnJlcGVhdERlbGF5KVxuICAgIG9wdGlvbnMucmVwZWF0RGVsYXkgPSBzZWNvbmRzVG9NaWxsaXNlY29uZHModHJhbnNpdGlvbi5yZXBlYXREZWxheSk7XG4gIGlmIChlYXNlKSB7XG4gICAgb3B0aW9uc1tcImVhc2VcIl0gPSBpc0Vhc2luZ0FycmF5KGVhc2UpID8gZWFzZS5tYXAoZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24pIDogZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24oZWFzZSk7XG4gIH1cbiAgaWYgKHRyYW5zaXRpb24udHlwZSA9PT0gXCJ0d2VlblwiKVxuICAgIG9wdGlvbnMudHlwZSA9IFwia2V5ZnJhbWVzXCI7XG4gIGlmICh5b3lvIHx8IGxvb3AgfHwgZmxpcCkge1xuICAgIHdhcm5pbmcoIWxlZ2FjeVJlcGVhdFdhcm5pbmcsIFwieW95bywgbG9vcCBhbmQgZmxpcCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBBUEkuIFJlcGxhY2Ugd2l0aCByZXBlYXQgYW5kIHJlcGVhdFR5cGUgb3B0aW9ucy5cIik7XG4gICAgbGVnYWN5UmVwZWF0V2FybmluZyA9IHRydWU7XG4gICAgaWYgKHlveW8pIHtcbiAgICAgIG9wdGlvbnMucmVwZWF0VHlwZSA9IFwicmV2ZXJzZVwiO1xuICAgIH0gZWxzZSBpZiAobG9vcCkge1xuICAgICAgb3B0aW9ucy5yZXBlYXRUeXBlID0gXCJsb29wXCI7XG4gICAgfSBlbHNlIGlmIChmbGlwKSB7XG4gICAgICBvcHRpb25zLnJlcGVhdFR5cGUgPSBcIm1pcnJvclwiO1xuICAgIH1cbiAgICBvcHRpb25zLnJlcGVhdCA9IGxvb3AgfHwgeW95byB8fCBmbGlwIHx8IHRyYW5zaXRpb24ucmVwZWF0O1xuICB9XG4gIGlmICh0cmFuc2l0aW9uLnR5cGUgIT09IFwic3ByaW5nXCIpXG4gICAgb3B0aW9ucy50eXBlID0gXCJrZXlmcmFtZXNcIjtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBnZXREZWxheUZyb21UcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB2YWx1ZVRyYW5zaXRpb24gPSBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB8fCB7fTtcbiAgcmV0dXJuIChfYiA9IChfYSA9IHZhbHVlVHJhbnNpdGlvbi5kZWxheSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJhbnNpdGlvbi5kZWxheSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVLZXlmcmFtZXMob3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnRvKSAmJiBvcHRpb25zLnRvWzBdID09PSBudWxsKSB7XG4gICAgb3B0aW9ucy50byA9IFsuLi5vcHRpb25zLnRvXTtcbiAgICBvcHRpb25zLnRvWzBdID0gb3B0aW9ucy5mcm9tO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0UG9wbW90aW9uQW5pbWF0aW9uT3B0aW9ucyh0cmFuc2l0aW9uLCBvcHRpb25zLCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy50bykgJiYgdHJhbnNpdGlvbi5kdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgdHJhbnNpdGlvbi5kdXJhdGlvbiA9IDAuODtcbiAgfVxuICBoeWRyYXRlS2V5ZnJhbWVzKG9wdGlvbnMpO1xuICBpZiAoIWlzVHJhbnNpdGlvbkRlZmluZWQodHJhbnNpdGlvbikpIHtcbiAgICB0cmFuc2l0aW9uID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRyYW5zaXRpb24pLCBnZXREZWZhdWx0VHJhbnNpdGlvbihrZXksIG9wdGlvbnMudG8pKTtcbiAgfVxuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCBjb252ZXJ0VHJhbnNpdGlvblRvQW5pbWF0aW9uT3B0aW9ucyh0cmFuc2l0aW9uKSk7XG59XG5mdW5jdGlvbiBnZXRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uLCBvbkNvbXBsZXRlKSB7XG4gIGNvbnN0IHZhbHVlVHJhbnNpdGlvbiA9IGdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHx8IHt9O1xuICBsZXQgb3JpZ2luID0gdmFsdWVUcmFuc2l0aW9uLmZyb20gIT09IHZvaWQgMCA/IHZhbHVlVHJhbnNpdGlvbi5mcm9tIDogdmFsdWUuZ2V0KCk7XG4gIGNvbnN0IGlzVGFyZ2V0QW5pbWF0YWJsZSA9IGlzQW5pbWF0YWJsZShrZXksIHRhcmdldCk7XG4gIGlmIChvcmlnaW4gPT09IFwibm9uZVwiICYmIGlzVGFyZ2V0QW5pbWF0YWJsZSAmJiB0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgb3JpZ2luID0gZ2V0QW5pbWF0YWJsZU5vbmUyKGtleSwgdGFyZ2V0KTtcbiAgfSBlbHNlIGlmIChpc1plcm8ob3JpZ2luKSAmJiB0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgb3JpZ2luID0gZ2V0WmVyb1VuaXQodGFyZ2V0KTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzWmVybyh0YXJnZXQpICYmIHR5cGVvZiBvcmlnaW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICB0YXJnZXQgPSBnZXRaZXJvVW5pdChvcmlnaW4pO1xuICB9XG4gIGNvbnN0IGlzT3JpZ2luQW5pbWF0YWJsZSA9IGlzQW5pbWF0YWJsZShrZXksIG9yaWdpbik7XG4gIHdhcm5pbmcoaXNPcmlnaW5BbmltYXRhYmxlID09PSBpc1RhcmdldEFuaW1hdGFibGUsIGBZb3UgYXJlIHRyeWluZyB0byBhbmltYXRlICR7a2V5fSBmcm9tIFwiJHtvcmlnaW59XCIgdG8gXCIke3RhcmdldH1cIi4gJHtvcmlnaW59IGlzIG5vdCBhbiBhbmltYXRhYmxlIHZhbHVlIC0gdG8gZW5hYmxlIHRoaXMgYW5pbWF0aW9uIHNldCAke29yaWdpbn0gdG8gYSB2YWx1ZSBhbmltYXRhYmxlIHRvICR7dGFyZ2V0fSB2aWEgdGhlIFxcYHN0eWxlXFxgIHByb3BlcnR5LmApO1xuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZnJvbTogb3JpZ2luLFxuICAgICAgdG86IHRhcmdldCxcbiAgICAgIHZlbG9jaXR5OiB2YWx1ZS5nZXRWZWxvY2l0eSgpLFxuICAgICAgb25Db21wbGV0ZSxcbiAgICAgIG9uVXBkYXRlOiAodikgPT4gdmFsdWUuc2V0KHYpXG4gICAgfTtcbiAgICByZXR1cm4gdmFsdWVUcmFuc2l0aW9uLnR5cGUgPT09IFwiaW5lcnRpYVwiIHx8IHZhbHVlVHJhbnNpdGlvbi50eXBlID09PSBcImRlY2F5XCIgPyBpbmVydGlhKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgdmFsdWVUcmFuc2l0aW9uKSkgOiBhbmltYXRlKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGdldFBvcG1vdGlvbkFuaW1hdGlvbk9wdGlvbnModmFsdWVUcmFuc2l0aW9uLCBvcHRpb25zLCBrZXkpKSwge1xuICAgICAgb25VcGRhdGU6ICh2KSA9PiB7XG4gICAgICAgIG9wdGlvbnMub25VcGRhdGUodik7XG4gICAgICAgIHZhbHVlVHJhbnNpdGlvbi5vblVwZGF0ZSAmJiB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUodik7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgICAgdmFsdWVUcmFuc2l0aW9uLm9uQ29tcGxldGUgJiYgdmFsdWVUcmFuc2l0aW9uLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0KCkge1xuICAgIGNvbnN0IGZpbmFsVGFyZ2V0ID0gcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyh0YXJnZXQpO1xuICAgIHZhbHVlLnNldChmaW5hbFRhcmdldCk7XG4gICAgb25Db21wbGV0ZSgpO1xuICAgIHZhbHVlVHJhbnNpdGlvbi5vblVwZGF0ZSAmJiB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUoZmluYWxUYXJnZXQpO1xuICAgIHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlICYmIHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlKCk7XG4gICAgcmV0dXJuIHsgc3RvcDogKCkgPT4ge1xuICAgIH0gfTtcbiAgfVxuICByZXR1cm4gIWlzT3JpZ2luQW5pbWF0YWJsZSB8fCAhaXNUYXJnZXRBbmltYXRhYmxlIHx8IHZhbHVlVHJhbnNpdGlvbi50eXBlID09PSBmYWxzZSA/IHNldCA6IHN0YXJ0O1xufVxuZnVuY3Rpb24gaXNaZXJvKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gMCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgcGFyc2VGbG9hdCh2YWx1ZSkgPT09IDAgJiYgdmFsdWUuaW5kZXhPZihcIiBcIikgPT09IC0xO1xufVxuZnVuY3Rpb24gZ2V0WmVyb1VuaXQocG90ZW50aWFsVW5pdFR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBwb3RlbnRpYWxVbml0VHlwZSA9PT0gXCJudW1iZXJcIiA/IDAgOiBnZXRBbmltYXRhYmxlTm9uZTIoXCJcIiwgcG90ZW50aWFsVW5pdFR5cGUpO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleSkge1xuICByZXR1cm4gdHJhbnNpdGlvbltrZXldIHx8IHRyYW5zaXRpb25bXCJkZWZhdWx0XCJdIHx8IHRyYW5zaXRpb247XG59XG5mdW5jdGlvbiBzdGFydEFuaW1hdGlvbihrZXksIHZhbHVlLCB0YXJnZXQsIHRyYW5zaXRpb24gPSB7fSkge1xuICBpZiAoaW5zdGFudEFuaW1hdGlvblN0YXRlLmN1cnJlbnQpIHtcbiAgICB0cmFuc2l0aW9uID0geyB0eXBlOiBmYWxzZSB9O1xuICB9XG4gIHJldHVybiB2YWx1ZS5zdGFydCgob25Db21wbGV0ZSkgPT4ge1xuICAgIGxldCBjb250cm9scztcbiAgICBjb25zdCBhbmltYXRpb24gPSBnZXRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uLCBvbkNvbXBsZXRlKTtcbiAgICBjb25zdCBkZWxheUJ5ID0gZ2V0RGVsYXlGcm9tVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpO1xuICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4gY29udHJvbHMgPSBhbmltYXRpb24oKTtcbiAgICBsZXQgY2FuY2VsRGVsYXk7XG4gICAgaWYgKGRlbGF5QnkpIHtcbiAgICAgIGNhbmNlbERlbGF5ID0gZGVsYXkoc3RhcnQsIHNlY29uZHNUb01pbGxpc2Vjb25kcyhkZWxheUJ5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0KCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWxEZWxheSAmJiBjYW5jZWxEZWxheSgpO1xuICAgICAgY29udHJvbHMgJiYgY29udHJvbHMuc3RvcCgpO1xuICAgIH07XG4gIH0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLW51bWVyaWNhbC1zdHJpbmcubWpzXG52YXIgaXNOdW1lcmljYWxTdHJpbmcgPSAodikgPT4gL15cXC0/XFxkKlxcLj9cXGQrJC8udGVzdCh2KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pcy16ZXJvLXZhbHVlLXN0cmluZy5tanNcbnZhciBpc1plcm9WYWx1ZVN0cmluZyA9ICh2KSA9PiAvXjBbXi5cXHNdKyQvLnRlc3Qodik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvYXJyYXkubWpzXG5mdW5jdGlvbiBhZGRVbmlxdWVJdGVtKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmluZGV4T2YoaXRlbSkgPT09IC0xKVxuICAgIGFyci5wdXNoKGl0ZW0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlSXRlbShhcnIsIGl0ZW0pIHtcbiAgY29uc3QgaW5kZXgyID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gIGlmIChpbmRleDIgPiAtMSlcbiAgICBhcnIuc3BsaWNlKGluZGV4MiwgMSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvc3Vic2NyaXB0aW9uLW1hbmFnZXIubWpzXG52YXIgU3Vic2NyaXB0aW9uTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gIH1cbiAgYWRkKGhhbmRsZXIpIHtcbiAgICBhZGRVbmlxdWVJdGVtKHRoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHJlbW92ZUl0ZW0odGhpcy5zdWJzY3JpcHRpb25zLCBoYW5kbGVyKTtcbiAgfVxuICBub3RpZnkoYTIsIGIyLCBjMykge1xuICAgIGNvbnN0IG51bVN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgIGlmICghbnVtU3Vic2NyaXB0aW9ucylcbiAgICAgIHJldHVybjtcbiAgICBpZiAobnVtU3Vic2NyaXB0aW9ucyA9PT0gMSkge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zWzBdKGEyLCBiMiwgYzMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtU3Vic2NyaXB0aW9uczsgaTIrKykge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5zdWJzY3JpcHRpb25zW2kyXTtcbiAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyKGEyLCBiMiwgYzMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggPSAwO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL2luZGV4Lm1qc1xudmFyIGlzRmxvYXQgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSk7XG59O1xudmFyIE1vdGlvblZhbHVlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gXCI3LjYuN1wiO1xuICAgIHRoaXMudGltZURlbHRhID0gMDtcbiAgICB0aGlzLmxhc3RVcGRhdGVkID0gMDtcbiAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgIHRoaXMucmVuZGVyU3Vic2NyaWJlcnMgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5ID0gKHYsIHJlbmRlciA9IHRydWUpID0+IHtcbiAgICAgIHRoaXMucHJldiA9IHRoaXMuY3VycmVudDtcbiAgICAgIHRoaXMuY3VycmVudCA9IHY7XG4gICAgICBjb25zdCB7IGRlbHRhLCB0aW1lc3RhbXAgfSA9IGdldEZyYW1lRGF0YSgpO1xuICAgICAgaWYgKHRoaXMubGFzdFVwZGF0ZWQgIT09IHRpbWVzdGFtcCkge1xuICAgICAgICB0aGlzLnRpbWVEZWx0YSA9IGRlbHRhO1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGVkID0gdGltZXN0YW1wO1xuICAgICAgICBlc19kZWZhdWx0LnBvc3RSZW5kZXIodGhpcy5zY2hlZHVsZVZlbG9jaXR5Q2hlY2spO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJldiAhPT0gdGhpcy5jdXJyZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMubm90aWZ5KHRoaXMuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy52ZWxvY2l0eVVwZGF0ZVN1YnNjcmliZXJzLmdldFNpemUoKSkge1xuICAgICAgICB0aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMubm90aWZ5KHRoaXMuZ2V0VmVsb2NpdHkoKSk7XG4gICAgICB9XG4gICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgIHRoaXMucmVuZGVyU3Vic2NyaWJlcnMubm90aWZ5KHRoaXMuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNjaGVkdWxlVmVsb2NpdHlDaGVjayA9ICgpID0+IGVzX2RlZmF1bHQucG9zdFJlbmRlcih0aGlzLnZlbG9jaXR5Q2hlY2spO1xuICAgIHRoaXMudmVsb2NpdHlDaGVjayA9ICh7IHRpbWVzdGFtcCB9KSA9PiB7XG4gICAgICBpZiAodGltZXN0YW1wICE9PSB0aGlzLmxhc3RVcGRhdGVkKSB7XG4gICAgICAgIHRoaXMucHJldiA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVVwZGF0ZVN1YnNjcmliZXJzLm5vdGlmeSh0aGlzLmdldFZlbG9jaXR5KCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYXNBbmltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucHJldiA9IHRoaXMuY3VycmVudCA9IGluaXQ7XG4gICAgdGhpcy5jYW5UcmFja1ZlbG9jaXR5ID0gaXNGbG9hdCh0aGlzLmN1cnJlbnQpO1xuICB9XG4gIG9uQ2hhbmdlKHN1YnNjcmlwdGlvbikge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzLmFkZChzdWJzY3JpcHRpb24pO1xuICB9XG4gIGNsZWFyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgfVxuICBvblJlbmRlclJlcXVlc3Qoc3Vic2NyaXB0aW9uKSB7XG4gICAgc3Vic2NyaXB0aW9uKHRoaXMuZ2V0KCkpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclN1YnNjcmliZXJzLmFkZChzdWJzY3JpcHRpb24pO1xuICB9XG4gIGF0dGFjaChwYXNzaXZlRWZmZWN0KSB7XG4gICAgdGhpcy5wYXNzaXZlRWZmZWN0ID0gcGFzc2l2ZUVmZmVjdDtcbiAgfVxuICBzZXQodiwgcmVuZGVyID0gdHJ1ZSkge1xuICAgIGlmICghcmVuZGVyIHx8ICF0aGlzLnBhc3NpdmVFZmZlY3QpIHtcbiAgICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5KHYsIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFzc2l2ZUVmZmVjdCh2LCB0aGlzLnVwZGF0ZUFuZE5vdGlmeSk7XG4gICAgfVxuICB9XG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICB9XG4gIGdldFByZXZpb3VzKCkge1xuICAgIHJldHVybiB0aGlzLnByZXY7XG4gIH1cbiAgZ2V0VmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA/IHZlbG9jaXR5UGVyU2Vjb25kKHBhcnNlRmxvYXQodGhpcy5jdXJyZW50KSAtIHBhcnNlRmxvYXQodGhpcy5wcmV2KSwgdGhpcy50aW1lRGVsdGEpIDogMDtcbiAgfVxuICBzdGFydChhbmltYXRpb24pIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuaGFzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uID0gYW5pbWF0aW9uKHJlc29sdmUpO1xuICAgIH0pLnRoZW4oKCkgPT4gdGhpcy5jbGVhckFuaW1hdGlvbigpKTtcbiAgfVxuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLnN0b3BBbmltYXRpb24pXG4gICAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICB0aGlzLmNsZWFyQW5pbWF0aW9uKCk7XG4gIH1cbiAgaXNBbmltYXRpbmcoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zdG9wQW5pbWF0aW9uO1xuICB9XG4gIGNsZWFyQW5pbWF0aW9uKCkge1xuICAgIHRoaXMuc3RvcEFuaW1hdGlvbiA9IG51bGw7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5jbGVhcigpO1xuICAgIHRoaXMuc3RvcCgpO1xuICB9XG59O1xuZnVuY3Rpb24gbW90aW9uVmFsdWUoaW5pdCkge1xuICByZXR1cm4gbmV3IE1vdGlvblZhbHVlKGluaXQpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvdGVzdC5tanNcbnZhciB0ZXN0VmFsdWVUeXBlID0gKHYpID0+ICh0eXBlKSA9PiB0eXBlLnRlc3Qodik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy90eXBlLWF1dG8ubWpzXG52YXIgYXV0byA9IHtcbiAgdGVzdDogKHYpID0+IHYgPT09IFwiYXV0b1wiLFxuICBwYXJzZTogKHYpID0+IHZcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9kaW1lbnNpb25zLm1qc1xudmFyIGRpbWVuc2lvblZhbHVlVHlwZXMgPSBbbnVtYmVyLCBweCwgcGVyY2VudCwgZGVncmVlcywgdncsIHZoLCBhdXRvXTtcbnZhciBmaW5kRGltZW5zaW9uVmFsdWVUeXBlID0gKHYpID0+IGRpbWVuc2lvblZhbHVlVHlwZXMuZmluZCh0ZXN0VmFsdWVUeXBlKHYpKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL2ZpbmQubWpzXG52YXIgdmFsdWVUeXBlcyA9IFsuLi5kaW1lbnNpb25WYWx1ZVR5cGVzLCBjb2xvciwgY29tcGxleF07XG52YXIgZmluZFZhbHVlVHlwZSA9ICh2KSA9PiB2YWx1ZVR5cGVzLmZpbmQodGVzdFZhbHVlVHlwZSh2KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL3Jlc29sdmUtZHluYW1pYy12YXJpYW50cy5tanNcbmZ1bmN0aW9uIGdldEN1cnJlbnQodmlzdWFsRWxlbWVudCkge1xuICBjb25zdCBjdXJyZW50ID0ge307XG4gIHZpc3VhbEVsZW1lbnQudmFsdWVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IGN1cnJlbnRba2V5XSA9IHZhbHVlLmdldCgpKTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBnZXRWZWxvY2l0eSh2aXN1YWxFbGVtZW50KSB7XG4gIGNvbnN0IHZlbG9jaXR5ID0ge307XG4gIHZpc3VhbEVsZW1lbnQudmFsdWVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHZlbG9jaXR5W2tleV0gPSB2YWx1ZS5nZXRWZWxvY2l0eSgpKTtcbiAgcmV0dXJuIHZlbG9jaXR5O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgY3VzdG9tKSB7XG4gIGNvbnN0IHByb3BzID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICByZXR1cm4gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24sIGN1c3RvbSAhPT0gdm9pZCAwID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBnZXRDdXJyZW50KHZpc3VhbEVsZW1lbnQpLCBnZXRWZWxvY2l0eSh2aXN1YWxFbGVtZW50KSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL3NldHRlcnMubWpzXG5mdW5jdGlvbiBzZXRNb3Rpb25WYWx1ZSh2aXN1YWxFbGVtZW50LCBrZXksIHZhbHVlKSB7XG4gIGlmICh2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSkpIHtcbiAgICB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSkuc2V0KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2aXN1YWxFbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUodmFsdWUpKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pIHtcbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgbGV0IF9hID0gcmVzb2x2ZWQgPyB2aXN1YWxFbGVtZW50Lm1ha2VUYXJnZXRBbmltYXRhYmxlKHJlc29sdmVkLCBmYWxzZSkgOiB7fSwgeyB0cmFuc2l0aW9uRW5kID0ge30sIHRyYW5zaXRpb24gPSB7fSB9ID0gX2EsIHRhcmdldCA9IF9fb2JqUmVzdChfYSwgW1widHJhbnNpdGlvbkVuZFwiLCBcInRyYW5zaXRpb25cIl0pO1xuICB0YXJnZXQgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGFyZ2V0KSwgdHJhbnNpdGlvbkVuZCk7XG4gIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyh0YXJnZXRba2V5XSk7XG4gICAgc2V0TW90aW9uVmFsdWUodmlzdWFsRWxlbWVudCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IG5ld1ZhbHVlS2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCkuZmlsdGVyKChrZXkpID0+ICF2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSkpO1xuICBjb25zdCBudW1OZXdWYWx1ZXMgPSBuZXdWYWx1ZUtleXMubGVuZ3RoO1xuICBpZiAoIW51bU5ld1ZhbHVlcylcbiAgICByZXR1cm47XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1OZXdWYWx1ZXM7IGkyKyspIHtcbiAgICBjb25zdCBrZXkgPSBuZXdWYWx1ZUtleXNbaTJdO1xuICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdGFyZ2V0VmFsdWVbMF07XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSAoX2IgPSAoX2EgPSBvcmlnaW5ba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmlzdWFsRWxlbWVudC5yZWFkVmFsdWUoa2V5KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGFyZ2V0W2tleV07XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAoaXNOdW1lcmljYWxTdHJpbmcodmFsdWUpIHx8IGlzWmVyb1ZhbHVlU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICghZmluZFZhbHVlVHlwZSh2YWx1ZSkgJiYgY29tcGxleC50ZXN0KHRhcmdldFZhbHVlKSkge1xuICAgICAgdmFsdWUgPSBnZXRBbmltYXRhYmxlTm9uZTIoa2V5LCB0YXJnZXRWYWx1ZSk7XG4gICAgfVxuICAgIHZpc3VhbEVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZSh2YWx1ZSkpO1xuICAgIGlmIChvcmlnaW5ba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICBvcmlnaW5ba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IG51bGwpXG4gICAgICB2aXN1YWxFbGVtZW50LnNldEJhc2VUYXJnZXQoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE9yaWdpbkZyb21UcmFuc2l0aW9uKGtleSwgdHJhbnNpdGlvbikge1xuICBpZiAoIXRyYW5zaXRpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCB2YWx1ZVRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gfHwgdHJhbnNpdGlvbltcImRlZmF1bHRcIl0gfHwgdHJhbnNpdGlvbjtcbiAgcmV0dXJuIHZhbHVlVHJhbnNpdGlvbi5mcm9tO1xufVxuZnVuY3Rpb24gZ2V0T3JpZ2luKHRhcmdldCwgdHJhbnNpdGlvbiwgdmlzdWFsRWxlbWVudCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IG9yaWdpbiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uT3JpZ2luID0gZ2V0T3JpZ2luRnJvbVRyYW5zaXRpb24oa2V5LCB0cmFuc2l0aW9uKTtcbiAgICBvcmlnaW5ba2V5XSA9IHRyYW5zaXRpb25PcmlnaW4gIT09IHZvaWQgMCA/IHRyYW5zaXRpb25PcmlnaW4gOiAoX2EgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3VzZS13aWxsLWNoYW5nZS9pcy5tanNcbmZ1bmN0aW9uIGlzV2lsbENoYW5nZU1vdGlvblZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKGlzTW90aW9uVmFsdWUodmFsdWUpICYmIHZhbHVlLmFkZCk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2FuaW1hdGlvbi5tanNcbmZ1bmN0aW9uIGFuaW1hdGVWaXN1YWxFbGVtZW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICB2aXN1YWxFbGVtZW50Lm5vdGlmeShcIkFuaW1hdGlvblN0YXJ0XCIsIGRlZmluaXRpb24pO1xuICBsZXQgYW5pbWF0aW9uO1xuICBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgIGNvbnN0IGFuaW1hdGlvbnMyID0gZGVmaW5pdGlvbi5tYXAoKHZhcmlhbnQpID0+IGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMpKTtcbiAgICBhbmltYXRpb24gPSBQcm9taXNlLmFsbChhbmltYXRpb25zMik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICBhbmltYXRpb24gPSBhbmltYXRlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZXNvbHZlZERlZmluaXRpb24gPSB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgb3B0aW9ucy5jdXN0b20pIDogZGVmaW5pdGlvbjtcbiAgICBhbmltYXRpb24gPSBhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHJlc29sdmVkRGVmaW5pdGlvbiwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGFuaW1hdGlvbi50aGVuKCgpID0+IHZpc3VhbEVsZW1lbnQubm90aWZ5KFwiQW5pbWF0aW9uQ29tcGxldGVcIiwgZGVmaW5pdGlvbikpO1xufVxuZnVuY3Rpb24gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBvcHRpb25zLmN1c3RvbSk7XG4gIGxldCB7IHRyYW5zaXRpb24gPSB2aXN1YWxFbGVtZW50LmdldERlZmF1bHRUcmFuc2l0aW9uKCkgfHwge30gfSA9IHJlc29sdmVkIHx8IHt9O1xuICBpZiAob3B0aW9ucy50cmFuc2l0aW9uT3ZlcnJpZGUpIHtcbiAgICB0cmFuc2l0aW9uID0gb3B0aW9ucy50cmFuc2l0aW9uT3ZlcnJpZGU7XG4gIH1cbiAgY29uc3QgZ2V0QW5pbWF0aW9uMiA9IHJlc29sdmVkID8gKCkgPT4gYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCByZXNvbHZlZCwgb3B0aW9ucykgOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcbiAgY29uc3QgZ2V0Q2hpbGRBbmltYXRpb25zID0gKChfYSA9IHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2l6ZSkgPyAoZm9yd2FyZERlbGF5ID0gMCkgPT4ge1xuICAgIGNvbnN0IHsgZGVsYXlDaGlsZHJlbiA9IDAsIHN0YWdnZXJDaGlsZHJlbiwgc3RhZ2dlckRpcmVjdGlvbiB9ID0gdHJhbnNpdGlvbjtcbiAgICByZXR1cm4gYW5pbWF0ZUNoaWxkcmVuKHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIGRlbGF5Q2hpbGRyZW4gKyBmb3J3YXJkRGVsYXksIHN0YWdnZXJDaGlsZHJlbiwgc3RhZ2dlckRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gIH0gOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcbiAgY29uc3QgeyB3aGVuIH0gPSB0cmFuc2l0aW9uO1xuICBpZiAod2hlbikge1xuICAgIGNvbnN0IFtmaXJzdCwgbGFzdF0gPSB3aGVuID09PSBcImJlZm9yZUNoaWxkcmVuXCIgPyBbZ2V0QW5pbWF0aW9uMiwgZ2V0Q2hpbGRBbmltYXRpb25zXSA6IFtnZXRDaGlsZEFuaW1hdGlvbnMsIGdldEFuaW1hdGlvbjJdO1xuICAgIHJldHVybiBmaXJzdCgpLnRoZW4obGFzdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtnZXRBbmltYXRpb24yKCksIGdldENoaWxkQW5pbWF0aW9ucyhvcHRpb25zLmRlbGF5KV0pO1xuICB9XG59XG5mdW5jdGlvbiBhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIHsgZGVsYXk6IGRlbGF5MiA9IDAsIHRyYW5zaXRpb25PdmVycmlkZSwgdHlwZSB9ID0ge30pIHtcbiAgdmFyIF9hO1xuICBsZXQgX2EyID0gdmlzdWFsRWxlbWVudC5tYWtlVGFyZ2V0QW5pbWF0YWJsZShkZWZpbml0aW9uKSwgeyB0cmFuc2l0aW9uID0gdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpLCB0cmFuc2l0aW9uRW5kIH0gPSBfYTIsIHRhcmdldCA9IF9fb2JqUmVzdChfYTIsIFtcInRyYW5zaXRpb25cIiwgXCJ0cmFuc2l0aW9uRW5kXCJdKTtcbiAgY29uc3Qgd2lsbENoYW5nZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoXCJ3aWxsQ2hhbmdlXCIpO1xuICBpZiAodHJhbnNpdGlvbk92ZXJyaWRlKVxuICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uT3ZlcnJpZGU7XG4gIGNvbnN0IGFuaW1hdGlvbnMyID0gW107XG4gIGNvbnN0IGFuaW1hdGlvblR5cGVTdGF0ZSA9IHR5cGUgJiYgKChfYSA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0ZSgpW3R5cGVdKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgY29uc3QgdmFsdWUgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgY29uc3QgdmFsdWVUYXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgICBpZiAoIXZhbHVlIHx8IHZhbHVlVGFyZ2V0ID09PSB2b2lkIDAgfHwgYW5pbWF0aW9uVHlwZVN0YXRlICYmIHNob3VsZEJsb2NrQW5pbWF0aW9uKGFuaW1hdGlvblR5cGVTdGF0ZSwga2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCB2YWx1ZVRyYW5zaXRpb24gPSBfX3NwcmVhZFZhbHVlcyh7IGRlbGF5OiBkZWxheTIgfSwgdHJhbnNpdGlvbik7XG4gICAgaWYgKHZpc3VhbEVsZW1lbnQuc2hvdWxkUmVkdWNlTW90aW9uICYmIHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICB2YWx1ZVRyYW5zaXRpb24gPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB2YWx1ZVRyYW5zaXRpb24pLCB7XG4gICAgICAgIHR5cGU6IGZhbHNlLFxuICAgICAgICBkZWxheTogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBhbmltYXRpb24gPSBzdGFydEFuaW1hdGlvbihrZXksIHZhbHVlLCB2YWx1ZVRhcmdldCwgdmFsdWVUcmFuc2l0aW9uKTtcbiAgICBpZiAoaXNXaWxsQ2hhbmdlTW90aW9uVmFsdWUod2lsbENoYW5nZSkpIHtcbiAgICAgIHdpbGxDaGFuZ2UuYWRkKGtleSk7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24udGhlbigoKSA9PiB3aWxsQ2hhbmdlLnJlbW92ZShrZXkpKTtcbiAgICB9XG4gICAgYW5pbWF0aW9uczIucHVzaChhbmltYXRpb24pO1xuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChhbmltYXRpb25zMikudGhlbigoKSA9PiB7XG4gICAgdHJhbnNpdGlvbkVuZCAmJiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgdHJhbnNpdGlvbkVuZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYW5pbWF0ZUNoaWxkcmVuKHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIGRlbGF5Q2hpbGRyZW4gPSAwLCBzdGFnZ2VyQ2hpbGRyZW4gPSAwLCBzdGFnZ2VyRGlyZWN0aW9uID0gMSwgb3B0aW9ucykge1xuICBjb25zdCBhbmltYXRpb25zMiA9IFtdO1xuICBjb25zdCBtYXhTdGFnZ2VyRHVyYXRpb24gPSAodmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4uc2l6ZSAtIDEpICogc3RhZ2dlckNoaWxkcmVuO1xuICBjb25zdCBnZW5lcmF0ZVN0YWdnZXJEdXJhdGlvbiA9IHN0YWdnZXJEaXJlY3Rpb24gPT09IDEgPyAoaTIgPSAwKSA9PiBpMiAqIHN0YWdnZXJDaGlsZHJlbiA6IChpMiA9IDApID0+IG1heFN0YWdnZXJEdXJhdGlvbiAtIGkyICogc3RhZ2dlckNoaWxkcmVuO1xuICBBcnJheS5mcm9tKHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuKS5zb3J0KHNvcnRCeVRyZWVPcmRlcikuZm9yRWFjaCgoY2hpbGQsIGkyKSA9PiB7XG4gICAgYW5pbWF0aW9uczIucHVzaChhbmltYXRlVmFyaWFudChjaGlsZCwgdmFyaWFudCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIGRlbGF5OiBkZWxheUNoaWxkcmVuICsgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24oaTIpXG4gICAgfSkpLnRoZW4oKCkgPT4gY2hpbGQubm90aWZ5KFwiQW5pbWF0aW9uQ29tcGxldGVcIiwgdmFyaWFudCkpKTtcbiAgfSk7XG4gIHJldHVybiBQcm9taXNlLmFsbChhbmltYXRpb25zMik7XG59XG5mdW5jdGlvbiBzb3J0QnlUcmVlT3JkZXIoYTIsIGIyKSB7XG4gIHJldHVybiBhMi5zb3J0Tm9kZVBvc2l0aW9uKGIyKTtcbn1cbmZ1bmN0aW9uIHNob3VsZEJsb2NrQW5pbWF0aW9uKHsgcHJvdGVjdGVkS2V5cywgbmVlZHNBbmltYXRpbmcgfSwga2V5KSB7XG4gIGNvbnN0IHNob3VsZEJsb2NrID0gcHJvdGVjdGVkS2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG5lZWRzQW5pbWF0aW5nW2tleV0gIT09IHRydWU7XG4gIG5lZWRzQW5pbWF0aW5nW2tleV0gPSBmYWxzZTtcbiAgcmV0dXJuIHNob3VsZEJsb2NrO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9hbmltYXRpb24tc3RhdGUubWpzXG52YXIgdmFyaWFudFByaW9yaXR5T3JkZXIgPSBbXG4gIEFuaW1hdGlvblR5cGUuQW5pbWF0ZSxcbiAgQW5pbWF0aW9uVHlwZS5JblZpZXcsXG4gIEFuaW1hdGlvblR5cGUuRm9jdXMsXG4gIEFuaW1hdGlvblR5cGUuSG92ZXIsXG4gIEFuaW1hdGlvblR5cGUuVGFwLFxuICBBbmltYXRpb25UeXBlLkRyYWcsXG4gIEFuaW1hdGlvblR5cGUuRXhpdFxuXTtcbnZhciByZXZlcnNlUHJpb3JpdHlPcmRlciA9IFsuLi52YXJpYW50UHJpb3JpdHlPcmRlcl0ucmV2ZXJzZSgpO1xudmFyIG51bUFuaW1hdGlvblR5cGVzID0gdmFyaWFudFByaW9yaXR5T3JkZXIubGVuZ3RoO1xuZnVuY3Rpb24gYW5pbWF0ZUxpc3QodmlzdWFsRWxlbWVudCkge1xuICByZXR1cm4gKGFuaW1hdGlvbnMyKSA9PiBQcm9taXNlLmFsbChhbmltYXRpb25zMi5tYXAoKHsgYW5pbWF0aW9uLCBvcHRpb25zIH0pID0+IGFuaW1hdGVWaXN1YWxFbGVtZW50KHZpc3VhbEVsZW1lbnQsIGFuaW1hdGlvbiwgb3B0aW9ucykpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFuaW1hdGlvblN0YXRlKHZpc3VhbEVsZW1lbnQpIHtcbiAgbGV0IGFuaW1hdGUzID0gYW5pbWF0ZUxpc3QodmlzdWFsRWxlbWVudCk7XG4gIGNvbnN0IHN0YXRlID0gY3JlYXRlU3RhdGUoKTtcbiAgbGV0IGlzSW5pdGlhbFJlbmRlciA9IHRydWU7XG4gIGNvbnN0IGJ1aWxkUmVzb2x2ZWRUeXBlVmFsdWVzID0gKGFjYywgZGVmaW5pdGlvbikgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICBjb25zdCBfYSA9IHJlc29sdmVkLCB7IHRyYW5zaXRpb24sIHRyYW5zaXRpb25FbmQgfSA9IF9hLCB0YXJnZXQgPSBfX29ialJlc3QoX2EsIFtcInRyYW5zaXRpb25cIiwgXCJ0cmFuc2l0aW9uRW5kXCJdKTtcbiAgICAgIGFjYyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBhY2MpLCB0YXJnZXQpLCB0cmFuc2l0aW9uRW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfTtcbiAgZnVuY3Rpb24gc2V0QW5pbWF0ZUZ1bmN0aW9uKG1ha2VBbmltYXRvcikge1xuICAgIGFuaW1hdGUzID0gbWFrZUFuaW1hdG9yKHZpc3VhbEVsZW1lbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGFuaW1hdGVDaGFuZ2VzKG9wdGlvbnMsIGNoYW5nZWRBY3RpdmVUeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByb3BzID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB2aXN1YWxFbGVtZW50LmdldFZhcmlhbnRDb250ZXh0KHRydWUpIHx8IHt9O1xuICAgIGNvbnN0IGFuaW1hdGlvbnMyID0gW107XG4gICAgY29uc3QgcmVtb3ZlZEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBlbmNvdW50ZXJlZEtleXMgPSB7fTtcbiAgICBsZXQgcmVtb3ZlZFZhcmlhbnRJbmRleCA9IEluZmluaXR5O1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1BbmltYXRpb25UeXBlczsgaTIrKykge1xuICAgICAgY29uc3QgdHlwZSA9IHJldmVyc2VQcmlvcml0eU9yZGVyW2kyXTtcbiAgICAgIGNvbnN0IHR5cGVTdGF0ZSA9IHN0YXRlW3R5cGVdO1xuICAgICAgY29uc3QgcHJvcCA9IChfYSA9IHByb3BzW3R5cGVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb250ZXh0W3R5cGVdO1xuICAgICAgY29uc3QgcHJvcElzVmFyaWFudCA9IGlzVmFyaWFudExhYmVsKHByb3ApO1xuICAgICAgY29uc3QgYWN0aXZlRGVsdGEgPSB0eXBlID09PSBjaGFuZ2VkQWN0aXZlVHlwZSA/IHR5cGVTdGF0ZS5pc0FjdGl2ZSA6IG51bGw7XG4gICAgICBpZiAoYWN0aXZlRGVsdGEgPT09IGZhbHNlKVxuICAgICAgICByZW1vdmVkVmFyaWFudEluZGV4ID0gaTI7XG4gICAgICBsZXQgaXNJbmhlcml0ZWQgPSBwcm9wID09PSBjb250ZXh0W3R5cGVdICYmIHByb3AgIT09IHByb3BzW3R5cGVdICYmIHByb3BJc1ZhcmlhbnQ7XG4gICAgICBpZiAoaXNJbmhlcml0ZWQgJiYgaXNJbml0aWFsUmVuZGVyICYmIHZpc3VhbEVsZW1lbnQubWFudWFsbHlBbmltYXRlT25Nb3VudCkge1xuICAgICAgICBpc0luaGVyaXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgZW5jb3VudGVyZWRLZXlzKTtcbiAgICAgIGlmICghdHlwZVN0YXRlLmlzQWN0aXZlICYmIGFjdGl2ZURlbHRhID09PSBudWxsIHx8ICFwcm9wICYmICF0eXBlU3RhdGUucHJldlByb3AgfHwgaXNBbmltYXRpb25Db250cm9scyhwcm9wKSB8fCB0eXBlb2YgcHJvcCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YXJpYW50RGlkQ2hhbmdlID0gY2hlY2tWYXJpYW50c0RpZENoYW5nZSh0eXBlU3RhdGUucHJldlByb3AsIHByb3ApO1xuICAgICAgbGV0IHNob3VsZEFuaW1hdGVUeXBlID0gdmFyaWFudERpZENoYW5nZSB8fCB0eXBlID09PSBjaGFuZ2VkQWN0aXZlVHlwZSAmJiB0eXBlU3RhdGUuaXNBY3RpdmUgJiYgIWlzSW5oZXJpdGVkICYmIHByb3BJc1ZhcmlhbnQgfHwgaTIgPiByZW1vdmVkVmFyaWFudEluZGV4ICYmIHByb3BJc1ZhcmlhbnQ7XG4gICAgICBjb25zdCBkZWZpbml0aW9uTGlzdCA9IEFycmF5LmlzQXJyYXkocHJvcCkgPyBwcm9wIDogW3Byb3BdO1xuICAgICAgbGV0IHJlc29sdmVkVmFsdWVzID0gZGVmaW5pdGlvbkxpc3QucmVkdWNlKGJ1aWxkUmVzb2x2ZWRUeXBlVmFsdWVzLCB7fSk7XG4gICAgICBpZiAoYWN0aXZlRGVsdGEgPT09IGZhbHNlKVxuICAgICAgICByZXNvbHZlZFZhbHVlcyA9IHt9O1xuICAgICAgY29uc3QgeyBwcmV2UmVzb2x2ZWRWYWx1ZXMgPSB7fSB9ID0gdHlwZVN0YXRlO1xuICAgICAgY29uc3QgYWxsS2V5cyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcmV2UmVzb2x2ZWRWYWx1ZXMpLCByZXNvbHZlZFZhbHVlcyk7XG4gICAgICBjb25zdCBtYXJrVG9BbmltYXRlID0gKGtleSkgPT4ge1xuICAgICAgICBzaG91bGRBbmltYXRlVHlwZSA9IHRydWU7XG4gICAgICAgIHJlbW92ZWRLZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICB0eXBlU3RhdGUubmVlZHNBbmltYXRpbmdba2V5XSA9IHRydWU7XG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICBjb25zdCBuZXh0ID0gcmVzb2x2ZWRWYWx1ZXNba2V5XTtcbiAgICAgICAgY29uc3QgcHJldiA9IHByZXZSZXNvbHZlZFZhbHVlc1trZXldO1xuICAgICAgICBpZiAoZW5jb3VudGVyZWRLZXlzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChuZXh0ICE9PSBwcmV2KSB7XG4gICAgICAgICAgaWYgKGlzS2V5ZnJhbWVzVGFyZ2V0KG5leHQpICYmIGlzS2V5ZnJhbWVzVGFyZ2V0KHByZXYpKSB7XG4gICAgICAgICAgICBpZiAoIXNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpIHx8IHZhcmlhbnREaWRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgbWFya1RvQW5pbWF0ZShrZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlZEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5leHQgIT09IHZvaWQgMCAmJiByZW1vdmVkS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlU3RhdGUucHJvdGVjdGVkS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHlwZVN0YXRlLnByZXZQcm9wID0gcHJvcDtcbiAgICAgIHR5cGVTdGF0ZS5wcmV2UmVzb2x2ZWRWYWx1ZXMgPSByZXNvbHZlZFZhbHVlcztcbiAgICAgIGlmICh0eXBlU3RhdGUuaXNBY3RpdmUpIHtcbiAgICAgICAgZW5jb3VudGVyZWRLZXlzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGVuY291bnRlcmVkS2V5cyksIHJlc29sdmVkVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0luaXRpYWxSZW5kZXIgJiYgdmlzdWFsRWxlbWVudC5ibG9ja0luaXRpYWxBbmltYXRpb24pIHtcbiAgICAgICAgc2hvdWxkQW5pbWF0ZVR5cGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRBbmltYXRlVHlwZSAmJiAhaXNJbmhlcml0ZWQpIHtcbiAgICAgICAgYW5pbWF0aW9uczIucHVzaCguLi5kZWZpbml0aW9uTGlzdC5tYXAoKGFuaW1hdGlvbikgPT4gKHtcbiAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAgb3B0aW9uczogX19zcHJlYWRWYWx1ZXMoeyB0eXBlIH0sIG9wdGlvbnMpXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmVkS2V5cy5zaXplKSB7XG4gICAgICBjb25zdCBmYWxsYmFja0FuaW1hdGlvbiA9IHt9O1xuICAgICAgcmVtb3ZlZEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrVGFyZ2V0ID0gdmlzdWFsRWxlbWVudC5nZXRCYXNlVGFyZ2V0KGtleSk7XG4gICAgICAgIGlmIChmYWxsYmFja1RhcmdldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZmFsbGJhY2tBbmltYXRpb25ba2V5XSA9IGZhbGxiYWNrVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGFuaW1hdGlvbnMyLnB1c2goeyBhbmltYXRpb246IGZhbGxiYWNrQW5pbWF0aW9uIH0pO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkQW5pbWF0ZSA9IEJvb2xlYW4oYW5pbWF0aW9uczIubGVuZ3RoKTtcbiAgICBpZiAoaXNJbml0aWFsUmVuZGVyICYmIHByb3BzLmluaXRpYWwgPT09IGZhbHNlICYmICF2aXN1YWxFbGVtZW50Lm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQpIHtcbiAgICAgIHNob3VsZEFuaW1hdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaXNJbml0aWFsUmVuZGVyID0gZmFsc2U7XG4gICAgcmV0dXJuIHNob3VsZEFuaW1hdGUgPyBhbmltYXRlMyhhbmltYXRpb25zMikgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRBY3RpdmUodHlwZSwgaXNBY3RpdmUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHN0YXRlW3R5cGVdLmlzQWN0aXZlID09PSBpc0FjdGl2ZSlcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAoX2EgPSB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIChfYTIgPSBjaGlsZC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIuc2V0QWN0aXZlKHR5cGUsIGlzQWN0aXZlKTtcbiAgICB9KTtcbiAgICBzdGF0ZVt0eXBlXS5pc0FjdGl2ZSA9IGlzQWN0aXZlO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMyID0gYW5pbWF0ZUNoYW5nZXMob3B0aW9ucywgdHlwZSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3RhdGUpIHtcbiAgICAgIHN0YXRlW2tleV0ucHJvdGVjdGVkS2V5cyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9uczI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbmltYXRlQ2hhbmdlcyxcbiAgICBzZXRBY3RpdmUsXG4gICAgc2V0QW5pbWF0ZUZ1bmN0aW9uLFxuICAgIGdldFN0YXRlOiAoKSA9PiBzdGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gY2hlY2tWYXJpYW50c0RpZENoYW5nZShwcmV2LCBuZXh0KSB7XG4gIGlmICh0eXBlb2YgbmV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBuZXh0ICE9PSBwcmV2O1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICByZXR1cm4gIXNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVTdGF0ZShpc0FjdGl2ZSA9IGZhbHNlKSB7XG4gIHJldHVybiB7XG4gICAgaXNBY3RpdmUsXG4gICAgcHJvdGVjdGVkS2V5czoge30sXG4gICAgbmVlZHNBbmltYXRpbmc6IHt9LFxuICAgIHByZXZSZXNvbHZlZFZhbHVlczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIFtBbmltYXRpb25UeXBlLkFuaW1hdGVdOiBjcmVhdGVUeXBlU3RhdGUodHJ1ZSksXG4gICAgW0FuaW1hdGlvblR5cGUuSW5WaWV3XTogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgW0FuaW1hdGlvblR5cGUuSG92ZXJdOiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICBbQW5pbWF0aW9uVHlwZS5UYXBdOiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICBbQW5pbWF0aW9uVHlwZS5EcmFnXTogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgW0FuaW1hdGlvblR5cGUuRm9jdXNdOiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICBbQW5pbWF0aW9uVHlwZS5FeGl0XTogY3JlYXRlVHlwZVN0YXRlKClcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvYW5pbWF0aW9ucy5tanNcbnZhciBhbmltYXRpb25zID0ge1xuICBhbmltYXRpb246IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KCh7IHZpc3VhbEVsZW1lbnQsIGFuaW1hdGU6IGFuaW1hdGUzIH0pID0+IHtcbiAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlIHx8ICh2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlID0gY3JlYXRlQW5pbWF0aW9uU3RhdGUodmlzdWFsRWxlbWVudCkpO1xuICAgIGlmIChpc0FuaW1hdGlvbkNvbnRyb2xzKGFuaW1hdGUzKSkge1xuICAgICAgKDAsIGltcG9ydF9yZWFjdDIzLnVzZUVmZmVjdCkoKCkgPT4gYW5pbWF0ZTMuc3Vic2NyaWJlKHZpc3VhbEVsZW1lbnQpLCBbYW5pbWF0ZTNdKTtcbiAgICB9XG4gIH0pLFxuICBleGl0OiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCgocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGN1c3RvbSwgdmlzdWFsRWxlbWVudCB9ID0gcHJvcHM7XG4gICAgY29uc3QgW2lzUHJlc2VudCwgc2FmZVRvUmVtb3ZlXSA9IHVzZVByZXNlbmNlKCk7XG4gICAgY29uc3QgcHJlc2VuY2VDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDIzLnVzZUNvbnRleHQpKFByZXNlbmNlQ29udGV4dCk7XG4gICAgKDAsIGltcG9ydF9yZWFjdDIzLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgICAgdmlzdWFsRWxlbWVudC5pc1ByZXNlbnQgPSBpc1ByZXNlbnQ7XG4gICAgICBjb25zdCBhbmltYXRpb24gPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlICYmIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuRXhpdCwgIWlzUHJlc2VudCwge1xuICAgICAgICBjdXN0b206IHByZXNlbmNlQ29udGV4dCAmJiBwcmVzZW5jZUNvbnRleHQuY3VzdG9tIHx8IGN1c3RvbVxuICAgICAgfSk7XG4gICAgICBpZiAoYW5pbWF0aW9uICYmICFpc1ByZXNlbnQpIHtcbiAgICAgICAgYW5pbWF0aW9uLnRoZW4oc2FmZVRvUmVtb3ZlKTtcbiAgICAgIH1cbiAgICB9LCBbaXNQcmVzZW50XSk7XG4gIH0pXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2RyYWcvdXNlLWRyYWcubWpzXG52YXIgaW1wb3J0X3JlYWN0MjQgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvUGFuU2Vzc2lvbi5tanNcbnZhciBQYW5TZXNzaW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihldmVudCwgaGFuZGxlcnMsIHsgdHJhbnNmb3JtUGFnZVBvaW50IH0gPSB7fSkge1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XG4gICAgdGhpcy5sYXN0TW92ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gbnVsbDtcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy51cGRhdGVQb2ludCA9ICgpID0+IHtcbiAgICAgIGlmICghKHRoaXMubGFzdE1vdmVFdmVudCAmJiB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaW5mbzIgPSBnZXRQYW5JbmZvKHRoaXMubGFzdE1vdmVFdmVudEluZm8sIHRoaXMuaGlzdG9yeSk7XG4gICAgICBjb25zdCBpc1BhblN0YXJ0ZWQgPSB0aGlzLnN0YXJ0RXZlbnQgIT09IG51bGw7XG4gICAgICBjb25zdCBpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZCA9IGRpc3RhbmNlKGluZm8yLm9mZnNldCwgeyB4OiAwLCB5OiAwIH0pID49IDM7XG4gICAgICBpZiAoIWlzUGFuU3RhcnRlZCAmJiAhaXNEaXN0YW5jZVBhc3RUaHJlc2hvbGQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgcG9pbnQ6IHBvaW50MyB9ID0gaW5mbzI7XG4gICAgICBjb25zdCB7IHRpbWVzdGFtcDogdGltZXN0YW1wMiB9ID0gZ2V0RnJhbWVEYXRhKCk7XG4gICAgICB0aGlzLmhpc3RvcnkucHVzaChfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwb2ludDMpLCB7IHRpbWVzdGFtcDogdGltZXN0YW1wMiB9KSk7XG4gICAgICBjb25zdCB7IG9uU3RhcnQsIG9uTW92ZSB9ID0gdGhpcy5oYW5kbGVycztcbiAgICAgIGlmICghaXNQYW5TdGFydGVkKSB7XG4gICAgICAgIG9uU3RhcnQgJiYgb25TdGFydCh0aGlzLmxhc3RNb3ZlRXZlbnQsIGluZm8yKTtcbiAgICAgICAgdGhpcy5zdGFydEV2ZW50ID0gdGhpcy5sYXN0TW92ZUV2ZW50O1xuICAgICAgfVxuICAgICAgb25Nb3ZlICYmIG9uTW92ZSh0aGlzLmxhc3RNb3ZlRXZlbnQsIGluZm8yKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUgPSAoZXZlbnQyLCBpbmZvMikgPT4ge1xuICAgICAgdGhpcy5sYXN0TW92ZUV2ZW50ID0gZXZlbnQyO1xuICAgICAgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8yLCB0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50MikgJiYgZXZlbnQyLmJ1dHRvbnMgPT09IDApIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAoZXZlbnQyLCBpbmZvMik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVzX2RlZmF1bHQudXBkYXRlKHRoaXMudXBkYXRlUG9pbnQsIHRydWUpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSAoZXZlbnQyLCBpbmZvMikgPT4ge1xuICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIGNvbnN0IHsgb25FbmQsIG9uU2Vzc2lvbkVuZCB9ID0gdGhpcy5oYW5kbGVycztcbiAgICAgIGNvbnN0IHBhbkluZm8gPSBnZXRQYW5JbmZvKHRyYW5zZm9ybVBvaW50KGluZm8yLCB0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCksIHRoaXMuaGlzdG9yeSk7XG4gICAgICBpZiAodGhpcy5zdGFydEV2ZW50ICYmIG9uRW5kKSB7XG4gICAgICAgIG9uRW5kKGV2ZW50MiwgcGFuSW5mbyk7XG4gICAgICB9XG4gICAgICBvblNlc3Npb25FbmQgJiYgb25TZXNzaW9uRW5kKGV2ZW50MiwgcGFuSW5mbyk7XG4gICAgfTtcbiAgICBpZiAoaXNUb3VjaEV2ZW50KGV2ZW50KSAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50ID0gdHJhbnNmb3JtUGFnZVBvaW50O1xuICAgIGNvbnN0IGluZm8gPSBleHRyYWN0RXZlbnRJbmZvKGV2ZW50KTtcbiAgICBjb25zdCBpbml0aWFsSW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICBjb25zdCB7IHBvaW50OiBwb2ludDIgfSA9IGluaXRpYWxJbmZvO1xuICAgIGNvbnN0IHsgdGltZXN0YW1wIH0gPSBnZXRGcmFtZURhdGEoKTtcbiAgICB0aGlzLmhpc3RvcnkgPSBbX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcG9pbnQyKSwgeyB0aW1lc3RhbXAgfSldO1xuICAgIGNvbnN0IHsgb25TZXNzaW9uU3RhcnQgfSA9IGhhbmRsZXJzO1xuICAgIG9uU2Vzc2lvblN0YXJ0ICYmIG9uU2Vzc2lvblN0YXJ0KGV2ZW50LCBnZXRQYW5JbmZvKGluaXRpYWxJbmZvLCB0aGlzLmhpc3RvcnkpKTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyA9IHBpcGUoYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVybW92ZVwiLCB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKSwgYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVydXBcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApLCBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApKTtcbiAgfVxuICB1cGRhdGVIYW5kbGVycyhoYW5kbGVycykge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgfVxuICBlbmQoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMgJiYgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBjYW5jZWxTeW5jLnVwZGF0ZSh0aGlzLnVwZGF0ZVBvaW50KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KGluZm8sIHRyYW5zZm9ybVBhZ2VQb2ludCkge1xuICByZXR1cm4gdHJhbnNmb3JtUGFnZVBvaW50ID8geyBwb2ludDogdHJhbnNmb3JtUGFnZVBvaW50KGluZm8ucG9pbnQpIH0gOiBpbmZvO1xufVxuZnVuY3Rpb24gc3VidHJhY3RQb2ludChhMiwgYjIpIHtcbiAgcmV0dXJuIHsgeDogYTIueCAtIGIyLngsIHk6IGEyLnkgLSBiMi55IH07XG59XG5mdW5jdGlvbiBnZXRQYW5JbmZvKHsgcG9pbnQ6IHBvaW50MiB9LCBoaXN0b3J5KSB7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IHBvaW50MixcbiAgICBkZWx0YTogc3VidHJhY3RQb2ludChwb2ludDIsIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgb2Zmc2V0OiBzdWJ0cmFjdFBvaW50KHBvaW50Miwgc3RhcnREZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgdmVsb2NpdHk6IGdldFZlbG9jaXR5MihoaXN0b3J5LCAwLjEpXG4gIH07XG59XG5mdW5jdGlvbiBzdGFydERldmljZVBvaW50KGhpc3RvcnkpIHtcbiAgcmV0dXJuIGhpc3RvcnlbMF07XG59XG5mdW5jdGlvbiBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSkge1xuICByZXR1cm4gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZ2V0VmVsb2NpdHkyKGhpc3RvcnksIHRpbWVEZWx0YSkge1xuICBpZiAoaGlzdG9yeS5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICB9XG4gIGxldCBpMiA9IGhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgbGV0IHRpbWVzdGFtcGVkUG9pbnQgPSBudWxsO1xuICBjb25zdCBsYXN0UG9pbnQgPSBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSk7XG4gIHdoaWxlIChpMiA+PSAwKSB7XG4gICAgdGltZXN0YW1wZWRQb2ludCA9IGhpc3RvcnlbaTJdO1xuICAgIGlmIChsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXAgPiBzZWNvbmRzVG9NaWxsaXNlY29uZHModGltZURlbHRhKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGkyLS07XG4gIH1cbiAgaWYgKCF0aW1lc3RhbXBlZFBvaW50KSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICB9XG4gIGNvbnN0IHRpbWUgPSAobGFzdFBvaW50LnRpbWVzdGFtcCAtIHRpbWVzdGFtcGVkUG9pbnQudGltZXN0YW1wKSAvIDFlMztcbiAgaWYgKHRpbWUgPT09IDApIHtcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgY29uc3QgY3VycmVudFZlbG9jaXR5ID0ge1xuICAgIHg6IChsYXN0UG9pbnQueCAtIHRpbWVzdGFtcGVkUG9pbnQueCkgLyB0aW1lLFxuICAgIHk6IChsYXN0UG9pbnQueSAtIHRpbWVzdGFtcGVkUG9pbnQueSkgLyB0aW1lXG4gIH07XG4gIGlmIChjdXJyZW50VmVsb2NpdHkueCA9PT0gSW5maW5pdHkpIHtcbiAgICBjdXJyZW50VmVsb2NpdHkueCA9IDA7XG4gIH1cbiAgaWYgKGN1cnJlbnRWZWxvY2l0eS55ID09PSBJbmZpbml0eSkge1xuICAgIGN1cnJlbnRWZWxvY2l0eS55ID0gMDtcbiAgfVxuICByZXR1cm4gY3VycmVudFZlbG9jaXR5O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvZGVsdGEtY2FsYy5tanNcbmZ1bmN0aW9uIGNhbGNMZW5ndGgoYXhpcykge1xuICByZXR1cm4gYXhpcy5tYXggLSBheGlzLm1pbjtcbn1cbmZ1bmN0aW9uIGlzTmVhcih2YWx1ZSwgdGFyZ2V0ID0gMCwgbWF4RGlzdGFuY2UgPSAwLjAxKSB7XG4gIHJldHVybiBkaXN0YW5jZSh2YWx1ZSwgdGFyZ2V0KSA8IG1heERpc3RhbmNlO1xufVxuZnVuY3Rpb24gY2FsY0F4aXNEZWx0YShkZWx0YSwgc291cmNlLCB0YXJnZXQsIG9yaWdpbiA9IDAuNSkge1xuICBkZWx0YS5vcmlnaW4gPSBvcmlnaW47XG4gIGRlbHRhLm9yaWdpblBvaW50ID0gbWl4KHNvdXJjZS5taW4sIHNvdXJjZS5tYXgsIGRlbHRhLm9yaWdpbik7XG4gIGRlbHRhLnNjYWxlID0gY2FsY0xlbmd0aCh0YXJnZXQpIC8gY2FsY0xlbmd0aChzb3VyY2UpO1xuICBpZiAoaXNOZWFyKGRlbHRhLnNjYWxlLCAxLCAxZS00KSB8fCBpc05hTihkZWx0YS5zY2FsZSkpXG4gICAgZGVsdGEuc2NhbGUgPSAxO1xuICBkZWx0YS50cmFuc2xhdGUgPSBtaXgodGFyZ2V0Lm1pbiwgdGFyZ2V0Lm1heCwgZGVsdGEub3JpZ2luKSAtIGRlbHRhLm9yaWdpblBvaW50O1xuICBpZiAoaXNOZWFyKGRlbHRhLnRyYW5zbGF0ZSkgfHwgaXNOYU4oZGVsdGEudHJhbnNsYXRlKSlcbiAgICBkZWx0YS50cmFuc2xhdGUgPSAwO1xufVxuZnVuY3Rpb24gY2FsY0JveERlbHRhKGRlbHRhLCBzb3VyY2UsIHRhcmdldCwgb3JpZ2luKSB7XG4gIGNhbGNBeGlzRGVsdGEoZGVsdGEueCwgc291cmNlLngsIHRhcmdldC54LCBvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW4ub3JpZ2luWCk7XG4gIGNhbGNBeGlzRGVsdGEoZGVsdGEueSwgc291cmNlLnksIHRhcmdldC55LCBvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW4ub3JpZ2luWSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldCwgcmVsYXRpdmUsIHBhcmVudCkge1xuICB0YXJnZXQubWluID0gcGFyZW50Lm1pbiArIHJlbGF0aXZlLm1pbjtcbiAgdGFyZ2V0Lm1heCA9IHRhcmdldC5taW4gKyBjYWxjTGVuZ3RoKHJlbGF0aXZlKTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUJveCh0YXJnZXQsIHJlbGF0aXZlLCBwYXJlbnQpIHtcbiAgY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQueCwgcmVsYXRpdmUueCwgcGFyZW50LngpO1xuICBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldC55LCByZWxhdGl2ZS55LCBwYXJlbnQueSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24odGFyZ2V0LCBsYXlvdXQsIHBhcmVudCkge1xuICB0YXJnZXQubWluID0gbGF5b3V0Lm1pbiAtIHBhcmVudC5taW47XG4gIHRhcmdldC5tYXggPSB0YXJnZXQubWluICsgY2FsY0xlbmd0aChsYXlvdXQpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlUG9zaXRpb24odGFyZ2V0LCBsYXlvdXQsIHBhcmVudCkge1xuICBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24odGFyZ2V0LngsIGxheW91dC54LCBwYXJlbnQueCk7XG4gIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQueSwgbGF5b3V0LnksIHBhcmVudC55KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3V0aWxzL2NvbnN0cmFpbnRzLm1qc1xuZnVuY3Rpb24gYXBwbHlDb25zdHJhaW50cyhwb2ludDIsIHsgbWluLCBtYXggfSwgZWxhc3RpYykge1xuICBpZiAobWluICE9PSB2b2lkIDAgJiYgcG9pbnQyIDwgbWluKSB7XG4gICAgcG9pbnQyID0gZWxhc3RpYyA/IG1peChtaW4sIHBvaW50MiwgZWxhc3RpYy5taW4pIDogTWF0aC5tYXgocG9pbnQyLCBtaW4pO1xuICB9IGVsc2UgaWYgKG1heCAhPT0gdm9pZCAwICYmIHBvaW50MiA+IG1heCkge1xuICAgIHBvaW50MiA9IGVsYXN0aWMgPyBtaXgobWF4LCBwb2ludDIsIGVsYXN0aWMubWF4KSA6IE1hdGgubWluKHBvaW50MiwgbWF4KTtcbiAgfVxuICByZXR1cm4gcG9pbnQyO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGF4aXMsIG1pbiwgbWF4KSB7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4gIT09IHZvaWQgMCA/IGF4aXMubWluICsgbWluIDogdm9pZCAwLFxuICAgIG1heDogbWF4ICE9PSB2b2lkIDAgPyBheGlzLm1heCArIG1heCAtIChheGlzLm1heCAtIGF4aXMubWluKSA6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQ29uc3RyYWludHMobGF5b3V0Qm94LCB7IHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCB9KSB7XG4gIHJldHVybiB7XG4gICAgeDogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC54LCBsZWZ0LCByaWdodCksXG4gICAgeTogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC55LCB0b3AsIGJvdHRvbSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRBeGlzLCBjb25zdHJhaW50c0F4aXMpIHtcbiAgbGV0IG1pbiA9IGNvbnN0cmFpbnRzQXhpcy5taW4gLSBsYXlvdXRBeGlzLm1pbjtcbiAgbGV0IG1heCA9IGNvbnN0cmFpbnRzQXhpcy5tYXggLSBsYXlvdXRBeGlzLm1heDtcbiAgaWYgKGNvbnN0cmFpbnRzQXhpcy5tYXggLSBjb25zdHJhaW50c0F4aXMubWluIDwgbGF5b3V0QXhpcy5tYXggLSBsYXlvdXRBeGlzLm1pbikge1xuICAgIFttaW4sIG1heF0gPSBbbWF4LCBtaW5dO1xuICB9XG4gIHJldHVybiB7IG1pbiwgbWF4IH07XG59XG5mdW5jdGlvbiBjYWxjVmlld3BvcnRDb25zdHJhaW50cyhsYXlvdXRCb3gsIGNvbnN0cmFpbnRzQm94KSB7XG4gIHJldHVybiB7XG4gICAgeDogY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC54LCBjb25zdHJhaW50c0JveC54KSxcbiAgICB5OiBjYWxjVmlld3BvcnRBeGlzQ29uc3RyYWludHMobGF5b3V0Qm94LnksIGNvbnN0cmFpbnRzQm94LnkpXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjT3JpZ2luMihzb3VyY2UsIHRhcmdldCkge1xuICBsZXQgb3JpZ2luID0gMC41O1xuICBjb25zdCBzb3VyY2VMZW5ndGggPSBjYWxjTGVuZ3RoKHNvdXJjZSk7XG4gIGNvbnN0IHRhcmdldExlbmd0aCA9IGNhbGNMZW5ndGgodGFyZ2V0KTtcbiAgaWYgKHRhcmdldExlbmd0aCA+IHNvdXJjZUxlbmd0aCkge1xuICAgIG9yaWdpbiA9IHByb2dyZXNzKHRhcmdldC5taW4sIHRhcmdldC5tYXggLSBzb3VyY2VMZW5ndGgsIHNvdXJjZS5taW4pO1xuICB9IGVsc2UgaWYgKHNvdXJjZUxlbmd0aCA+IHRhcmdldExlbmd0aCkge1xuICAgIG9yaWdpbiA9IHByb2dyZXNzKHNvdXJjZS5taW4sIHNvdXJjZS5tYXggLSB0YXJnZXRMZW5ndGgsIHRhcmdldC5taW4pO1xuICB9XG4gIHJldHVybiBjbGFtcDIoMCwgMSwgb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHJlYmFzZUF4aXNDb25zdHJhaW50cyhsYXlvdXQsIGNvbnN0cmFpbnRzKSB7XG4gIGNvbnN0IHJlbGF0aXZlQ29uc3RyYWludHMgPSB7fTtcbiAgaWYgKGNvbnN0cmFpbnRzLm1pbiAhPT0gdm9pZCAwKSB7XG4gICAgcmVsYXRpdmVDb25zdHJhaW50cy5taW4gPSBjb25zdHJhaW50cy5taW4gLSBsYXlvdXQubWluO1xuICB9XG4gIGlmIChjb25zdHJhaW50cy5tYXggIT09IHZvaWQgMCkge1xuICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWF4ID0gY29uc3RyYWludHMubWF4IC0gbGF5b3V0Lm1pbjtcbiAgfVxuICByZXR1cm4gcmVsYXRpdmVDb25zdHJhaW50cztcbn1cbnZhciBkZWZhdWx0RWxhc3RpYyA9IDAuMzU7XG5mdW5jdGlvbiByZXNvbHZlRHJhZ0VsYXN0aWMoZHJhZ0VsYXN0aWMgPSBkZWZhdWx0RWxhc3RpYykge1xuICBpZiAoZHJhZ0VsYXN0aWMgPT09IGZhbHNlKSB7XG4gICAgZHJhZ0VsYXN0aWMgPSAwO1xuICB9IGVsc2UgaWYgKGRyYWdFbGFzdGljID09PSB0cnVlKSB7XG4gICAgZHJhZ0VsYXN0aWMgPSBkZWZhdWx0RWxhc3RpYztcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgXCJsZWZ0XCIsIFwicmlnaHRcIiksXG4gICAgeTogcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBcInRvcFwiLCBcImJvdHRvbVwiKVxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBtaW5MYWJlbCwgbWF4TGFiZWwpIHtcbiAgcmV0dXJuIHtcbiAgICBtaW46IHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIG1pbkxhYmVsKSxcbiAgICBtYXg6IHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIG1heExhYmVsKVxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbGFiZWwpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gdHlwZW9mIGRyYWdFbGFzdGljID09PSBcIm51bWJlclwiID8gZHJhZ0VsYXN0aWMgOiAoX2EgPSBkcmFnRWxhc3RpY1tsYWJlbF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9tb2RlbHMubWpzXG52YXIgY3JlYXRlQXhpc0RlbHRhID0gKCkgPT4gKHtcbiAgdHJhbnNsYXRlOiAwLFxuICBzY2FsZTogMSxcbiAgb3JpZ2luOiAwLFxuICBvcmlnaW5Qb2ludDogMFxufSk7XG52YXIgY3JlYXRlRGVsdGEgPSAoKSA9PiAoe1xuICB4OiBjcmVhdGVBeGlzRGVsdGEoKSxcbiAgeTogY3JlYXRlQXhpc0RlbHRhKClcbn0pO1xudmFyIGNyZWF0ZUF4aXMgPSAoKSA9PiAoeyBtaW46IDAsIG1heDogMCB9KTtcbnZhciBjcmVhdGVCb3ggPSAoKSA9PiAoe1xuICB4OiBjcmVhdGVBeGlzKCksXG4gIHk6IGNyZWF0ZUF4aXMoKVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi91dGlscy9lYWNoLWF4aXMubWpzXG5mdW5jdGlvbiBlYWNoQXhpcyhjYWxsYmFjaykge1xuICByZXR1cm4gW2NhbGxiYWNrKFwieFwiKSwgY2FsbGJhY2soXCJ5XCIpXTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2NvbnZlcnNpb24ubWpzXG5mdW5jdGlvbiBjb252ZXJ0Qm91bmRpbmdCb3hUb0JveCh7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSB9KSB7XG4gIHJldHVybiB7XG4gICAgeDogeyBtaW46IGxlZnQsIG1heDogcmlnaHQgfSxcbiAgICB5OiB7IG1pbjogdG9wLCBtYXg6IGJvdHRvbSB9XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveCh7IHgsIHkgfSkge1xuICByZXR1cm4geyB0b3A6IHkubWluLCByaWdodDogeC5tYXgsIGJvdHRvbTogeS5tYXgsIGxlZnQ6IHgubWluIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1Cb3hQb2ludHMocG9pbnQyLCB0cmFuc2Zvcm1Qb2ludDIpIHtcbiAgaWYgKCF0cmFuc2Zvcm1Qb2ludDIpXG4gICAgcmV0dXJuIHBvaW50MjtcbiAgY29uc3QgdG9wTGVmdCA9IHRyYW5zZm9ybVBvaW50Mih7IHg6IHBvaW50Mi5sZWZ0LCB5OiBwb2ludDIudG9wIH0pO1xuICBjb25zdCBib3R0b21SaWdodCA9IHRyYW5zZm9ybVBvaW50Mih7IHg6IHBvaW50Mi5yaWdodCwgeTogcG9pbnQyLmJvdHRvbSB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHRvcExlZnQueSxcbiAgICBsZWZ0OiB0b3BMZWZ0LngsXG4gICAgYm90dG9tOiBib3R0b21SaWdodC55LFxuICAgIHJpZ2h0OiBib3R0b21SaWdodC54XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi91dGlscy9oYXMtdHJhbnNmb3JtLm1qc1xuZnVuY3Rpb24gaXNJZGVudGl0eVNjYWxlKHNjYWxlMikge1xuICByZXR1cm4gc2NhbGUyID09PSB2b2lkIDAgfHwgc2NhbGUyID09PSAxO1xufVxuZnVuY3Rpb24gaGFzU2NhbGUoeyBzY2FsZTogc2NhbGUyLCBzY2FsZVgsIHNjYWxlWSB9KSB7XG4gIHJldHVybiAhaXNJZGVudGl0eVNjYWxlKHNjYWxlMikgfHwgIWlzSWRlbnRpdHlTY2FsZShzY2FsZVgpIHx8ICFpc0lkZW50aXR5U2NhbGUoc2NhbGVZKTtcbn1cbmZ1bmN0aW9uIGhhc1RyYW5zZm9ybSh2YWx1ZXMpIHtcbiAgcmV0dXJuIGhhc1NjYWxlKHZhbHVlcykgfHwgaGFzMkRUcmFuc2xhdGUodmFsdWVzKSB8fCB2YWx1ZXMueiB8fCB2YWx1ZXMucm90YXRlIHx8IHZhbHVlcy5yb3RhdGVYIHx8IHZhbHVlcy5yb3RhdGVZO1xufVxuZnVuY3Rpb24gaGFzMkRUcmFuc2xhdGUodmFsdWVzKSB7XG4gIHJldHVybiBpczJEVHJhbnNsYXRlKHZhbHVlcy54KSB8fCBpczJEVHJhbnNsYXRlKHZhbHVlcy55KTtcbn1cbmZ1bmN0aW9uIGlzMkRUcmFuc2xhdGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlICE9PSBcIjAlXCI7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9kZWx0YS1hcHBseS5tanNcbmZ1bmN0aW9uIHNjYWxlUG9pbnQocG9pbnQyLCBzY2FsZTIsIG9yaWdpblBvaW50KSB7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbU9yaWdpbiA9IHBvaW50MiAtIG9yaWdpblBvaW50O1xuICBjb25zdCBzY2FsZWQgPSBzY2FsZTIgKiBkaXN0YW5jZUZyb21PcmlnaW47XG4gIHJldHVybiBvcmlnaW5Qb2ludCArIHNjYWxlZDtcbn1cbmZ1bmN0aW9uIGFwcGx5UG9pbnREZWx0YShwb2ludDIsIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgaWYgKGJveFNjYWxlICE9PSB2b2lkIDApIHtcbiAgICBwb2ludDIgPSBzY2FsZVBvaW50KHBvaW50MiwgYm94U2NhbGUsIG9yaWdpblBvaW50KTtcbiAgfVxuICByZXR1cm4gc2NhbGVQb2ludChwb2ludDIsIHNjYWxlMiwgb3JpZ2luUG9pbnQpICsgdHJhbnNsYXRlO1xufVxuZnVuY3Rpb24gYXBwbHlBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlID0gMCwgc2NhbGUyID0gMSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKSB7XG4gIGF4aXMubWluID0gYXBwbHlQb2ludERlbHRhKGF4aXMubWluLCB0cmFuc2xhdGUsIHNjYWxlMiwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbiAgYXhpcy5tYXggPSBhcHBseVBvaW50RGVsdGEoYXhpcy5tYXgsIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xufVxuZnVuY3Rpb24gYXBwbHlCb3hEZWx0YShib3gsIHsgeCwgeSB9KSB7XG4gIGFwcGx5QXhpc0RlbHRhKGJveC54LCB4LnRyYW5zbGF0ZSwgeC5zY2FsZSwgeC5vcmlnaW5Qb2ludCk7XG4gIGFwcGx5QXhpc0RlbHRhKGJveC55LCB5LnRyYW5zbGF0ZSwgeS5zY2FsZSwgeS5vcmlnaW5Qb2ludCk7XG59XG5mdW5jdGlvbiBhcHBseVRyZWVEZWx0YXMoYm94LCB0cmVlU2NhbGUsIHRyZWVQYXRoLCBpc1NoYXJlZFRyYW5zaXRpb24gPSBmYWxzZSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB0cmVlTGVuZ3RoID0gdHJlZVBhdGgubGVuZ3RoO1xuICBpZiAoIXRyZWVMZW5ndGgpXG4gICAgcmV0dXJuO1xuICB0cmVlU2NhbGUueCA9IHRyZWVTY2FsZS55ID0gMTtcbiAgbGV0IG5vZGU7XG4gIGxldCBkZWx0YTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRyZWVMZW5ndGg7IGkyKyspIHtcbiAgICBub2RlID0gdHJlZVBhdGhbaTJdO1xuICAgIGRlbHRhID0gbm9kZS5wcm9qZWN0aW9uRGVsdGE7XG4gICAgaWYgKCgoX2IgPSAoX2EgPSBub2RlLmluc3RhbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3R5bGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNwbGF5KSA9PT0gXCJjb250ZW50c1wiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGlzU2hhcmVkVHJhbnNpdGlvbiAmJiBub2RlLm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmIG5vZGUuc2Nyb2xsICYmIG5vZGUgIT09IG5vZGUucm9vdCkge1xuICAgICAgdHJhbnNmb3JtQm94KGJveCwgeyB4OiAtbm9kZS5zY3JvbGwueCwgeTogLW5vZGUuc2Nyb2xsLnkgfSk7XG4gICAgfVxuICAgIGlmIChkZWx0YSkge1xuICAgICAgdHJlZVNjYWxlLnggKj0gZGVsdGEueC5zY2FsZTtcbiAgICAgIHRyZWVTY2FsZS55ICo9IGRlbHRhLnkuc2NhbGU7XG4gICAgICBhcHBseUJveERlbHRhKGJveCwgZGVsdGEpO1xuICAgIH1cbiAgICBpZiAoaXNTaGFyZWRUcmFuc2l0aW9uICYmIGhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgIHRyYW5zZm9ybUJveChib3gsIG5vZGUubGF0ZXN0VmFsdWVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZUF4aXMoYXhpcywgZGlzdGFuY2UyKSB7XG4gIGF4aXMubWluID0gYXhpcy5taW4gKyBkaXN0YW5jZTI7XG4gIGF4aXMubWF4ID0gYXhpcy5tYXggKyBkaXN0YW5jZTI7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1BeGlzKGF4aXMsIHRyYW5zZm9ybXMsIFtrZXksIHNjYWxlS2V5LCBvcmlnaW5LZXldKSB7XG4gIGNvbnN0IGF4aXNPcmlnaW4gPSB0cmFuc2Zvcm1zW29yaWdpbktleV0gIT09IHZvaWQgMCA/IHRyYW5zZm9ybXNbb3JpZ2luS2V5XSA6IDAuNTtcbiAgY29uc3Qgb3JpZ2luUG9pbnQgPSBtaXgoYXhpcy5taW4sIGF4aXMubWF4LCBheGlzT3JpZ2luKTtcbiAgYXBwbHlBeGlzRGVsdGEoYXhpcywgdHJhbnNmb3Jtc1trZXldLCB0cmFuc2Zvcm1zW3NjYWxlS2V5XSwgb3JpZ2luUG9pbnQsIHRyYW5zZm9ybXMuc2NhbGUpO1xufVxudmFyIHhLZXlzID0gW1wieFwiLCBcInNjYWxlWFwiLCBcIm9yaWdpblhcIl07XG52YXIgeUtleXMgPSBbXCJ5XCIsIFwic2NhbGVZXCIsIFwib3JpZ2luWVwiXTtcbmZ1bmN0aW9uIHRyYW5zZm9ybUJveChib3gsIHRyYW5zZm9ybSkge1xuICB0cmFuc2Zvcm1BeGlzKGJveC54LCB0cmFuc2Zvcm0sIHhLZXlzKTtcbiAgdHJhbnNmb3JtQXhpcyhib3gueSwgdHJhbnNmb3JtLCB5S2V5cyk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi91dGlscy9tZWFzdXJlLm1qc1xuZnVuY3Rpb24gbWVhc3VyZVZpZXdwb3J0Qm94KGluc3RhbmNlLCB0cmFuc2Zvcm1Qb2ludDIpIHtcbiAgcmV0dXJuIGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHRyYW5zZm9ybUJveFBvaW50cyhpbnN0YW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJhbnNmb3JtUG9pbnQyKSk7XG59XG5mdW5jdGlvbiBtZWFzdXJlUGFnZUJveChlbGVtZW50LCByb290UHJvamVjdGlvbk5vZGUyLCB0cmFuc2Zvcm1QYWdlUG9pbnQpIHtcbiAgY29uc3Qgdmlld3BvcnRCb3ggPSBtZWFzdXJlVmlld3BvcnRCb3goZWxlbWVudCwgdHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgY29uc3QgeyBzY3JvbGw6IHNjcm9sbDIgfSA9IHJvb3RQcm9qZWN0aW9uTm9kZTI7XG4gIGlmIChzY3JvbGwyKSB7XG4gICAgdHJhbnNsYXRlQXhpcyh2aWV3cG9ydEJveC54LCBzY3JvbGwyLngpO1xuICAgIHRyYW5zbGF0ZUF4aXModmlld3BvcnRCb3gueSwgc2Nyb2xsMi55KTtcbiAgfVxuICByZXR1cm4gdmlld3BvcnRCb3g7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy9WaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLm1qc1xudmFyIGVsZW1lbnREcmFnQ29udHJvbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2aXN1YWxFbGVtZW50KSB7XG4gICAgdGhpcy5vcGVuR2xvYmFsTG9jayA9IG51bGw7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgdGhpcy5jb25zdHJhaW50cyA9IGZhbHNlO1xuICAgIHRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgdGhpcy5lbGFzdGljID0gY3JlYXRlQm94KCk7XG4gICAgdGhpcy52aXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudDtcbiAgfVxuICBzdGFydChvcmlnaW5FdmVudCwgeyBzbmFwVG9DdXJzb3IgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy52aXN1YWxFbGVtZW50LmlzUHJlc2VudCA9PT0gZmFsc2UpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb25TZXNzaW9uU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgaWYgKHNuYXBUb0N1cnNvcikge1xuICAgICAgICB0aGlzLnNuYXBUb0N1cnNvcihleHRyYWN0RXZlbnRJbmZvKGV2ZW50LCBcInBhZ2VcIikucG9pbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25TdGFydCA9IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBkcmFnOiBkcmFnMiwgZHJhZ1Byb3BhZ2F0aW9uLCBvbkRyYWdTdGFydCB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgaWYgKGRyYWcyICYmICFkcmFnUHJvcGFnYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMub3Blbkdsb2JhbExvY2spXG4gICAgICAgICAgdGhpcy5vcGVuR2xvYmFsTG9jaygpO1xuICAgICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrID0gZ2V0R2xvYmFsTG9jayhkcmFnMik7XG4gICAgICAgIGlmICghdGhpcy5vcGVuR2xvYmFsTG9jaylcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMucmVzb2x2ZUNvbnN0cmFpbnRzKCk7XG4gICAgICBpZiAodGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24pIHtcbiAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24uaXNBbmltYXRpb25CbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24udGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuZ2V0KCkgfHwgMDtcbiAgICAgICAgaWYgKHBlcmNlbnQudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVkQXhpcyA9IChfYiA9IChfYTIgPSB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIubGF5b3V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICAgIGlmIChtZWFzdXJlZEF4aXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGNhbGNMZW5ndGgobWVhc3VyZWRBeGlzKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBsZW5ndGggKiAocGFyc2VGbG9hdChjdXJyZW50KSAvIDEwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3JpZ2luUG9pbnRbYXhpc10gPSBjdXJyZW50O1xuICAgICAgfSk7XG4gICAgICBvbkRyYWdTdGFydCA9PT0gbnVsbCB8fCBvbkRyYWdTdGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnU3RhcnQoZXZlbnQsIGluZm8pO1xuICAgICAgKF9hID0gdGhpcy52aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuRHJhZywgdHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdmUgPSAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgIGNvbnN0IHsgZHJhZ1Byb3BhZ2F0aW9uLCBkcmFnRGlyZWN0aW9uTG9jaywgb25EaXJlY3Rpb25Mb2NrLCBvbkRyYWcgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgIGlmICghZHJhZ1Byb3BhZ2F0aW9uICYmICF0aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IG9mZnNldCB9ID0gaW5mbztcbiAgICAgIGlmIChkcmFnRGlyZWN0aW9uTG9jayAmJiB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gZ2V0Q3VycmVudERpcmVjdGlvbihvZmZzZXQpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50RGlyZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgb25EaXJlY3Rpb25Mb2NrID09PSBudWxsIHx8IG9uRGlyZWN0aW9uTG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EaXJlY3Rpb25Mb2NrKHRoaXMuY3VycmVudERpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVBeGlzKFwieFwiLCBpbmZvLnBvaW50LCBvZmZzZXQpO1xuICAgICAgdGhpcy51cGRhdGVBeGlzKFwieVwiLCBpbmZvLnBvaW50LCBvZmZzZXQpO1xuICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnJlbmRlcigpO1xuICAgICAgb25EcmFnID09PSBudWxsIHx8IG9uRHJhZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnKGV2ZW50LCBpbmZvKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uU2Vzc2lvbkVuZCA9IChldmVudCwgaW5mbykgPT4gdGhpcy5zdG9wKGV2ZW50LCBpbmZvKTtcbiAgICB0aGlzLnBhblNlc3Npb24gPSBuZXcgUGFuU2Vzc2lvbihvcmlnaW5FdmVudCwge1xuICAgICAgb25TZXNzaW9uU3RhcnQsXG4gICAgICBvblN0YXJ0LFxuICAgICAgb25Nb3ZlLFxuICAgICAgb25TZXNzaW9uRW5kXG4gICAgfSwgeyB0cmFuc2Zvcm1QYWdlUG9pbnQ6IHRoaXMudmlzdWFsRWxlbWVudC5nZXRUcmFuc2Zvcm1QYWdlUG9pbnQoKSB9KTtcbiAgfVxuICBzdG9wKGV2ZW50LCBpbmZvKSB7XG4gICAgY29uc3QgaXNEcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZztcbiAgICB0aGlzLmNhbmNlbCgpO1xuICAgIGlmICghaXNEcmFnZ2luZylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHZlbG9jaXR5IH0gPSBpbmZvO1xuICAgIHRoaXMuc3RhcnRBbmltYXRpb24odmVsb2NpdHkpO1xuICAgIGNvbnN0IHsgb25EcmFnRW5kIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgb25EcmFnRW5kID09PSBudWxsIHx8IG9uRHJhZ0VuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnRW5kKGV2ZW50LCBpbmZvKTtcbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24pIHtcbiAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLmlzQW5pbWF0aW9uQmxvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLnBhblNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmQoKTtcbiAgICB0aGlzLnBhblNlc3Npb24gPSB2b2lkIDA7XG4gICAgY29uc3QgeyBkcmFnUHJvcGFnYXRpb24gfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICBpZiAoIWRyYWdQcm9wYWdhdGlvbiAmJiB0aGlzLm9wZW5HbG9iYWxMb2NrKSB7XG4gICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrKCk7XG4gICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrID0gbnVsbDtcbiAgICB9XG4gICAgKF9iID0gdGhpcy52aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuRHJhZywgZmFsc2UpO1xuICB9XG4gIHVwZGF0ZUF4aXMoYXhpcywgX3BvaW50LCBvZmZzZXQpIHtcbiAgICBjb25zdCB7IGRyYWc6IGRyYWcyIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgaWYgKCFvZmZzZXQgfHwgIXNob3VsZERyYWcoYXhpcywgZHJhZzIsIHRoaXMuY3VycmVudERpcmVjdGlvbikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgbGV0IG5leHQgPSB0aGlzLm9yaWdpblBvaW50W2F4aXNdICsgb2Zmc2V0W2F4aXNdO1xuICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzICYmIHRoaXMuY29uc3RyYWludHNbYXhpc10pIHtcbiAgICAgIG5leHQgPSBhcHBseUNvbnN0cmFpbnRzKG5leHQsIHRoaXMuY29uc3RyYWludHNbYXhpc10sIHRoaXMuZWxhc3RpY1theGlzXSk7XG4gICAgfVxuICAgIGF4aXNWYWx1ZS5zZXQobmV4dCk7XG4gIH1cbiAgcmVzb2x2ZUNvbnN0cmFpbnRzKCkge1xuICAgIGNvbnN0IHsgZHJhZ0NvbnN0cmFpbnRzLCBkcmFnRWxhc3RpYyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgIGNvbnN0IHsgbGF5b3V0IH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbiB8fCB7fTtcbiAgICBjb25zdCBwcmV2Q29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgIGlmIChkcmFnQ29uc3RyYWludHMgJiYgaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSkge1xuICAgICAgaWYgKCF0aGlzLmNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSB0aGlzLnJlc29sdmVSZWZDb25zdHJhaW50cygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHJhZ0NvbnN0cmFpbnRzICYmIGxheW91dCkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gY2FsY1JlbGF0aXZlQ29uc3RyYWludHMobGF5b3V0LmxheW91dEJveCwgZHJhZ0NvbnN0cmFpbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbGFzdGljID0gcmVzb2x2ZURyYWdFbGFzdGljKGRyYWdFbGFzdGljKTtcbiAgICBpZiAocHJldkNvbnN0cmFpbnRzICE9PSB0aGlzLmNvbnN0cmFpbnRzICYmIGxheW91dCAmJiB0aGlzLmNvbnN0cmFpbnRzICYmICF0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cykge1xuICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJhaW50c1theGlzXSA9IHJlYmFzZUF4aXNDb25zdHJhaW50cyhsYXlvdXQubGF5b3V0Qm94W2F4aXNdLCB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlc29sdmVSZWZDb25zdHJhaW50cygpIHtcbiAgICBjb25zdCB7IGRyYWdDb25zdHJhaW50czogY29uc3RyYWludHMsIG9uTWVhc3VyZURyYWdDb25zdHJhaW50cyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgIGlmICghY29uc3RyYWludHMgfHwgIWlzUmVmT2JqZWN0KGNvbnN0cmFpbnRzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBjb25zdHJhaW50c0VsZW1lbnQgPSBjb25zdHJhaW50cy5jdXJyZW50O1xuICAgIGludmFyaWFudChjb25zdHJhaW50c0VsZW1lbnQgIT09IG51bGwsIFwiSWYgYGRyYWdDb25zdHJhaW50c2AgaXMgc2V0IGFzIGEgUmVhY3QgcmVmLCB0aGF0IHJlZiBtdXN0IGJlIHBhc3NlZCB0byBhbm90aGVyIGNvbXBvbmVudCdzIGByZWZgIHByb3AuXCIpO1xuICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgIGlmICghcHJvamVjdGlvbiB8fCAhcHJvamVjdGlvbi5sYXlvdXQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY29uc3RyYWludHNCb3ggPSBtZWFzdXJlUGFnZUJveChjb25zdHJhaW50c0VsZW1lbnQsIHByb2plY3Rpb24ucm9vdCwgdGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpKTtcbiAgICBsZXQgbWVhc3VyZWRDb25zdHJhaW50cyA9IGNhbGNWaWV3cG9ydENvbnN0cmFpbnRzKHByb2plY3Rpb24ubGF5b3V0LmxheW91dEJveCwgY29uc3RyYWludHNCb3gpO1xuICAgIGlmIChvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMpIHtcbiAgICAgIGNvbnN0IHVzZXJDb25zdHJhaW50cyA9IG9uTWVhc3VyZURyYWdDb25zdHJhaW50cyhjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveChtZWFzdXJlZENvbnN0cmFpbnRzKSk7XG4gICAgICB0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cyA9ICEhdXNlckNvbnN0cmFpbnRzO1xuICAgICAgaWYgKHVzZXJDb25zdHJhaW50cykge1xuICAgICAgICBtZWFzdXJlZENvbnN0cmFpbnRzID0gY29udmVydEJvdW5kaW5nQm94VG9Cb3godXNlckNvbnN0cmFpbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lYXN1cmVkQ29uc3RyYWludHM7XG4gIH1cbiAgc3RhcnRBbmltYXRpb24odmVsb2NpdHkpIHtcbiAgICBjb25zdCB7IGRyYWc6IGRyYWcyLCBkcmFnTW9tZW50dW0sIGRyYWdFbGFzdGljLCBkcmFnVHJhbnNpdGlvbiwgZHJhZ1NuYXBUb09yaWdpbiwgb25EcmFnVHJhbnNpdGlvbkVuZCB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyB8fCB7fTtcbiAgICBjb25zdCBtb21lbnR1bUFuaW1hdGlvbnMgPSBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcyLCB0aGlzLmN1cnJlbnREaXJlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0cmFuc2l0aW9uID0gKF9hID0gY29uc3RyYWludHMgPT09IG51bGwgfHwgY29uc3RyYWludHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnN0cmFpbnRzW2F4aXNdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgIGlmIChkcmFnU25hcFRvT3JpZ2luKVxuICAgICAgICB0cmFuc2l0aW9uID0geyBtaW46IDAsIG1heDogMCB9O1xuICAgICAgY29uc3QgYm91bmNlU3RpZmZuZXNzID0gZHJhZ0VsYXN0aWMgPyAyMDAgOiAxZTY7XG4gICAgICBjb25zdCBib3VuY2VEYW1waW5nID0gZHJhZ0VsYXN0aWMgPyA0MCA6IDFlNztcbiAgICAgIGNvbnN0IGluZXJ0aWEyID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICB0eXBlOiBcImluZXJ0aWFcIixcbiAgICAgICAgdmVsb2NpdHk6IGRyYWdNb21lbnR1bSA/IHZlbG9jaXR5W2F4aXNdIDogMCxcbiAgICAgICAgYm91bmNlU3RpZmZuZXNzLFxuICAgICAgICBib3VuY2VEYW1waW5nLFxuICAgICAgICB0aW1lQ29uc3RhbnQ6IDc1MCxcbiAgICAgICAgcmVzdERlbHRhOiAxLFxuICAgICAgICByZXN0U3BlZWQ6IDEwXG4gICAgICB9LCBkcmFnVHJhbnNpdGlvbiksIHRyYW5zaXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRBeGlzVmFsdWVBbmltYXRpb24oYXhpcywgaW5lcnRpYTIpO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChtb21lbnR1bUFuaW1hdGlvbnMpLnRoZW4ob25EcmFnVHJhbnNpdGlvbkVuZCk7XG4gIH1cbiAgc3RhcnRBeGlzVmFsdWVBbmltYXRpb24oYXhpcywgdHJhbnNpdGlvbikge1xuICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgIHJldHVybiBzdGFydEFuaW1hdGlvbihheGlzLCBheGlzVmFsdWUsIDAsIHRyYW5zaXRpb24pO1xuICB9XG4gIHN0b3BBbmltYXRpb24oKSB7XG4gICAgZWFjaEF4aXMoKGF4aXMpID0+IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpLnN0b3AoKSk7XG4gIH1cbiAgZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRyYWdLZXkgPSBcIl9kcmFnXCIgKyBheGlzLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgZXh0ZXJuYWxNb3Rpb25WYWx1ZSA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpW2RyYWdLZXldO1xuICAgIHJldHVybiBleHRlcm5hbE1vdGlvblZhbHVlID8gZXh0ZXJuYWxNb3Rpb25WYWx1ZSA6IHRoaXMudmlzdWFsRWxlbWVudC5nZXRWYWx1ZShheGlzLCAoX2IgPSAoX2EgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKS5pbml0aWFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYXhpc10pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICB9XG4gIHNuYXBUb0N1cnNvcihwb2ludDIpIHtcbiAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgY29uc3QgeyBkcmFnOiBkcmFnMiB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcyLCB0aGlzLmN1cnJlbnREaXJlY3Rpb24pKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgaWYgKHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gcHJvamVjdGlvbi5sYXlvdXQubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICBheGlzVmFsdWUuc2V0KHBvaW50MltheGlzXSAtIG1peChtaW4sIG1heCwgMC41KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZHJhZzogZHJhZzIsIGRyYWdDb25zdHJhaW50cyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgIGlmICghaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSB8fCAhcHJvamVjdGlvbiB8fCAhdGhpcy5jb25zdHJhaW50cylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICBjb25zdCBib3hQcm9ncmVzcyA9IHsgeDogMCwgeTogMCB9O1xuICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgIGlmIChheGlzVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0ID0gYXhpc1ZhbHVlLmdldCgpO1xuICAgICAgICBib3hQcm9ncmVzc1theGlzXSA9IGNhbGNPcmlnaW4yKHsgbWluOiBsYXRlc3QsIG1heDogbGF0ZXN0IH0sIHRoaXMuY29uc3RyYWludHNbYXhpc10pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtVGVtcGxhdGUgfSA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgIHRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlID8gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpIDogXCJub25lXCI7XG4gICAgKF9hID0gcHJvamVjdGlvbi5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlU2Nyb2xsKCk7XG4gICAgcHJvamVjdGlvbi51cGRhdGVMYXlvdXQoKTtcbiAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygpO1xuICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZzIsIG51bGwpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMuY29uc3RyYWludHNbYXhpc107XG4gICAgICBheGlzVmFsdWUuc2V0KG1peChtaW4sIG1heCwgYm94UHJvZ3Jlc3NbYXhpc10pKTtcbiAgICB9KTtcbiAgfVxuICBhZGRMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy52aXN1YWxFbGVtZW50LmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgZWxlbWVudERyYWdDb250cm9scy5zZXQodGhpcy52aXN1YWxFbGVtZW50LCB0aGlzKTtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy52aXN1YWxFbGVtZW50LmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcFBvaW50ZXJMaXN0ZW5lciA9IGFkZFBvaW50ZXJFdmVudChlbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBkcmFnOiBkcmFnMiwgZHJhZ0xpc3RlbmVyID0gdHJ1ZSB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgZHJhZzIgJiYgZHJhZ0xpc3RlbmVyICYmIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIH0pO1xuICAgIGNvbnN0IG1lYXN1cmVEcmFnQ29uc3RyYWludHMgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IGRyYWdDb25zdHJhaW50cyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgaWYgKGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IHRoaXMucmVzb2x2ZVJlZkNvbnN0cmFpbnRzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICBjb25zdCBzdG9wTWVhc3VyZUxheW91dExpc3RlbmVyID0gcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwibWVhc3VyZVwiLCBtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKTtcbiAgICBpZiAocHJvamVjdGlvbiAmJiAhcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgIChfYSA9IHByb2plY3Rpb24ucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgcHJvamVjdGlvbi51cGRhdGVMYXlvdXQoKTtcbiAgICB9XG4gICAgbWVhc3VyZURyYWdDb25zdHJhaW50cygpO1xuICAgIGNvbnN0IHN0b3BSZXNpemVMaXN0ZW5lciA9IGFkZERvbUV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5zY2FsZVBvc2l0aW9uV2l0aGluQ29uc3RyYWludHMoKSk7XG4gICAgY29uc3Qgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyID0gcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiZGlkVXBkYXRlXCIsICh7IGRlbHRhLCBoYXNMYXlvdXRDaGFuZ2VkIH0pID0+IHtcbiAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcgJiYgaGFzTGF5b3V0Q2hhbmdlZCkge1xuICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vdGlvblZhbHVlMiA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgIGlmICghbW90aW9uVmFsdWUyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHRoaXMub3JpZ2luUG9pbnRbYXhpc10gKz0gZGVsdGFbYXhpc10udHJhbnNsYXRlO1xuICAgICAgICAgIG1vdGlvblZhbHVlMi5zZXQobW90aW9uVmFsdWUyLmdldCgpICsgZGVsdGFbYXhpc10udHJhbnNsYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3RvcFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICBzdG9wUG9pbnRlckxpc3RlbmVyKCk7XG4gICAgICBzdG9wTWVhc3VyZUxheW91dExpc3RlbmVyKCk7XG4gICAgICBzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIgPT09IG51bGwgfHwgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG4gIGdldFByb3BzKCkge1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgY29uc3QgeyBkcmFnOiBkcmFnMiA9IGZhbHNlLCBkcmFnRGlyZWN0aW9uTG9jayA9IGZhbHNlLCBkcmFnUHJvcGFnYXRpb24gPSBmYWxzZSwgZHJhZ0NvbnN0cmFpbnRzID0gZmFsc2UsIGRyYWdFbGFzdGljID0gZGVmYXVsdEVsYXN0aWMsIGRyYWdNb21lbnR1bSA9IHRydWUgfSA9IHByb3BzO1xuICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcyksIHtcbiAgICAgIGRyYWc6IGRyYWcyLFxuICAgICAgZHJhZ0RpcmVjdGlvbkxvY2ssXG4gICAgICBkcmFnUHJvcGFnYXRpb24sXG4gICAgICBkcmFnQ29uc3RyYWludHMsXG4gICAgICBkcmFnRWxhc3RpYyxcbiAgICAgIGRyYWdNb21lbnR1bVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkRHJhZyhkaXJlY3Rpb24sIGRyYWcyLCBjdXJyZW50RGlyZWN0aW9uKSB7XG4gIHJldHVybiAoZHJhZzIgPT09IHRydWUgfHwgZHJhZzIgPT09IGRpcmVjdGlvbikgJiYgKGN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwgfHwgY3VycmVudERpcmVjdGlvbiA9PT0gZGlyZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnREaXJlY3Rpb24ob2Zmc2V0LCBsb2NrVGhyZXNob2xkID0gMTApIHtcbiAgbGV0IGRpcmVjdGlvbiA9IG51bGw7XG4gIGlmIChNYXRoLmFicyhvZmZzZXQueSkgPiBsb2NrVGhyZXNob2xkKSB7XG4gICAgZGlyZWN0aW9uID0gXCJ5XCI7XG4gIH0gZWxzZSBpZiAoTWF0aC5hYnMob2Zmc2V0LngpID4gbG9ja1RocmVzaG9sZCkge1xuICAgIGRpcmVjdGlvbiA9IFwieFwiO1xuICB9XG4gIHJldHVybiBkaXJlY3Rpb247XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91c2UtZHJhZy5tanNcbmZ1bmN0aW9uIHVzZURyYWcocHJvcHMpIHtcbiAgY29uc3QgeyBkcmFnQ29udHJvbHM6IGdyb3VwRHJhZ0NvbnRyb2xzLCB2aXN1YWxFbGVtZW50IH0gPSBwcm9wcztcbiAgY29uc3QgZHJhZ0NvbnRyb2xzID0gdXNlQ29uc3RhbnQoKCkgPT4gbmV3IFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHModmlzdWFsRWxlbWVudCkpO1xuICAoMCwgaW1wb3J0X3JlYWN0MjQudXNlRWZmZWN0KSgoKSA9PiBncm91cERyYWdDb250cm9scyAmJiBncm91cERyYWdDb250cm9scy5zdWJzY3JpYmUoZHJhZ0NvbnRyb2xzKSwgW2RyYWdDb250cm9scywgZ3JvdXBEcmFnQ29udHJvbHNdKTtcbiAgKDAsIGltcG9ydF9yZWFjdDI0LnVzZUVmZmVjdCkoKCkgPT4gZHJhZ0NvbnRyb2xzLmFkZExpc3RlbmVycygpLCBbZHJhZ0NvbnRyb2xzXSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLXBhbi1nZXN0dXJlLm1qc1xudmFyIGltcG9ydF9yZWFjdDI1ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gdXNlUGFuR2VzdHVyZSh7IG9uUGFuLCBvblBhblN0YXJ0LCBvblBhbkVuZCwgb25QYW5TZXNzaW9uU3RhcnQsIHZpc3VhbEVsZW1lbnQgfSkge1xuICBjb25zdCBoYXNQYW5FdmVudHMgPSBvblBhbiB8fCBvblBhblN0YXJ0IHx8IG9uUGFuRW5kIHx8IG9uUGFuU2Vzc2lvblN0YXJ0O1xuICBjb25zdCBwYW5TZXNzaW9uID0gKDAsIGltcG9ydF9yZWFjdDI1LnVzZVJlZikobnVsbCk7XG4gIGNvbnN0IHsgdHJhbnNmb3JtUGFnZVBvaW50IH0gPSAoMCwgaW1wb3J0X3JlYWN0MjUudXNlQ29udGV4dCkoTW90aW9uQ29uZmlnQ29udGV4dCk7XG4gIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgIG9uU2Vzc2lvblN0YXJ0OiBvblBhblNlc3Npb25TdGFydCxcbiAgICBvblN0YXJ0OiBvblBhblN0YXJ0LFxuICAgIG9uTW92ZTogb25QYW4sXG4gICAgb25FbmQ6IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgcGFuU2Vzc2lvbi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIG9uUGFuRW5kICYmIG9uUGFuRW5kKGV2ZW50LCBpbmZvKTtcbiAgICB9XG4gIH07XG4gICgwLCBpbXBvcnRfcmVhY3QyNS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBpZiAocGFuU2Vzc2lvbi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBwYW5TZXNzaW9uLmN1cnJlbnQudXBkYXRlSGFuZGxlcnMoaGFuZGxlcnMpO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICBwYW5TZXNzaW9uLmN1cnJlbnQgPSBuZXcgUGFuU2Vzc2lvbihldmVudCwgaGFuZGxlcnMsIHtcbiAgICAgIHRyYW5zZm9ybVBhZ2VQb2ludFxuICAgIH0pO1xuICB9XG4gIHVzZVBvaW50ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIGhhc1BhbkV2ZW50cyAmJiBvblBvaW50ZXJEb3duKTtcbiAgdXNlVW5tb3VudEVmZmVjdCgoKSA9PiBwYW5TZXNzaW9uLmN1cnJlbnQgJiYgcGFuU2Vzc2lvbi5jdXJyZW50LmVuZCgpKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvZHJhZy5tanNcbnZhciBkcmFnID0ge1xuICBwYW46IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZVBhbkdlc3R1cmUpLFxuICBkcmFnOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VEcmFnKVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2Nzcy12YXJpYWJsZXMtY29udmVyc2lvbi5tanNcbmZ1bmN0aW9uIGlzQ1NTVmFyaWFibGUyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChcInZhcigtLVwiKTtcbn1cbnZhciBjc3NWYXJpYWJsZVJlZ2V4ID0gL3ZhclxcKCgtLVthLXpBLVowLTktX10rKSw/ID8oW2EtekEtWjAtOSAoKSUjLiwtXSspP1xcKS87XG5mdW5jdGlvbiBwYXJzZUNTU1ZhcmlhYmxlKGN1cnJlbnQpIHtcbiAgY29uc3QgbWF0Y2ggPSBjc3NWYXJpYWJsZVJlZ2V4LmV4ZWMoY3VycmVudCk7XG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIFssXTtcbiAgY29uc3QgWywgdG9rZW4sIGZhbGxiYWNrXSA9IG1hdGNoO1xuICByZXR1cm4gW3Rva2VuLCBmYWxsYmFja107XG59XG52YXIgbWF4RGVwdGggPSA0O1xuZnVuY3Rpb24gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50LCBkZXB0aCA9IDEpIHtcbiAgaW52YXJpYW50KGRlcHRoIDw9IG1heERlcHRoLCBgTWF4IENTUyB2YXJpYWJsZSBmYWxsYmFjayBkZXB0aCBkZXRlY3RlZCBpbiBwcm9wZXJ0eSBcIiR7Y3VycmVudH1cIi4gVGhpcyBtYXkgaW5kaWNhdGUgYSBjaXJjdWxhciBmYWxsYmFjayBkZXBlbmRlbmN5LmApO1xuICBjb25zdCBbdG9rZW4sIGZhbGxiYWNrXSA9IHBhcnNlQ1NTVmFyaWFibGUoY3VycmVudCk7XG4gIGlmICghdG9rZW4pXG4gICAgcmV0dXJuO1xuICBjb25zdCByZXNvbHZlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUodG9rZW4pO1xuICBpZiAocmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWQudHJpbSgpO1xuICB9IGVsc2UgaWYgKGlzQ1NTVmFyaWFibGUyKGZhbGxiYWNrKSkge1xuICAgIHJldHVybiBnZXRWYXJpYWJsZVZhbHVlKGZhbGxiYWNrLCBlbGVtZW50LCBkZXB0aCArIDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNTU1ZhcmlhYmxlcyh2aXN1YWxFbGVtZW50LCBfYSwgdHJhbnNpdGlvbkVuZCkge1xuICB2YXIgdGFyZ2V0ID0gX19vYmpSZXN0KF9hLCBbXSk7XG4gIGNvbnN0IGVsZW1lbnQgPSB2aXN1YWxFbGVtZW50LmN1cnJlbnQ7XG4gIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSlcbiAgICByZXR1cm4geyB0YXJnZXQsIHRyYW5zaXRpb25FbmQgfTtcbiAgaWYgKHRyYW5zaXRpb25FbmQpIHtcbiAgICB0cmFuc2l0aW9uRW5kID0gX19zcHJlYWRWYWx1ZXMoe30sIHRyYW5zaXRpb25FbmQpO1xuICB9XG4gIHZpc3VhbEVsZW1lbnQudmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IHZhbHVlLmdldCgpO1xuICAgIGlmICghaXNDU1NWYXJpYWJsZTIoY3VycmVudCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBnZXRWYXJpYWJsZVZhbHVlKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgIGlmIChyZXNvbHZlZClcbiAgICAgIHZhbHVlLnNldChyZXNvbHZlZCk7XG4gIH0pO1xuICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKCFpc0NTU1ZhcmlhYmxlMihjdXJyZW50KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHJlc29sdmVkID0gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50KTtcbiAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSByZXNvbHZlZDtcbiAgICBpZiAodHJhbnNpdGlvbkVuZCAmJiB0cmFuc2l0aW9uRW5kW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgdHJhbnNpdGlvbkVuZFtrZXldID0gY3VycmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy91bml0LWNvbnZlcnNpb24ubWpzXG52YXIgcG9zaXRpb25hbEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwid2lkdGhcIixcbiAgXCJoZWlnaHRcIixcbiAgXCJ0b3BcIixcbiAgXCJsZWZ0XCIsXG4gIFwicmlnaHRcIixcbiAgXCJib3R0b21cIixcbiAgXCJ4XCIsXG4gIFwieVwiXG5dKTtcbnZhciBpc1Bvc2l0aW9uYWxLZXkgPSAoa2V5KSA9PiBwb3NpdGlvbmFsS2V5cy5oYXMoa2V5KTtcbnZhciBoYXNQb3NpdGlvbmFsS2V5ID0gKHRhcmdldCkgPT4ge1xuICByZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5zb21lKGlzUG9zaXRpb25hbEtleSk7XG59O1xudmFyIHNldEFuZFJlc2V0VmVsb2NpdHkgPSAodmFsdWUsIHRvKSA9PiB7XG4gIHZhbHVlLnNldCh0bywgZmFsc2UpO1xuICB2YWx1ZS5zZXQodG8pO1xufTtcbnZhciBpc051bU9yUHhUeXBlID0gKHYpID0+IHYgPT09IG51bWJlciB8fCB2ID09PSBweDtcbnZhciBCb3VuZGluZ0JveERpbWVuc2lvbjtcbihmdW5jdGlvbihCb3VuZGluZ0JveERpbWVuc2lvbjIpIHtcbiAgQm91bmRpbmdCb3hEaW1lbnNpb24yW1wid2lkdGhcIl0gPSBcIndpZHRoXCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcImhlaWdodFwiXSA9IFwiaGVpZ2h0XCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcImxlZnRcIl0gPSBcImxlZnRcIjtcbiAgQm91bmRpbmdCb3hEaW1lbnNpb24yW1wicmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcInRvcFwiXSA9IFwidG9wXCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcImJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG59KShCb3VuZGluZ0JveERpbWVuc2lvbiB8fCAoQm91bmRpbmdCb3hEaW1lbnNpb24gPSB7fSkpO1xudmFyIGdldFBvc0Zyb21NYXRyaXggPSAobWF0cml4LCBwb3MpID0+IHBhcnNlRmxvYXQobWF0cml4LnNwbGl0KFwiLCBcIilbcG9zXSk7XG52YXIgZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCA9IChwb3MyLCBwb3MzKSA9PiAoX2Jib3gsIHsgdHJhbnNmb3JtIH0pID0+IHtcbiAgaWYgKHRyYW5zZm9ybSA9PT0gXCJub25lXCIgfHwgIXRyYW5zZm9ybSlcbiAgICByZXR1cm4gMDtcbiAgY29uc3QgbWF0cml4M2QgPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXgzZFxcKCguKylcXCkkLyk7XG4gIGlmIChtYXRyaXgzZCkge1xuICAgIHJldHVybiBnZXRQb3NGcm9tTWF0cml4KG1hdHJpeDNkWzFdLCBwb3MzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtYXRyaXggPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXhcXCgoLispXFwpJC8pO1xuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHJldHVybiBnZXRQb3NGcm9tTWF0cml4KG1hdHJpeFsxXSwgcG9zMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxufTtcbnZhciB0cmFuc2Zvcm1LZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wieFwiLCBcInlcIiwgXCJ6XCJdKTtcbnZhciBub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cyA9IHRyYW5zZm9ybVByb3BPcmRlci5maWx0ZXIoKGtleSkgPT4gIXRyYW5zZm9ybUtleXMuaGFzKGtleSkpO1xuZnVuY3Rpb24gcmVtb3ZlTm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybSh2aXN1YWxFbGVtZW50KSB7XG4gIGNvbnN0IHJlbW92ZWRUcmFuc2Zvcm1zID0gW107XG4gIG5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm1LZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZW1vdmVkVHJhbnNmb3Jtcy5wdXNoKFtrZXksIHZhbHVlLmdldCgpXSk7XG4gICAgICB2YWx1ZS5zZXQoa2V5LnN0YXJ0c1dpdGgoXCJzY2FsZVwiKSA/IDEgOiAwKTtcbiAgICB9XG4gIH0pO1xuICBpZiAocmVtb3ZlZFRyYW5zZm9ybXMubGVuZ3RoKVxuICAgIHZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gIHJldHVybiByZW1vdmVkVHJhbnNmb3Jtcztcbn1cbnZhciBwb3NpdGlvbmFsVmFsdWVzID0ge1xuICB3aWR0aDogKHsgeCB9LCB7IHBhZGRpbmdMZWZ0ID0gXCIwXCIsIHBhZGRpbmdSaWdodCA9IFwiMFwiIH0pID0+IHgubWF4IC0geC5taW4gLSBwYXJzZUZsb2F0KHBhZGRpbmdMZWZ0KSAtIHBhcnNlRmxvYXQocGFkZGluZ1JpZ2h0KSxcbiAgaGVpZ2h0OiAoeyB5IH0sIHsgcGFkZGluZ1RvcCA9IFwiMFwiLCBwYWRkaW5nQm90dG9tID0gXCIwXCIgfSkgPT4geS5tYXggLSB5Lm1pbiAtIHBhcnNlRmxvYXQocGFkZGluZ1RvcCkgLSBwYXJzZUZsb2F0KHBhZGRpbmdCb3R0b20pLFxuICB0b3A6IChfYmJveCwgeyB0b3AgfSkgPT4gcGFyc2VGbG9hdCh0b3ApLFxuICBsZWZ0OiAoX2Jib3gsIHsgbGVmdCB9KSA9PiBwYXJzZUZsb2F0KGxlZnQpLFxuICBib3R0b206ICh7IHkgfSwgeyB0b3AgfSkgPT4gcGFyc2VGbG9hdCh0b3ApICsgKHkubWF4IC0geS5taW4pLFxuICByaWdodDogKHsgeCB9LCB7IGxlZnQgfSkgPT4gcGFyc2VGbG9hdChsZWZ0KSArICh4Lm1heCAtIHgubWluKSxcbiAgeDogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg0LCAxMyksXG4gIHk6IGdldFRyYW5zbGF0ZUZyb21NYXRyaXgoNSwgMTQpXG59O1xudmFyIGNvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyA9ICh0YXJnZXQsIHZpc3VhbEVsZW1lbnQsIGNoYW5nZWRLZXlzKSA9PiB7XG4gIGNvbnN0IG9yaWdpbkJib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICBjb25zdCBlbGVtZW50ID0gdmlzdWFsRWxlbWVudC5jdXJyZW50O1xuICBjb25zdCBlbGVtZW50Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIGNvbnN0IHsgZGlzcGxheSB9ID0gZWxlbWVudENvbXB1dGVkU3R5bGU7XG4gIGNvbnN0IG9yaWdpbiA9IHt9O1xuICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICB2aXN1YWxFbGVtZW50LnNldFN0YXRpY1ZhbHVlKFwiZGlzcGxheVwiLCB0YXJnZXQuZGlzcGxheSB8fCBcImJsb2NrXCIpO1xuICB9XG4gIGNoYW5nZWRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIG9yaWdpbltrZXldID0gcG9zaXRpb25hbFZhbHVlc1trZXldKG9yaWdpbkJib3gsIGVsZW1lbnRDb21wdXRlZFN0eWxlKTtcbiAgfSk7XG4gIHZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gIGNvbnN0IHRhcmdldEJib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICBjaGFuZ2VkS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICBzZXRBbmRSZXNldFZlbG9jaXR5KHZhbHVlLCBvcmlnaW5ba2V5XSk7XG4gICAgdGFyZ2V0W2tleV0gPSBwb3NpdGlvbmFsVmFsdWVzW2tleV0odGFyZ2V0QmJveCwgZWxlbWVudENvbXB1dGVkU3R5bGUpO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgY2hlY2tBbmRDb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXMgPSAodmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4gPSB7fSwgdHJhbnNpdGlvbkVuZCA9IHt9KSA9PiB7XG4gIHRhcmdldCA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0YXJnZXQpO1xuICB0cmFuc2l0aW9uRW5kID0gX19zcHJlYWRWYWx1ZXMoe30sIHRyYW5zaXRpb25FbmQpO1xuICBjb25zdCB0YXJnZXRQb3NpdGlvbmFsS2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCkuZmlsdGVyKGlzUG9zaXRpb25hbEtleSk7XG4gIGxldCByZW1vdmVkVHJhbnNmb3JtVmFsdWVzID0gW107XG4gIGxldCBoYXNBdHRlbXB0ZWRUb1JlbW92ZVRyYW5zZm9ybVZhbHVlcyA9IGZhbHNlO1xuICBjb25zdCBjaGFuZ2VkVmFsdWVUeXBlS2V5cyA9IFtdO1xuICB0YXJnZXRQb3NpdGlvbmFsS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnQuaGFzVmFsdWUoa2V5KSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZnJvbSA9IG9yaWdpbltrZXldO1xuICAgIGxldCBmcm9tVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUoZnJvbSk7XG4gICAgY29uc3QgdG8gPSB0YXJnZXRba2V5XTtcbiAgICBsZXQgdG9UeXBlO1xuICAgIGlmIChpc0tleWZyYW1lc1RhcmdldCh0bykpIHtcbiAgICAgIGNvbnN0IG51bUtleWZyYW1lcyA9IHRvLmxlbmd0aDtcbiAgICAgIGNvbnN0IGZyb21JbmRleCA9IHRvWzBdID09PSBudWxsID8gMSA6IDA7XG4gICAgICBmcm9tID0gdG9bZnJvbUluZGV4XTtcbiAgICAgIGZyb21UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZShmcm9tKTtcbiAgICAgIGZvciAobGV0IGkyID0gZnJvbUluZGV4OyBpMiA8IG51bUtleWZyYW1lczsgaTIrKykge1xuICAgICAgICBpZiAoIXRvVHlwZSkge1xuICAgICAgICAgIHRvVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodG9baTJdKTtcbiAgICAgICAgICBpbnZhcmlhbnQodG9UeXBlID09PSBmcm9tVHlwZSB8fCBpc051bU9yUHhUeXBlKGZyb21UeXBlKSAmJiBpc051bU9yUHhUeXBlKHRvVHlwZSksIFwiS2V5ZnJhbWVzIG11c3QgYmUgb2YgdGhlIHNhbWUgZGltZW5zaW9uIGFzIHRoZSBjdXJyZW50IHZhbHVlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludmFyaWFudChmaW5kRGltZW5zaW9uVmFsdWVUeXBlKHRvW2kyXSkgPT09IHRvVHlwZSwgXCJBbGwga2V5ZnJhbWVzIG11c3QgYmUgb2YgdGhlIHNhbWUgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0b1R5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKHRvKTtcbiAgICB9XG4gICAgaWYgKGZyb21UeXBlICE9PSB0b1R5cGUpIHtcbiAgICAgIGlmIChpc051bU9yUHhUeXBlKGZyb21UeXBlKSAmJiBpc051bU9yUHhUeXBlKHRvVHlwZSkpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHZhbHVlLmdldCgpO1xuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YWx1ZS5zZXQocGFyc2VGbG9hdChjdXJyZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gcGFyc2VGbG9hdCh0byk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0bykgJiYgdG9UeXBlID09PSBweCkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdG8ubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChmcm9tVHlwZSA9PT0gbnVsbCB8fCBmcm9tVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnJvbVR5cGUudHJhbnNmb3JtKSAmJiAodG9UeXBlID09PSBudWxsIHx8IHRvVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9UeXBlLnRyYW5zZm9ybSkgJiYgKGZyb20gPT09IDAgfHwgdG8gPT09IDApKSB7XG4gICAgICAgIGlmIChmcm9tID09PSAwKSB7XG4gICAgICAgICAgdmFsdWUuc2V0KHRvVHlwZS50cmFuc2Zvcm0oZnJvbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gZnJvbVR5cGUudHJhbnNmb3JtKHRvKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNBdHRlbXB0ZWRUb1JlbW92ZVRyYW5zZm9ybVZhbHVlcykge1xuICAgICAgICAgIHJlbW92ZWRUcmFuc2Zvcm1WYWx1ZXMgPSByZW1vdmVOb25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtKHZpc3VhbEVsZW1lbnQpO1xuICAgICAgICAgIGhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkVmFsdWVUeXBlS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHRyYW5zaXRpb25FbmRba2V5XSA9IHRyYW5zaXRpb25FbmRba2V5XSAhPT0gdm9pZCAwID8gdHJhbnNpdGlvbkVuZFtrZXldIDogdGFyZ2V0W2tleV07XG4gICAgICAgIHNldEFuZFJlc2V0VmVsb2NpdHkodmFsdWUsIHRvKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoY2hhbmdlZFZhbHVlVHlwZUtleXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc2Nyb2xsWSA9IGNoYW5nZWRWYWx1ZVR5cGVLZXlzLmluZGV4T2YoXCJoZWlnaHRcIikgPj0gMCA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IG51bGw7XG4gICAgY29uc3QgY29udmVydGVkVGFyZ2V0ID0gY29udmVydENoYW5nZWRWYWx1ZVR5cGVzKHRhcmdldCwgdmlzdWFsRWxlbWVudCwgY2hhbmdlZFZhbHVlVHlwZUtleXMpO1xuICAgIGlmIChyZW1vdmVkVHJhbnNmb3JtVmFsdWVzLmxlbmd0aCkge1xuICAgICAgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpLnNldCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgICBpZiAoaXNCcm93c2VyICYmIHNjcm9sbFkgIT09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyh7IHRvcDogc2Nyb2xsWSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGFyZ2V0OiBjb252ZXJ0ZWRUYXJnZXQsIHRyYW5zaXRpb25FbmQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB0YXJnZXQsIHRyYW5zaXRpb25FbmQgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVuaXRDb252ZXJzaW9uKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKSB7XG4gIHJldHVybiBoYXNQb3NpdGlvbmFsS2V5KHRhcmdldCkgPyBjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCkgOiB7IHRhcmdldCwgdHJhbnNpdGlvbkVuZCB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvcGFyc2UtZG9tLXZhcmlhbnQubWpzXG52YXIgcGFyc2VEb21WYXJpYW50ID0gKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKSA9PiB7XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUNTU1ZhcmlhYmxlcyh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIHRyYW5zaXRpb25FbmQpO1xuICB0YXJnZXQgPSByZXNvbHZlZC50YXJnZXQ7XG4gIHRyYW5zaXRpb25FbmQgPSByZXNvbHZlZC50cmFuc2l0aW9uRW5kO1xuICByZXR1cm4gdW5pdENvbnZlcnNpb24odmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvVmlzdWFsRWxlbWVudC5tanNcbnZhciBpbXBvcnRfcmVhY3QyNiA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9yZWR1Y2VkLW1vdGlvbi9zdGF0ZS5tanNcbnZhciBwcmVmZXJzUmVkdWNlZE1vdGlvbiA9IHsgY3VycmVudDogbnVsbCB9O1xudmFyIGhhc1JlZHVjZWRNb3Rpb25MaXN0ZW5lciA9IHsgY3VycmVudDogZmFsc2UgfTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9yZWR1Y2VkLW1vdGlvbi9pbmRleC5tanNcbmZ1bmN0aW9uIGluaXRQcmVmZXJzUmVkdWNlZE1vdGlvbigpIHtcbiAgaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLmN1cnJlbnQgPSB0cnVlO1xuICBpZiAoIWlzQnJvd3NlcilcbiAgICByZXR1cm47XG4gIGlmICh3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgIGNvbnN0IG1vdGlvbk1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uKVwiKTtcbiAgICBjb25zdCBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMgPSAoKSA9PiBwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50ID0gbW90aW9uTWVkaWFRdWVyeS5tYXRjaGVzO1xuICAgIG1vdGlvbk1lZGlhUXVlcnkuYWRkTGlzdGVuZXIoc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzKTtcbiAgICBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMoKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvbW90aW9uLXZhbHVlcy5tanNcbmZ1bmN0aW9uIHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhlbGVtZW50LCBuZXh0LCBwcmV2KSB7XG4gIGNvbnN0IHsgd2lsbENoYW5nZSB9ID0gbmV4dDtcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9IG5leHRba2V5XTtcbiAgICBjb25zdCBwcmV2VmFsdWUgPSBwcmV2W2tleV07XG4gICAgaWYgKGlzTW90aW9uVmFsdWUobmV4dFZhbHVlKSkge1xuICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG5leHRWYWx1ZSk7XG4gICAgICBpZiAoaXNXaWxsQ2hhbmdlTW90aW9uVmFsdWUod2lsbENoYW5nZSkpIHtcbiAgICAgICAgd2lsbENoYW5nZS5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIHdhcm5PbmNlKG5leHRWYWx1ZS52ZXJzaW9uID09PSBcIjcuNi43XCIsIGBBdHRlbXB0aW5nIHRvIG1peCBGcmFtZXIgTW90aW9uIHZlcnNpb25zICR7bmV4dFZhbHVlLnZlcnNpb259IHdpdGggNy42LjcgbWF5IG5vdCB3b3JrIGFzIGV4cGVjdGVkLmApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNNb3Rpb25WYWx1ZShwcmV2VmFsdWUpKSB7XG4gICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUobmV4dFZhbHVlKSk7XG4gICAgICBpZiAoaXNXaWxsQ2hhbmdlTW90aW9uVmFsdWUod2lsbENoYW5nZSkpIHtcbiAgICAgICAgd2lsbENoYW5nZS5yZW1vdmUoa2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG4gICAgICBpZiAoZWxlbWVudC5oYXNWYWx1ZShrZXkpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSBlbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgICAgICFleGlzdGluZ1ZhbHVlLmhhc0FuaW1hdGVkICYmIGV4aXN0aW5nVmFsdWUuc2V0KG5leHRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsYXRlc3RWYWx1ZSA9IGVsZW1lbnQuZ2V0U3RhdGljVmFsdWUoa2V5KTtcbiAgICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKGxhdGVzdFZhbHVlICE9PSB2b2lkIDAgPyBsYXRlc3RWYWx1ZSA6IG5leHRWYWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgaWYgKG5leHRba2V5XSA9PT0gdm9pZCAwKVxuICAgICAgZWxlbWVudC5yZW1vdmVWYWx1ZShrZXkpO1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9WaXN1YWxFbGVtZW50Lm1qc1xudmFyIGZlYXR1cmVOYW1lcyA9IE9iamVjdC5rZXlzKGZlYXR1cmVEZWZpbml0aW9ucyk7XG52YXIgbnVtRmVhdHVyZXMgPSBmZWF0dXJlTmFtZXMubGVuZ3RoO1xudmFyIHByb3BFdmVudEhhbmRsZXJzID0gW1xuICBcIkFuaW1hdGlvblN0YXJ0XCIsXG4gIFwiQW5pbWF0aW9uQ29tcGxldGVcIixcbiAgXCJVcGRhdGVcIixcbiAgXCJVbm1vdW50XCIsXG4gIFwiQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICBcIkxheW91dE1lYXN1cmVcIixcbiAgXCJMYXlvdXRBbmltYXRpb25TdGFydFwiLFxuICBcIkxheW91dEFuaW1hdGlvbkNvbXBsZXRlXCJcbl07XG52YXIgVmlzdWFsRWxlbWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyBwYXJlbnQsIHByb3BzLCByZWR1Y2VkTW90aW9uQ29uZmlnLCB2aXN1YWxTdGF0ZSB9LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuaXNWYXJpYW50Tm9kZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNDb250cm9sbGluZ1ZhcmlhbnRzID0gZmFsc2U7XG4gICAgdGhpcy5zaG91bGRSZWR1Y2VNb3Rpb24gPSBudWxsO1xuICAgIHRoaXMudmFsdWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmlzUHJlc2VudCA9IHRydWU7XG4gICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJldk1vdGlvblZhbHVlcyA9IHt9O1xuICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgdGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zID0ge307XG4gICAgdGhpcy5ub3RpZnlVcGRhdGUgPSAoKSA9PiB0aGlzLm5vdGlmeShcIlVwZGF0ZVwiLCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgdGhpcy5yZW5kZXIgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuY3VycmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy50cmlnZ2VyQnVpbGQoKTtcbiAgICAgIHRoaXMucmVuZGVySW5zdGFuY2UodGhpcy5jdXJyZW50LCB0aGlzLnJlbmRlclN0YXRlLCB0aGlzLnByb3BzLnN0eWxlLCB0aGlzLnByb2plY3Rpb24pO1xuICAgIH07XG4gICAgdGhpcy5zY2hlZHVsZVJlbmRlciA9ICgpID0+IGVzX2RlZmF1bHQucmVuZGVyKHRoaXMucmVuZGVyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgY29uc3QgeyBsYXRlc3RWYWx1ZXMsIHJlbmRlclN0YXRlIH0gPSB2aXN1YWxTdGF0ZTtcbiAgICB0aGlzLmxhdGVzdFZhbHVlcyA9IGxhdGVzdFZhbHVlcztcbiAgICB0aGlzLmJhc2VUYXJnZXQgPSBfX3NwcmVhZFZhbHVlcyh7fSwgbGF0ZXN0VmFsdWVzKTtcbiAgICB0aGlzLmluaXRpYWxWYWx1ZXMgPSBwcm9wcy5pbml0aWFsID8gX19zcHJlYWRWYWx1ZXMoe30sIGxhdGVzdFZhbHVlcykgOiB7fTtcbiAgICB0aGlzLnJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMuZGVwdGggPSBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcbiAgICB0aGlzLnJlZHVjZWRNb3Rpb25Db25maWcgPSByZWR1Y2VkTW90aW9uQ29uZmlnO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHMgPSBpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpO1xuICAgIHRoaXMuaXNWYXJpYW50Tm9kZSA9IGlzVmFyaWFudE5vZGUocHJvcHMpO1xuICAgIGlmICh0aGlzLmlzVmFyaWFudE5vZGUpIHtcbiAgICAgIHRoaXMudmFyaWFudENoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB9XG4gICAgdGhpcy5tYW51YWxseUFuaW1hdGVPbk1vdW50ID0gQm9vbGVhbihwYXJlbnQgJiYgcGFyZW50LmN1cnJlbnQpO1xuICAgIGNvbnN0IF9hID0gdGhpcy5zY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpLCB7IHdpbGxDaGFuZ2UgfSA9IF9hLCBpbml0aWFsTW90aW9uVmFsdWVzID0gX19vYmpSZXN0KF9hLCBbXCJ3aWxsQ2hhbmdlXCJdKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbml0aWFsTW90aW9uVmFsdWVzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxNb3Rpb25WYWx1ZXNba2V5XTtcbiAgICAgIGlmIChsYXRlc3RWYWx1ZXNba2V5XSAhPT0gdm9pZCAwICYmIGlzTW90aW9uVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLnNldChsYXRlc3RWYWx1ZXNba2V5XSwgZmFsc2UpO1xuICAgICAgICBpZiAoaXNXaWxsQ2hhbmdlTW90aW9uVmFsdWUod2lsbENoYW5nZSkpIHtcbiAgICAgICAgICB3aWxsQ2hhbmdlLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhfcHJvcHMpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgbW91bnQoaW5zdGFuY2UpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgaWYgKHRoaXMucHJvamVjdGlvbikge1xuICAgICAgdGhpcy5wcm9qZWN0aW9uLm1vdW50KGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMuaXNWYXJpYW50Tm9kZSAmJiAhdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHMpIHtcbiAgICAgIHRoaXMucmVtb3ZlRnJvbVZhcmlhbnRUcmVlID0gKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRWYXJpYW50Q2hpbGQodGhpcyk7XG4gICAgfVxuICAgIHRoaXMudmFsdWVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHRoaXMuYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICAgIGlmICghaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLmN1cnJlbnQpIHtcbiAgICAgIGluaXRQcmVmZXJzUmVkdWNlZE1vdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLnNob3VsZFJlZHVjZU1vdGlvbiA9IHRoaXMucmVkdWNlZE1vdGlvbkNvbmZpZyA9PT0gXCJuZXZlclwiID8gZmFsc2UgOiB0aGlzLnJlZHVjZWRNb3Rpb25Db25maWcgPT09IFwiYWx3YXlzXCIgPyB0cnVlIDogcHJlZmVyc1JlZHVjZWRNb3Rpb24uY3VycmVudDtcbiAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5hZGQodGhpcyk7XG4gICAgdGhpcy5zZXRQcm9wcyh0aGlzLnByb3BzKTtcbiAgfVxuICB1bm1vdW50KCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIChfYSA9IHRoaXMucHJvamVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVubW91bnQoKTtcbiAgICBjYW5jZWxTeW5jLnVwZGF0ZSh0aGlzLm5vdGlmeVVwZGF0ZSk7XG4gICAgY2FuY2VsU3luYy5yZW5kZXIodGhpcy5yZW5kZXIpO1xuICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmZvckVhY2goKHJlbW92ZSkgPT4gcmVtb3ZlKCkpO1xuICAgIChfYiA9IHRoaXMucmVtb3ZlRnJvbVZhcmlhbnRUcmVlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzKTtcbiAgICAoX2MgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNoaWxkcmVuLmRlbGV0ZSh0aGlzKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmV2ZW50cykge1xuICAgICAgdGhpcy5ldmVudHNba2V5XS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB9XG4gIGJpbmRUb01vdGlvblZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCByZW1vdmVPbkNoYW5nZSA9IHZhbHVlLm9uQ2hhbmdlKChsYXRlc3RWYWx1ZSkgPT4ge1xuICAgICAgdGhpcy5sYXRlc3RWYWx1ZXNba2V5XSA9IGxhdGVzdFZhbHVlO1xuICAgICAgdGhpcy5wcm9wcy5vblVwZGF0ZSAmJiBlc19kZWZhdWx0LnVwZGF0ZSh0aGlzLm5vdGlmeVVwZGF0ZSwgZmFsc2UsIHRydWUpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlbW92ZU9uUmVuZGVyUmVxdWVzdCA9IHZhbHVlLm9uUmVuZGVyUmVxdWVzdCh0aGlzLnNjaGVkdWxlUmVuZGVyKTtcbiAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5zZXQoa2V5LCAoKSA9PiB7XG4gICAgICByZW1vdmVPbkNoYW5nZSgpO1xuICAgICAgcmVtb3ZlT25SZW5kZXJSZXF1ZXN0KCk7XG4gICAgfSk7XG4gIH1cbiAgc29ydE5vZGVQb3NpdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5jdXJyZW50IHx8ICF0aGlzLnNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbiB8fCB0aGlzLnR5cGUgIT09IG90aGVyLnR5cGUpXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gdGhpcy5zb3J0SW5zdGFuY2VOb2RlUG9zaXRpb24odGhpcy5jdXJyZW50LCBvdGhlci5jdXJyZW50KTtcbiAgfVxuICBsb2FkRmVhdHVyZXMocmVuZGVyZWRQcm9wcywgaXNTdHJpY3QsIHByZWxvYWRlZEZlYXR1cmVzLCBwcm9qZWN0aW9uSWQsIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsIGluaXRpYWxMYXlvdXRHcm91cENvbmZpZykge1xuICAgIGNvbnN0IGZlYXR1cmVzID0gW107XG4gICAgaWYgKGVudiAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgcHJlbG9hZGVkRmVhdHVyZXMgJiYgaXNTdHJpY3QpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJZb3UgaGF2ZSByZW5kZXJlZCBhIGBtb3Rpb25gIGNvbXBvbmVudCB3aXRoaW4gYSBgTGF6eU1vdGlvbmAgY29tcG9uZW50LiBUaGlzIHdpbGwgYnJlYWsgdHJlZSBzaGFraW5nLiBJbXBvcnQgYW5kIHJlbmRlciBhIGBtYCBjb21wb25lbnQgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1GZWF0dXJlczsgaTIrKykge1xuICAgICAgY29uc3QgbmFtZSA9IGZlYXR1cmVOYW1lc1tpMl07XG4gICAgICBjb25zdCB7IGlzRW5hYmxlZCwgQ29tcG9uZW50IH0gPSBmZWF0dXJlRGVmaW5pdGlvbnNbbmFtZV07XG4gICAgICBpZiAoaXNFbmFibGVkKHJlbmRlcmVkUHJvcHMpICYmIENvbXBvbmVudCkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKCgwLCBpbXBvcnRfcmVhY3QyNi5jcmVhdGVFbGVtZW50KShDb21wb25lbnQsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgIGtleTogbmFtZVxuICAgICAgICB9LCByZW5kZXJlZFByb3BzKSwge1xuICAgICAgICAgIHZpc3VhbEVsZW1lbnQ6IHRoaXNcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLnByb2plY3Rpb24gJiYgUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5wcm9qZWN0aW9uID0gbmV3IFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IocHJvamVjdGlvbklkLCB0aGlzLmxhdGVzdFZhbHVlcywgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucHJvamVjdGlvbik7XG4gICAgICBjb25zdCB7IGxheW91dElkLCBsYXlvdXQsIGRyYWc6IGRyYWcyLCBkcmFnQ29uc3RyYWludHMsIGxheW91dFNjcm9sbCB9ID0gcmVuZGVyZWRQcm9wcztcbiAgICAgIHRoaXMucHJvamVjdGlvbi5zZXRPcHRpb25zKHtcbiAgICAgICAgbGF5b3V0SWQsXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgYWx3YXlzTWVhc3VyZUxheW91dDogQm9vbGVhbihkcmFnMikgfHwgZHJhZ0NvbnN0cmFpbnRzICYmIGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cyksXG4gICAgICAgIHZpc3VhbEVsZW1lbnQ6IHRoaXMsXG4gICAgICAgIHNjaGVkdWxlUmVuZGVyOiAoKSA9PiB0aGlzLnNjaGVkdWxlUmVuZGVyKCksXG4gICAgICAgIGFuaW1hdGlvblR5cGU6IHR5cGVvZiBsYXlvdXQgPT09IFwic3RyaW5nXCIgPyBsYXlvdXQgOiBcImJvdGhcIixcbiAgICAgICAgaW5pdGlhbFByb21vdGlvbkNvbmZpZzogaW5pdGlhbExheW91dEdyb3VwQ29uZmlnLFxuICAgICAgICBsYXlvdXRTY3JvbGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cbiAgdHJpZ2dlckJ1aWxkKCkge1xuICAgIHRoaXMuYnVpbGQodGhpcy5yZW5kZXJTdGF0ZSwgdGhpcy5sYXRlc3RWYWx1ZXMsIHRoaXMub3B0aW9ucywgdGhpcy5wcm9wcyk7XG4gIH1cbiAgbWVhc3VyZVZpZXdwb3J0Qm94KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQgPyB0aGlzLm1lYXN1cmVJbnN0YW5jZVZpZXdwb3J0Qm94KHRoaXMuY3VycmVudCwgdGhpcy5wcm9wcykgOiBjcmVhdGVCb3goKTtcbiAgfVxuICBnZXRTdGF0aWNWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlc3RWYWx1ZXNba2V5XTtcbiAgfVxuICBzZXRTdGF0aWNWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5sYXRlc3RWYWx1ZXNba2V5XSA9IHZhbHVlO1xuICB9XG4gIG1ha2VUYXJnZXRBbmltYXRhYmxlKHRhcmdldCwgY2FuTXV0YXRlID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLm1ha2VUYXJnZXRBbmltYXRhYmxlRnJvbUluc3RhbmNlKHRhcmdldCwgdGhpcy5wcm9wcywgY2FuTXV0YXRlKTtcbiAgfVxuICBzZXRQcm9wcyhwcm9wcykge1xuICAgIGlmIChwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSB8fCB0aGlzLnByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgfVxuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgcHJvcEV2ZW50SGFuZGxlcnMubGVuZ3RoOyBpMisrKSB7XG4gICAgICBjb25zdCBrZXkgPSBwcm9wRXZlbnRIYW5kbGVyc1tpMl07XG4gICAgICBpZiAodGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zW2tleV0pIHtcbiAgICAgICAgdGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zW2tleV0oKTtcbiAgICAgICAgZGVsZXRlIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlzdGVuZXIgPSBwcm9wc1tcIm9uXCIgKyBrZXldO1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldID0gdGhpcy5vbihrZXksIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmV2TW90aW9uVmFsdWVzID0gdXBkYXRlTW90aW9uVmFsdWVzRnJvbVByb3BzKHRoaXMsIHRoaXMuc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKSwgdGhpcy5wcmV2TW90aW9uVmFsdWVzKTtcbiAgfVxuICBnZXRQcm9wcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcztcbiAgfVxuICBnZXRWYXJpYW50KG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucHJvcHMudmFyaWFudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtuYW1lXTtcbiAgfVxuICBnZXREZWZhdWx0VHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy50cmFuc2l0aW9uO1xuICB9XG4gIGdldFRyYW5zZm9ybVBhZ2VQb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy50cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gIH1cbiAgZ2V0Q2xvc2VzdFZhcmlhbnROb2RlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gdGhpcy5pc1ZhcmlhbnROb2RlID8gdGhpcyA6IChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q2xvc2VzdFZhcmlhbnROb2RlKCk7XG4gIH1cbiAgZ2V0VmFyaWFudENvbnRleHQoc3RhcnRBdFBhcmVudCA9IGZhbHNlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoc3RhcnRBdFBhcmVudClcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFZhcmlhbnRDb250ZXh0KCk7XG4gICAgaWYgKCF0aGlzLmlzQ29udHJvbGxpbmdWYXJpYW50cykge1xuICAgICAgY29uc3QgY29udGV4dDIgPSAoKF9iID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRWYXJpYW50Q29udGV4dCgpKSB8fCB7fTtcbiAgICAgIGlmICh0aGlzLnByb3BzLmluaXRpYWwgIT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0Mi5pbml0aWFsID0gdGhpcy5wcm9wcy5pbml0aWFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRleHQyO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0ge307XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bVZhcmlhbnRQcm9wczsgaTIrKykge1xuICAgICAgY29uc3QgbmFtZSA9IHZhcmlhbnRQcm9wczJbaTJdO1xuICAgICAgY29uc3QgcHJvcCA9IHRoaXMucHJvcHNbbmFtZV07XG4gICAgICBpZiAoaXNWYXJpYW50TGFiZWwocHJvcCkgfHwgcHJvcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGV4dFtuYW1lXSA9IHByb3A7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIGFkZFZhcmlhbnRDaGlsZChjaGlsZCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjbG9zZXN0VmFyaWFudE5vZGUgPSB0aGlzLmdldENsb3Nlc3RWYXJpYW50Tm9kZSgpO1xuICAgIGlmIChjbG9zZXN0VmFyaWFudE5vZGUpIHtcbiAgICAgIChfYSA9IGNsb3Nlc3RWYXJpYW50Tm9kZS52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGQoY2hpbGQpO1xuICAgICAgcmV0dXJuICgpID0+IGNsb3Nlc3RWYXJpYW50Tm9kZS52YXJpYW50Q2hpbGRyZW4uZGVsZXRlKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgYWRkVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLmhhc1ZhbHVlKGtleSkpXG4gICAgICB0aGlzLnJlbW92ZVZhbHVlKGtleSk7XG4gICAgdGhpcy52YWx1ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgIHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gPSB2YWx1ZS5nZXQoKTtcbiAgICB0aGlzLmJpbmRUb01vdGlvblZhbHVlKGtleSwgdmFsdWUpO1xuICB9XG4gIHJlbW92ZVZhbHVlKGtleSkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLnZhbHVlcy5kZWxldGUoa2V5KTtcbiAgICAoX2EgPSB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKCk7XG4gICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgZGVsZXRlIHRoaXMubGF0ZXN0VmFsdWVzW2tleV07XG4gICAgdGhpcy5yZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZShrZXksIHRoaXMucmVuZGVyU3RhdGUpO1xuICB9XG4gIGhhc1ZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcy5oYXMoa2V5KTtcbiAgfVxuICBnZXRWYWx1ZShrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh0aGlzLnByb3BzLnZhbHVlcyAmJiB0aGlzLnByb3BzLnZhbHVlc1trZXldKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy52YWx1ZXNba2V5XTtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZXMuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDAgJiYgZGVmYXVsdFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gbW90aW9uVmFsdWUoZGVmYXVsdFZhbHVlKTtcbiAgICAgIHRoaXMuYWRkVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkVmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gIT09IHZvaWQgMCB8fCAhdGhpcy5jdXJyZW50ID8gdGhpcy5sYXRlc3RWYWx1ZXNba2V5XSA6IHRoaXMucmVhZFZhbHVlRnJvbUluc3RhbmNlKHRoaXMuY3VycmVudCwga2V5LCB0aGlzLm9wdGlvbnMpO1xuICB9XG4gIHNldEJhc2VUYXJnZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuYmFzZVRhcmdldFtrZXldID0gdmFsdWU7XG4gIH1cbiAgZ2V0QmFzZVRhcmdldChrZXkpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBpbml0aWFsIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHZhbHVlRnJvbUluaXRpYWwgPSB0eXBlb2YgaW5pdGlhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgaW5pdGlhbCA9PT0gXCJvYmplY3RcIiA/IChfYSA9IHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHRoaXMucHJvcHMsIGluaXRpYWwpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fba2V5XSA6IHZvaWQgMDtcbiAgICBpZiAoaW5pdGlhbCAmJiB2YWx1ZUZyb21Jbml0aWFsICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2YWx1ZUZyb21Jbml0aWFsO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldEJhc2VUYXJnZXRGcm9tUHJvcHModGhpcy5wcm9wcywga2V5KTtcbiAgICBpZiAodGFyZ2V0ICE9PSB2b2lkIDAgJiYgIWlzTW90aW9uVmFsdWUodGFyZ2V0KSlcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlc1trZXldICE9PSB2b2lkIDAgJiYgdmFsdWVGcm9tSW5pdGlhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5iYXNlVGFyZ2V0W2tleV07XG4gIH1cbiAgb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmFkZChjYWxsYmFjayk7XG4gIH1cbiAgbm90aWZ5KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm90aWZ5KC4uLmFyZ3MpO1xuICB9XG59O1xudmFyIHZhcmlhbnRQcm9wczIgPSBbXCJpbml0aWFsXCIsIC4uLnZhcmlhbnRQcmlvcml0eU9yZGVyXTtcbnZhciBudW1WYXJpYW50UHJvcHMgPSB2YXJpYW50UHJvcHMyLmxlbmd0aDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL0RPTVZpc3VhbEVsZW1lbnQubWpzXG52YXIgRE9NVmlzdWFsRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgVmlzdWFsRWxlbWVudCB7XG4gIHNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbihhMiwgYjIpIHtcbiAgICByZXR1cm4gYTIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYjIpICYgMiA/IDEgOiAtMTtcbiAgfVxuICBnZXRCYXNlVGFyZ2V0RnJvbVByb3BzKHByb3BzLCBrZXkpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHByb3BzLnN0eWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fba2V5XTtcbiAgfVxuICByZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZShrZXksIHsgdmFycywgc3R5bGUgfSkge1xuICAgIGRlbGV0ZSB2YXJzW2tleV07XG4gICAgZGVsZXRlIHN0eWxlW2tleV07XG4gIH1cbiAgbWFrZVRhcmdldEFuaW1hdGFibGVGcm9tSW5zdGFuY2UoX2EsIHsgdHJhbnNmb3JtVmFsdWVzIH0sIGlzTW91bnRlZCkge1xuICAgIHZhciBfYiA9IF9hLCB7IHRyYW5zaXRpb24sIHRyYW5zaXRpb25FbmQgfSA9IF9iLCB0YXJnZXQgPSBfX29ialJlc3QoX2IsIFtcInRyYW5zaXRpb25cIiwgXCJ0cmFuc2l0aW9uRW5kXCJdKTtcbiAgICBsZXQgb3JpZ2luID0gZ2V0T3JpZ2luKHRhcmdldCwgdHJhbnNpdGlvbiB8fCB7fSwgdGhpcyk7XG4gICAgaWYgKHRyYW5zZm9ybVZhbHVlcykge1xuICAgICAgaWYgKHRyYW5zaXRpb25FbmQpXG4gICAgICAgIHRyYW5zaXRpb25FbmQgPSB0cmFuc2Zvcm1WYWx1ZXModHJhbnNpdGlvbkVuZCk7XG4gICAgICBpZiAodGFyZ2V0KVxuICAgICAgICB0YXJnZXQgPSB0cmFuc2Zvcm1WYWx1ZXModGFyZ2V0KTtcbiAgICAgIGlmIChvcmlnaW4pXG4gICAgICAgIG9yaWdpbiA9IHRyYW5zZm9ybVZhbHVlcyhvcmlnaW4pO1xuICAgIH1cbiAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICBjaGVja1RhcmdldEZvck5ld1ZhbHVlcyh0aGlzLCB0YXJnZXQsIG9yaWdpbik7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZURvbVZhcmlhbnQodGhpcywgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpO1xuICAgICAgdHJhbnNpdGlvbkVuZCA9IHBhcnNlZC50cmFuc2l0aW9uRW5kO1xuICAgICAgdGFyZ2V0ID0gcGFyc2VkLnRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICB0cmFuc2l0aW9uRW5kXG4gICAgfSwgdGFyZ2V0KTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC9IVE1MVmlzdWFsRWxlbWVudC5tanNcbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxudmFyIEhUTUxWaXN1YWxFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBET01WaXN1YWxFbGVtZW50IHtcbiAgcmVhZFZhbHVlRnJvbUluc3RhbmNlKGluc3RhbmNlLCBrZXkpIHtcbiAgICBpZiAodHJhbnNmb3JtUHJvcHMuaGFzKGtleSkpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRUeXBlID0gZ2V0RGVmYXVsdFZhbHVlVHlwZShrZXkpO1xuICAgICAgcmV0dXJuIGRlZmF1bHRUeXBlID8gZGVmYXVsdFR5cGUuZGVmYXVsdCB8fCAwIDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUyKGluc3RhbmNlKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gKGlzQ1NTVmFyaWFibGUoa2V5KSA/IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShrZXkpIDogY29tcHV0ZWRTdHlsZVtrZXldKSB8fCAwO1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xuICAgIH1cbiAgfVxuICBtZWFzdXJlSW5zdGFuY2VWaWV3cG9ydEJveChpbnN0YW5jZSwgeyB0cmFuc2Zvcm1QYWdlUG9pbnQgfSkge1xuICAgIHJldHVybiBtZWFzdXJlVmlld3BvcnRCb3goaW5zdGFuY2UsIHRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gIH1cbiAgYnVpbGQocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMpIHtcbiAgICBidWlsZEhUTUxTdHlsZXMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICB9XG4gIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpO1xuICB9XG4gIHJlbmRlckluc3RhbmNlKGluc3RhbmNlLCByZW5kZXJTdGF0ZSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gICAgcmVuZGVySFRNTChpbnN0YW5jZSwgcmVuZGVyU3RhdGUsIHN0eWxlUHJvcCwgcHJvamVjdGlvbik7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy9TVkdWaXN1YWxFbGVtZW50Lm1qc1xudmFyIFNWR1Zpc3VhbEVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIERPTVZpc3VhbEVsZW1lbnQge1xuICBnZXRCYXNlVGFyZ2V0RnJvbVByb3BzKHByb3BzLCBrZXkpIHtcbiAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgfVxuICByZWFkVmFsdWVGcm9tSW5zdGFuY2UoaW5zdGFuY2UsIGtleSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodHJhbnNmb3JtUHJvcHMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiAoKF9hID0gZ2V0RGVmYXVsdFZhbHVlVHlwZShrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVmYXVsdCkgfHwgMDtcbiAgICB9XG4gICAga2V5ID0gIWNhbWVsQ2FzZUF0dHJpYnV0ZXMuaGFzKGtleSkgPyBjYW1lbFRvRGFzaChrZXkpIDoga2V5O1xuICAgIHJldHVybiBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgfVxuICBtZWFzdXJlSW5zdGFuY2VWaWV3cG9ydEJveCgpIHtcbiAgICByZXR1cm4gY3JlYXRlQm94KCk7XG4gIH1cbiAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczIocHJvcHMpO1xuICB9XG4gIGJ1aWxkKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzKSB7XG4gICAgYnVpbGRTVkdBdHRycyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBvcHRpb25zLCBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gIH1cbiAgcmVuZGVySW5zdGFuY2UoaW5zdGFuY2UsIHJlbmRlclN0YXRlLCBzdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgICByZW5kZXJTVkcoaW5zdGFuY2UsIHJlbmRlclN0YXRlLCBzdHlsZVByb3AsIHByb2plY3Rpb24pO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vY3JlYXRlLXZpc3VhbC1lbGVtZW50Lm1qc1xudmFyIGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQgPSAoQ29tcG9uZW50LCBvcHRpb25zKSA9PiB7XG4gIHJldHVybiBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpID8gbmV3IFNWR1Zpc3VhbEVsZW1lbnQob3B0aW9ucywgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogZmFsc2UgfSkgOiBuZXcgSFRNTFZpc3VhbEVsZW1lbnQob3B0aW9ucywgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogdHJ1ZSB9KTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xheW91dC9NZWFzdXJlTGF5b3V0Lm1qc1xudmFyIGltcG9ydF9yZWFjdDI3ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIiksIDEpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWJvcmRlci1yYWRpdXMubWpzXG5mdW5jdGlvbiBwaXhlbHNUb1BlcmNlbnQocGl4ZWxzLCBheGlzKSB7XG4gIGlmIChheGlzLm1heCA9PT0gYXhpcy5taW4pXG4gICAgcmV0dXJuIDA7XG4gIHJldHVybiBwaXhlbHMgLyAoYXhpcy5tYXggLSBheGlzLm1pbikgKiAxMDA7XG59XG52YXIgY29ycmVjdEJvcmRlclJhZGl1cyA9IHtcbiAgY29ycmVjdDogKGxhdGVzdCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS50YXJnZXQpXG4gICAgICByZXR1cm4gbGF0ZXN0O1xuICAgIGlmICh0eXBlb2YgbGF0ZXN0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAocHgudGVzdChsYXRlc3QpKSB7XG4gICAgICAgIGxhdGVzdCA9IHBhcnNlRmxvYXQobGF0ZXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsYXRlc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHggPSBwaXhlbHNUb1BlcmNlbnQobGF0ZXN0LCBub2RlLnRhcmdldC54KTtcbiAgICBjb25zdCB5ID0gcGl4ZWxzVG9QZXJjZW50KGxhdGVzdCwgbm9kZS50YXJnZXQueSk7XG4gICAgcmV0dXJuIGAke3h9JSAke3l9JWA7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9zdHlsZXMvc2NhbGUtYm94LXNoYWRvdy5tanNcbnZhciB2YXJUb2tlbiA9IFwiXyRjc3NcIjtcbnZhciBjb3JyZWN0Qm94U2hhZG93ID0ge1xuICBjb3JyZWN0OiAobGF0ZXN0LCB7IHRyZWVTY2FsZSwgcHJvamVjdGlvbkRlbHRhIH0pID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbCA9IGxhdGVzdDtcbiAgICBjb25zdCBjb250YWluc0NTU1ZhcmlhYmxlcyA9IGxhdGVzdC5pbmNsdWRlcyhcInZhcihcIik7XG4gICAgY29uc3QgY3NzVmFyaWFibGVzID0gW107XG4gICAgaWYgKGNvbnRhaW5zQ1NTVmFyaWFibGVzKSB7XG4gICAgICBsYXRlc3QgPSBsYXRlc3QucmVwbGFjZShjc3NWYXJpYWJsZVJlZ2V4LCAobWF0Y2gpID0+IHtcbiAgICAgICAgY3NzVmFyaWFibGVzLnB1c2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gdmFyVG9rZW47XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2hhZG93ID0gY29tcGxleC5wYXJzZShsYXRlc3QpO1xuICAgIGlmIChzaGFkb3cubGVuZ3RoID4gNSlcbiAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIobGF0ZXN0KTtcbiAgICBjb25zdCBvZmZzZXQgPSB0eXBlb2Ygc2hhZG93WzBdICE9PSBcIm51bWJlclwiID8gMSA6IDA7XG4gICAgY29uc3QgeFNjYWxlID0gcHJvamVjdGlvbkRlbHRhLnguc2NhbGUgKiB0cmVlU2NhbGUueDtcbiAgICBjb25zdCB5U2NhbGUgPSBwcm9qZWN0aW9uRGVsdGEueS5zY2FsZSAqIHRyZWVTY2FsZS55O1xuICAgIHNoYWRvd1swICsgb2Zmc2V0XSAvPSB4U2NhbGU7XG4gICAgc2hhZG93WzEgKyBvZmZzZXRdIC89IHlTY2FsZTtcbiAgICBjb25zdCBhdmVyYWdlU2NhbGUgPSBtaXgoeFNjYWxlLCB5U2NhbGUsIDAuNSk7XG4gICAgaWYgKHR5cGVvZiBzaGFkb3dbMiArIG9mZnNldF0gPT09IFwibnVtYmVyXCIpXG4gICAgICBzaGFkb3dbMiArIG9mZnNldF0gLz0gYXZlcmFnZVNjYWxlO1xuICAgIGlmICh0eXBlb2Ygc2hhZG93WzMgKyBvZmZzZXRdID09PSBcIm51bWJlclwiKVxuICAgICAgc2hhZG93WzMgKyBvZmZzZXRdIC89IGF2ZXJhZ2VTY2FsZTtcbiAgICBsZXQgb3V0cHV0ID0gdGVtcGxhdGUoc2hhZG93KTtcbiAgICBpZiAoY29udGFpbnNDU1NWYXJpYWJsZXMpIHtcbiAgICAgIGxldCBpMiA9IDA7XG4gICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSh2YXJUb2tlbiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBjc3NWYXJpYWJsZSA9IGNzc1ZhcmlhYmxlc1tpMl07XG4gICAgICAgIGkyKys7XG4gICAgICAgIHJldHVybiBjc3NWYXJpYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9sYXlvdXQvTWVhc3VyZUxheW91dC5tanNcbnZhciBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9yZWFjdDI3LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyB2aXN1YWxFbGVtZW50LCBsYXlvdXRHcm91cCwgc3dpdGNoTGF5b3V0R3JvdXAsIGxheW91dElkIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICBhZGRTY2FsZUNvcnJlY3RvcihkZWZhdWx0U2NhbGVDb3JyZWN0b3JzKTtcbiAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgaWYgKGxheW91dEdyb3VwLmdyb3VwKVxuICAgICAgICBsYXlvdXRHcm91cC5ncm91cC5hZGQocHJvamVjdGlvbik7XG4gICAgICBpZiAoc3dpdGNoTGF5b3V0R3JvdXAgJiYgc3dpdGNoTGF5b3V0R3JvdXAucmVnaXN0ZXIgJiYgbGF5b3V0SWQpIHtcbiAgICAgICAgc3dpdGNoTGF5b3V0R3JvdXAucmVnaXN0ZXIocHJvamVjdGlvbik7XG4gICAgICB9XG4gICAgICBwcm9qZWN0aW9uLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25Db21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICAgIHByb2plY3Rpb24uc2V0T3B0aW9ucyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9qZWN0aW9uLm9wdGlvbnMpLCB7XG4gICAgICAgIG9uRXhpdENvbXBsZXRlOiAoKSA9PiB0aGlzLnNhZmVUb1JlbW92ZSgpXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNFdmVyVXBkYXRlZCA9IHRydWU7XG4gIH1cbiAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzKSB7XG4gICAgY29uc3QgeyBsYXlvdXREZXBlbmRlbmN5LCB2aXN1YWxFbGVtZW50LCBkcmFnOiBkcmFnMiwgaXNQcmVzZW50IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSB2aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgaWYgKCFwcm9qZWN0aW9uKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcHJvamVjdGlvbi5pc1ByZXNlbnQgPSBpc1ByZXNlbnQ7XG4gICAgaWYgKGRyYWcyIHx8IHByZXZQcm9wcy5sYXlvdXREZXBlbmRlbmN5ICE9PSBsYXlvdXREZXBlbmRlbmN5IHx8IGxheW91dERlcGVuZGVuY3kgPT09IHZvaWQgMCkge1xuICAgICAgcHJvamVjdGlvbi53aWxsVXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmIChwcmV2UHJvcHMuaXNQcmVzZW50ICE9PSBpc1ByZXNlbnQpIHtcbiAgICAgIGlmIChpc1ByZXNlbnQpIHtcbiAgICAgICAgcHJvamVjdGlvbi5wcm9tb3RlKCk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9qZWN0aW9uLnJlbGVnYXRlKCkpIHtcbiAgICAgICAgZXNfZGVmYXVsdC5wb3N0UmVuZGVyKCgpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgaWYgKCEoKF9hID0gcHJvamVjdGlvbi5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVtYmVycy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMucHJvcHMudmlzdWFsRWxlbWVudDtcbiAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgcHJvamVjdGlvbi5yb290LmRpZFVwZGF0ZSgpO1xuICAgICAgaWYgKCFwcm9qZWN0aW9uLmN1cnJlbnRBbmltYXRpb24gJiYgcHJvamVjdGlvbi5pc0xlYWQoKSkge1xuICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQsIGxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cDogcHJvbW90ZUNvbnRleHQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB2aXN1YWxFbGVtZW50O1xuICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICBwcm9qZWN0aW9uLnNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQoKTtcbiAgICAgIGlmIChsYXlvdXRHcm91cCA9PT0gbnVsbCB8fCBsYXlvdXRHcm91cCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0R3JvdXAuZ3JvdXApXG4gICAgICAgIGxheW91dEdyb3VwLmdyb3VwLnJlbW92ZShwcm9qZWN0aW9uKTtcbiAgICAgIGlmIChwcm9tb3RlQ29udGV4dCA9PT0gbnVsbCB8fCBwcm9tb3RlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvbW90ZUNvbnRleHQuZGVyZWdpc3RlcilcbiAgICAgICAgcHJvbW90ZUNvbnRleHQuZGVyZWdpc3Rlcihwcm9qZWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgc2FmZVRvUmVtb3ZlKCkge1xuICAgIGNvbnN0IHsgc2FmZVRvUmVtb3ZlIH0gPSB0aGlzLnByb3BzO1xuICAgIHNhZmVUb1JlbW92ZSA9PT0gbnVsbCB8fCBzYWZlVG9SZW1vdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNhZmVUb1JlbW92ZSgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbmZ1bmN0aW9uIE1lYXN1cmVMYXlvdXQocHJvcHMpIHtcbiAgY29uc3QgW2lzUHJlc2VudCwgc2FmZVRvUmVtb3ZlXSA9IHVzZVByZXNlbmNlKCk7XG4gIGNvbnN0IGxheW91dEdyb3VwID0gKDAsIGltcG9ydF9yZWFjdDI3LnVzZUNvbnRleHQpKExheW91dEdyb3VwQ29udGV4dCk7XG4gIHJldHVybiBpbXBvcnRfcmVhY3QyNy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcyksIHsgbGF5b3V0R3JvdXAsIHN3aXRjaExheW91dEdyb3VwOiAoMCwgaW1wb3J0X3JlYWN0MjcudXNlQ29udGV4dCkoU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0KSwgaXNQcmVzZW50LCBzYWZlVG9SZW1vdmUgfSkpO1xufVxudmFyIGRlZmF1bHRTY2FsZUNvcnJlY3RvcnMgPSB7XG4gIGJvcmRlclJhZGl1czogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgY29ycmVjdEJvcmRlclJhZGl1cyksIHtcbiAgICBhcHBseVRvOiBbXG4gICAgICBcImJvcmRlclRvcExlZnRSYWRpdXNcIixcbiAgICAgIFwiYm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcbiAgICAgIFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiLFxuICAgICAgXCJib3JkZXJCb3R0b21SaWdodFJhZGl1c1wiXG4gICAgXVxuICB9KSxcbiAgYm9yZGVyVG9wTGVmdFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICBib3hTaGFkb3c6IGNvcnJlY3RCb3hTaGFkb3dcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xheW91dC9pbmRleC5tanNcbnZhciBsYXlvdXRGZWF0dXJlcyA9IHtcbiAgbWVhc3VyZUxheW91dDogTWVhc3VyZUxheW91dFxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vYW5pbWF0ZS5tanNcbmZ1bmN0aW9uIGFuaW1hdGUyKGZyb20sIHRvLCB0cmFuc2l0aW9uID0ge30pIHtcbiAgY29uc3QgdmFsdWUgPSBpc01vdGlvblZhbHVlKGZyb20pID8gZnJvbSA6IG1vdGlvblZhbHVlKGZyb20pO1xuICBzdGFydEFuaW1hdGlvbihcIlwiLCB2YWx1ZSwgdG8sIHRyYW5zaXRpb24pO1xuICByZXR1cm4ge1xuICAgIHN0b3A6ICgpID0+IHZhbHVlLnN0b3AoKSxcbiAgICBpc0FuaW1hdGluZzogKCkgPT4gdmFsdWUuaXNBbmltYXRpbmcoKVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vYW5pbWF0aW9uL21peC12YWx1ZXMubWpzXG52YXIgYm9yZGVycyA9IFtcIlRvcExlZnRcIiwgXCJUb3BSaWdodFwiLCBcIkJvdHRvbUxlZnRcIiwgXCJCb3R0b21SaWdodFwiXTtcbnZhciBudW1Cb3JkZXJzID0gYm9yZGVycy5sZW5ndGg7XG52YXIgYXNOdW1iZXIgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG52YXIgaXNQeCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHB4LnRlc3QodmFsdWUpO1xuZnVuY3Rpb24gbWl4VmFsdWVzKHRhcmdldCwgZm9sbG93LCBsZWFkLCBwcm9ncmVzczMsIHNob3VsZENyb3NzZmFkZU9wYWNpdHksIGlzT25seU1lbWJlcikge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGlmIChzaG91bGRDcm9zc2ZhZGVPcGFjaXR5KSB7XG4gICAgdGFyZ2V0Lm9wYWNpdHkgPSBtaXgoXG4gICAgICAwLFxuICAgICAgKF9hID0gbGVhZC5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLFxuICAgICAgZWFzZUNyb3NzZmFkZUluKHByb2dyZXNzMylcbiAgICApO1xuICAgIHRhcmdldC5vcGFjaXR5RXhpdCA9IG1peCgoX2IgPSBmb2xsb3cub3BhY2l0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMSwgMCwgZWFzZUNyb3NzZmFkZU91dChwcm9ncmVzczMpKTtcbiAgfSBlbHNlIGlmIChpc09ubHlNZW1iZXIpIHtcbiAgICB0YXJnZXQub3BhY2l0eSA9IG1peCgoX2MgPSBmb2xsb3cub3BhY2l0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMSwgKF9kID0gbGVhZC5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAxLCBwcm9ncmVzczMpO1xuICB9XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1Cb3JkZXJzOyBpMisrKSB7XG4gICAgY29uc3QgYm9yZGVyTGFiZWwgPSBgYm9yZGVyJHtib3JkZXJzW2kyXX1SYWRpdXNgO1xuICAgIGxldCBmb2xsb3dSYWRpdXMgPSBnZXRSYWRpdXMoZm9sbG93LCBib3JkZXJMYWJlbCk7XG4gICAgbGV0IGxlYWRSYWRpdXMgPSBnZXRSYWRpdXMobGVhZCwgYm9yZGVyTGFiZWwpO1xuICAgIGlmIChmb2xsb3dSYWRpdXMgPT09IHZvaWQgMCAmJiBsZWFkUmFkaXVzID09PSB2b2lkIDApXG4gICAgICBjb250aW51ZTtcbiAgICBmb2xsb3dSYWRpdXMgfHwgKGZvbGxvd1JhZGl1cyA9IDApO1xuICAgIGxlYWRSYWRpdXMgfHwgKGxlYWRSYWRpdXMgPSAwKTtcbiAgICBjb25zdCBjYW5NaXggPSBmb2xsb3dSYWRpdXMgPT09IDAgfHwgbGVhZFJhZGl1cyA9PT0gMCB8fCBpc1B4KGZvbGxvd1JhZGl1cykgPT09IGlzUHgobGVhZFJhZGl1cyk7XG4gICAgaWYgKGNhbk1peCkge1xuICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IE1hdGgubWF4KG1peChhc051bWJlcihmb2xsb3dSYWRpdXMpLCBhc051bWJlcihsZWFkUmFkaXVzKSwgcHJvZ3Jlc3MzKSwgMCk7XG4gICAgICBpZiAocGVyY2VudC50ZXN0KGxlYWRSYWRpdXMpIHx8IHBlcmNlbnQudGVzdChmb2xsb3dSYWRpdXMpKSB7XG4gICAgICAgIHRhcmdldFtib3JkZXJMYWJlbF0gKz0gXCIlXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFtib3JkZXJMYWJlbF0gPSBsZWFkUmFkaXVzO1xuICAgIH1cbiAgfVxuICBpZiAoZm9sbG93LnJvdGF0ZSB8fCBsZWFkLnJvdGF0ZSkge1xuICAgIHRhcmdldC5yb3RhdGUgPSBtaXgoZm9sbG93LnJvdGF0ZSB8fCAwLCBsZWFkLnJvdGF0ZSB8fCAwLCBwcm9ncmVzczMpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSYWRpdXModmFsdWVzLCByYWRpdXNOYW1lKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IHZhbHVlc1tyYWRpdXNOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWVzLmJvcmRlclJhZGl1cztcbn1cbnZhciBlYXNlQ3Jvc3NmYWRlSW4gPSBjb21wcmVzcygwLCAwLjUsIGNpcmNPdXQpO1xudmFyIGVhc2VDcm9zc2ZhZGVPdXQgPSBjb21wcmVzcygwLjUsIDAuOTUsIGxpbmVhcik7XG5mdW5jdGlvbiBjb21wcmVzcyhtaW4sIG1heCwgZWFzaW5nKSB7XG4gIHJldHVybiAocDIpID0+IHtcbiAgICBpZiAocDIgPCBtaW4pXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAocDIgPiBtYXgpXG4gICAgICByZXR1cm4gMTtcbiAgICByZXR1cm4gZWFzaW5nKHByb2dyZXNzKG1pbiwgbWF4LCBwMikpO1xuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvY29weS5tanNcbmZ1bmN0aW9uIGNvcHlBeGlzSW50byhheGlzLCBvcmlnaW5BeGlzKSB7XG4gIGF4aXMubWluID0gb3JpZ2luQXhpcy5taW47XG4gIGF4aXMubWF4ID0gb3JpZ2luQXhpcy5tYXg7XG59XG5mdW5jdGlvbiBjb3B5Qm94SW50byhib3gsIG9yaWdpbkJveCkge1xuICBjb3B5QXhpc0ludG8oYm94LngsIG9yaWdpbkJveC54KTtcbiAgY29weUF4aXNJbnRvKGJveC55LCBvcmlnaW5Cb3gueSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9kZWx0YS1yZW1vdmUubWpzXG5mdW5jdGlvbiByZW1vdmVQb2ludERlbHRhKHBvaW50MiwgdHJhbnNsYXRlLCBzY2FsZTIsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICBwb2ludDIgLT0gdHJhbnNsYXRlO1xuICBwb2ludDIgPSBzY2FsZVBvaW50KHBvaW50MiwgMSAvIHNjYWxlMiwgb3JpZ2luUG9pbnQpO1xuICBpZiAoYm94U2NhbGUgIT09IHZvaWQgMCkge1xuICAgIHBvaW50MiA9IHNjYWxlUG9pbnQocG9pbnQyLCAxIC8gYm94U2NhbGUsIG9yaWdpblBvaW50KTtcbiAgfVxuICByZXR1cm4gcG9pbnQyO1xufVxuZnVuY3Rpb24gcmVtb3ZlQXhpc0RlbHRhKGF4aXMsIHRyYW5zbGF0ZSA9IDAsIHNjYWxlMiA9IDEsIG9yaWdpbiA9IDAuNSwgYm94U2NhbGUsIG9yaWdpbkF4aXMgPSBheGlzLCBzb3VyY2VBeGlzID0gYXhpcykge1xuICBpZiAocGVyY2VudC50ZXN0KHRyYW5zbGF0ZSkpIHtcbiAgICB0cmFuc2xhdGUgPSBwYXJzZUZsb2F0KHRyYW5zbGF0ZSk7XG4gICAgY29uc3QgcmVsYXRpdmVQcm9ncmVzcyA9IG1peChzb3VyY2VBeGlzLm1pbiwgc291cmNlQXhpcy5tYXgsIHRyYW5zbGF0ZSAvIDEwMCk7XG4gICAgdHJhbnNsYXRlID0gcmVsYXRpdmVQcm9ncmVzcyAtIHNvdXJjZUF4aXMubWluO1xuICB9XG4gIGlmICh0eXBlb2YgdHJhbnNsYXRlICE9PSBcIm51bWJlclwiKVxuICAgIHJldHVybjtcbiAgbGV0IG9yaWdpblBvaW50ID0gbWl4KG9yaWdpbkF4aXMubWluLCBvcmlnaW5BeGlzLm1heCwgb3JpZ2luKTtcbiAgaWYgKGF4aXMgPT09IG9yaWdpbkF4aXMpXG4gICAgb3JpZ2luUG9pbnQgLT0gdHJhbnNsYXRlO1xuICBheGlzLm1pbiA9IHJlbW92ZVBvaW50RGVsdGEoYXhpcy5taW4sIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xuICBheGlzLm1heCA9IHJlbW92ZVBvaW50RGVsdGEoYXhpcy5tYXgsIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYXhpcywgdHJhbnNmb3JtcywgW2tleSwgc2NhbGVLZXksIG9yaWdpbktleV0sIG9yaWdpbiwgc291cmNlQXhpcykge1xuICByZW1vdmVBeGlzRGVsdGEoYXhpcywgdHJhbnNmb3Jtc1trZXldLCB0cmFuc2Zvcm1zW3NjYWxlS2V5XSwgdHJhbnNmb3Jtc1tvcmlnaW5LZXldLCB0cmFuc2Zvcm1zLnNjYWxlLCBvcmlnaW4sIHNvdXJjZUF4aXMpO1xufVxudmFyIHhLZXlzMiA9IFtcInhcIiwgXCJzY2FsZVhcIiwgXCJvcmlnaW5YXCJdO1xudmFyIHlLZXlzMiA9IFtcInlcIiwgXCJzY2FsZVlcIiwgXCJvcmlnaW5ZXCJdO1xuZnVuY3Rpb24gcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3gsIHRyYW5zZm9ybXMsIG9yaWdpbkJveCwgc291cmNlQm94KSB7XG4gIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGJveC54LCB0cmFuc2Zvcm1zLCB4S2V5czIsIG9yaWdpbkJveCA9PT0gbnVsbCB8fCBvcmlnaW5Cb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbkJveC54LCBzb3VyY2VCb3ggPT09IG51bGwgfHwgc291cmNlQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2VCb3gueCk7XG4gIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGJveC55LCB0cmFuc2Zvcm1zLCB5S2V5czIsIG9yaWdpbkJveCA9PT0gbnVsbCB8fCBvcmlnaW5Cb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbkJveC55LCBzb3VyY2VCb3ggPT09IG51bGwgfHwgc291cmNlQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2VCb3gueSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS91dGlscy5tanNcbmZ1bmN0aW9uIGlzQXhpc0RlbHRhWmVybyhkZWx0YSkge1xuICByZXR1cm4gZGVsdGEudHJhbnNsYXRlID09PSAwICYmIGRlbHRhLnNjYWxlID09PSAxO1xufVxuZnVuY3Rpb24gaXNEZWx0YVplcm8oZGVsdGEpIHtcbiAgcmV0dXJuIGlzQXhpc0RlbHRhWmVybyhkZWx0YS54KSAmJiBpc0F4aXNEZWx0YVplcm8oZGVsdGEueSk7XG59XG5mdW5jdGlvbiBib3hFcXVhbHMoYTIsIGIyKSB7XG4gIHJldHVybiBhMi54Lm1pbiA9PT0gYjIueC5taW4gJiYgYTIueC5tYXggPT09IGIyLngubWF4ICYmIGEyLnkubWluID09PSBiMi55Lm1pbiAmJiBhMi55Lm1heCA9PT0gYjIueS5tYXg7XG59XG5mdW5jdGlvbiBhc3BlY3RSYXRpbyhib3gpIHtcbiAgcmV0dXJuIGNhbGNMZW5ndGgoYm94LngpIC8gY2FsY0xlbmd0aChib3gueSk7XG59XG5mdW5jdGlvbiBpc0Nsb3NlVG8oYTIsIGIyLCBtYXggPSAwLjEpIHtcbiAgcmV0dXJuIGRpc3RhbmNlKGEyLCBiMikgPD0gbWF4O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc2hhcmVkL3N0YWNrLm1qc1xudmFyIE5vZGVTdGFjayA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tZW1iZXJzID0gW107XG4gIH1cbiAgYWRkKG5vZGUpIHtcbiAgICBhZGRVbmlxdWVJdGVtKHRoaXMubWVtYmVycywgbm9kZSk7XG4gICAgbm9kZS5zY2hlZHVsZVJlbmRlcigpO1xuICB9XG4gIHJlbW92ZShub2RlKSB7XG4gICAgcmVtb3ZlSXRlbSh0aGlzLm1lbWJlcnMsIG5vZGUpO1xuICAgIGlmIChub2RlID09PSB0aGlzLnByZXZMZWFkKSB7XG4gICAgICB0aGlzLnByZXZMZWFkID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gdGhpcy5sZWFkKSB7XG4gICAgICBjb25zdCBwcmV2TGVhZCA9IHRoaXMubWVtYmVyc1t0aGlzLm1lbWJlcnMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAocHJldkxlYWQpIHtcbiAgICAgICAgdGhpcy5wcm9tb3RlKHByZXZMZWFkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVsZWdhdGUobm9kZSkge1xuICAgIGNvbnN0IGluZGV4T2ZOb2RlID0gdGhpcy5tZW1iZXJzLmZpbmRJbmRleCgobWVtYmVyKSA9PiBub2RlID09PSBtZW1iZXIpO1xuICAgIGlmIChpbmRleE9mTm9kZSA9PT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcHJldkxlYWQ7XG4gICAgZm9yIChsZXQgaTIgPSBpbmRleE9mTm9kZTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgY29uc3QgbWVtYmVyID0gdGhpcy5tZW1iZXJzW2kyXTtcbiAgICAgIGlmIChtZW1iZXIuaXNQcmVzZW50ICE9PSBmYWxzZSkge1xuICAgICAgICBwcmV2TGVhZCA9IG1lbWJlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgdGhpcy5wcm9tb3RlKHByZXZMZWFkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHByb21vdGUobm9kZSwgcHJlc2VydmVGb2xsb3dPcGFjaXR5KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByZXZMZWFkID0gdGhpcy5sZWFkO1xuICAgIGlmIChub2RlID09PSBwcmV2TGVhZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnByZXZMZWFkID0gcHJldkxlYWQ7XG4gICAgdGhpcy5sZWFkID0gbm9kZTtcbiAgICBub2RlLnNob3coKTtcbiAgICBpZiAocHJldkxlYWQpIHtcbiAgICAgIHByZXZMZWFkLmluc3RhbmNlICYmIHByZXZMZWFkLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICBub2RlLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICBub2RlLnJlc3VtZUZyb20gPSBwcmV2TGVhZDtcbiAgICAgIGlmIChwcmVzZXJ2ZUZvbGxvd09wYWNpdHkpIHtcbiAgICAgICAgbm9kZS5yZXN1bWVGcm9tLnByZXNlcnZlT3BhY2l0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJldkxlYWQuc25hcHNob3QpIHtcbiAgICAgICAgbm9kZS5zbmFwc2hvdCA9IHByZXZMZWFkLnNuYXBzaG90O1xuICAgICAgICBub2RlLnNuYXBzaG90LmxhdGVzdFZhbHVlcyA9IHByZXZMZWFkLmFuaW1hdGlvblZhbHVlcyB8fCBwcmV2TGVhZC5sYXRlc3RWYWx1ZXM7XG4gICAgICAgIG5vZGUuc25hcHNob3QuaXNTaGFyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKChfYSA9IG5vZGUucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgbm9kZS5pc0xheW91dERpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY3Jvc3NmYWRlIH0gPSBub2RlLm9wdGlvbnM7XG4gICAgICBpZiAoY3Jvc3NmYWRlID09PSBmYWxzZSkge1xuICAgICAgICBwcmV2TGVhZC5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4aXRBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICB0aGlzLm1lbWJlcnMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgIChfYiA9IChfYSA9IG5vZGUub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgIChfZSA9IChfYyA9IG5vZGUucmVzdW1pbmdGcm9tKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9kID0gX2Mub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKTtcbiAgICB9KTtcbiAgfVxuICBzY2hlZHVsZVJlbmRlcigpIHtcbiAgICB0aGlzLm1lbWJlcnMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZS5pbnN0YW5jZSAmJiBub2RlLnNjaGVkdWxlUmVuZGVyKGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICByZW1vdmVMZWFkU25hcHNob3QoKSB7XG4gICAgaWYgKHRoaXMubGVhZCAmJiB0aGlzLmxlYWQuc25hcHNob3QpIHtcbiAgICAgIHRoaXMubGVhZC5zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9zdHlsZXMvdHJhbnNmb3JtLm1qc1xudmFyIGlkZW50aXR5UHJvamVjdGlvbiA9IFwidHJhbnNsYXRlM2QoMHB4LCAwcHgsIDApIHNjYWxlKDEsIDEpIHNjYWxlKDEsIDEpXCI7XG5mdW5jdGlvbiBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0oZGVsdGEsIHRyZWVTY2FsZSwgbGF0ZXN0VHJhbnNmb3JtKSB7XG4gIGNvbnN0IHhUcmFuc2xhdGUgPSBkZWx0YS54LnRyYW5zbGF0ZSAvIHRyZWVTY2FsZS54O1xuICBjb25zdCB5VHJhbnNsYXRlID0gZGVsdGEueS50cmFuc2xhdGUgLyB0cmVlU2NhbGUueTtcbiAgbGV0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3hUcmFuc2xhdGV9cHgsICR7eVRyYW5zbGF0ZX1weCwgMCkgYDtcbiAgdHJhbnNmb3JtICs9IGBzY2FsZSgkezEgLyB0cmVlU2NhbGUueH0sICR7MSAvIHRyZWVTY2FsZS55fSkgYDtcbiAgaWYgKGxhdGVzdFRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHsgcm90YXRlLCByb3RhdGVYLCByb3RhdGVZIH0gPSBsYXRlc3RUcmFuc2Zvcm07XG4gICAgaWYgKHJvdGF0ZSlcbiAgICAgIHRyYW5zZm9ybSArPSBgcm90YXRlKCR7cm90YXRlfWRlZykgYDtcbiAgICBpZiAocm90YXRlWClcbiAgICAgIHRyYW5zZm9ybSArPSBgcm90YXRlWCgke3JvdGF0ZVh9ZGVnKSBgO1xuICAgIGlmIChyb3RhdGVZKVxuICAgICAgdHJhbnNmb3JtICs9IGByb3RhdGVZKCR7cm90YXRlWX1kZWcpIGA7XG4gIH1cbiAgY29uc3QgZWxlbWVudFNjYWxlWCA9IGRlbHRhLnguc2NhbGUgKiB0cmVlU2NhbGUueDtcbiAgY29uc3QgZWxlbWVudFNjYWxlWSA9IGRlbHRhLnkuc2NhbGUgKiB0cmVlU2NhbGUueTtcbiAgdHJhbnNmb3JtICs9IGBzY2FsZSgke2VsZW1lbnRTY2FsZVh9LCAke2VsZW1lbnRTY2FsZVl9KWA7XG4gIHJldHVybiB0cmFuc2Zvcm0gPT09IGlkZW50aXR5UHJvamVjdGlvbiA/IFwibm9uZVwiIDogdHJhbnNmb3JtO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9jb21wYXJlLWJ5LWRlcHRoLm1qc1xudmFyIGNvbXBhcmVCeURlcHRoID0gKGEyLCBiMikgPT4gYTIuZGVwdGggLSBiMi5kZXB0aDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvZmxhdC10cmVlLm1qc1xudmFyIEZsYXRUcmVlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gIH1cbiAgYWRkKGNoaWxkKSB7XG4gICAgYWRkVW5pcXVlSXRlbSh0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XG4gICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgfVxuICByZW1vdmUoY2hpbGQpIHtcbiAgICByZW1vdmVJdGVtKHRoaXMuY2hpbGRyZW4sIGNoaWxkKTtcbiAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICB9XG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmlzRGlydHkgJiYgdGhpcy5jaGlsZHJlbi5zb3J0KGNvbXBhcmVCeURlcHRoKTtcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2FsbGJhY2spO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9jcmVhdGUtcHJvamVjdGlvbi1ub2RlLm1qc1xudmFyIHRyYW5zZm9ybUF4ZXMgPSBbXCJcIiwgXCJYXCIsIFwiWVwiLCBcIlpcIl07XG52YXIgYW5pbWF0aW9uVGFyZ2V0ID0gMWUzO1xuZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbk5vZGUoeyBhdHRhY2hSZXNpemVMaXN0ZW5lciwgZGVmYXVsdFBhcmVudCwgbWVhc3VyZVNjcm9sbCwgY2hlY2tJc1Njcm9sbFJvb3QsIHJlc2V0VHJhbnNmb3JtIH0pIHtcbiAgcmV0dXJuIGNsYXNzIFByb2plY3Rpb25Ob2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50SWQsIGxhdGVzdFZhbHVlcyA9IHt9LCBwYXJlbnQgPSBkZWZhdWx0UGFyZW50ID09PSBudWxsIHx8IGRlZmF1bHRQYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmF1bHRQYXJlbnQoKSkge1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuaXNUcmVlQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmlzQW5pbWF0aW9uQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gZmFsc2U7XG4gICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IGZhbHNlO1xuICAgICAgdGhpcy51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1NWRyA9IGZhbHNlO1xuICAgICAgdGhpcy5uZWVkc1Jlc2V0ID0gZmFsc2U7XG4gICAgICB0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgICB0aGlzLnRyZWVTY2FsZSA9IHsgeDogMSwgeTogMSB9O1xuICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5jaGVja1VwZGF0ZUZhaWxlZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNVcGRhdGluZykge1xuICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHJlc29sdmVUYXJnZXREZWx0YSk7XG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChjYWxjUHJvamVjdGlvbik7XG4gICAgICB9O1xuICAgICAgdGhpcy5oYXNQcm9qZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSAwO1xuICAgICAgdGhpcy5zaGFyZWROb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB0aGlzLmVsZW1lbnRJZCA9IGVsZW1lbnRJZDtcbiAgICAgIHRoaXMubGF0ZXN0VmFsdWVzID0gbGF0ZXN0VmFsdWVzO1xuICAgICAgdGhpcy5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgfHwgcGFyZW50IDogdGhpcztcbiAgICAgIHRoaXMucGF0aCA9IHBhcmVudCA/IFsuLi5wYXJlbnQucGF0aCwgcGFyZW50XSA6IFtdO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLmRlcHRoID0gcGFyZW50ID8gcGFyZW50LmRlcHRoICsgMSA6IDA7XG4gICAgICBlbGVtZW50SWQgJiYgdGhpcy5yb290LnJlZ2lzdGVyUG90ZW50aWFsTm9kZShlbGVtZW50SWQsIHRoaXMpO1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGF0aC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgdGhpcy5wYXRoW2kyXS5zaG91bGRSZXNldFRyYW5zZm9ybSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yb290ID09PSB0aGlzKVxuICAgICAgICB0aGlzLm5vZGVzID0gbmV3IEZsYXRUcmVlKCk7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCF0aGlzLmV2ZW50SGFuZGxlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycy5zZXQobmFtZSwgbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5ldmVudEhhbmRsZXJzLmdldChuYW1lKS5hZGQoaGFuZGxlcik7XG4gICAgfVxuICAgIG5vdGlmeUxpc3RlbmVycyhuYW1lLCAuLi5hcmdzKSB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25NYW5hZ2VyID0gdGhpcy5ldmVudEhhbmRsZXJzLmdldChuYW1lKTtcbiAgICAgIHN1YnNjcmlwdGlvbk1hbmFnZXIgPT09IG51bGwgfHwgc3Vic2NyaXB0aW9uTWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Vic2NyaXB0aW9uTWFuYWdlci5ub3RpZnkoLi4uYXJncyk7XG4gICAgfVxuICAgIGhhc0xpc3RlbmVycyhuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudEhhbmRsZXJzLmhhcyhuYW1lKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJQb3RlbnRpYWxOb2RlKGlkMiwgbm9kZSkge1xuICAgICAgdGhpcy5wb3RlbnRpYWxOb2Rlcy5zZXQoaWQyLCBub2RlKTtcbiAgICB9XG4gICAgbW91bnQoaW5zdGFuY2UsIGlzTGF5b3V0RGlydHkgPSBmYWxzZSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuaXNTVkcgPSBpbnN0YW5jZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgJiYgaW5zdGFuY2UudGFnTmFtZSAhPT0gXCJzdmdcIjtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgIGNvbnN0IHsgbGF5b3V0SWQsIGxheW91dCwgdmlzdWFsRWxlbWVudCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKHZpc3VhbEVsZW1lbnQgJiYgIXZpc3VhbEVsZW1lbnQuY3VycmVudCkge1xuICAgICAgICB2aXN1YWxFbGVtZW50Lm1vdW50KGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucm9vdC5ub2Rlcy5hZGQodGhpcyk7XG4gICAgICAoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkcmVuLmFkZCh0aGlzKTtcbiAgICAgIHRoaXMuZWxlbWVudElkICYmIHRoaXMucm9vdC5wb3RlbnRpYWxOb2Rlcy5kZWxldGUodGhpcy5lbGVtZW50SWQpO1xuICAgICAgaWYgKGlzTGF5b3V0RGlydHkgJiYgKGxheW91dCB8fCBsYXlvdXRJZCkpIHtcbiAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRhY2hSZXNpemVMaXN0ZW5lcikge1xuICAgICAgICBsZXQgY2FuY2VsRGVsYXk7XG4gICAgICAgIGNvbnN0IHJlc2l6ZVVuYmxvY2tVcGRhdGUgPSAoKSA9PiB0aGlzLnJvb3QudXBkYXRlQmxvY2tlZEJ5UmVzaXplID0gZmFsc2U7XG4gICAgICAgIGF0dGFjaFJlc2l6ZUxpc3RlbmVyKGluc3RhbmNlLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yb290LnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IHRydWU7XG4gICAgICAgICAgY2FuY2VsRGVsYXkgJiYgY2FuY2VsRGVsYXkoKTtcbiAgICAgICAgICBjYW5jZWxEZWxheSA9IGRlbGF5KHJlc2l6ZVVuYmxvY2tVcGRhdGUsIDI1MCk7XG4gICAgICAgICAgaWYgKGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplKSB7XG4gICAgICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGZpbmlzaEFuaW1hdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXlvdXRJZCkge1xuICAgICAgICB0aGlzLnJvb3QucmVnaXN0ZXJTaGFyZWROb2RlKGxheW91dElkLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UgJiYgdmlzdWFsRWxlbWVudCAmJiAobGF5b3V0SWQgfHwgbGF5b3V0KSkge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwgKHsgZGVsdGEsIGhhc0xheW91dENoYW5nZWQsIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCwgbGF5b3V0OiBuZXdMYXlvdXQgfSkgPT4ge1xuICAgICAgICAgIHZhciBfYTIsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgIGlmICh0aGlzLmlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsYXlvdXRUcmFuc2l0aW9uID0gKF9iID0gKF9hMiA9IHRoaXMub3B0aW9ucy50cmFuc2l0aW9uKSAhPT0gbnVsbCAmJiBfYTIgIT09IHZvaWQgMCA/IF9hMiA6IHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdExheW91dFRyYW5zaXRpb247XG4gICAgICAgICAgY29uc3QgeyBvbkxheW91dEFuaW1hdGlvblN0YXJ0LCBvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlIH0gPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Q2hhbmdlZCA9ICF0aGlzLnRhcmdldExheW91dCB8fCAhYm94RXF1YWxzKHRoaXMudGFyZ2V0TGF5b3V0LCBuZXdMYXlvdXQpIHx8IGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZDtcbiAgICAgICAgICBjb25zdCBoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gIWhhc0xheW91dENoYW5nZWQgJiYgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkO1xuICAgICAgICAgIGlmICgoKF9jID0gdGhpcy5yZXN1bWVGcm9tKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaW5zdGFuY2UpIHx8IGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgfHwgaGFzTGF5b3V0Q2hhbmdlZCAmJiAodGFyZ2V0Q2hhbmdlZCB8fCAhdGhpcy5jdXJyZW50QW5pbWF0aW9uKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1lRnJvbSkge1xuICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbSA9IHRoaXMucmVzdW1lRnJvbTtcbiAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20ucmVzdW1pbmdGcm9tID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRBbmltYXRpb25PcmlnaW4oZGVsdGEsIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQpO1xuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGdldFZhbHVlVHJhbnNpdGlvbihsYXlvdXRUcmFuc2l0aW9uLCBcImxheW91dFwiKSksIHtcbiAgICAgICAgICAgICAgb25QbGF5OiBvbkxheW91dEFuaW1hdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh2aXN1YWxFbGVtZW50LnNob3VsZFJlZHVjZU1vdGlvbikge1xuICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLmRlbGF5ID0gMDtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9ucy50eXBlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKGFuaW1hdGlvbk9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc0xheW91dENoYW5nZWQgJiYgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9PT0gMCkge1xuICAgICAgICAgICAgICBmaW5pc2hBbmltYXRpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzTGVhZCgpICYmICgoX2UgPSAoX2QgPSB0aGlzLm9wdGlvbnMpLm9uRXhpdENvbXBsZXRlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRhcmdldExheW91dCA9IG5ld0xheW91dDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVubW91bnQoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdGhpcy5vcHRpb25zLmxheW91dElkICYmIHRoaXMud2lsbFVwZGF0ZSgpO1xuICAgICAgdGhpcy5yb290Lm5vZGVzLnJlbW92ZSh0aGlzKTtcbiAgICAgIChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSh0aGlzKTtcbiAgICAgIChfYiA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hpbGRyZW4uZGVsZXRlKHRoaXMpO1xuICAgICAgdGhpcy5pbnN0YW5jZSA9IHZvaWQgMDtcbiAgICAgIGNhbmNlbFN5bmMucHJlUmVuZGVyKHRoaXMudXBkYXRlUHJvamVjdGlvbik7XG4gICAgfVxuICAgIGJsb2NrVXBkYXRlKCkge1xuICAgICAgdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgPSB0cnVlO1xuICAgIH1cbiAgICB1bmJsb2NrVXBkYXRlKCkge1xuICAgICAgdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaXNVcGRhdGVCbG9ja2VkKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkIHx8IHRoaXMudXBkYXRlQmxvY2tlZEJ5UmVzaXplO1xuICAgIH1cbiAgICBpc1RyZWVBbmltYXRpb25CbG9ja2VkKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIHRoaXMuaXNBbmltYXRpb25CbG9ja2VkIHx8ICgoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSkgfHwgZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0VXBkYXRlKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMuaXNVcGRhdGVCbG9ja2VkKCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuaXNVcGRhdGluZyA9IHRydWU7XG4gICAgICAoX2EgPSB0aGlzLm5vZGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChyZXNldFJvdGF0aW9uKTtcbiAgICB9XG4gICAgd2lsbFVwZGF0ZShzaG91bGROb3RpZnlMaXN0ZW5lcnMgPSB0cnVlKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGlmICh0aGlzLnJvb3QuaXNVcGRhdGVCbG9ja2VkKCkpIHtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAhdGhpcy5yb290LmlzVXBkYXRpbmcgJiYgdGhpcy5yb290LnN0YXJ0VXBkYXRlKCk7XG4gICAgICBpZiAodGhpcy5pc0xheW91dERpcnR5KVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGF0aC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpMl07XG4gICAgICAgIG5vZGUuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICBub2RlLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBsYXlvdXRJZCwgbGF5b3V0IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAobGF5b3V0SWQgPT09IHZvaWQgMCAmJiAhbGF5b3V0KVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZSA9IChfYyA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0UHJvcHMoKS50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICAgIHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB0cmFuc2Zvcm1UZW1wbGF0ZSA9PT0gbnVsbCB8fCB0cmFuc2Zvcm1UZW1wbGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpO1xuICAgICAgdGhpcy51cGRhdGVTbmFwc2hvdCgpO1xuICAgICAgc2hvdWxkTm90aWZ5TGlzdGVuZXJzICYmIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwid2lsbFVwZGF0ZVwiKTtcbiAgICB9XG4gICAgZGlkVXBkYXRlKCkge1xuICAgICAgY29uc3QgdXBkYXRlV2FzQmxvY2tlZCA9IHRoaXMuaXNVcGRhdGVCbG9ja2VkKCk7XG4gICAgICBpZiAodXBkYXRlV2FzQmxvY2tlZCkge1xuICAgICAgICB0aGlzLnVuYmxvY2tVcGRhdGUoKTtcbiAgICAgICAgdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJNZWFzdXJlbWVudHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNVcGRhdGluZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5wb3RlbnRpYWxOb2Rlcy5zaXplKSB7XG4gICAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMuZm9yRWFjaChtb3VudE5vZGVFYXJseSk7XG4gICAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChyZXNldFRyYW5zZm9ybVN0eWxlKTtcbiAgICAgIHRoaXMubm9kZXMuZm9yRWFjaCh1cGRhdGVMYXlvdXQpO1xuICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKG5vdGlmeUxheW91dFVwZGF0ZSk7XG4gICAgICB0aGlzLmNsZWFyQWxsU25hcHNob3RzKCk7XG4gICAgICBmbHVzaFN5bmMudXBkYXRlKCk7XG4gICAgICBmbHVzaFN5bmMucHJlUmVuZGVyKCk7XG4gICAgICBmbHVzaFN5bmMucmVuZGVyKCk7XG4gICAgfVxuICAgIGNsZWFyQWxsU25hcHNob3RzKCkge1xuICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNsZWFyU25hcHNob3QpO1xuICAgICAgdGhpcy5zaGFyZWROb2Rlcy5mb3JFYWNoKHJlbW92ZUxlYWRTbmFwc2hvdHMpO1xuICAgIH1cbiAgICBzY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24oKSB7XG4gICAgICBlc19kZWZhdWx0LnByZVJlbmRlcih0aGlzLnVwZGF0ZVByb2plY3Rpb24sIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgc2NoZWR1bGVDaGVja0FmdGVyVW5tb3VudCgpIHtcbiAgICAgIGVzX2RlZmF1bHQucG9zdFJlbmRlcigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgICB0aGlzLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yb290LmNoZWNrVXBkYXRlRmFpbGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVTbmFwc2hvdCgpIHtcbiAgICAgIGlmICh0aGlzLnNuYXBzaG90IHx8ICF0aGlzLmluc3RhbmNlKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnNuYXBzaG90ID0gdGhpcy5tZWFzdXJlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUxheW91dCgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy51cGRhdGVTY3JvbGwoKTtcbiAgICAgIGlmICghKHRoaXMub3B0aW9ucy5hbHdheXNNZWFzdXJlTGF5b3V0ICYmIHRoaXMuaXNMZWFkKCkpICYmICF0aGlzLmlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVzdW1lRnJvbSAmJiAhdGhpcy5yZXN1bWVGcm9tLmluc3RhbmNlKSB7XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0aGlzLnBhdGgubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpMl07XG4gICAgICAgICAgbm9kZS51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcHJldkxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgICAgdGhpcy5sYXlvdXQgPSB0aGlzLm1lYXN1cmUoZmFsc2UpO1xuICAgICAgdGhpcy5sYXlvdXRDb3JyZWN0ZWQgPSBjcmVhdGVCb3goKTtcbiAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xuICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSB2b2lkIDA7XG4gICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcIm1lYXN1cmVcIiwgdGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgIChfYSA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm90aWZ5KFwiTGF5b3V0TWVhc3VyZVwiLCB0aGlzLmxheW91dC5sYXlvdXRCb3gsIHByZXZMYXlvdXQgPT09IG51bGwgfHwgcHJldkxheW91dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldkxheW91dC5sYXlvdXRCb3gpO1xuICAgIH1cbiAgICB1cGRhdGVTY3JvbGwoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxheW91dFNjcm9sbCAmJiB0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuaXNTY3JvbGxSb290ID0gY2hlY2tJc1Njcm9sbFJvb3QodGhpcy5pbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsID0gbWVhc3VyZVNjcm9sbCh0aGlzLmluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXJlc2V0VHJhbnNmb3JtKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpc1Jlc2V0UmVxdWVzdGVkID0gdGhpcy5pc0xheW91dERpcnR5IHx8IHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm07XG4gICAgICBjb25zdCBoYXNQcm9qZWN0aW9uID0gdGhpcy5wcm9qZWN0aW9uRGVsdGEgJiYgIWlzRGVsdGFaZXJvKHRoaXMucHJvamVjdGlvbkRlbHRhKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlID0gKF9hID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQcm9wcygpLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHRyYW5zZm9ybVRlbXBsYXRlID09PSBudWxsIHx8IHRyYW5zZm9ybVRlbXBsYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLmxhdGVzdFZhbHVlcywgXCJcIik7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZUhhc0NoYW5nZWQgPSB0cmFuc2Zvcm1UZW1wbGF0ZVZhbHVlICE9PSB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlO1xuICAgICAgaWYgKGlzUmVzZXRSZXF1ZXN0ZWQgJiYgKGhhc1Byb2plY3Rpb24gfHwgaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSB8fCB0cmFuc2Zvcm1UZW1wbGF0ZUhhc0NoYW5nZWQpKSB7XG4gICAgICAgIHJlc2V0VHJhbnNmb3JtKHRoaXMuaW5zdGFuY2UsIHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUpO1xuICAgICAgICB0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZShyZW1vdmVUcmFuc2Zvcm0gPSB0cnVlKSB7XG4gICAgICBjb25zdCBwYWdlQm94ID0gdGhpcy5tZWFzdXJlUGFnZUJveCgpO1xuICAgICAgbGV0IGxheW91dEJveCA9IHRoaXMucmVtb3ZlRWxlbWVudFNjcm9sbChwYWdlQm94KTtcbiAgICAgIGlmIChyZW1vdmVUcmFuc2Zvcm0pIHtcbiAgICAgICAgbGF5b3V0Qm94ID0gdGhpcy5yZW1vdmVUcmFuc2Zvcm0obGF5b3V0Qm94KTtcbiAgICAgIH1cbiAgICAgIHJvdW5kQm94KGxheW91dEJveCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWFzdXJlZEJveDogcGFnZUJveCxcbiAgICAgICAgbGF5b3V0Qm94LFxuICAgICAgICBsYXRlc3RWYWx1ZXM6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBtZWFzdXJlUGFnZUJveCgpIHtcbiAgICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICByZXR1cm4gY3JlYXRlQm94KCk7XG4gICAgICBjb25zdCBib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICAgICAgY29uc3QgeyBzY3JvbGw6IHNjcm9sbDIgfSA9IHRoaXMucm9vdDtcbiAgICAgIGlmIChzY3JvbGwyKSB7XG4gICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94LngsIHNjcm9sbDIueCk7XG4gICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94LnksIHNjcm9sbDIueSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm94O1xuICAgIH1cbiAgICByZW1vdmVFbGVtZW50U2Nyb2xsKGJveCkge1xuICAgICAgY29uc3QgYm94V2l0aG91dFNjcm9sbCA9IGNyZWF0ZUJveCgpO1xuICAgICAgY29weUJveEludG8oYm94V2l0aG91dFNjcm9sbCwgYm94KTtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0aGlzLnBhdGgubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaTJdO1xuICAgICAgICBjb25zdCB7IHNjcm9sbDogc2Nyb2xsMiwgb3B0aW9ucywgaXNTY3JvbGxSb290IH0gPSBub2RlO1xuICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5yb290ICYmIHNjcm9sbDIgJiYgb3B0aW9ucy5sYXlvdXRTY3JvbGwpIHtcbiAgICAgICAgICBpZiAoaXNTY3JvbGxSb290KSB7XG4gICAgICAgICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0U2Nyb2xsLCBib3gpO1xuICAgICAgICAgICAgY29uc3QgeyBzY3JvbGw6IHJvb3RTY3JvbGwgfSA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIGlmIChyb290U2Nyb2xsKSB7XG4gICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC54LCAtcm9vdFNjcm9sbC54KTtcbiAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLnksIC1yb290U2Nyb2xsLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueCwgc2Nyb2xsMi54KTtcbiAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueSwgc2Nyb2xsMi55KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJveFdpdGhvdXRTY3JvbGw7XG4gICAgfVxuICAgIGFwcGx5VHJhbnNmb3JtKGJveCwgdHJhbnNmb3JtT25seSA9IGZhbHNlKSB7XG4gICAgICBjb25zdCB3aXRoVHJhbnNmb3JtcyA9IGNyZWF0ZUJveCgpO1xuICAgICAgY29weUJveEludG8od2l0aFRyYW5zZm9ybXMsIGJveCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgdGhpcy5wYXRoLmxlbmd0aDsgaTIrKykge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2kyXTtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1Pbmx5ICYmIG5vZGUub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiYgbm9kZS5zY3JvbGwgJiYgbm9kZSAhPT0gbm9kZS5yb290KSB7XG4gICAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCB7XG4gICAgICAgICAgICB4OiAtbm9kZS5zY3JvbGwueCxcbiAgICAgICAgICAgIHk6IC1ub2RlLnNjcm9sbC55XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0cmFuc2Zvcm1Cb3god2l0aFRyYW5zZm9ybXMsIG5vZGUubGF0ZXN0VmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3JtcywgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhUcmFuc2Zvcm1zO1xuICAgIH1cbiAgICByZW1vdmVUcmFuc2Zvcm0oYm94KSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBib3hXaXRob3V0VHJhbnNmb3JtID0gY3JlYXRlQm94KCk7XG4gICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0VHJhbnNmb3JtLCBib3gpO1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGF0aC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpMl07XG4gICAgICAgIGlmICghbm9kZS5pbnN0YW5jZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBoYXNTY2FsZShub2RlLmxhdGVzdFZhbHVlcykgJiYgbm9kZS51cGRhdGVTbmFwc2hvdCgpO1xuICAgICAgICBjb25zdCBzb3VyY2VCb3ggPSBjcmVhdGVCb3goKTtcbiAgICAgICAgY29uc3Qgbm9kZUJveCA9IG5vZGUubWVhc3VyZVBhZ2VCb3goKTtcbiAgICAgICAgY29weUJveEludG8oc291cmNlQm94LCBub2RlQm94KTtcbiAgICAgICAgcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3hXaXRob3V0VHJhbnNmb3JtLCBub2RlLmxhdGVzdFZhbHVlcywgKF9hID0gbm9kZS5zbmFwc2hvdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxheW91dEJveCwgc291cmNlQm94KTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94V2l0aG91dFRyYW5zZm9ybSwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveFdpdGhvdXRUcmFuc2Zvcm07XG4gICAgfVxuICAgIHNldFRhcmdldERlbHRhKGRlbHRhKSB7XG4gICAgICB0aGlzLnRhcmdldERlbHRhID0gZGVsdGE7XG4gICAgICB0aGlzLnJvb3Quc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uKCk7XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucyksIHtcbiAgICAgICAgY3Jvc3NmYWRlOiBvcHRpb25zLmNyb3NzZmFkZSAhPT0gdm9pZCAwID8gb3B0aW9ucy5jcm9zc2ZhZGUgOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJNZWFzdXJlbWVudHMoKSB7XG4gICAgICB0aGlzLnNjcm9sbCA9IHZvaWQgMDtcbiAgICAgIHRoaXMubGF5b3V0ID0gdm9pZCAwO1xuICAgICAgdGhpcy5zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICAgIHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLnRhcmdldERlbHRhID0gdm9pZCAwO1xuICAgICAgdGhpcy50YXJnZXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVzb2x2ZVRhcmdldERlbHRhKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBsYXlvdXQsIGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICEobGF5b3V0IHx8IGxheW91dElkKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLnRhcmdldERlbHRhICYmICF0aGlzLnJlbGF0aXZlVGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGFyZW50ID0gdGhpcy5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICBpZiAocmVsYXRpdmVQYXJlbnQgJiYgcmVsYXRpdmVQYXJlbnQubGF5b3V0KSB7XG4gICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudCA9IHJlbGF0aXZlUGFyZW50O1xuICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24odGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCByZWxhdGl2ZVBhcmVudC5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmICF0aGlzLnRhcmdldERlbHRhKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoIXRoaXMudGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgIHRoaXMudGFyZ2V0V2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gJiYgKChfYSA9IHRoaXMucmVsYXRpdmVQYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50YXJnZXQpKSB7XG4gICAgICAgIGNhbGNSZWxhdGl2ZUJveCh0aGlzLnRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVBhcmVudC50YXJnZXQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldERlbHRhKSB7XG4gICAgICAgIGlmIChCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSkge1xuICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5hcHBseVRyYW5zZm9ybSh0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMudGFyZ2V0LCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5Qm94RGVsdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0RGVsdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUJveEludG8odGhpcy50YXJnZXQsIHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXJlbnQgPSB0aGlzLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhcmVudCAmJiBCb29sZWFuKHJlbGF0aXZlUGFyZW50LnJlc3VtaW5nRnJvbSkgPT09IEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pICYmICFyZWxhdGl2ZVBhcmVudC5vcHRpb25zLmxheW91dFNjcm9sbCAmJiByZWxhdGl2ZVBhcmVudC50YXJnZXQpIHtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gcmVsYXRpdmVQYXJlbnQ7XG4gICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbih0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCB0aGlzLnRhcmdldCwgcmVsYXRpdmVQYXJlbnQudGFyZ2V0KTtcbiAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpIHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQgfHwgaGFzU2NhbGUodGhpcy5wYXJlbnQubGF0ZXN0VmFsdWVzKSB8fCBoYXMyRFRyYW5zbGF0ZSh0aGlzLnBhcmVudC5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgaWYgKCh0aGlzLnBhcmVudC5yZWxhdGl2ZVRhcmdldCB8fCB0aGlzLnBhcmVudC50YXJnZXREZWx0YSkgJiYgdGhpcy5wYXJlbnQubGF5b3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYWxjUHJvamVjdGlvbigpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHsgbGF5b3V0LCBsYXlvdXRJZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy5pc1RyZWVBbmltYXRpbmcgPSBCb29sZWFuKCgoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVHJlZUFuaW1hdGluZykgfHwgdGhpcy5jdXJyZW50QW5pbWF0aW9uIHx8IHRoaXMucGVuZGluZ0FuaW1hdGlvbik7XG4gICAgICBpZiAoIXRoaXMuaXNUcmVlQW5pbWF0aW5nKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmxheW91dCB8fCAhKGxheW91dCB8fCBsYXlvdXRJZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgIGNvcHlCb3hJbnRvKHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgYXBwbHlUcmVlRGVsdGFzKHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0aGlzLnRyZWVTY2FsZSwgdGhpcy5wYXRoLCBCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSB8fCB0aGlzICE9PSBsZWFkKTtcbiAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBsZWFkO1xuICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghdGhpcy5wcm9qZWN0aW9uRGVsdGEpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0gPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldlRyZWVTY2FsZVggPSB0aGlzLnRyZWVTY2FsZS54O1xuICAgICAgY29uc3QgcHJldlRyZWVTY2FsZVkgPSB0aGlzLnRyZWVTY2FsZS55O1xuICAgICAgY29uc3QgcHJldlByb2plY3Rpb25UcmFuc2Zvcm0gPSB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm07XG4gICAgICBjYWxjQm94RGVsdGEodGhpcy5wcm9qZWN0aW9uRGVsdGEsIHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0YXJnZXQsIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybSA9IGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSh0aGlzLnByb2plY3Rpb25EZWx0YSwgdGhpcy50cmVlU2NhbGUpO1xuICAgICAgaWYgKHRoaXMucHJvamVjdGlvblRyYW5zZm9ybSAhPT0gcHJldlByb2plY3Rpb25UcmFuc2Zvcm0gfHwgdGhpcy50cmVlU2NhbGUueCAhPT0gcHJldlRyZWVTY2FsZVggfHwgdGhpcy50cmVlU2NhbGUueSAhPT0gcHJldlRyZWVTY2FsZVkpIHtcbiAgICAgICAgdGhpcy5oYXNQcm9qZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwicHJvamVjdGlvblVwZGF0ZVwiLCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgc2NoZWR1bGVSZW5kZXIobm90aWZ5QWxsMiA9IHRydWUpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5zY2hlZHVsZVJlbmRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgbm90aWZ5QWxsMiAmJiAoKF9jID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2NoZWR1bGVSZW5kZXIoKSk7XG4gICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20gJiYgIXRoaXMucmVzdW1pbmdGcm9tLmluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMucmVzdW1pbmdGcm9tID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRBbmltYXRpb25PcmlnaW4oZGVsdGEsIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSBmYWxzZSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLnNuYXBzaG90O1xuICAgICAgY29uc3Qgc25hcHNob3RMYXRlc3RWYWx1ZXMgPSAoc25hcHNob3QgPT09IG51bGwgfHwgc25hcHNob3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNuYXBzaG90LmxhdGVzdFZhbHVlcykgfHwge307XG4gICAgICBjb25zdCBtaXhlZFZhbHVlcyA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICBjb25zdCB0YXJnZXREZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0ID0gIWhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICBjb25zdCByZWxhdGl2ZUxheW91dCA9IGNyZWF0ZUJveCgpO1xuICAgICAgY29uc3QgaXNTaGFyZWRMYXlvdXRBbmltYXRpb24gPSBzbmFwc2hvdCA9PT0gbnVsbCB8fCBzbmFwc2hvdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc25hcHNob3QuaXNTaGFyZWQ7XG4gICAgICBjb25zdCBpc09ubHlNZW1iZXIgPSAoKChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lbWJlcnMubGVuZ3RoKSB8fCAwKSA8PSAxO1xuICAgICAgY29uc3Qgc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSA9IEJvb2xlYW4oaXNTaGFyZWRMYXlvdXRBbmltYXRpb24gJiYgIWlzT25seU1lbWJlciAmJiB0aGlzLm9wdGlvbnMuY3Jvc3NmYWRlID09PSB0cnVlICYmICF0aGlzLnBhdGguc29tZShoYXNPcGFjaXR5Q3Jvc3NmYWRlKSk7XG4gICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzID0gMDtcbiAgICAgIHRoaXMubWl4VGFyZ2V0RGVsdGEgPSAobGF0ZXN0KSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzMyA9IGxhdGVzdCAvIDFlMztcbiAgICAgICAgbWl4QXhpc0RlbHRhKHRhcmdldERlbHRhLngsIGRlbHRhLngsIHByb2dyZXNzMyk7XG4gICAgICAgIG1peEF4aXNEZWx0YSh0YXJnZXREZWx0YS55LCBkZWx0YS55LCBwcm9ncmVzczMpO1xuICAgICAgICB0aGlzLnNldFRhcmdldERlbHRhKHRhcmdldERlbHRhKTtcbiAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVUYXJnZXQgJiYgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiAmJiB0aGlzLmxheW91dCAmJiAoKF9hMiA9IHRoaXMucmVsYXRpdmVQYXJlbnQpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLmxheW91dCkpIHtcbiAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZUxheW91dCwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCB0aGlzLnJlbGF0aXZlUGFyZW50LmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgIG1peEJveCh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCByZWxhdGl2ZUxheW91dCwgcHJvZ3Jlc3MzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTaGFyZWRMYXlvdXRBbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvblZhbHVlcyA9IG1peGVkVmFsdWVzO1xuICAgICAgICAgIG1peFZhbHVlcyhtaXhlZFZhbHVlcywgc25hcHNob3RMYXRlc3RWYWx1ZXMsIHRoaXMubGF0ZXN0VmFsdWVzLCBwcm9ncmVzczMsIHNob3VsZENyb3NzZmFkZU9wYWNpdHksIGlzT25seU1lbWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290LnNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSBwcm9ncmVzczM7XG4gICAgICB9O1xuICAgICAgdGhpcy5taXhUYXJnZXREZWx0YSgwKTtcbiAgICB9XG4gICAgc3RhcnRBbmltYXRpb24ob3B0aW9ucykge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwiYW5pbWF0aW9uU3RhcnRcIik7XG4gICAgICAoX2EgPSB0aGlzLmN1cnJlbnRBbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7XG4gICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgKF9iID0gdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdBbmltYXRpb24pIHtcbiAgICAgICAgY2FuY2VsU3luYy51cGRhdGUodGhpcy5wZW5kaW5nQW5pbWF0aW9uKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gZXNfZGVmYXVsdC51cGRhdGUoKCkgPT4ge1xuICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGUyKDAsIGFuaW1hdGlvblRhcmdldCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgICBvblVwZGF0ZTogKGxhdGVzdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgIHRoaXMubWl4VGFyZ2V0RGVsdGEobGF0ZXN0KTtcbiAgICAgICAgICAgIChfYTIgPSBvcHRpb25zLm9uVXBkYXRlKSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMi5jYWxsKG9wdGlvbnMsIGxhdGVzdCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgKF9hMiA9IG9wdGlvbnMub25Db21wbGV0ZSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVBbmltYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHRoaXMucmVzdW1pbmdGcm9tKSB7XG4gICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuY3VycmVudEFuaW1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSB2b2lkIDA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29tcGxldGVBbmltYXRpb24oKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20ucHJlc2VydmVPcGFjaXR5ID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXhpdEFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICB0aGlzLnJlc3VtaW5nRnJvbSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uVmFsdWVzID0gdm9pZCAwO1xuICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJhbmltYXRpb25Db21wbGV0ZVwiKTtcbiAgICB9XG4gICAgZmluaXNoQW5pbWF0aW9uKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgICAoX2EgPSB0aGlzLm1peFRhcmdldERlbHRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBhbmltYXRpb25UYXJnZXQpO1xuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24uc3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpO1xuICAgIH1cbiAgICBhcHBseVRyYW5zZm9ybXNUb1RhcmdldCgpIHtcbiAgICAgIGNvbnN0IGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgIGxldCB7IHRhcmdldFdpdGhUcmFuc2Zvcm1zLCB0YXJnZXQsIGxheW91dCwgbGF0ZXN0VmFsdWVzIH0gPSBsZWFkO1xuICAgICAgaWYgKCF0YXJnZXRXaXRoVHJhbnNmb3JtcyB8fCAhdGFyZ2V0IHx8ICFsYXlvdXQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzICE9PSBsZWFkICYmIHRoaXMubGF5b3V0ICYmIGxheW91dCAmJiBzaG91bGRBbmltYXRlUG9zaXRpb25Pbmx5KHRoaXMub3B0aW9ucy5hbmltYXRpb25UeXBlLCB0aGlzLmxheW91dC5sYXlvdXRCb3gsIGxheW91dC5sYXlvdXRCb3gpKSB7XG4gICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0IHx8IGNyZWF0ZUJveCgpO1xuICAgICAgICBjb25zdCB4TGVuZ3RoID0gY2FsY0xlbmd0aCh0aGlzLmxheW91dC5sYXlvdXRCb3gueCk7XG4gICAgICAgIHRhcmdldC54Lm1pbiA9IGxlYWQudGFyZ2V0LngubWluO1xuICAgICAgICB0YXJnZXQueC5tYXggPSB0YXJnZXQueC5taW4gKyB4TGVuZ3RoO1xuICAgICAgICBjb25zdCB5TGVuZ3RoID0gY2FsY0xlbmd0aCh0aGlzLmxheW91dC5sYXlvdXRCb3gueSk7XG4gICAgICAgIHRhcmdldC55Lm1pbiA9IGxlYWQudGFyZ2V0LnkubWluO1xuICAgICAgICB0YXJnZXQueS5tYXggPSB0YXJnZXQueS5taW4gKyB5TGVuZ3RoO1xuICAgICAgfVxuICAgICAgY29weUJveEludG8odGFyZ2V0V2l0aFRyYW5zZm9ybXMsIHRhcmdldCk7XG4gICAgICB0cmFuc2Zvcm1Cb3godGFyZ2V0V2l0aFRyYW5zZm9ybXMsIGxhdGVzdFZhbHVlcyk7XG4gICAgICBjYWxjQm94RGVsdGEodGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtLCB0aGlzLmxheW91dENvcnJlY3RlZCwgdGFyZ2V0V2l0aFRyYW5zZm9ybXMsIGxhdGVzdFZhbHVlcyk7XG4gICAgfVxuICAgIHJlZ2lzdGVyU2hhcmVkTm9kZShsYXlvdXRJZCwgbm9kZSkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBpZiAoIXRoaXMuc2hhcmVkTm9kZXMuaGFzKGxheW91dElkKSkge1xuICAgICAgICB0aGlzLnNoYXJlZE5vZGVzLnNldChsYXlvdXRJZCwgbmV3IE5vZGVTdGFjaygpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5zaGFyZWROb2Rlcy5nZXQobGF5b3V0SWQpO1xuICAgICAgc3RhY2suYWRkKG5vZGUpO1xuICAgICAgbm9kZS5wcm9tb3RlKHtcbiAgICAgICAgdHJhbnNpdGlvbjogKF9hID0gbm9kZS5vcHRpb25zLmluaXRpYWxQcm9tb3Rpb25Db25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmFuc2l0aW9uLFxuICAgICAgICBwcmVzZXJ2ZUZvbGxvd09wYWNpdHk6IChfYyA9IChfYiA9IG5vZGUub3B0aW9ucy5pbml0aWFsUHJvbW90aW9uQ29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hvdWxkUHJlc2VydmVGb2xsb3dPcGFjaXR5KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgbm9kZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpc0xlYWQoKSB7XG4gICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgIHJldHVybiBzdGFjayA/IHN0YWNrLmxlYWQgPT09IHRoaXMgOiB0cnVlO1xuICAgIH1cbiAgICBnZXRMZWFkKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBsYXlvdXRJZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgcmV0dXJuIGxheW91dElkID8gKChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlYWQpIHx8IHRoaXMgOiB0aGlzO1xuICAgIH1cbiAgICBnZXRQcmV2TGVhZCgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHsgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIHJldHVybiBsYXlvdXRJZCA/IChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZXZMZWFkIDogdm9pZCAwO1xuICAgIH1cbiAgICBnZXRTdGFjaygpIHtcbiAgICAgIGNvbnN0IHsgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChsYXlvdXRJZClcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5zaGFyZWROb2Rlcy5nZXQobGF5b3V0SWQpO1xuICAgIH1cbiAgICBwcm9tb3RlKHsgbmVlZHNSZXNldCwgdHJhbnNpdGlvbiwgcHJlc2VydmVGb2xsb3dPcGFjaXR5IH0gPSB7fSkge1xuICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICBpZiAoc3RhY2spXG4gICAgICAgIHN0YWNrLnByb21vdGUodGhpcywgcHJlc2VydmVGb2xsb3dPcGFjaXR5KTtcbiAgICAgIGlmIChuZWVkc1Jlc2V0KSB7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zaXRpb24pXG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyh7IHRyYW5zaXRpb24gfSk7XG4gICAgfVxuICAgIHJlbGVnYXRlKCkge1xuICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrLnJlbGVnYXRlKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXNldFJvdGF0aW9uKCkge1xuICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBoYXNSb3RhdGUgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHJlc2V0VmFsdWVzID0ge307XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgdHJhbnNmb3JtQXhlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgY29uc3QgYXhpcyA9IHRyYW5zZm9ybUF4ZXNbaTJdO1xuICAgICAgICBjb25zdCBrZXkgPSBcInJvdGF0ZVwiICsgYXhpcztcbiAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50LmdldFN0YXRpY1ZhbHVlKGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBoYXNSb3RhdGUgPSB0cnVlO1xuICAgICAgICByZXNldFZhbHVlc1trZXldID0gdmlzdWFsRWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXkpO1xuICAgICAgICB2aXN1YWxFbGVtZW50LnNldFN0YXRpY1ZhbHVlKGtleSwgMCk7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1JvdGF0ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50LnJlbmRlcigpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzZXRWYWx1ZXMpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRTdGF0aWNWYWx1ZShrZXksIHJlc2V0VmFsdWVzW2tleV0pO1xuICAgICAgfVxuICAgICAgdmlzdWFsRWxlbWVudC5zY2hlZHVsZVJlbmRlcigpO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0aW9uU3R5bGVzKHN0eWxlUHJvcCA9IHt9KSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHt9O1xuICAgICAgaWYgKCF0aGlzLmluc3RhbmNlIHx8IHRoaXMuaXNTVkcpXG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlcy52aXNpYmlsaXR5ID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlID0gKF9hID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQcm9wcygpLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgaWYgKHRoaXMubmVlZHNSZXNldCkge1xuICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3R5bGVzLm9wYWNpdHkgPSBcIlwiO1xuICAgICAgICBzdHlsZXMucG9pbnRlckV2ZW50cyA9IHJlc29sdmVNb3Rpb25WYWx1ZShzdHlsZVByb3AucG9pbnRlckV2ZW50cykgfHwgXCJcIjtcbiAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlID8gdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpIDogXCJub25lXCI7XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICB9XG4gICAgICBjb25zdCBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICBpZiAoIXRoaXMucHJvamVjdGlvbkRlbHRhIHx8ICF0aGlzLmxheW91dCB8fCAhbGVhZC50YXJnZXQpIHtcbiAgICAgICAgY29uc3QgZW1wdHlTdHlsZXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRJZCkge1xuICAgICAgICAgIGVtcHR5U3R5bGVzLm9wYWNpdHkgPSB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5ICE9PSB2b2lkIDAgPyB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5IDogMTtcbiAgICAgICAgICBlbXB0eVN0eWxlcy5wb2ludGVyRXZlbnRzID0gcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc1Byb2plY3RlZCAmJiAhaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgIGVtcHR5U3R5bGVzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlID8gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpIDogXCJub25lXCI7XG4gICAgICAgICAgdGhpcy5oYXNQcm9qZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1wdHlTdHlsZXM7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZXNUb1JlbmRlciA9IGxlYWQuYW5pbWF0aW9uVmFsdWVzIHx8IGxlYWQubGF0ZXN0VmFsdWVzO1xuICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXNUb1RhcmdldCgpO1xuICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSh0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0sIHRoaXMudHJlZVNjYWxlLCB2YWx1ZXNUb1JlbmRlcik7XG4gICAgICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlKHZhbHVlc1RvUmVuZGVyLCBzdHlsZXMudHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5wcm9qZWN0aW9uRGVsdGE7XG4gICAgICBzdHlsZXMudHJhbnNmb3JtT3JpZ2luID0gYCR7eC5vcmlnaW4gKiAxMDB9JSAke3kub3JpZ2luICogMTAwfSUgMGA7XG4gICAgICBpZiAobGVhZC5hbmltYXRpb25WYWx1ZXMpIHtcbiAgICAgICAgc3R5bGVzLm9wYWNpdHkgPSBsZWFkID09PSB0aGlzID8gKF9jID0gKF9iID0gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMSA6IHRoaXMucHJlc2VydmVPcGFjaXR5ID8gdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eSA6IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHlFeGl0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVzLm9wYWNpdHkgPSBsZWFkID09PSB0aGlzID8gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSAhPT0gdm9pZCAwID8gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSA6IFwiXCIgOiB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdCAhPT0gdm9pZCAwID8gdmFsdWVzVG9SZW5kZXIub3BhY2l0eUV4aXQgOiAwO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NhbGVDb3JyZWN0b3JzKSB7XG4gICAgICAgIGlmICh2YWx1ZXNUb1JlbmRlcltrZXldID09PSB2b2lkIDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHsgY29ycmVjdCwgYXBwbHlUbyB9ID0gc2NhbGVDb3JyZWN0b3JzW2tleV07XG4gICAgICAgIGNvbnN0IGNvcnJlY3RlZCA9IGNvcnJlY3QodmFsdWVzVG9SZW5kZXJba2V5XSwgbGVhZCk7XG4gICAgICAgIGlmIChhcHBseVRvKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gYXBwbHlUby5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bTsgaTIrKykge1xuICAgICAgICAgICAgc3R5bGVzW2FwcGx5VG9baTJdXSA9IGNvcnJlY3RlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVzW2tleV0gPSBjb3JyZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0SWQpIHtcbiAgICAgICAgc3R5bGVzLnBvaW50ZXJFdmVudHMgPSBsZWFkID09PSB0aGlzID8gcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiIDogXCJub25lXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH1cbiAgICBjbGVhclNuYXBzaG90KCkge1xuICAgICAgdGhpcy5yZXN1bWVGcm9tID0gdGhpcy5zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmVzZXRUcmVlKCkge1xuICAgICAgdGhpcy5yb290Lm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gbm9kZS5jdXJyZW50QW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJvb3Qubm9kZXMuZm9yRWFjaChjbGVhck1lYXN1cmVtZW50cyk7XG4gICAgICB0aGlzLnJvb3Quc2hhcmVkTm9kZXMuY2xlYXIoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVMYXlvdXQobm9kZSkge1xuICBub2RlLnVwZGF0ZUxheW91dCgpO1xufVxuZnVuY3Rpb24gbm90aWZ5TGF5b3V0VXBkYXRlKG5vZGUpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGNvbnN0IHNuYXBzaG90ID0gKChfYSA9IG5vZGUucmVzdW1lRnJvbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNuYXBzaG90KSB8fCBub2RlLnNuYXBzaG90O1xuICBpZiAobm9kZS5pc0xlYWQoKSAmJiBub2RlLmxheW91dCAmJiBzbmFwc2hvdCAmJiBub2RlLmhhc0xpc3RlbmVycyhcImRpZFVwZGF0ZVwiKSkge1xuICAgIGNvbnN0IHsgbGF5b3V0Qm94OiBsYXlvdXQsIG1lYXN1cmVkQm94OiBtZWFzdXJlZExheW91dCB9ID0gbm9kZS5sYXlvdXQ7XG4gICAgY29uc3QgeyBhbmltYXRpb25UeXBlIH0gPSBub2RlLm9wdGlvbnM7XG4gICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IFwic2l6ZVwiKSB7XG4gICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICBjb25zdCBheGlzU25hcHNob3QgPSBzbmFwc2hvdC5pc1NoYXJlZCA/IHNuYXBzaG90Lm1lYXN1cmVkQm94W2F4aXNdIDogc25hcHNob3QubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjYWxjTGVuZ3RoKGF4aXNTbmFwc2hvdCk7XG4gICAgICAgIGF4aXNTbmFwc2hvdC5taW4gPSBsYXlvdXRbYXhpc10ubWluO1xuICAgICAgICBheGlzU25hcHNob3QubWF4ID0gYXhpc1NuYXBzaG90Lm1pbiArIGxlbmd0aDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkQW5pbWF0ZVBvc2l0aW9uT25seShhbmltYXRpb25UeXBlLCBzbmFwc2hvdC5sYXlvdXRCb3gsIGxheW91dCkpIHtcbiAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgIGNvbnN0IGF4aXNTbmFwc2hvdCA9IHNuYXBzaG90LmlzU2hhcmVkID8gc25hcHNob3QubWVhc3VyZWRCb3hbYXhpc10gOiBzbmFwc2hvdC5sYXlvdXRCb3hbYXhpc107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNhbGNMZW5ndGgobGF5b3V0W2F4aXNdKTtcbiAgICAgICAgYXhpc1NuYXBzaG90Lm1heCA9IGF4aXNTbmFwc2hvdC5taW4gKyBsZW5ndGg7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbGF5b3V0RGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgIGNhbGNCb3hEZWx0YShsYXlvdXREZWx0YSwgbGF5b3V0LCBzbmFwc2hvdC5sYXlvdXRCb3gpO1xuICAgIGNvbnN0IHZpc3VhbERlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICBpZiAoc25hcHNob3QuaXNTaGFyZWQpIHtcbiAgICAgIGNhbGNCb3hEZWx0YSh2aXN1YWxEZWx0YSwgbm9kZS5hcHBseVRyYW5zZm9ybShtZWFzdXJlZExheW91dCwgdHJ1ZSksIHNuYXBzaG90Lm1lYXN1cmVkQm94KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsY0JveERlbHRhKHZpc3VhbERlbHRhLCBsYXlvdXQsIHNuYXBzaG90LmxheW91dEJveCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc0xheW91dENoYW5nZWQgPSAhaXNEZWx0YVplcm8obGF5b3V0RGVsdGEpO1xuICAgIGxldCBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAoIW5vZGUucmVzdW1lRnJvbSkge1xuICAgICAgY29uc3QgcmVsYXRpdmVQYXJlbnQgPSBub2RlLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICBpZiAocmVsYXRpdmVQYXJlbnQgJiYgIXJlbGF0aXZlUGFyZW50LnJlc3VtZUZyb20pIHtcbiAgICAgICAgY29uc3QgeyBzbmFwc2hvdDogcGFyZW50U25hcHNob3QsIGxheW91dDogcGFyZW50TGF5b3V0IH0gPSByZWxhdGl2ZVBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudFNuYXBzaG90ICYmIHBhcmVudExheW91dCkge1xuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlU25hcHNob3QgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZVNuYXBzaG90LCBzbmFwc2hvdC5sYXlvdXRCb3gsIHBhcmVudFNuYXBzaG90LmxheW91dEJveCk7XG4gICAgICAgICAgY29uc3QgcmVsYXRpdmVMYXlvdXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZUxheW91dCwgbGF5b3V0LCBwYXJlbnRMYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICBpZiAoIWJveEVxdWFscyhyZWxhdGl2ZVNuYXBzaG90LCByZWxhdGl2ZUxheW91dCkpIHtcbiAgICAgICAgICAgIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUubm90aWZ5TGlzdGVuZXJzKFwiZGlkVXBkYXRlXCIsIHtcbiAgICAgIGxheW91dCxcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZGVsdGE6IHZpc3VhbERlbHRhLFxuICAgICAgbGF5b3V0RGVsdGEsXG4gICAgICBoYXNMYXlvdXRDaGFuZ2VkLFxuICAgICAgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobm9kZS5pc0xlYWQoKSkge1xuICAgIChfYyA9IChfYiA9IG5vZGUub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgfVxuICBub2RlLm9wdGlvbnMudHJhbnNpdGlvbiA9IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGNsZWFyU25hcHNob3Qobm9kZSkge1xuICBub2RlLmNsZWFyU25hcHNob3QoKTtcbn1cbmZ1bmN0aW9uIGNsZWFyTWVhc3VyZW1lbnRzKG5vZGUpIHtcbiAgbm9kZS5jbGVhck1lYXN1cmVtZW50cygpO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm1TdHlsZShub2RlKSB7XG4gIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gbm9kZS5vcHRpb25zO1xuICBpZiAodmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50LmdldFByb3BzKCkub25CZWZvcmVMYXlvdXRNZWFzdXJlKSB7XG4gICAgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJCZWZvcmVMYXlvdXRNZWFzdXJlXCIpO1xuICB9XG4gIG5vZGUucmVzZXRUcmFuc2Zvcm0oKTtcbn1cbmZ1bmN0aW9uIGZpbmlzaEFuaW1hdGlvbihub2RlKSB7XG4gIG5vZGUuZmluaXNoQW5pbWF0aW9uKCk7XG4gIG5vZGUudGFyZ2V0RGVsdGEgPSBub2RlLnJlbGF0aXZlVGFyZ2V0ID0gbm9kZS50YXJnZXQgPSB2b2lkIDA7XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0RGVsdGEobm9kZSkge1xuICBub2RlLnJlc29sdmVUYXJnZXREZWx0YSgpO1xufVxuZnVuY3Rpb24gY2FsY1Byb2plY3Rpb24obm9kZSkge1xuICBub2RlLmNhbGNQcm9qZWN0aW9uKCk7XG59XG5mdW5jdGlvbiByZXNldFJvdGF0aW9uKG5vZGUpIHtcbiAgbm9kZS5yZXNldFJvdGF0aW9uKCk7XG59XG5mdW5jdGlvbiByZW1vdmVMZWFkU25hcHNob3RzKHN0YWNrKSB7XG4gIHN0YWNrLnJlbW92ZUxlYWRTbmFwc2hvdCgpO1xufVxuZnVuY3Rpb24gbWl4QXhpc0RlbHRhKG91dHB1dCwgZGVsdGEsIHAyKSB7XG4gIG91dHB1dC50cmFuc2xhdGUgPSBtaXgoZGVsdGEudHJhbnNsYXRlLCAwLCBwMik7XG4gIG91dHB1dC5zY2FsZSA9IG1peChkZWx0YS5zY2FsZSwgMSwgcDIpO1xuICBvdXRwdXQub3JpZ2luID0gZGVsdGEub3JpZ2luO1xuICBvdXRwdXQub3JpZ2luUG9pbnQgPSBkZWx0YS5vcmlnaW5Qb2ludDtcbn1cbmZ1bmN0aW9uIG1peEF4aXMob3V0cHV0LCBmcm9tLCB0bywgcDIpIHtcbiAgb3V0cHV0Lm1pbiA9IG1peChmcm9tLm1pbiwgdG8ubWluLCBwMik7XG4gIG91dHB1dC5tYXggPSBtaXgoZnJvbS5tYXgsIHRvLm1heCwgcDIpO1xufVxuZnVuY3Rpb24gbWl4Qm94KG91dHB1dCwgZnJvbSwgdG8sIHAyKSB7XG4gIG1peEF4aXMob3V0cHV0LngsIGZyb20ueCwgdG8ueCwgcDIpO1xuICBtaXhBeGlzKG91dHB1dC55LCBmcm9tLnksIHRvLnksIHAyKTtcbn1cbmZ1bmN0aW9uIGhhc09wYWNpdHlDcm9zc2ZhZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5hbmltYXRpb25WYWx1ZXMgJiYgbm9kZS5hbmltYXRpb25WYWx1ZXMub3BhY2l0eUV4aXQgIT09IHZvaWQgMDtcbn1cbnZhciBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbiA9IHtcbiAgZHVyYXRpb246IDAuNDUsXG4gIGVhc2U6IFswLjQsIDAsIDAuMSwgMV1cbn07XG5mdW5jdGlvbiBtb3VudE5vZGVFYXJseShub2RlLCBpZDIpIHtcbiAgbGV0IHNlYXJjaE5vZGUgPSBub2RlLnJvb3Q7XG4gIGZvciAobGV0IGkyID0gbm9kZS5wYXRoLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBpZiAoQm9vbGVhbihub2RlLnBhdGhbaTJdLmluc3RhbmNlKSkge1xuICAgICAgc2VhcmNoTm9kZSA9IG5vZGUucGF0aFtpMl07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2VhcmNoRWxlbWVudCA9IHNlYXJjaE5vZGUgJiYgc2VhcmNoTm9kZSAhPT0gbm9kZS5yb290ID8gc2VhcmNoTm9kZS5pbnN0YW5jZSA6IGRvY3VtZW50O1xuICBjb25zdCBlbGVtZW50ID0gc2VhcmNoRWxlbWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wcm9qZWN0aW9uLWlkPVwiJHtpZDJ9XCJdYCk7XG4gIGlmIChlbGVtZW50KVxuICAgIG5vZGUubW91bnQoZWxlbWVudCwgdHJ1ZSk7XG59XG5mdW5jdGlvbiByb3VuZEF4aXMoYXhpcykge1xuICBheGlzLm1pbiA9IE1hdGgucm91bmQoYXhpcy5taW4pO1xuICBheGlzLm1heCA9IE1hdGgucm91bmQoYXhpcy5tYXgpO1xufVxuZnVuY3Rpb24gcm91bmRCb3goYm94KSB7XG4gIHJvdW5kQXhpcyhib3gueCk7XG4gIHJvdW5kQXhpcyhib3gueSk7XG59XG5mdW5jdGlvbiBzaG91bGRBbmltYXRlUG9zaXRpb25Pbmx5KGFuaW1hdGlvblR5cGUsIHNuYXBzaG90LCBsYXlvdXQpIHtcbiAgcmV0dXJuIGFuaW1hdGlvblR5cGUgPT09IFwicG9zaXRpb25cIiB8fCBhbmltYXRpb25UeXBlID09PSBcInByZXNlcnZlLWFzcGVjdFwiICYmICFpc0Nsb3NlVG8oYXNwZWN0UmF0aW8oc25hcHNob3QpLCBhc3BlY3RSYXRpbyhsYXlvdXQpLCAwLjIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9Eb2N1bWVudFByb2plY3Rpb25Ob2RlLm1qc1xudmFyIERvY3VtZW50UHJvamVjdGlvbk5vZGUgPSBjcmVhdGVQcm9qZWN0aW9uTm9kZSh7XG4gIGF0dGFjaFJlc2l6ZUxpc3RlbmVyOiAocmVmLCBub3RpZnkpID0+IGFkZERvbUV2ZW50KHJlZiwgXCJyZXNpemVcIiwgbm90aWZ5KSxcbiAgbWVhc3VyZVNjcm9sbDogKCkgPT4gKHtcbiAgICB4OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsXG4gICAgeTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcFxuICB9KSxcbiAgY2hlY2tJc1Njcm9sbFJvb3Q6ICgpID0+IHRydWVcbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9IVE1MUHJvamVjdGlvbk5vZGUubWpzXG52YXIgcm9vdFByb2plY3Rpb25Ob2RlID0ge1xuICBjdXJyZW50OiB2b2lkIDBcbn07XG52YXIgSFRNTFByb2plY3Rpb25Ob2RlID0gY3JlYXRlUHJvamVjdGlvbk5vZGUoe1xuICBtZWFzdXJlU2Nyb2xsOiAoaW5zdGFuY2UpID0+ICh7XG4gICAgeDogaW5zdGFuY2Uuc2Nyb2xsTGVmdCxcbiAgICB5OiBpbnN0YW5jZS5zY3JvbGxUb3BcbiAgfSksXG4gIGRlZmF1bHRQYXJlbnQ6ICgpID0+IHtcbiAgICBpZiAoIXJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50KSB7XG4gICAgICBjb25zdCBkb2N1bWVudE5vZGUgPSBuZXcgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSgwLCB7fSk7XG4gICAgICBkb2N1bWVudE5vZGUubW91bnQod2luZG93KTtcbiAgICAgIGRvY3VtZW50Tm9kZS5zZXRPcHRpb25zKHsgbGF5b3V0U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQgPSBkb2N1bWVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiByb290UHJvamVjdGlvbk5vZGUuY3VycmVudDtcbiAgfSxcbiAgcmVzZXRUcmFuc2Zvcm06IChpbnN0YW5jZSwgdmFsdWUpID0+IHtcbiAgICBpbnN0YW5jZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBcIm5vbmVcIjtcbiAgfSxcbiAgY2hlY2tJc1Njcm9sbFJvb3Q6IChpbnN0YW5jZSkgPT4gQm9vbGVhbih3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbnN0YW5jZSkucG9zaXRpb24gPT09IFwiZml4ZWRcIilcbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vbW90aW9uLm1qc1xudmFyIGZlYXR1cmVCdW5kbGUgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgYW5pbWF0aW9ucyksIGdlc3R1cmVBbmltYXRpb25zKSwgZHJhZyksIGxheW91dEZlYXR1cmVzKTtcbnZhciBtb3Rpb24gPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlTW90aW9uUHJveHkoKENvbXBvbmVudCwgY29uZmlnKSA9PiBjcmVhdGVEb21Nb3Rpb25Db25maWcoQ29tcG9uZW50LCBjb25maWcsIGZlYXR1cmVCdW5kbGUsIGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQsIEhUTUxQcm9qZWN0aW9uTm9kZSkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2NsYW1wLmVzLmpzXG52YXIgY2xhbXAzID0gKG1pbiwgbWF4LCB2KSA9PiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2lzLW51bWJlci5lcy5qc1xudmFyIGlzTnVtYmVyID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvaXMtZWFzaW5nLWxpc3QuZXMuanNcbnZhciBpc0Vhc2luZ0xpc3QgPSAoZWFzaW5nKSA9PiBBcnJheS5pc0FycmF5KGVhc2luZykgJiYgIWlzTnVtYmVyKGVhc2luZ1swXSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3Qvd3JhcC5lcy5qc1xudmFyIHdyYXAgPSAobWluLCBtYXgsIHYpID0+IHtcbiAgY29uc3QgcmFuZ2VTaXplID0gbWF4IC0gbWluO1xuICByZXR1cm4gKCh2IC0gbWluKSAlIHJhbmdlU2l6ZSArIHJhbmdlU2l6ZSkgJSByYW5nZVNpemUgKyBtaW47XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2Vhc2luZy5lcy5qc1xuZnVuY3Rpb24gZ2V0RWFzaW5nRm9yU2VnbWVudChlYXNpbmcsIGkyKSB7XG4gIHJldHVybiBpc0Vhc2luZ0xpc3QoZWFzaW5nKSA/IGVhc2luZ1t3cmFwKDAsIGVhc2luZy5sZW5ndGgsIGkyKV0gOiBlYXNpbmc7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvbWl4LmVzLmpzXG52YXIgbWl4MiA9IChtaW4sIG1heCwgcHJvZ3Jlc3MzKSA9PiAtcHJvZ3Jlc3MzICogbWluICsgcHJvZ3Jlc3MzICogbWF4ICsgbWluO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L25vb3AuZXMuanNcbnZhciBub29wUmV0dXJuID0gKHYpID0+IHY7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvcHJvZ3Jlc3MuZXMuanNcbnZhciBwcm9ncmVzczIgPSAobWluLCBtYXgsIHZhbHVlKSA9PiBtYXggLSBtaW4gPT09IDAgPyAxIDogKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L29mZnNldC5lcy5qc1xuZnVuY3Rpb24gZmlsbE9mZnNldChvZmZzZXQsIHJlbWFpbmluZykge1xuICBjb25zdCBtaW4gPSBvZmZzZXRbb2Zmc2V0Lmxlbmd0aCAtIDFdO1xuICBmb3IgKGxldCBpMiA9IDE7IGkyIDw9IHJlbWFpbmluZzsgaTIrKykge1xuICAgIGNvbnN0IG9mZnNldFByb2dyZXNzID0gcHJvZ3Jlc3MyKDAsIHJlbWFpbmluZywgaTIpO1xuICAgIG9mZnNldC5wdXNoKG1peDIobWluLCAxLCBvZmZzZXRQcm9ncmVzcykpO1xuICB9XG59XG5mdW5jdGlvbiBkZWZhdWx0T2Zmc2V0MihsZW5ndGgpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gWzBdO1xuICBmaWxsT2Zmc2V0KG9mZnNldCwgbGVuZ3RoIC0gMSk7XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvaW50ZXJwb2xhdGUuZXMuanNcbmZ1bmN0aW9uIGludGVycG9sYXRlMihvdXRwdXQsIGlucHV0ID0gZGVmYXVsdE9mZnNldDIob3V0cHV0Lmxlbmd0aCksIGVhc2luZyA9IG5vb3BSZXR1cm4pIHtcbiAgY29uc3QgbGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcbiAgY29uc3QgcmVtYWluZGVyID0gbGVuZ3RoIC0gaW5wdXQubGVuZ3RoO1xuICByZW1haW5kZXIgPiAwICYmIGZpbGxPZmZzZXQoaW5wdXQsIHJlbWFpbmRlcik7XG4gIHJldHVybiAodCkgPT4ge1xuICAgIGxldCBpMiA9IDA7XG4gICAgZm9yICg7IGkyIDwgbGVuZ3RoIC0gMjsgaTIrKykge1xuICAgICAgaWYgKHQgPCBpbnB1dFtpMiArIDFdKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IHByb2dyZXNzSW5SYW5nZSA9IGNsYW1wMygwLCAxLCBwcm9ncmVzczIoaW5wdXRbaTJdLCBpbnB1dFtpMiArIDFdLCB0KSk7XG4gICAgY29uc3Qgc2VnbWVudEVhc2luZyA9IGdldEVhc2luZ0ZvclNlZ21lbnQoZWFzaW5nLCBpMik7XG4gICAgcHJvZ3Jlc3NJblJhbmdlID0gc2VnbWVudEVhc2luZyhwcm9ncmVzc0luUmFuZ2UpO1xuICAgIHJldHVybiBtaXgyKG91dHB1dFtpMl0sIG91dHB1dFtpMiArIDFdLCBwcm9ncmVzc0luUmFuZ2UpO1xuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2lzLWZ1bmN0aW9uLmVzLmpzXG52YXIgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvaXMtc3RyaW5nLmVzLmpzXG52YXIgaXNTdHJpbmcyID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvdmVsb2NpdHkuZXMuanNcbmZ1bmN0aW9uIHZlbG9jaXR5UGVyU2Vjb25kMih2ZWxvY2l0eSwgZnJhbWVEdXJhdGlvbikge1xuICByZXR1cm4gZnJhbWVEdXJhdGlvbiA/IHZlbG9jaXR5ICogKDFlMyAvIGZyYW1lRHVyYXRpb24pIDogMDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvdXRpbHMvcmVzb2x2ZS1lbGVtZW50cy5lcy5qc1xuZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnRzKGVsZW1lbnRzLCBzZWxlY3RvckNhY2hlKSB7XG4gIHZhciBfYTtcbiAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChzZWxlY3RvckNhY2hlKSB7XG4gICAgICAoX2EgPSBzZWxlY3RvckNhY2hlW2VsZW1lbnRzXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2VsZWN0b3JDYWNoZVtlbGVtZW50c10gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRzKTtcbiAgICAgIGVsZW1lbnRzID0gc2VsZWN0b3JDYWNoZVtlbGVtZW50c107XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbGVtZW50cyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50cyB8fCBbXSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy90c2xpYi9tb2R1bGVzL2luZGV4LmpzXG52YXIgaW1wb3J0X3RzbGliNCA9IF9fdG9FU00ocmVxdWlyZV90c2xpYjIoKSwgMSk7XG52YXIge1xuICBfX2V4dGVuZHM6IF9fZXh0ZW5kczIsXG4gIF9fYXNzaWduOiBfX2Fzc2lnbjIsXG4gIF9fcmVzdDogX19yZXN0MixcbiAgX19kZWNvcmF0ZTogX19kZWNvcmF0ZTIsXG4gIF9fcGFyYW06IF9fcGFyYW0yLFxuICBfX21ldGFkYXRhOiBfX21ldGFkYXRhMixcbiAgX19hd2FpdGVyOiBfX2F3YWl0ZXIyLFxuICBfX2dlbmVyYXRvcjogX19nZW5lcmF0b3IyLFxuICBfX2V4cG9ydFN0YXI6IF9fZXhwb3J0U3RhcjIsXG4gIF9fY3JlYXRlQmluZGluZzogX19jcmVhdGVCaW5kaW5nMixcbiAgX192YWx1ZXM6IF9fdmFsdWVzMixcbiAgX19yZWFkOiBfX3JlYWQyLFxuICBfX3NwcmVhZDogX19zcHJlYWQyLFxuICBfX3NwcmVhZEFycmF5czogX19zcHJlYWRBcnJheXMyLFxuICBfX3NwcmVhZEFycmF5OiBfX3NwcmVhZEFycmF5MixcbiAgX19hd2FpdDogX19hd2FpdDIsXG4gIF9fYXN5bmNHZW5lcmF0b3I6IF9fYXN5bmNHZW5lcmF0b3IyLFxuICBfX2FzeW5jRGVsZWdhdG9yOiBfX2FzeW5jRGVsZWdhdG9yMixcbiAgX19hc3luY1ZhbHVlczogX19hc3luY1ZhbHVlczIsXG4gIF9fbWFrZVRlbXBsYXRlT2JqZWN0OiBfX21ha2VUZW1wbGF0ZU9iamVjdDIsXG4gIF9faW1wb3J0U3RhcjogX19pbXBvcnRTdGFyMixcbiAgX19pbXBvcnREZWZhdWx0OiBfX2ltcG9ydERlZmF1bHQyLFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MixcbiAgX19jbGFzc1ByaXZhdGVGaWVsZFNldDogX19jbGFzc1ByaXZhdGVGaWVsZFNldDIsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJbjogX19jbGFzc1ByaXZhdGVGaWVsZEluMlxufSA9IGltcG9ydF90c2xpYjQuZGVmYXVsdDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvcmVzaXplL2hhbmRsZS1lbGVtZW50LmVzLmpzXG52YXIgcmVzaXplSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBvYnNlcnZlcjtcbmZ1bmN0aW9uIGdldEVsZW1lbnRTaXplKHRhcmdldCwgYm9yZGVyQm94U2l6ZSkge1xuICBpZiAoYm9yZGVyQm94U2l6ZSkge1xuICAgIGNvbnN0IHsgaW5saW5lU2l6ZSwgYmxvY2tTaXplIH0gPSBib3JkZXJCb3hTaXplWzBdO1xuICAgIHJldHVybiB7IHdpZHRoOiBpbmxpbmVTaXplLCBoZWlnaHQ6IGJsb2NrU2l6ZSB9O1xuICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgJiYgXCJnZXRCQm94XCIgaW4gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5nZXRCQm94KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0YXJnZXQub2Zmc2V0V2lkdGgsXG4gICAgICBoZWlnaHQ6IHRhcmdldC5vZmZzZXRIZWlnaHRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBub3RpZnlUYXJnZXQoeyB0YXJnZXQsIGNvbnRlbnRSZWN0LCBib3JkZXJCb3hTaXplIH0pIHtcbiAgdmFyIF9hO1xuICAoX2EgPSByZXNpemVIYW5kbGVycy5nZXQodGFyZ2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICBoYW5kbGVyKHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRlbnRTaXplOiBjb250ZW50UmVjdCxcbiAgICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gZ2V0RWxlbWVudFNpemUodGFyZ2V0LCBib3JkZXJCb3hTaXplKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBub3RpZnlBbGwoZW50cmllcykge1xuICBlbnRyaWVzLmZvckVhY2gobm90aWZ5VGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKCkge1xuICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybjtcbiAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIobm90aWZ5QWxsKTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUVsZW1lbnQodGFyZ2V0LCBoYW5kbGVyKSB7XG4gIGlmICghb2JzZXJ2ZXIpXG4gICAgY3JlYXRlUmVzaXplT2JzZXJ2ZXIoKTtcbiAgY29uc3QgZWxlbWVudHMgPSByZXNvbHZlRWxlbWVudHModGFyZ2V0KTtcbiAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgIGxldCBlbGVtZW50SGFuZGxlcnMgPSByZXNpemVIYW5kbGVycy5nZXQoZWxlbWVudCk7XG4gICAgaWYgKCFlbGVtZW50SGFuZGxlcnMpIHtcbiAgICAgIGVsZW1lbnRIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICByZXNpemVIYW5kbGVycy5zZXQoZWxlbWVudCwgZWxlbWVudEhhbmRsZXJzKTtcbiAgICB9XG4gICAgZWxlbWVudEhhbmRsZXJzLmFkZChoYW5kbGVyKTtcbiAgICBvYnNlcnZlciA9PT0gbnVsbCB8fCBvYnNlcnZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudEhhbmRsZXJzID0gcmVzaXplSGFuZGxlcnMuZ2V0KGVsZW1lbnQpO1xuICAgICAgZWxlbWVudEhhbmRsZXJzID09PSBudWxsIHx8IGVsZW1lbnRIYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudEhhbmRsZXJzLmRlbGV0ZShoYW5kbGVyKTtcbiAgICAgIGlmICghKGVsZW1lbnRIYW5kbGVycyA9PT0gbnVsbCB8fCBlbGVtZW50SGFuZGxlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnRIYW5kbGVycy5zaXplKSkge1xuICAgICAgICBvYnNlcnZlciA9PT0gbnVsbCB8fCBvYnNlcnZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9yZXNpemUvaGFuZGxlLXdpbmRvdy5lcy5qc1xudmFyIHdpbmRvd0NhbGxiYWNrcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgd2luZG93UmVzaXplSGFuZGxlcjtcbmZ1bmN0aW9uIGNyZWF0ZVdpbmRvd1Jlc2l6ZUhhbmRsZXIoKSB7XG4gIHdpbmRvd1Jlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBpbmZvID0ge1xuICAgICAgdGFyZ2V0OiB3aW5kb3csXG4gICAgICBzaXplLFxuICAgICAgY29udGVudFNpemU6IHNpemVcbiAgICB9O1xuICAgIHdpbmRvd0NhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soaW5mbykpO1xuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB3aW5kb3dSZXNpemVIYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZVdpbmRvdyhjYWxsYmFjaykge1xuICB3aW5kb3dDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgaWYgKCF3aW5kb3dSZXNpemVIYW5kbGVyKVxuICAgIGNyZWF0ZVdpbmRvd1Jlc2l6ZUhhbmRsZXIoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB3aW5kb3dDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICBpZiAoIXdpbmRvd0NhbGxiYWNrcy5zaXplICYmIHdpbmRvd1Jlc2l6ZUhhbmRsZXIpIHtcbiAgICAgIHdpbmRvd1Jlc2l6ZUhhbmRsZXIgPSB2b2lkIDA7XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9yZXNpemUvaW5kZXguZXMuanNcbmZ1bmN0aW9uIHJlc2l6ZShhMiwgYjIpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oYTIpID8gcmVzaXplV2luZG93KGEyKSA6IHJlc2l6ZUVsZW1lbnQoYTIsIGIyKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL2luZm8uZXMuanNcbnZhciBtYXhFbGFwc2VkMiA9IDUwO1xudmFyIGNyZWF0ZUF4aXNJbmZvID0gKCkgPT4gKHtcbiAgY3VycmVudDogMCxcbiAgb2Zmc2V0OiBbXSxcbiAgcHJvZ3Jlc3M6IDAsXG4gIHNjcm9sbExlbmd0aDogMCxcbiAgdGFyZ2V0T2Zmc2V0OiAwLFxuICB0YXJnZXRMZW5ndGg6IDAsXG4gIGNvbnRhaW5lckxlbmd0aDogMCxcbiAgdmVsb2NpdHk6IDBcbn0pO1xudmFyIGNyZWF0ZVNjcm9sbEluZm8gPSAoKSA9PiAoe1xuICB0aW1lOiAwLFxuICB4OiBjcmVhdGVBeGlzSW5mbygpLFxuICB5OiBjcmVhdGVBeGlzSW5mbygpXG59KTtcbnZhciBrZXlzID0ge1xuICB4OiB7XG4gICAgbGVuZ3RoOiBcIldpZHRoXCIsXG4gICAgcG9zaXRpb246IFwiTGVmdFwiXG4gIH0sXG4gIHk6IHtcbiAgICBsZW5ndGg6IFwiSGVpZ2h0XCIsXG4gICAgcG9zaXRpb246IFwiVG9wXCJcbiAgfVxufTtcbmZ1bmN0aW9uIHVwZGF0ZUF4aXNJbmZvKGVsZW1lbnQsIGF4aXNOYW1lLCBpbmZvLCB0aW1lKSB7XG4gIGNvbnN0IGF4aXMgPSBpbmZvW2F4aXNOYW1lXTtcbiAgY29uc3QgeyBsZW5ndGgsIHBvc2l0aW9uIH0gPSBrZXlzW2F4aXNOYW1lXTtcbiAgY29uc3QgcHJldiA9IGF4aXMuY3VycmVudDtcbiAgY29uc3QgcHJldlRpbWUgPSBpbmZvLnRpbWU7XG4gIGF4aXMuY3VycmVudCA9IGVsZW1lbnRbXCJzY3JvbGxcIiArIHBvc2l0aW9uXTtcbiAgYXhpcy5zY3JvbGxMZW5ndGggPSBlbGVtZW50W1wic2Nyb2xsXCIgKyBsZW5ndGhdIC0gZWxlbWVudFtcImNsaWVudFwiICsgbGVuZ3RoXTtcbiAgYXhpcy5vZmZzZXQubGVuZ3RoID0gMDtcbiAgYXhpcy5vZmZzZXRbMF0gPSAwO1xuICBheGlzLm9mZnNldFsxXSA9IGF4aXMuc2Nyb2xsTGVuZ3RoO1xuICBheGlzLnByb2dyZXNzID0gcHJvZ3Jlc3MyKDAsIGF4aXMuc2Nyb2xsTGVuZ3RoLCBheGlzLmN1cnJlbnQpO1xuICBjb25zdCBlbGFwc2VkID0gdGltZSAtIHByZXZUaW1lO1xuICBheGlzLnZlbG9jaXR5ID0gZWxhcHNlZCA+IG1heEVsYXBzZWQyID8gMCA6IHZlbG9jaXR5UGVyU2Vjb25kMihheGlzLmN1cnJlbnQgLSBwcmV2LCBlbGFwc2VkKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNjcm9sbEluZm8oZWxlbWVudCwgaW5mbywgdGltZSkge1xuICB1cGRhdGVBeGlzSW5mbyhlbGVtZW50LCBcInhcIiwgaW5mbywgdGltZSk7XG4gIHVwZGF0ZUF4aXNJbmZvKGVsZW1lbnQsIFwieVwiLCBpbmZvLCB0aW1lKTtcbiAgaW5mby50aW1lID0gdGltZTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL29mZnNldHMvaW5zZXQuZXMuanNcbmZ1bmN0aW9uIGNhbGNJbnNldChlbGVtZW50LCBjb250YWluZXIpIHtcbiAgbGV0IGluc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gIGxldCBjdXJyZW50ID0gZWxlbWVudDtcbiAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gY29udGFpbmVyKSB7XG4gICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgaW5zZXQueCArPSBjdXJyZW50Lm9mZnNldExlZnQ7XG4gICAgICBpbnNldC55ICs9IGN1cnJlbnQub2Zmc2V0VG9wO1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQub2Zmc2V0UGFyZW50O1xuICAgIH0gZWxzZSBpZiAoY3VycmVudCBpbnN0YW5jZW9mIFNWR0dyYXBoaWNzRWxlbWVudCAmJiBcImdldEJCb3hcIiBpbiBjdXJyZW50KSB7XG4gICAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gY3VycmVudC5nZXRCQm94KCk7XG4gICAgICBpbnNldC54ICs9IGxlZnQ7XG4gICAgICBpbnNldC55ICs9IHRvcDtcbiAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQudGFnTmFtZSAhPT0gXCJzdmdcIikge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5zZXQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9vZmZzZXRzL3ByZXNldHMuZXMuanNcbnZhciBTY3JvbGxPZmZzZXQgPSB7XG4gIEVudGVyOiBbXG4gICAgWzAsIDFdLFxuICAgIFsxLCAxXVxuICBdLFxuICBFeGl0OiBbXG4gICAgWzAsIDBdLFxuICAgIFsxLCAwXVxuICBdLFxuICBBbnk6IFtcbiAgICBbMSwgMF0sXG4gICAgWzAsIDFdXG4gIF0sXG4gIEFsbDogW1xuICAgIFswLCAwXSxcbiAgICBbMSwgMV1cbiAgXVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL29mZnNldHMvZWRnZS5lcy5qc1xudmFyIG5hbWVkRWRnZXMgPSB7XG4gIHN0YXJ0OiAwLFxuICBjZW50ZXI6IDAuNSxcbiAgZW5kOiAxXG59O1xuZnVuY3Rpb24gcmVzb2x2ZUVkZ2UoZWRnZSwgbGVuZ3RoLCBpbnNldCA9IDApIHtcbiAgbGV0IGRlbHRhID0gMDtcbiAgaWYgKG5hbWVkRWRnZXNbZWRnZV0gIT09IHZvaWQgMCkge1xuICAgIGVkZ2UgPSBuYW1lZEVkZ2VzW2VkZ2VdO1xuICB9XG4gIGlmIChpc1N0cmluZzIoZWRnZSkpIHtcbiAgICBjb25zdCBhc051bWJlcjIgPSBwYXJzZUZsb2F0KGVkZ2UpO1xuICAgIGlmIChlZGdlLmVuZHNXaXRoKFwicHhcIikpIHtcbiAgICAgIGRlbHRhID0gYXNOdW1iZXIyO1xuICAgIH0gZWxzZSBpZiAoZWRnZS5lbmRzV2l0aChcIiVcIikpIHtcbiAgICAgIGVkZ2UgPSBhc051bWJlcjIgLyAxMDA7XG4gICAgfSBlbHNlIGlmIChlZGdlLmVuZHNXaXRoKFwidndcIikpIHtcbiAgICAgIGRlbHRhID0gYXNOdW1iZXIyIC8gMTAwICogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIH0gZWxzZSBpZiAoZWRnZS5lbmRzV2l0aChcInZoXCIpKSB7XG4gICAgICBkZWx0YSA9IGFzTnVtYmVyMiAvIDEwMCAqIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkZ2UgPSBhc051bWJlcjI7XG4gICAgfVxuICB9XG4gIGlmIChpc051bWJlcihlZGdlKSkge1xuICAgIGRlbHRhID0gbGVuZ3RoICogZWRnZTtcbiAgfVxuICByZXR1cm4gaW5zZXQgKyBkZWx0YTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL29mZnNldHMvb2Zmc2V0LmVzLmpzXG52YXIgZGVmYXVsdE9mZnNldDMgPSBbMCwgMF07XG5mdW5jdGlvbiByZXNvbHZlT2Zmc2V0KG9mZnNldCwgY29udGFpbmVyTGVuZ3RoLCB0YXJnZXRMZW5ndGgsIHRhcmdldEluc2V0KSB7XG4gIGxldCBvZmZzZXREZWZpbml0aW9uID0gQXJyYXkuaXNBcnJheShvZmZzZXQpID8gb2Zmc2V0IDogZGVmYXVsdE9mZnNldDM7XG4gIGxldCB0YXJnZXRQb2ludCA9IDA7XG4gIGxldCBjb250YWluZXJQb2ludCA9IDA7XG4gIGlmIChpc051bWJlcihvZmZzZXQpKSB7XG4gICAgb2Zmc2V0RGVmaW5pdGlvbiA9IFtvZmZzZXQsIG9mZnNldF07XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcyKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQudHJpbSgpO1xuICAgIGlmIChvZmZzZXQuaW5jbHVkZXMoXCIgXCIpKSB7XG4gICAgICBvZmZzZXREZWZpbml0aW9uID0gb2Zmc2V0LnNwbGl0KFwiIFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0RGVmaW5pdGlvbiA9IFtvZmZzZXQsIG5hbWVkRWRnZXNbb2Zmc2V0XSA/IG9mZnNldCA6IGAwYF07XG4gICAgfVxuICB9XG4gIHRhcmdldFBvaW50ID0gcmVzb2x2ZUVkZ2Uob2Zmc2V0RGVmaW5pdGlvblswXSwgdGFyZ2V0TGVuZ3RoLCB0YXJnZXRJbnNldCk7XG4gIGNvbnRhaW5lclBvaW50ID0gcmVzb2x2ZUVkZ2Uob2Zmc2V0RGVmaW5pdGlvblsxXSwgY29udGFpbmVyTGVuZ3RoKTtcbiAgcmV0dXJuIHRhcmdldFBvaW50IC0gY29udGFpbmVyUG9pbnQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9vZmZzZXRzL2luZGV4LmVzLmpzXG52YXIgcG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbmZ1bmN0aW9uIHJlc29sdmVPZmZzZXRzKGNvbnRhaW5lciwgaW5mbywgb3B0aW9ucykge1xuICBsZXQgeyBvZmZzZXQ6IG9mZnNldERlZmluaXRpb24gPSBTY3JvbGxPZmZzZXQuQWxsIH0gPSBvcHRpb25zO1xuICBjb25zdCB7IHRhcmdldCA9IGNvbnRhaW5lciwgYXhpcyA9IFwieVwiIH0gPSBvcHRpb25zO1xuICBjb25zdCBsZW5ndGhMYWJlbCA9IGF4aXMgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgY29uc3QgaW5zZXQgPSB0YXJnZXQgIT09IGNvbnRhaW5lciA/IGNhbGNJbnNldCh0YXJnZXQsIGNvbnRhaW5lcikgOiBwb2ludDtcbiAgY29uc3QgdGFyZ2V0U2l6ZSA9IHRhcmdldCA9PT0gY29udGFpbmVyID8geyB3aWR0aDogY29udGFpbmVyLnNjcm9sbFdpZHRoLCBoZWlnaHQ6IGNvbnRhaW5lci5zY3JvbGxIZWlnaHQgfSA6IHsgd2lkdGg6IHRhcmdldC5jbGllbnRXaWR0aCwgaGVpZ2h0OiB0YXJnZXQuY2xpZW50SGVpZ2h0IH07XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSB7XG4gICAgd2lkdGg6IGNvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGNvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgfTtcbiAgaW5mb1theGlzXS5vZmZzZXQubGVuZ3RoID0gMDtcbiAgbGV0IGhhc0NoYW5nZWQgPSAhaW5mb1theGlzXS5pbnRlcnBvbGF0ZTtcbiAgY29uc3QgbnVtT2Zmc2V0cyA9IG9mZnNldERlZmluaXRpb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtT2Zmc2V0czsgaTIrKykge1xuICAgIGNvbnN0IG9mZnNldCA9IHJlc29sdmVPZmZzZXQob2Zmc2V0RGVmaW5pdGlvbltpMl0sIGNvbnRhaW5lclNpemVbbGVuZ3RoTGFiZWxdLCB0YXJnZXRTaXplW2xlbmd0aExhYmVsXSwgaW5zZXRbYXhpc10pO1xuICAgIGlmICghaGFzQ2hhbmdlZCAmJiBvZmZzZXQgIT09IGluZm9bYXhpc10uaW50ZXJwb2xhdG9yT2Zmc2V0c1tpMl0pIHtcbiAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpbmZvW2F4aXNdLm9mZnNldFtpMl0gPSBvZmZzZXQ7XG4gIH1cbiAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICBpbmZvW2F4aXNdLmludGVycG9sYXRlID0gaW50ZXJwb2xhdGUyKGRlZmF1bHRPZmZzZXQyKG51bU9mZnNldHMpLCBpbmZvW2F4aXNdLm9mZnNldCk7XG4gICAgaW5mb1theGlzXS5pbnRlcnBvbGF0b3JPZmZzZXRzID0gWy4uLmluZm9bYXhpc10ub2Zmc2V0XTtcbiAgfVxuICBpbmZvW2F4aXNdLnByb2dyZXNzID0gaW5mb1theGlzXS5pbnRlcnBvbGF0ZShpbmZvW2F4aXNdLmN1cnJlbnQpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvb24tc2Nyb2xsLWhhbmRsZXIuZXMuanNcbmZ1bmN0aW9uIG1lYXN1cmUoY29udGFpbmVyLCB0YXJnZXQgPSBjb250YWluZXIsIGluZm8pIHtcbiAgaW5mby54LnRhcmdldE9mZnNldCA9IDA7XG4gIGluZm8ueS50YXJnZXRPZmZzZXQgPSAwO1xuICBpZiAodGFyZ2V0ICE9PSBjb250YWluZXIpIHtcbiAgICBsZXQgbm9kZSA9IHRhcmdldDtcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9IGNvbnRhaW5lcikge1xuICAgICAgaW5mby54LnRhcmdldE9mZnNldCArPSBub2RlLm9mZnNldExlZnQ7XG4gICAgICBpbmZvLnkudGFyZ2V0T2Zmc2V0ICs9IG5vZGUub2Zmc2V0VG9wO1xuICAgICAgbm9kZSA9IG5vZGUub2Zmc2V0UGFyZW50O1xuICAgIH1cbiAgfVxuICBpbmZvLngudGFyZ2V0TGVuZ3RoID0gdGFyZ2V0ID09PSBjb250YWluZXIgPyB0YXJnZXQuc2Nyb2xsV2lkdGggOiB0YXJnZXQuY2xpZW50V2lkdGg7XG4gIGluZm8ueS50YXJnZXRMZW5ndGggPSB0YXJnZXQgPT09IGNvbnRhaW5lciA/IHRhcmdldC5zY3JvbGxIZWlnaHQgOiB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICBpbmZvLnguY29udGFpbmVyTGVuZ3RoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICBpbmZvLnkuY29udGFpbmVyTGVuZ3RoID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9uU2Nyb2xsSGFuZGxlcihlbGVtZW50LCBvblNjcm9sbCwgaW5mbywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgXCJ5XCI7XG4gIHJldHVybiB7XG4gICAgbWVhc3VyZTogKCkgPT4gbWVhc3VyZShlbGVtZW50LCBvcHRpb25zLnRhcmdldCwgaW5mbyksXG4gICAgdXBkYXRlOiAodGltZSkgPT4ge1xuICAgICAgdXBkYXRlU2Nyb2xsSW5mbyhlbGVtZW50LCBpbmZvLCB0aW1lKTtcbiAgICAgIGlmIChvcHRpb25zLm9mZnNldCB8fCBvcHRpb25zLnRhcmdldCkge1xuICAgICAgICByZXNvbHZlT2Zmc2V0cyhlbGVtZW50LCBpbmZvLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5vdGlmeTogaXNGdW5jdGlvbihvblNjcm9sbCkgPyAoKSA9PiBvblNjcm9sbChpbmZvKSA6IHNjcnViQW5pbWF0aW9uKG9uU2Nyb2xsLCBpbmZvW2F4aXNdKVxuICB9O1xufVxuZnVuY3Rpb24gc2NydWJBbmltYXRpb24oY29udHJvbHMsIGF4aXNJbmZvKSB7XG4gIGNvbnRyb2xzLnBhdXNlKCk7XG4gIGNvbnRyb2xzLmZvckVhY2hOYXRpdmUoKGFuaW1hdGlvbiwgeyBlYXNpbmcgfSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGFuaW1hdGlvbi51cGRhdGVEdXJhdGlvbikge1xuICAgICAgaWYgKCFlYXNpbmcpXG4gICAgICAgIGFuaW1hdGlvbi5lYXNpbmcgPSBub29wUmV0dXJuO1xuICAgICAgYW5pbWF0aW9uLnVwZGF0ZUR1cmF0aW9uKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0aW1pbmdPcHRpb25zID0geyBkdXJhdGlvbjogMWUzIH07XG4gICAgICBpZiAoIWVhc2luZylcbiAgICAgICAgdGltaW5nT3B0aW9ucy5lYXNpbmcgPSBcImxpbmVhclwiO1xuICAgICAgKF9iID0gKF9hID0gYW5pbWF0aW9uLmVmZmVjdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZVRpbWluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRpbWluZ09wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29udHJvbHMuY3VycmVudFRpbWUgPSBheGlzSW5mby5wcm9ncmVzcztcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL2luZGV4LmVzLmpzXG52YXIgc2Nyb2xsTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgcmVzaXplTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgb25TY3JvbGxIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIGdldEV2ZW50VGFyZ2V0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/IHdpbmRvdyA6IGVsZW1lbnQ7XG5mdW5jdGlvbiBzY3JvbGwob25TY3JvbGwsIF9hID0ge30pIHtcbiAgdmFyIHsgY29udGFpbmVyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IH0gPSBfYSwgb3B0aW9ucyA9IF9fcmVzdDIoX2EsIFtcImNvbnRhaW5lclwiXSk7XG4gIGxldCBjb250YWluZXJIYW5kbGVycyA9IG9uU2Nyb2xsSGFuZGxlcnMuZ2V0KGNvbnRhaW5lcik7XG4gIGlmICghY29udGFpbmVySGFuZGxlcnMpIHtcbiAgICBjb250YWluZXJIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgb25TY3JvbGxIYW5kbGVycy5zZXQoY29udGFpbmVyLCBjb250YWluZXJIYW5kbGVycyk7XG4gIH1cbiAgY29uc3QgaW5mbyA9IGNyZWF0ZVNjcm9sbEluZm8oKTtcbiAgY29uc3QgY29udGFpbmVySGFuZGxlciA9IGNyZWF0ZU9uU2Nyb2xsSGFuZGxlcihjb250YWluZXIsIG9uU2Nyb2xsLCBpbmZvLCBvcHRpb25zKTtcbiAgY29udGFpbmVySGFuZGxlcnMuYWRkKGNvbnRhaW5lckhhbmRsZXIpO1xuICBpZiAoIXNjcm9sbExpc3RlbmVycy5oYXMoY29udGFpbmVyKSkge1xuICAgIGNvbnN0IGxpc3RlbmVyMiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBjb250YWluZXJIYW5kbGVycylcbiAgICAgICAgaGFuZGxlci5tZWFzdXJlKCk7XG4gICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgY29udGFpbmVySGFuZGxlcnMpXG4gICAgICAgIGhhbmRsZXIudXBkYXRlKHRpbWUpO1xuICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGNvbnRhaW5lckhhbmRsZXJzKVxuICAgICAgICBoYW5kbGVyLm5vdGlmeSgpO1xuICAgIH07XG4gICAgc2Nyb2xsTGlzdGVuZXJzLnNldChjb250YWluZXIsIGxpc3RlbmVyMik7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoY29udGFpbmVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBsaXN0ZW5lcjIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICBpZiAoY29udGFpbmVyICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHJlc2l6ZUxpc3RlbmVycy5zZXQoY29udGFpbmVyLCByZXNpemUoY29udGFpbmVyLCBsaXN0ZW5lcjIpKTtcbiAgICB9XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbGlzdGVuZXIyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIH1cbiAgY29uc3QgbGlzdGVuZXIgPSBzY3JvbGxMaXN0ZW5lcnMuZ2V0KGNvbnRhaW5lcik7XG4gIGNvbnN0IG9uTG9hZFByb2Nlc3NzID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxpc3RlbmVyKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICh0eXBlb2Ygb25TY3JvbGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIG9uU2Nyb2xsLnN0b3AoKTtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShvbkxvYWRQcm9jZXNzcyk7XG4gICAgY29uc3QgY29udGFpbmVySGFuZGxlcnMyID0gb25TY3JvbGxIYW5kbGVycy5nZXQoY29udGFpbmVyKTtcbiAgICBpZiAoIWNvbnRhaW5lckhhbmRsZXJzMilcbiAgICAgIHJldHVybjtcbiAgICBjb250YWluZXJIYW5kbGVyczIuZGVsZXRlKGNvbnRhaW5lckhhbmRsZXIpO1xuICAgIGlmIChjb250YWluZXJIYW5kbGVyczIuc2l6ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsaXN0ZW5lcjIgPSBzY3JvbGxMaXN0ZW5lcnMuZ2V0KGNvbnRhaW5lcik7XG4gICAgc2Nyb2xsTGlzdGVuZXJzLmRlbGV0ZShjb250YWluZXIpO1xuICAgIGlmIChsaXN0ZW5lcjIpIHtcbiAgICAgIGdldEV2ZW50VGFyZ2V0KGNvbnRhaW5lcikucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBsaXN0ZW5lcjIpO1xuICAgICAgKF9hMiA9IHJlc2l6ZUxpc3RlbmVycy5nZXQoY29udGFpbmVyKSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIoKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGxpc3RlbmVyMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3VzZS1zY3JvbGwubWpzXG52YXIgaW1wb3J0X3JlYWN0MjggPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgY3JlYXRlU2Nyb2xsTW90aW9uVmFsdWVzID0gKCkgPT4gKHtcbiAgc2Nyb2xsWDogbW90aW9uVmFsdWUoMCksXG4gIHNjcm9sbFk6IG1vdGlvblZhbHVlKDApLFxuICBzY3JvbGxYUHJvZ3Jlc3M6IG1vdGlvblZhbHVlKDApLFxuICBzY3JvbGxZUHJvZ3Jlc3M6IG1vdGlvblZhbHVlKDApXG59KTtcbmZ1bmN0aW9uIHVzZVNjcm9sbChfYSA9IHt9KSB7XG4gIHZhciBfYiA9IF9hLCB7IGNvbnRhaW5lciwgdGFyZ2V0LCBsYXlvdXRFZmZlY3QgPSB0cnVlIH0gPSBfYiwgb3B0aW9ucyA9IF9fb2JqUmVzdChfYiwgW1wiY29udGFpbmVyXCIsIFwidGFyZ2V0XCIsIFwibGF5b3V0RWZmZWN0XCJdKTtcbiAgY29uc3QgdmFsdWVzID0gdXNlQ29uc3RhbnQoY3JlYXRlU2Nyb2xsTW90aW9uVmFsdWVzKTtcbiAgY29uc3QgdXNlTGlmZWN5Y2xlRWZmZWN0ID0gbGF5b3V0RWZmZWN0ID8gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA6IGltcG9ydF9yZWFjdDI4LnVzZUVmZmVjdDtcbiAgdXNlTGlmZWN5Y2xlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gc2Nyb2xsKCh7IHgsIHkgfSkgPT4ge1xuICAgICAgdmFsdWVzLnNjcm9sbFguc2V0KHguY3VycmVudCk7XG4gICAgICB2YWx1ZXMuc2Nyb2xsWFByb2dyZXNzLnNldCh4LnByb2dyZXNzKTtcbiAgICAgIHZhbHVlcy5zY3JvbGxZLnNldCh5LmN1cnJlbnQpO1xuICAgICAgdmFsdWVzLnNjcm9sbFlQcm9ncmVzcy5zZXQoeS5wcm9ncmVzcyk7XG4gICAgfSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIGNvbnRhaW5lcjogKGNvbnRhaW5lciA9PT0gbnVsbCB8fCBjb250YWluZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRhaW5lci5jdXJyZW50KSB8fCB2b2lkIDAsXG4gICAgICB0YXJnZXQ6ICh0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQuY3VycmVudCkgfHwgdm9pZCAwXG4gICAgfSkpO1xuICB9LCBbXSk7XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbi8vIHNyYy9NZW51LnRzeFxudmFyIGltcG9ydF9qc3hfcnVudGltZTIgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgTWVudSA9ICgpID0+IHtcbiAgY29uc3QgeyBzY3JvbGxZUHJvZ3Jlc3MgfSA9IHVzZVNjcm9sbCgpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeHMpKFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwiaGlkZGVuIHNtOmJsb2NrXCIsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKG1vdGlvbi5kaXYsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInByb2dyZXNzLWJhclwiLFxuICAgICAgICBzdHlsZTogeyBzY2FsZVg6IHNjcm9sbFlQcm9ncmVzcyB9XG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3hzKShcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gYmctZ3JhZGllbnQtdG8tciBmcm9tLWJsdWUtNDAwIHRvLWJsdWUtNTAwXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCIvXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlB5bGFyXFx1MjEyMiBBSVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyb3VuZGVkLXhsIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiL2Jsb2dcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiRGFpbHkgV29ya1wiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyb3VuZGVkLXhsIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiL3doYXQtaXMtcHlsYXJcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQWJvdXRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4KShcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicm91bmRlZC14bCBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGVcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4KShcImFcIiwge1xuICAgICAgICAgICAgICBocmVmOiBcIi9weWxhci1saWNlbnNlXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlRoZSBMaWNlbnNlXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCJodHRwczovL3BlbmNpbC5kb21haW5zXCIsXG4gICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgcmVsOiBcIm5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUGVuY2lsIERvbWFpbnNcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4cykoXCJkaXZcIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImhpZGRlbiBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGUgbWQ6YmxvY2tcIixcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4KShcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImhpZGRlbiBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGUgbWQ6YmxvY2tcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgICAgICAgIGhyZWY6IFwiaHR0cDovL3R3aXR0ZXIuY29tL3N1cGVyZGF0YXNcIixcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgICAgIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJUd2l0dGVyXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgICAgICBocmVmOiBcImh0dHA6Ly9naXRodWIuY29tL21pZ3VlbGdhcmdhbGxvL25leHQxMy1nYWxsZXJ5LWltYWdlLXR1cmJvXCIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgICAgIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImhpZGRlbiBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGUgbWQ6YmxvY2tcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoXCJwaWN0dXJlXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4KShcImltZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHNyYzogXCJodHRwczovL2ltZy5zaGllbGRzLmlvL2dpdGh1Yi9zdGFycy9taWd1ZWxnYXJnYWxsby9OZXh0MTMtZ2FsbGVyeS1pbWFnZS10dXJibz9zdHlsZT1zb2NpYWxcIixcbiAgICAgICAgICAgICAgICAgICAgYWx0OiBcIkxhbmRzY2FwZSBwaWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMjBcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4KShWZXJzaW9uLCB7fSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KVxuICAgICAgICBdXG4gICAgICB9KVxuICAgIF1cbiAgfSk7XG59O1xuXG4vLyBzcmMvTWVudVB5bGFyLnRzeFxudmFyIGltcG9ydF9qc3hfcnVudGltZTMgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgTWVudVB5bGFyID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUzLmpzeCkoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJmbGV4IGhpZGRlbiBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIGJnLWdyYWRpZW50LXRvLXIgZnJvbS1ibHVlLTQwMCB0by1ibHVlLTUwMCBzbTpibG9ja1wiLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTMuanN4cykoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcImZsZXggZmxleC1yb3dcIixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMy5qc3gpKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicm91bmRlZC14bCBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGVcIixcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUzLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgIGhyZWY6IFwiL2Jsb2dcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIk91ciBEYWlseSBXb3JrXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUzLmpzeCkoXCJidXR0b25cIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJyb3VuZGVkLXhsIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZVwiLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTMuanN4KShcImFcIiwge1xuICAgICAgICAgICAgaHJlZjogXCIvd2hhdC1pcy1weWxhclwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiV2hhdCBpcyBQeWxhciBBSVwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMy5qc3gpKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicm91bmRlZC14bCBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGVcIixcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUzLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgIGhyZWY6IFwiL3B5bGFyLWxpY2Vuc2VcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIkxpY2Vuc2VcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyBzcmMvVGl0bGVQeWxhci50c3hcbnZhciBpbXBvcnRfanN4X3J1bnRpbWU0ID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIFRpdGxlUHlsYXIgPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4cykoXCJkaXZcIiwge1xuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4cykoXCJoMVwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJweS04IHRleHQtY2VudGVyIHRleHQtNXhsIGZvbnQtYm9sZFwiLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMC41LCBkdXJhdGlvbjogMS41IH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJQXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDAuNiwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwieVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeCkobW90aW9uLnNwYW4sIHtcbiAgICAgICAgICAgIGluaXRpYWw6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgYW5pbWF0ZTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB7IGRlbGF5OiAwLjcsIGR1cmF0aW9uOiAxLjUgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcImxcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMC44LCBkdXJhdGlvbjogMS41IH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJhXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDAuOSwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiclxcdTIxMjJcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMSwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiXFx4QTBcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMS4xLCBkdXJhdGlvbjogMS41IH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDEuMiwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiSVwiXG4gICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4cykobW90aW9uLmgyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJweS04IHRleHQtY2VudGVyIHRleHQtNHhsIGZvbnQtYm9sZFwiLFxuICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgYW5pbWF0ZTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDEuNCwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiUHlcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIFwidGhvblwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiTFwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJlYXJuaW5nXCIsXG4gICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeCkoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJ0ZXh0LWJsdWUtNTAwXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBcInJ0aWZpY2lhbFwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiUlwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJlc2VhcmNoXFx1MjEyMlwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibGFja1wiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiIFwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeCkoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJ0ZXh0LWJsdWUtNTAwXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBcInJ0aWZpY2lhbFwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiSVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJudGVsbGlnZW5jZVwiLFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgIF1cbiAgICAgIH0pXG4gICAgXVxuICB9KTtcbn07XG5cbi8vIHNyYy9MaXN0UHlsYXIudHN4XG52YXIgaW1wb3J0X2pzeF9ydW50aW1lNSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBMaXN0UHlsYXIgPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4KShcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm10LTggZmxleCBmbGV4LXJvdyBqdXN0aWZ5LWNlbnRlclwiLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4cykoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcImZsZXggdy0zLzQgZmxleC1jb2xcIixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwiaDJcIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJ0ZXh0LTJ4bCBmb250LWJvbGRcIixcbiAgICAgICAgICBjaGlsZHJlbjogXCJXZWxjb21lIHRvIHRoZSBQeWxhciBBSSBCbG9nXCJcbiAgICAgICAgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3hzKShcInBcIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJtdC00IHRleHQtbGdcIixcbiAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgXCJQeWxhciBBSSBpczpcIixcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3hzKShcInVsXCIsIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImxpc3QtaW5zaWRlIGxpc3QtZGlzY1wiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwibGlcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiR2VuZXJhdGl2ZSBhcnQgcmVzdWx0c1wiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIldoYXQgaXMgZ2VuZXJhdGl2ZSBhcnQ/IEdlbmVyYXRpdmUgYXJ0IGlzIGEgZm9ybSBvZiBhcnQgdGhhdCB1c2VzIGEgY29tcHV0ZXIgdG8gY3JlYXRlIGFydC4gVGhlIGNvbXB1dGVyIGlzIHByb2dyYW1tZWQgdG8gY3JlYXRlIGFydCBiYXNlZCBvbiBhIHNldCBvZiBydWxlcy5cIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwicFwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJcXHhBMFwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeCkoXCJsaVwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJQcm9tdCBFbmdpbmVlcmluZyBkZXNpZ25cIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJQcm9tdCBFbmdpbmVlcmluZyBpcyBhIGZvcm0gb2YgZW5naW5lZXJpbmcgdGhhdCB1c2VzIGEgY29tcHV0ZXIgdG8gY3JlYXRlIGVuZ2luZWVyaW5nLiBUaGUgY29tcHV0ZXIgaXMgcHJvZ3JhbW1lZCB0byBjcmVhdGUgZW5naW5lZXJpbmcgYmFzZWQgb24gYSBzZXQgb2YgcnVsZXMuXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4KShcInBcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiXFx4QTBcIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwibGlcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiU3RhYmxlRGlmZnVzaW9uIDIuMCBtb2RpZmllZFwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlN0YWJsZURpZmZ1c2lvbiAyLjAgaXMgYSBjb21wdXRlciBwcm9ncmFtIHRoYXQgaXMgdXNlZCB0byBjcmVhdGUgYXJ0IGJhc2VkIG9uIGEgc2V0IG9mIHJ1bGVzLlwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeCkoXCJwXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlxceEEwXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9Gb290ZXIudHN4XG52YXIgaW1wb3J0X2pzeF9ydW50aW1lNiA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBGb290ZXIgPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTYuanN4cykoXCJmb290ZXJcIiwge1xuICAgIGNsYXNzTmFtZTogXCJiZy13aGl0ZSBweS04IHRleHQtY2VudGVyXCIsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3gpKFwiZGl2XCIsIHtcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3hzKShcImFcIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBcIk1hZGUgd2l0aCBcXHUyNzY0XFx1RkUwRiBieVwiLFxuICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTYuanN4KShcImFcIiwge1xuICAgICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vdHdpdHRlci5jb20vbWlndWVsZ2FyZ2FsbG9cIixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgICByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaG92ZXI6dGV4dC1ibHVlIHRleHQtaW5kaWdvLTYwMFwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJNaWd1ZWwgR2FyZ2FsbG9cIlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBcIi5cIlxuICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU2LmpzeCkoXCJkaXZcIiwge1xuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU2LmpzeHMpKFwiYVwiLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIFwiMjAyMiBcXHhBOVwiLFxuICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTYuanN4KShcImFcIiwge1xuICAgICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vc3BhY2VzL3N1cGVyZGF0YXMvTElDRU5TRVwiLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJob3Zlcjp0ZXh0LWJsdWUgdGV4dC1pbmRpZ28tNjAwXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlB5bGFyXFx1MjEyMiBBSSBjcmVhdGl2ZSBNTCBsaWNlbnNlXCJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCIuXCJcbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3gpKFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImhpZGRlbiBzbTpibG9ja1wiLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU2LmpzeHMpKFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiZmxleCB3LWZ1bGwgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCIsXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiaHR0cHM6Ly92ZXJjZWwuY29tL25ldy9jbG9uZT9yZXBvc2l0b3J5LXVybD1odHRwcyUzQSUyRiUyRmdpdGh1Yi5jb20lMkZtaWd1ZWxnYXJnYWxsbyUyRk5leHQxMy1GZXRjaC1EYXRhLXR1cmJvJnByb2plY3QtbmFtZT1taWd1ZWxnYXJnYWxsby1uZXh0MTMtZmV0Y2gtZGF0YS10dXJibyZyZXBvLW5hbWU9bWlndWVsZ2FyZ2FsbG8tbmV4dDEzLWZldGNoLWRhdGEtdHVyYm9cIixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgICByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaGlkZGVuIHAtMiBtZDpibG9ja1wiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU2LmpzeCkoXCJwaWN0dXJlXCIsIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU2LmpzeCkoXCJpbWdcIiwge1xuICAgICAgICAgICAgICAgICAgc3JjOiBcImh0dHBzOi8vdmVyY2VsLmNvbS9idXR0b25cIixcbiAgICAgICAgICAgICAgICAgIGFsdDogXCJMYW5kc2NhcGUgcGljdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgd2lkdGg6IDc1LFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyMFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9zcGFjZXMvc3VwZXJkYXRhcy9MSUNFTlNFXCIsXG4gICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImhpZGRlbiBwLTIgbWQ6YmxvY2tcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3gpKFwicGljdHVyZVwiLCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3gpKFwiaW1nXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNyYzogXCJodHRwczovL2h1Z2dpbmdmYWNlLmNvL2Zyb250L2Fzc2V0cy9odWdnaW5nZmFjZV9sb2dvLnN2Z1wiLFxuICAgICAgICAgICAgICAgICAgYWx0OiBcIkxhbmRzY2FwZSBwaWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICB3aWR0aDogNDAsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTYuanN4KShcInBcIiwge1xuICAgICAgICBjaGlsZHJlbjogXCJQbGVhc2UgZG8gbm90IGNvbnNpZGVyIHRoZSBzY29yZSBhcyBpbnZlc3RtZW50IGFkdmljZS5cIlxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xufTtcblxuLy8gc3JjL1Njcm9sbGFibGUudHN4XG52YXIgaW1wb3J0X2pzeF9ydW50aW1lNyA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBTY3JvbGxhYmxlID0gKCkgPT4ge1xuICBjb25zdCB7IHNjcm9sbFlQcm9ncmVzcyB9ID0gdXNlU2Nyb2xsKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTcuanN4KShtb3Rpb24uZGl2LCB7XG4gICAgY2xhc3NOYW1lOiBcInByb2dyZXNzLWJhclwiLFxuICAgIHN0eWxlOiB7IHNjYWxlWDogc2Nyb2xsWVByb2dyZXNzIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvQmxvZ1B5bGFyL2Jsb2cudHN4XG52YXIgaW1wb3J0X2pzeF9ydW50aW1lOCA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBFTEVNRU5UUzIgPSA1O1xudmFyIGJsb2cgPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTguanN4KShcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOC5qc3gpKFwic3ZnXCIsIHtcbiAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICB3aWR0aDogXCI5NVwiLFxuICAgICAgaGVpZ2h0OiBcIjk1XCIsXG4gICAgICBzdHJva2U6IFwiI0ZGRlwiLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCIwXCIsXG4gICAgICB2aWV3Qm94OiBcIjAgMCA5NSA5NVwiLFxuICAgICAgY2xhc3NOYW1lOiBcIm0tMiByb3VuZGVkLXhsIHB5LTIgc2hhZG93LW1kIGhvdmVyOnNoYWRvdy14bFwiLFxuICAgICAgc3R5bGU6IGsoRUxFTUVOVFMyKSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTguanN4KShcInBhdGhcIiwge1xuICAgICAgICBkOiBcIk0zMi44MTYsMTIuOTUsMzAuMzQ5LDguNTY4aDQuNzhhLjQzOS40MzksMCwwLDEsLjM0Ni4ybC45MzEsMS41MzRjLjU1OC45MiwxLjIyNSwyLjAyLDEuNjA3LDIuNjQ4Wk0yMy45NzUsMzkuNDk1YS4zMzkuMzM5LDAsMCwxLS4zMTUuMjA3SDE4Ljc3Mmw3LjU5NS0xMy42MzVhLjczMS43MzEsMCwwLDAtLjYzNi0xLjA4N2gwTDEyLjc4NywyNWwtMi41NzQtNC40NTZIMjkuMDc2Yy4wMTEsMCwuMDIsMCwuMDMxLDBhLjY3Ny42NzcsMCwwLDAsLjIxNy0uMDQ1bC4wNDctLjAyYS43MjIuNzIyLDAsMCwwLC4zNDYtLjMxM2wzLjEwOC01Ljc0NWg1LjEzWm0tNi40NjgtLjUxOC0uNjEzLTEuMDA5Yy0uNzg1LTEuMy0xLjc5MS0yLjk1NS0xLjktMy4xMzdhLjM4NS4zODUsMCwwLDEsLjAyNC0uMzU1bDQuNDU3LTguMDI3LDUuMDE5LS4wMDZaTTguOTQ4LDMwLjQ0NCw2LjQ1MywyNi4wMTEsOC45NjgsMjEuM2wyLjUyMiw0LjM2N0MxMC43MDYsMjcuMTQsOS40ODMsMjkuNDQyLDguOTQ4LDMwLjQ0NFptLTMuMzQ4LjY5SDIuODgxYS40NDMuNDQzLDAsMCwxLS4zNDMtLjJMMS43MjYsMjkuNkMxLjE0NywyOC42NDEuNDA5LDI3LjQyNSwwLDI2Ljc1Mkg1LjJsMi40NjYsNC4zODNaTTE0LjAzNy4yMDhBLjMzOC4zMzgsMCwwLDEsMTQuMzUxLDBoNC45MUwxMS42NDYsMTMuNjM2Yy0uMDA2LjAxMS0uMDEuMDIzLS4wMTYuMDM1cy0uMDIxLjA0Ni0uMDMuMDctLjAxNS4wNDYtLjAyMS4wNjktLjAxMS4wNDQtLjAxNC4wNjZhLjY0OC42NDgsMCwwLDAtLjAwOC4wODFjMCwuMDEyLDAsLjAyMywwLC4wMzZzMCwuMDE4LDAsLjAyN2EuNTkxLjU5MSwwLDAsMCwuMDA4LjA3OS41MzguNTM4LDAsMCwwLC4wMTIuMDY2Yy4wMDYuMDIzLjAxMy4wNDUuMDIxLjA2OHMuMDE2LjA0NS4wMjUuMDY2LjAyMS4wNDEuMDMzLjA2Mi4wMjMuMDQuMDM3LjA1OWEuNjQ0LjY0NCwwLDAsMCwuMDQ1LjA1NWMuMDE2LjAxNy4wMzEuMDM1LjA0OC4wNTFzLjAzNS4wMjkuMDUzLjA0M2EuNjM0LjYzNCwwLDAsMCwuMDYzLjA0NWwuMDIzLjAxNmMuMDA4LDAsLjAxOC4wMDYuMDI3LjAxMWEuNzI5LjcyOSwwLDAsMCwuMTE5LjA0OGMuMDE1LDAsLjAyOS4wMS4wNDQuMDEzYS43LjcsMCwwLDAsLjE2NC4wMjFoLjMzbDEyLjYxOS0uMDE3Yy4zMzQuNTguOTU3LDEuNjczLDEuNDg5LDIuNnEuNjEyLDEuMDcyLDEuMDEsMS43NjhIOC45NDljLS4wMDgsMC0uMDE2LDAtLjAyNCwwYS43MjUuNzI1LDAsMCwwLS42MzEuMzgyTDUuMTg1LDI1LjI5SC4wNTlabTYuNDc5LjUzNC40NTYuNzVjLjgsMS4zMjEsMS45MzIsMy4xODUsMi4wNTIsMy4zNzlBLjM4My4zODMsMCwwLDEsMjMsNS4yMjdsLTQuNDU3LDguMDI3LTUuMDE3LjAwNlptOC41NDYsOC41MTEsMi41LDQuNDM1LTIuNTQ1LDQuN2MtLjMtLjUyOS0uNjgtMS4xODktMS4wMzQtMS44MDgtLjctMS4yMjQtMS4yMDgtMi4xMTUtMS40OTUtMi42MTNDMjcuMDI4LDEyLjk3NywyOC40NjIsMTAuMzQ5LDI5LjA2Miw5LjI1M1pcIixcbiAgICAgICAgaWQ6IFwiRmlsbC0xXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJmaWxsLXllbGxvdy01MDBcIlxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9CbG9nUHlsYXIvcG9zdDEyMDMyMDIyLnRzeFxudmFyIGltcG9ydF9qc3hfcnVudGltZTkgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgRUxFTUVOVFMzID0gNTtcbnZhciBwb3N0MTIwMzIwMjIgPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTkuanN4KShcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOS5qc3gpKFwic3ZnXCIsIHtcbiAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICB3aWR0aDogXCI5NVwiLFxuICAgICAgaGVpZ2h0OiBcIjk1XCIsXG4gICAgICBzdHJva2U6IFwiI0ZGRlwiLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCIwXCIsXG4gICAgICB2aWV3Qm94OiBcIjAgMCA5NSA5NVwiLFxuICAgICAgY2xhc3NOYW1lOiBcIm0tMiByb3VuZGVkLXhsIHB5LTIgc2hhZG93LW1kIGhvdmVyOnNoYWRvdy14bFwiLFxuICAgICAgc3R5bGU6IGsoRUxFTUVOVFMzKSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTkuanN4KShcInBhdGhcIiwge1xuICAgICAgICBkOiBcIk0zMi44MTYsMTIuOTUsMzAuMzQ5LDguNTY4aDQuNzhhLjQzOS40MzksMCwwLDEsLjM0Ni4ybC45MzEsMS41MzRjLjU1OC45MiwxLjIyNSwyLjAyLDEuNjA3LDIuNjQ4Wk0yMy45NzUsMzkuNDk1YS4zMzkuMzM5LDAsMCwxLS4zMTUuMjA3SDE4Ljc3Mmw3LjU5NS0xMy42MzVhLjczMS43MzEsMCwwLDAtLjYzNi0xLjA4N2gwTDEyLjc4NywyNWwtMi41NzQtNC40NTZIMjkuMDc2Yy4wMTEsMCwuMDIsMCwuMDMxLDBhLjY3Ny42NzcsMCwwLDAsLjIxNy0uMDQ1bC4wNDctLjAyYS43MjIuNzIyLDAsMCwwLC4zNDYtLjMxM2wzLjEwOC01Ljc0NWg1LjEzWm0tNi40NjgtLjUxOC0uNjEzLTEuMDA5Yy0uNzg1LTEuMy0xLjc5MS0yLjk1NS0xLjktMy4xMzdhLjM4NS4zODUsMCwwLDEsLjAyNC0uMzU1bDQuNDU3LTguMDI3LDUuMDE5LS4wMDZaTTguOTQ4LDMwLjQ0NCw2LjQ1MywyNi4wMTEsOC45NjgsMjEuM2wyLjUyMiw0LjM2N0MxMC43MDYsMjcuMTQsOS40ODMsMjkuNDQyLDguOTQ4LDMwLjQ0NFptLTMuMzQ4LjY5SDIuODgxYS40NDMuNDQzLDAsMCwxLS4zNDMtLjJMMS43MjYsMjkuNkMxLjE0NywyOC42NDEuNDA5LDI3LjQyNSwwLDI2Ljc1Mkg1LjJsMi40NjYsNC4zODNaTTE0LjAzNy4yMDhBLjMzOC4zMzgsMCwwLDEsMTQuMzUxLDBoNC45MUwxMS42NDYsMTMuNjM2Yy0uMDA2LjAxMS0uMDEuMDIzLS4wMTYuMDM1cy0uMDIxLjA0Ni0uMDMuMDctLjAxNS4wNDYtLjAyMS4wNjktLjAxMS4wNDQtLjAxNC4wNjZhLjY0OC42NDgsMCwwLDAtLjAwOC4wODFjMCwuMDEyLDAsLjAyMywwLC4wMzZzMCwuMDE4LDAsLjAyN2EuNTkxLjU5MSwwLDAsMCwuMDA4LjA3OS41MzguNTM4LDAsMCwwLC4wMTIuMDY2Yy4wMDYuMDIzLjAxMy4wNDUuMDIxLjA2OHMuMDE2LjA0NS4wMjUuMDY2LjAyMS4wNDEuMDMzLjA2Mi4wMjMuMDQuMDM3LjA1OWEuNjQ0LjY0NCwwLDAsMCwuMDQ1LjA1NWMuMDE2LjAxNy4wMzEuMDM1LjA0OC4wNTFzLjAzNS4wMjkuMDUzLjA0M2EuNjM0LjYzNCwwLDAsMCwuMDYzLjA0NWwuMDIzLjAxNmMuMDA4LDAsLjAxOC4wMDYuMDI3LjAxMWEuNzI5LjcyOSwwLDAsMCwuMTE5LjA0OGMuMDE1LDAsLjAyOS4wMS4wNDQuMDEzYS43LjcsMCwwLDAsLjE2NC4wMjFoLjMzbDEyLjYxOS0uMDE3Yy4zMzQuNTguOTU3LDEuNjczLDEuNDg5LDIuNnEuNjEyLDEuMDcyLDEuMDEsMS43NjhIOC45NDljLS4wMDgsMC0uMDE2LDAtLjAyNCwwYS43MjUuNzI1LDAsMCwwLS42MzEuMzgyTDUuMTg1LDI1LjI5SC4wNTlabTYuNDc5LjUzNC40NTYuNzVjLjgsMS4zMjEsMS45MzIsMy4xODUsMi4wNTIsMy4zNzlBLjM4My4zODMsMCwwLDEsMjMsNS4yMjdsLTQuNDU3LDguMDI3LTUuMDE3LjAwNlptOC41NDYsOC41MTEsMi41LDQuNDM1LTIuNTQ1LDQuN2MtLjMtLjUyOS0uNjgtMS4xODktMS4wMzQtMS44MDgtLjctMS4yMjQtMS4yMDgtMi4xMTUtMS40OTUtMi42MTNDMjcuMDI4LDEyLjk3NywyOC40NjIsMTAuMzQ5LDI5LjA2Miw5LjI1M1pcIixcbiAgICAgICAgaWQ6IFwiRmlsbC0xXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJmaWxsLXllbGxvdy01MDBcIlxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRm9vdGVyLFxuICBMaXN0UHlsYXIsXG4gIE1lbnUsXG4gIE1lbnVQeWxhcixcbiAgU2Nyb2xsYWJsZSxcbiAgVGl0bGVQeWxhcixcbiAgVmVyc2lvbixcbiAgYmxvZyxcbiAgcG9zdDEyMDMyMDIyXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../packages/ui/dist/index.js\n");

/***/ }),

/***/ "next/head":
/*!****************************!*\
  !*** external "next/head" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("next/head");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = require("react");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "react/jsx-runtime":
/*!************************************!*\
  !*** external "react/jsx-runtime" ***!
  \************************************/
/***/ ((module) => {

module.exports = require("react/jsx-runtime");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("./src/pages/index.tsx"));
module.exports = __webpack_exports__;

})();