"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "../../packages/ui/dist/index.mjs":
/*!****************************************!*\
  !*** ../../packages/ui/dist/index.mjs ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Footer\": function() { return /* binding */ Footer; },\n/* harmony export */   \"ListPylar\": function() { return /* binding */ ListPylar; },\n/* harmony export */   \"Menu\": function() { return /* binding */ Menu; },\n/* harmony export */   \"MenuPylar\": function() { return /* binding */ MenuPylar; },\n/* harmony export */   \"Scrollable\": function() { return /* binding */ Scrollable; },\n/* harmony export */   \"TitlePylar\": function() { return /* binding */ TitlePylar; },\n/* harmony export */   \"Version\": function() { return /* binding */ Version; },\n/* harmony export */   \"blog\": function() { return /* binding */ blog; },\n/* harmony export */   \"post12032022\": function() { return /* binding */ post12032022; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"../../node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../node_modules/next/dist/build/polyfills/process.js\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a2, b2) => {\n  for (var prop in b2 || (b2 = {}))\n    if (__hasOwnProp.call(b2, prop))\n      __defNormalProp(a2, prop, b2[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b2)) {\n      if (__propIsEnum.call(b2, prop))\n        __defNormalProp(a2, prop, b2[prop]);\n    }\n  return a2;\n};\nvar __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb2, mod) => function __require() {\n  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// ../../node_modules/@emotion/memoize/dist/memoize.esm.js\nfunction memoize(fn) {\n  var cache = {};\n  return function(arg) {\n    if (cache[arg] === void 0)\n      cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\nvar memoize_esm_default;\nvar init_memoize_esm = __esm({\n  \"../../node_modules/@emotion/memoize/dist/memoize.esm.js\"() {\n    memoize_esm_default = memoize;\n  }\n});\n\n// ../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\nvar is_prop_valid_esm_exports = {};\n__export(is_prop_valid_esm_exports, {\n  default: () => is_prop_valid_esm_default\n});\nvar reactPropsRegex, index, is_prop_valid_esm_default;\nvar init_is_prop_valid_esm = __esm({\n  \"../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\"() {\n    init_memoize_esm();\n    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;\n    index = memoize_esm_default(\n      function(prop) {\n        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;\n      }\n    );\n    is_prop_valid_esm_default = index;\n  }\n});\n\n// ../../node_modules/popmotion/node_modules/tslib/tslib.js\nvar require_tslib = __commonJS({\n  \"../../node_modules/popmotion/node_modules/tslib/tslib.js\"(exports, module) {\n    var __extends3;\n    var __assign3;\n    var __rest3;\n    var __decorate3;\n    var __param3;\n    var __metadata3;\n    var __awaiter3;\n    var __generator3;\n    var __exportStar3;\n    var __values3;\n    var __read3;\n    var __spread3;\n    var __spreadArrays3;\n    var __spreadArray3;\n    var __await3;\n    var __asyncGenerator3;\n    var __asyncDelegator3;\n    var __asyncValues3;\n    var __makeTemplateObject3;\n    var __importStar3;\n    var __importDefault3;\n    var __classPrivateFieldGet3;\n    var __classPrivateFieldSet3;\n    var __classPrivateFieldIn3;\n    var __createBinding3;\n    (function(factory) {\n      var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n      if (typeof define === \"function\" && define.amd) {\n        define(\"tslib\", [\"exports\"], function(exports2) {\n          factory(createExporter(root, createExporter(exports2)));\n        });\n      } else if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        factory(createExporter(root, createExporter(module.exports)));\n      } else {\n        factory(createExporter(root));\n      }\n      function createExporter(exports2, previous) {\n        if (exports2 !== root) {\n          if (typeof Object.create === \"function\") {\n            Object.defineProperty(exports2, \"__esModule\", { value: true });\n          } else {\n            exports2.__esModule = true;\n          }\n        }\n        return function(id2, v) {\n          return exports2[id2] = previous ? previous(id2, v) : v;\n        };\n      }\n    })(function(exporter) {\n      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p2 in b2)\n          if (Object.prototype.hasOwnProperty.call(b2, p2))\n            d2[p2] = b2[p2];\n      };\n      __extends3 = function(d2, b2) {\n        if (typeof b2 !== \"function\" && b2 !== null)\n          throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n        extendStatics(d2, b2);\n        function __() {\n          this.constructor = d2;\n        }\n        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n      };\n      __assign3 = Object.assign || function(t) {\n        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {\n          s = arguments[i2];\n          for (var p2 in s)\n            if (Object.prototype.hasOwnProperty.call(s, p2))\n              t[p2] = s[p2];\n        }\n        return t;\n      };\n      __rest3 = function(s, e) {\n        var t = {};\n        for (var p2 in s)\n          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)\n            t[p2] = s[p2];\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {\n            if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))\n              t[p2[i2]] = s[p2[i2]];\n          }\n        return t;\n      };\n      __decorate3 = function(decorators, target, key, desc) {\n        var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n          r = Reflect.decorate(decorators, target, key, desc);\n        else\n          for (var i2 = decorators.length - 1; i2 >= 0; i2--)\n            if (d2 = decorators[i2])\n              r = (c3 < 3 ? d2(r) : c3 > 3 ? d2(target, key, r) : d2(target, key)) || r;\n        return c3 > 3 && r && Object.defineProperty(target, key, r), r;\n      };\n      __param3 = function(paramIndex, decorator) {\n        return function(target, key) {\n          decorator(target, key, paramIndex);\n        };\n      };\n      __metadata3 = function(metadataKey, metadataValue) {\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n          return Reflect.metadata(metadataKey, metadataValue);\n      };\n      __awaiter3 = function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      __generator3 = function(thisArg, body) {\n        var _ = { label: 0, sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        }, trys: [], ops: [] }, f2, y, t, g2;\n        return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n          return this;\n        }), g2;\n        function verb(n) {\n          return function(v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f2)\n            throw new TypeError(\"Generator is already executing.\");\n          while (_)\n            try {\n              if (f2 = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                return t;\n              if (y = 0, t)\n                op = [op[0] & 2, t.value];\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n                case 4:\n                  _.label++;\n                  return { value: op[1], done: false };\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n                case 7:\n                  op = _.ops.pop();\n                  _.trys.pop();\n                  continue;\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n                    _.ops.push(op);\n                    break;\n                  }\n                  if (t[2])\n                    _.ops.pop();\n                  _.trys.pop();\n                  continue;\n              }\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f2 = t = 0;\n            }\n          if (op[0] & 5)\n            throw op[1];\n          return { value: op[0] ? op[1] : void 0, done: true };\n        }\n      };\n      __exportStar3 = function(m, o) {\n        for (var p2 in m)\n          if (p2 !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p2))\n            __createBinding3(o, m, p2);\n      };\n      __createBinding3 = Object.create ? function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        var desc = Object.getOwnPropertyDescriptor(m, k2);\n        if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n          desc = { enumerable: true, get: function() {\n            return m[k2];\n          } };\n        }\n        Object.defineProperty(o, k22, desc);\n      } : function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        o[k22] = m[k2];\n      };\n      __values3 = function(o) {\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i2 = 0;\n        if (m)\n          return m.call(o);\n        if (o && typeof o.length === \"number\")\n          return {\n            next: function() {\n              if (o && i2 >= o.length)\n                o = void 0;\n              return { value: o && o[i2++], done: !o };\n            }\n          };\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n      };\n      __read3 = function(o, n) {\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n        if (!m)\n          return o;\n        var i2 = m.call(o), r, ar = [], e;\n        try {\n          while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)\n            ar.push(r.value);\n        } catch (error) {\n          e = { error };\n        } finally {\n          try {\n            if (r && !r.done && (m = i2[\"return\"]))\n              m.call(i2);\n          } finally {\n            if (e)\n              throw e.error;\n          }\n        }\n        return ar;\n      };\n      __spread3 = function() {\n        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)\n          ar = ar.concat(__read3(arguments[i2]));\n        return ar;\n      };\n      __spreadArrays3 = function() {\n        for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n          s += arguments[i2].length;\n        for (var r = Array(s), k2 = 0, i2 = 0; i2 < il; i2++)\n          for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k2++)\n            r[k2] = a2[j];\n        return r;\n      };\n      __spreadArray3 = function(to, from, pack) {\n        if (pack || arguments.length === 2)\n          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {\n            if (ar || !(i2 in from)) {\n              if (!ar)\n                ar = Array.prototype.slice.call(from, 0, i2);\n              ar[i2] = from[i2];\n            }\n          }\n        return to.concat(ar || Array.prototype.slice.call(from));\n      };\n      __await3 = function(v) {\n        return this instanceof __await3 ? (this.v = v, this) : new __await3(v);\n      };\n      __asyncGenerator3 = function(thisArg, _arguments, generator) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];\n        return i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2;\n        function verb(n) {\n          if (g2[n])\n            i2[n] = function(v) {\n              return new Promise(function(a2, b2) {\n                q.push([n, v, a2, b2]) > 1 || resume(n, v);\n              });\n            };\n        }\n        function resume(n, v) {\n          try {\n            step(g2[n](v));\n          } catch (e) {\n            settle(q[0][3], e);\n          }\n        }\n        function step(r) {\n          r.value instanceof __await3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n        }\n        function fulfill(value) {\n          resume(\"next\", value);\n        }\n        function reject(value) {\n          resume(\"throw\", value);\n        }\n        function settle(f2, v) {\n          if (f2(v), q.shift(), q.length)\n            resume(q[0][0], q[0][1]);\n        }\n      };\n      __asyncDelegator3 = function(o) {\n        var i2, p2;\n        return i2 = {}, verb(\"next\"), verb(\"throw\", function(e) {\n          throw e;\n        }), verb(\"return\"), i2[Symbol.iterator] = function() {\n          return this;\n        }, i2;\n        function verb(n, f2) {\n          i2[n] = o[n] ? function(v) {\n            return (p2 = !p2) ? { value: __await3(o[n](v)), done: n === \"return\" } : f2 ? f2(v) : v;\n          } : f2;\n        }\n      };\n      __asyncValues3 = function(o) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var m = o[Symbol.asyncIterator], i2;\n        return m ? m.call(o) : (o = typeof __values3 === \"function\" ? __values3(o) : o[Symbol.iterator](), i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2);\n        function verb(n) {\n          i2[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n              v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n          };\n        }\n        function settle(resolve, reject, d2, v) {\n          Promise.resolve(v).then(function(v2) {\n            resolve({ value: v2, done: d2 });\n          }, reject);\n        }\n      };\n      __makeTemplateObject3 = function(cooked, raw) {\n        if (Object.defineProperty) {\n          Object.defineProperty(cooked, \"raw\", { value: raw });\n        } else {\n          cooked.raw = raw;\n        }\n        return cooked;\n      };\n      var __setModuleDefault = Object.create ? function(o, v) {\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n      } : function(o, v) {\n        o[\"default\"] = v;\n      };\n      __importStar3 = function(mod) {\n        if (mod && mod.__esModule)\n          return mod;\n        var result = {};\n        if (mod != null) {\n          for (var k2 in mod)\n            if (k2 !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k2))\n              __createBinding3(result, mod, k2);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n      };\n      __importDefault3 = function(mod) {\n        return mod && mod.__esModule ? mod : { \"default\": mod };\n      };\n      __classPrivateFieldGet3 = function(receiver, state, kind, f2) {\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a getter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n        return kind === \"m\" ? f2 : kind === \"a\" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);\n      };\n      __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {\n        if (kind === \"m\")\n          throw new TypeError(\"Private method is not writable\");\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a setter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n        return kind === \"a\" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;\n      };\n      __classPrivateFieldIn3 = function(state, receiver) {\n        if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\")\n          throw new TypeError(\"Cannot use 'in' operator on non-object\");\n        return typeof state === \"function\" ? receiver === state : state.has(receiver);\n      };\n      exporter(\"__extends\", __extends3);\n      exporter(\"__assign\", __assign3);\n      exporter(\"__rest\", __rest3);\n      exporter(\"__decorate\", __decorate3);\n      exporter(\"__param\", __param3);\n      exporter(\"__metadata\", __metadata3);\n      exporter(\"__awaiter\", __awaiter3);\n      exporter(\"__generator\", __generator3);\n      exporter(\"__exportStar\", __exportStar3);\n      exporter(\"__createBinding\", __createBinding3);\n      exporter(\"__values\", __values3);\n      exporter(\"__read\", __read3);\n      exporter(\"__spread\", __spread3);\n      exporter(\"__spreadArrays\", __spreadArrays3);\n      exporter(\"__spreadArray\", __spreadArray3);\n      exporter(\"__await\", __await3);\n      exporter(\"__asyncGenerator\", __asyncGenerator3);\n      exporter(\"__asyncDelegator\", __asyncDelegator3);\n      exporter(\"__asyncValues\", __asyncValues3);\n      exporter(\"__makeTemplateObject\", __makeTemplateObject3);\n      exporter(\"__importStar\", __importStar3);\n      exporter(\"__importDefault\", __importDefault3);\n      exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet3);\n      exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet3);\n      exporter(\"__classPrivateFieldIn\", __classPrivateFieldIn3);\n    });\n  }\n});\n\n// ../../node_modules/tslib/tslib.js\nvar require_tslib2 = __commonJS({\n  \"../../node_modules/tslib/tslib.js\"(exports, module) {\n    var __extends3;\n    var __assign3;\n    var __rest3;\n    var __decorate3;\n    var __param3;\n    var __metadata3;\n    var __awaiter3;\n    var __generator3;\n    var __exportStar3;\n    var __values3;\n    var __read3;\n    var __spread3;\n    var __spreadArrays3;\n    var __spreadArray3;\n    var __await3;\n    var __asyncGenerator3;\n    var __asyncDelegator3;\n    var __asyncValues3;\n    var __makeTemplateObject3;\n    var __importStar3;\n    var __importDefault3;\n    var __classPrivateFieldGet3;\n    var __classPrivateFieldSet3;\n    var __classPrivateFieldIn3;\n    var __createBinding3;\n    (function(factory) {\n      var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n      if (typeof define === \"function\" && define.amd) {\n        define(\"tslib\", [\"exports\"], function(exports2) {\n          factory(createExporter(root, createExporter(exports2)));\n        });\n      } else if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        factory(createExporter(root, createExporter(module.exports)));\n      } else {\n        factory(createExporter(root));\n      }\n      function createExporter(exports2, previous) {\n        if (exports2 !== root) {\n          if (typeof Object.create === \"function\") {\n            Object.defineProperty(exports2, \"__esModule\", { value: true });\n          } else {\n            exports2.__esModule = true;\n          }\n        }\n        return function(id2, v) {\n          return exports2[id2] = previous ? previous(id2, v) : v;\n        };\n      }\n    })(function(exporter) {\n      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p2 in b2)\n          if (Object.prototype.hasOwnProperty.call(b2, p2))\n            d2[p2] = b2[p2];\n      };\n      __extends3 = function(d2, b2) {\n        if (typeof b2 !== \"function\" && b2 !== null)\n          throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n        extendStatics(d2, b2);\n        function __() {\n          this.constructor = d2;\n        }\n        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n      };\n      __assign3 = Object.assign || function(t) {\n        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {\n          s = arguments[i2];\n          for (var p2 in s)\n            if (Object.prototype.hasOwnProperty.call(s, p2))\n              t[p2] = s[p2];\n        }\n        return t;\n      };\n      __rest3 = function(s, e) {\n        var t = {};\n        for (var p2 in s)\n          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)\n            t[p2] = s[p2];\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {\n            if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))\n              t[p2[i2]] = s[p2[i2]];\n          }\n        return t;\n      };\n      __decorate3 = function(decorators, target, key, desc) {\n        var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n          r = Reflect.decorate(decorators, target, key, desc);\n        else\n          for (var i2 = decorators.length - 1; i2 >= 0; i2--)\n            if (d2 = decorators[i2])\n              r = (c3 < 3 ? d2(r) : c3 > 3 ? d2(target, key, r) : d2(target, key)) || r;\n        return c3 > 3 && r && Object.defineProperty(target, key, r), r;\n      };\n      __param3 = function(paramIndex, decorator) {\n        return function(target, key) {\n          decorator(target, key, paramIndex);\n        };\n      };\n      __metadata3 = function(metadataKey, metadataValue) {\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n          return Reflect.metadata(metadataKey, metadataValue);\n      };\n      __awaiter3 = function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      __generator3 = function(thisArg, body) {\n        var _ = { label: 0, sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        }, trys: [], ops: [] }, f2, y, t, g2;\n        return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n          return this;\n        }), g2;\n        function verb(n) {\n          return function(v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f2)\n            throw new TypeError(\"Generator is already executing.\");\n          while (g2 && (g2 = 0, op[0] && (_ = 0)), _)\n            try {\n              if (f2 = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                return t;\n              if (y = 0, t)\n                op = [op[0] & 2, t.value];\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n                case 4:\n                  _.label++;\n                  return { value: op[1], done: false };\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n                case 7:\n                  op = _.ops.pop();\n                  _.trys.pop();\n                  continue;\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n                    _.ops.push(op);\n                    break;\n                  }\n                  if (t[2])\n                    _.ops.pop();\n                  _.trys.pop();\n                  continue;\n              }\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f2 = t = 0;\n            }\n          if (op[0] & 5)\n            throw op[1];\n          return { value: op[0] ? op[1] : void 0, done: true };\n        }\n      };\n      __exportStar3 = function(m, o) {\n        for (var p2 in m)\n          if (p2 !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p2))\n            __createBinding3(o, m, p2);\n      };\n      __createBinding3 = Object.create ? function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        var desc = Object.getOwnPropertyDescriptor(m, k2);\n        if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n          desc = { enumerable: true, get: function() {\n            return m[k2];\n          } };\n        }\n        Object.defineProperty(o, k22, desc);\n      } : function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        o[k22] = m[k2];\n      };\n      __values3 = function(o) {\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i2 = 0;\n        if (m)\n          return m.call(o);\n        if (o && typeof o.length === \"number\")\n          return {\n            next: function() {\n              if (o && i2 >= o.length)\n                o = void 0;\n              return { value: o && o[i2++], done: !o };\n            }\n          };\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n      };\n      __read3 = function(o, n) {\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n        if (!m)\n          return o;\n        var i2 = m.call(o), r, ar = [], e;\n        try {\n          while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)\n            ar.push(r.value);\n        } catch (error) {\n          e = { error };\n        } finally {\n          try {\n            if (r && !r.done && (m = i2[\"return\"]))\n              m.call(i2);\n          } finally {\n            if (e)\n              throw e.error;\n          }\n        }\n        return ar;\n      };\n      __spread3 = function() {\n        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)\n          ar = ar.concat(__read3(arguments[i2]));\n        return ar;\n      };\n      __spreadArrays3 = function() {\n        for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n          s += arguments[i2].length;\n        for (var r = Array(s), k2 = 0, i2 = 0; i2 < il; i2++)\n          for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k2++)\n            r[k2] = a2[j];\n        return r;\n      };\n      __spreadArray3 = function(to, from, pack) {\n        if (pack || arguments.length === 2)\n          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {\n            if (ar || !(i2 in from)) {\n              if (!ar)\n                ar = Array.prototype.slice.call(from, 0, i2);\n              ar[i2] = from[i2];\n            }\n          }\n        return to.concat(ar || Array.prototype.slice.call(from));\n      };\n      __await3 = function(v) {\n        return this instanceof __await3 ? (this.v = v, this) : new __await3(v);\n      };\n      __asyncGenerator3 = function(thisArg, _arguments, generator) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];\n        return i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2;\n        function verb(n) {\n          if (g2[n])\n            i2[n] = function(v) {\n              return new Promise(function(a2, b2) {\n                q.push([n, v, a2, b2]) > 1 || resume(n, v);\n              });\n            };\n        }\n        function resume(n, v) {\n          try {\n            step(g2[n](v));\n          } catch (e) {\n            settle(q[0][3], e);\n          }\n        }\n        function step(r) {\n          r.value instanceof __await3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n        }\n        function fulfill(value) {\n          resume(\"next\", value);\n        }\n        function reject(value) {\n          resume(\"throw\", value);\n        }\n        function settle(f2, v) {\n          if (f2(v), q.shift(), q.length)\n            resume(q[0][0], q[0][1]);\n        }\n      };\n      __asyncDelegator3 = function(o) {\n        var i2, p2;\n        return i2 = {}, verb(\"next\"), verb(\"throw\", function(e) {\n          throw e;\n        }), verb(\"return\"), i2[Symbol.iterator] = function() {\n          return this;\n        }, i2;\n        function verb(n, f2) {\n          i2[n] = o[n] ? function(v) {\n            return (p2 = !p2) ? { value: __await3(o[n](v)), done: n === \"return\" } : f2 ? f2(v) : v;\n          } : f2;\n        }\n      };\n      __asyncValues3 = function(o) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var m = o[Symbol.asyncIterator], i2;\n        return m ? m.call(o) : (o = typeof __values3 === \"function\" ? __values3(o) : o[Symbol.iterator](), i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2);\n        function verb(n) {\n          i2[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n              v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n          };\n        }\n        function settle(resolve, reject, d2, v) {\n          Promise.resolve(v).then(function(v2) {\n            resolve({ value: v2, done: d2 });\n          }, reject);\n        }\n      };\n      __makeTemplateObject3 = function(cooked, raw) {\n        if (Object.defineProperty) {\n          Object.defineProperty(cooked, \"raw\", { value: raw });\n        } else {\n          cooked.raw = raw;\n        }\n        return cooked;\n      };\n      var __setModuleDefault = Object.create ? function(o, v) {\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n      } : function(o, v) {\n        o[\"default\"] = v;\n      };\n      __importStar3 = function(mod) {\n        if (mod && mod.__esModule)\n          return mod;\n        var result = {};\n        if (mod != null) {\n          for (var k2 in mod)\n            if (k2 !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k2))\n              __createBinding3(result, mod, k2);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n      };\n      __importDefault3 = function(mod) {\n        return mod && mod.__esModule ? mod : { \"default\": mod };\n      };\n      __classPrivateFieldGet3 = function(receiver, state, kind, f2) {\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a getter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n        return kind === \"m\" ? f2 : kind === \"a\" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);\n      };\n      __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {\n        if (kind === \"m\")\n          throw new TypeError(\"Private method is not writable\");\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a setter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n        return kind === \"a\" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;\n      };\n      __classPrivateFieldIn3 = function(state, receiver) {\n        if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\")\n          throw new TypeError(\"Cannot use 'in' operator on non-object\");\n        return typeof state === \"function\" ? receiver === state : state.has(receiver);\n      };\n      exporter(\"__extends\", __extends3);\n      exporter(\"__assign\", __assign3);\n      exporter(\"__rest\", __rest3);\n      exporter(\"__decorate\", __decorate3);\n      exporter(\"__param\", __param3);\n      exporter(\"__metadata\", __metadata3);\n      exporter(\"__awaiter\", __awaiter3);\n      exporter(\"__generator\", __generator3);\n      exporter(\"__exportStar\", __exportStar3);\n      exporter(\"__createBinding\", __createBinding3);\n      exporter(\"__values\", __values3);\n      exporter(\"__read\", __read3);\n      exporter(\"__spread\", __spread3);\n      exporter(\"__spreadArrays\", __spreadArrays3);\n      exporter(\"__spreadArray\", __spreadArray3);\n      exporter(\"__await\", __await3);\n      exporter(\"__asyncGenerator\", __asyncGenerator3);\n      exporter(\"__asyncDelegator\", __asyncDelegator3);\n      exporter(\"__asyncValues\", __asyncValues3);\n      exporter(\"__makeTemplateObject\", __makeTemplateObject3);\n      exporter(\"__importStar\", __importStar3);\n      exporter(\"__importDefault\", __importDefault3);\n      exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet3);\n      exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet3);\n      exporter(\"__classPrivateFieldIn\", __classPrivateFieldIn3);\n    });\n  }\n});\n\n// ../../node_modules/meshgrad/dist/index.mjs\nvar i = () => Math.round(Math.random() * 360);\nvar c = (n) => Math.round(Math.random() * (n * 100) % 100);\nvar g = (n, t, e) => Math.round(t / e * (n * 100) % 100);\nvar d = (n) => {\n  if (!!n) {\n    n = n.replace(/#/g, \"\"), n.length === 3 && (n = n.split(\"\").map(function(b2) {\n      return b2 + b2;\n    }).join(\"\"));\n    var t = /^([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})[\\da-z]{0,0}$/i.exec(n);\n    if (!!t) {\n      var e = parseInt(t[1], 16), r = parseInt(t[2], 16), a2 = parseInt(t[3], 16);\n      e /= 255, r /= 255, a2 /= 255;\n      var o = Math.max(e, r, a2), s = Math.min(e, r, a2), u = (o + s) / 2;\n      if (o == s)\n        u = 0;\n      else {\n        var m = o - s;\n        switch (o) {\n          case e:\n            u = (r - a2) / m + (r < a2 ? 6 : 0);\n            break;\n          case r:\n            u = (a2 - e) / m + 2;\n            break;\n          case a2:\n            u = (e - r) / m + 4;\n            break;\n        }\n        u /= 6;\n      }\n      return u = Math.round(360 * u), u;\n    }\n  }\n};\nvar p = (n, t) => Array.from({ length: n }, (e, r) => r === 0 ? `hsl(${t}, 100%, 80%)` : r < n / 1.4 ? `hsl(${t - 30 * (1 - 2 * (r % 2)) * (r > 2 ? r / 2 : r)}, 100%, ${76 - r * (1 - 2 * (r % 2)) * 1.75}%)` : `hsl(${t - 150 * (1 - 2 * (r % 2))}, 100%, ${76 - r * (1 - 2 * (r % 2)) * 1.25}%)`);\nvar M = (n, t, e) => Array.from({ length: n }, (r, a2) => `radial-gradient(at ${e ? g(a2, e, n) : c(a2)}% ${e ? g(a2 * 10, e, n) : c(a2 * 10)}%, ${t[a2]} 0px, transparent 50%)\n`);\nvar f = (n, t, e) => {\n  let r = p(n, t || i()), a2 = M(n, r, e || void 0);\n  return [r[0], a2.join(\",\")];\n};\nvar k = (n, t, e) => {\n  let [r, a2] = f(n, d(t) ? d(t) : void 0, e || void 0);\n  return { backgroundColor: r, backgroundImage: a2 };\n};\n\n// src/Version.tsx\n\nvar ELEMENTS = 8;\nvar Version = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n    className: \"m-2 hidden rounded-full py-2 px-4 text-xs font-bold text-black shadow-md hover:shadow-xl md:block\",\n    style: k(ELEMENTS),\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n      href: \"http://github.com/miguelgargallo/next13-gallery-image-turbo\",\n      target: \"_blank\",\n      rel: \"noopener noreferrer\",\n      children: \"v1.0.2\"\n    })\n  });\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/index.mjs\n\n\n\n// ../../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs\n\nvar MotionConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n  transformPagePoint: (p2) => p2,\n  isStatic: false,\n  reducedMotion: \"never\"\n});\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/index.mjs\n\nvar MotionContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\nfunction useVisualElementContext() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionContext).visualElement;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/context/PresenceContext.mjs\n\nvar PresenceContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n\n// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/utils/is-browser.mjs\nvar isBrowser = typeof document !== \"undefined\";\n\n// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\nvar useIsomorphicLayoutEffect = isBrowser ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n\n// ../../node_modules/framer-motion/dist/es/context/LazyContext.mjs\n\nvar LazyContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({ strict: false });\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n  const parent = useVisualElementContext();\n  const lazyContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LazyContext);\n  const presenceContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PresenceContext);\n  const reducedMotionConfig = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionConfigContext).reducedMotion;\n  const visualElementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  createVisualElement = createVisualElement || lazyContext.renderer;\n  if (!visualElementRef.current && createVisualElement) {\n    visualElementRef.current = createVisualElement(Component, {\n      visualState,\n      parent,\n      props,\n      presenceId: presenceContext ? presenceContext.id : void 0,\n      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,\n      reducedMotionConfig\n    });\n  }\n  const visualElement = visualElementRef.current;\n  useIsomorphicLayoutEffect(() => {\n    visualElement && visualElement.render();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (visualElement && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n  });\n  useIsomorphicLayoutEffect(() => () => visualElement && visualElement.notify(\"Unmount\"), []);\n  return visualElement;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/utils/is-ref-object.mjs\nfunction isRefObject(ref) {\n  return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\nfunction useMotionRef(visualState, visualElement, externalRef) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (instance) => {\n      instance && visualState.mount && visualState.mount(instance);\n      if (visualElement) {\n        instance ? visualElement.mount(instance) : visualElement.unmount();\n      }\n      if (externalRef) {\n        if (typeof externalRef === \"function\") {\n          externalRef(instance);\n        } else if (isRefObject(externalRef)) {\n          externalRef.current = instance;\n        }\n      }\n    },\n    [visualElement]\n  );\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs\nfunction isVariantLabel(v) {\n  return typeof v === \"string\" || Array.isArray(v);\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs\nfunction isAnimationControls(v) {\n  return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs\nvar variantProps = [\n  \"initial\",\n  \"animate\",\n  \"exit\",\n  \"whileHover\",\n  \"whileDrag\",\n  \"whileTap\",\n  \"whileFocus\",\n  \"whileInView\"\n];\nfunction isControllingVariants(props) {\n  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));\n}\nfunction isVariantNode(props) {\n  return Boolean(isControllingVariants(props) || props.variants);\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs\nfunction getCurrentTreeVariants(props, context) {\n  if (isControllingVariants(props)) {\n    const { initial, animate: animate3 } = props;\n    return {\n      initial: initial === false || isVariantLabel(initial) ? initial : void 0,\n      animate: isVariantLabel(animate3) ? animate3 : void 0\n    };\n  }\n  return props.inherit !== false ? context : {};\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\nfunction useCreateMotionContext(props) {\n  const { initial, animate: animate3 } = getCurrentTreeVariants(props, (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionContext));\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({ initial, animate: animate3 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate3)]);\n}\nfunction variantLabelsAsDependency(prop) {\n  return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/definitions.mjs\nvar createDefinition = (propNames) => ({\n  isEnabled: (props) => propNames.some((name) => !!props[name])\n});\nvar featureDefinitions = {\n  measureLayout: createDefinition([\"layout\", \"layoutId\", \"drag\"]),\n  animation: createDefinition([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileFocus\",\n    \"whileDrag\",\n    \"whileInView\"\n  ]),\n  exit: createDefinition([\"exit\"]),\n  drag: createDefinition([\"drag\", \"dragControls\"]),\n  focus: createDefinition([\"whileFocus\"]),\n  hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n  tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n  pan: createDefinition([\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanSessionStart\",\n    \"onPanEnd\"\n  ]),\n  inView: createDefinition([\n    \"whileInView\",\n    \"onViewportEnter\",\n    \"onViewportLeave\"\n  ])\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/load-features.mjs\nfunction loadFeatures(features) {\n  for (const key in features) {\n    if (key === \"projectionNodeConstructor\") {\n      featureDefinitions.projectionNodeConstructor = features[key];\n    } else {\n      featureDefinitions[key].Component = features[key];\n    }\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/use-constant.mjs\n\nfunction useConstant(init) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  if (ref.current === null) {\n    ref.current = init();\n  }\n  return ref.current;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/node/state.mjs\nvar globalProjectionState = {\n  hasAnimatedSinceResize: true,\n  hasEverUpdated: false\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/node/id.mjs\nvar id = 1;\nfunction useProjectionId() {\n  return useConstant(() => {\n    if (globalProjectionState.hasEverUpdated) {\n      return id++;\n    }\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs\n\nvar LayoutGroupContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/VisualElementHandler.mjs\n\nvar VisualElementHandler = class extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  getSnapshotBeforeUpdate() {\n    const { visualElement, props } = this.props;\n    if (visualElement)\n      visualElement.setProps(props);\n    return null;\n  }\n  componentDidUpdate() {\n  }\n  render() {\n    return this.props.children;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs\n\nvar SwitchLayoutGroupContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/symbol.mjs\nvar motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n\n// ../../node_modules/framer-motion/dist/es/motion/index.mjs\nfunction createMotionComponent({ preloadedFeatures, createVisualElement, projectionNodeConstructor, useRender, useVisualState, Component }) {\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  function MotionComponent(props, externalRef) {\n    const configAndProps = __spreadProps(__spreadValues(__spreadValues({}, (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionConfigContext)), props), {\n      layoutId: useLayoutId(props)\n    });\n    const { isStatic } = configAndProps;\n    let features = null;\n    const context = useCreateMotionContext(props);\n    const projectionId = isStatic ? void 0 : useProjectionId();\n    const visualState = useVisualState(props, isStatic);\n    if (!isStatic && isBrowser) {\n      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);\n      const lazyStrictMode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LazyContext).strict;\n      const initialLayoutGroupConfig = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SwitchLayoutGroupContext);\n      if (context.visualElement) {\n        features = context.visualElement.loadFeatures(\n          configAndProps,\n          lazyStrictMode,\n          preloadedFeatures,\n          projectionId,\n          projectionNodeConstructor || featureDefinitions.projectionNodeConstructor,\n          initialLayoutGroupConfig\n        );\n      }\n    }\n    return react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      VisualElementHandler,\n      { visualElement: context.visualElement, props: configAndProps },\n      features,\n      react__WEBPACK_IMPORTED_MODULE_1__.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement))\n    );\n  }\n  const ForwardRefComponent = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(MotionComponent);\n  ForwardRefComponent[motionComponentSymbol] = Component;\n  return ForwardRefComponent;\n}\nfunction useLayoutId({ layoutId }) {\n  const layoutGroupId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LayoutGroupContext).id;\n  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs\nfunction createMotionProxy(createConfig) {\n  function custom(Component, customMotionComponentConfig = {}) {\n    return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n  }\n  if (typeof Proxy === \"undefined\") {\n    return custom;\n  }\n  const componentCache = /* @__PURE__ */ new Map();\n  return new Proxy(custom, {\n    get: (_target, key) => {\n      if (!componentCache.has(key)) {\n        componentCache.set(key, custom(key));\n      }\n      return componentCache.get(key);\n    }\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs\nvar lowercaseSVGElements = [\n  \"animate\",\n  \"circle\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"g\",\n  \"image\",\n  \"line\",\n  \"filter\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"rect\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"tspan\",\n  \"use\",\n  \"view\"\n];\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs\nfunction isSVGComponent(Component) {\n  if (typeof Component !== \"string\" || Component.includes(\"-\")) {\n    return false;\n  } else if (lowercaseSVGElements.indexOf(Component) > -1 || /[A-Z]/.test(Component)) {\n    return true;\n  }\n  return false;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/use-render.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/render/html/use-props.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs\nvar scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n  Object.assign(scaleCorrectors, correctors);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/transform.mjs\nvar transformPropOrder = [\n  \"transformPerspective\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"translateX\",\n  \"translateY\",\n  \"translateZ\",\n  \"scale\",\n  \"scaleX\",\n  \"scaleY\",\n  \"rotate\",\n  \"rotateX\",\n  \"rotateY\",\n  \"rotateZ\",\n  \"skew\",\n  \"skewX\",\n  \"skewY\"\n];\nvar transformProps = new Set(transformPropOrder);\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n  return transformProps.has(key) || key.startsWith(\"origin\") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === \"opacity\");\n}\n\n// ../../node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs\nvar isMotionValue = (value) => !!(value === null || value === void 0 ? void 0 : value.getVelocity);\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\nvar sortTransformProps = (a2, b2) => transformPropOrder.indexOf(a2) - transformPropOrder.indexOf(b2);\nfunction buildTransform({ transform, transformKeys: transformKeys2 }, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {\n  let transformString = \"\";\n  transformKeys2.sort(sortTransformProps);\n  for (const key of transformKeys2) {\n    transformString += `${translateAlias[key] || key}(${transform[key]}) `;\n  }\n  if (enableHardwareAcceleration && !transform.z) {\n    transformString += \"translateZ(0)\";\n  }\n  transformString = transformString.trim();\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n  return transformString;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs\nfunction isCSSVariable(key) {\n  return key.startsWith(\"--\");\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs\nvar getValueAsType = (value, type) => {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n\n// ../../node_modules/style-value-types/dist/es/utils.mjs\nvar clamp = (min, max) => (v) => Math.max(Math.min(v, max), min);\nvar sanitize = (v) => v % 1 ? Number(v.toFixed(5)) : v;\nvar floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nvar colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))/gi;\nvar singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))$/i;\nfunction isString(v) {\n  return typeof v === \"string\";\n}\n\n// ../../node_modules/style-value-types/dist/es/numbers/index.mjs\nvar number = {\n  test: (v) => typeof v === \"number\",\n  parse: parseFloat,\n  transform: (v) => v\n};\nvar alpha = Object.assign(Object.assign({}, number), { transform: clamp(0, 1) });\nvar scale = Object.assign(Object.assign({}, number), { default: 1 });\n\n// ../../node_modules/style-value-types/dist/es/numbers/units.mjs\nvar createUnitType = (unit) => ({\n  test: (v) => isString(v) && v.endsWith(unit) && v.split(\" \").length === 1,\n  parse: parseFloat,\n  transform: (v) => `${v}${unit}`\n});\nvar degrees = createUnitType(\"deg\");\nvar percent = createUnitType(\"%\");\nvar px = createUnitType(\"px\");\nvar vh = createUnitType(\"vh\");\nvar vw = createUnitType(\"vw\");\nvar progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v) => percent.parse(v) / 100, transform: (v) => percent.transform(v * 100) });\n\n// ../../node_modules/style-value-types/dist/es/color/utils.mjs\nvar isColorString = (type, testProp) => (v) => {\n  return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));\n};\nvar splitColor = (aName, bName, cName) => (v) => {\n  if (!isString(v))\n    return v;\n  const [a2, b2, c3, alpha2] = v.match(floatRegex);\n  return {\n    [aName]: parseFloat(a2),\n    [bName]: parseFloat(b2),\n    [cName]: parseFloat(c3),\n    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1\n  };\n};\n\n// ../../node_modules/style-value-types/dist/es/color/hsla.mjs\nvar hsla = {\n  test: isColorString(\"hsl\", \"hue\"),\n  parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n    return \"hsla(\" + Math.round(hue) + \", \" + percent.transform(sanitize(saturation)) + \", \" + percent.transform(sanitize(lightness)) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\";\n  }\n};\n\n// ../../node_modules/style-value-types/dist/es/color/rgba.mjs\nvar clampRgbUnit = clamp(0, 255);\nvar rgbUnit = Object.assign(Object.assign({}, number), { transform: (v) => Math.round(clampRgbUnit(v)) });\nvar rgba = {\n  test: isColorString(\"rgb\", \"red\"),\n  parse: splitColor(\"red\", \"green\", \"blue\"),\n  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" + rgbUnit.transform(red) + \", \" + rgbUnit.transform(green) + \", \" + rgbUnit.transform(blue) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\"\n};\n\n// ../../node_modules/style-value-types/dist/es/color/hex.mjs\nfunction parseHex(v) {\n  let r = \"\";\n  let g2 = \"\";\n  let b2 = \"\";\n  let a2 = \"\";\n  if (v.length > 5) {\n    r = v.substr(1, 2);\n    g2 = v.substr(3, 2);\n    b2 = v.substr(5, 2);\n    a2 = v.substr(7, 2);\n  } else {\n    r = v.substr(1, 1);\n    g2 = v.substr(2, 1);\n    b2 = v.substr(3, 1);\n    a2 = v.substr(4, 1);\n    r += r;\n    g2 += g2;\n    b2 += b2;\n    a2 += a2;\n  }\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g2, 16),\n    blue: parseInt(b2, 16),\n    alpha: a2 ? parseInt(a2, 16) / 255 : 1\n  };\n}\nvar hex = {\n  test: isColorString(\"#\"),\n  parse: parseHex,\n  transform: rgba.transform\n};\n\n// ../../node_modules/style-value-types/dist/es/color/index.mjs\nvar color = {\n  test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n  parse: (v) => {\n    if (rgba.test(v)) {\n      return rgba.parse(v);\n    } else if (hsla.test(v)) {\n      return hsla.parse(v);\n    } else {\n      return hex.parse(v);\n    }\n  },\n  transform: (v) => {\n    return isString(v) ? v : v.hasOwnProperty(\"red\") ? rgba.transform(v) : hsla.transform(v);\n  }\n};\n\n// ../../node_modules/style-value-types/dist/es/complex/index.mjs\nvar colorToken = \"${c}\";\nvar numberToken = \"${n}\";\nfunction test(v) {\n  var _a, _b, _c, _d;\n  return isNaN(v) && isString(v) && ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;\n}\nfunction analyse(v) {\n  if (typeof v === \"number\")\n    v = `${v}`;\n  const values = [];\n  let numColors = 0;\n  const colors = v.match(colorRegex);\n  if (colors) {\n    numColors = colors.length;\n    v = v.replace(colorRegex, colorToken);\n    values.push(...colors.map(color.parse));\n  }\n  const numbers = v.match(floatRegex);\n  if (numbers) {\n    v = v.replace(floatRegex, numberToken);\n    values.push(...numbers.map(number.parse));\n  }\n  return { values, numColors, tokenised: v };\n}\nfunction parse(v) {\n  return analyse(v).values;\n}\nfunction createTransformer(v) {\n  const { values, numColors, tokenised } = analyse(v);\n  const numValues = values.length;\n  return (v2) => {\n    let output = tokenised;\n    for (let i2 = 0; i2 < numValues; i2++) {\n      output = output.replace(i2 < numColors ? colorToken : numberToken, i2 < numColors ? color.transform(v2[i2]) : sanitize(v2[i2]));\n    }\n    return output;\n  };\n}\nvar convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone(v) {\n  const parsed = parse(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\nvar complex = { test, parse, createTransformer, getAnimatableNone };\n\n// ../../node_modules/style-value-types/dist/es/complex/filter.mjs\nvar maxDefaults = /* @__PURE__ */ new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n  let [name, value] = v.slice(0, -1).split(\"(\");\n  if (name === \"drop-shadow\")\n    return v;\n  const [number2] = value.match(floatRegex) || [];\n  if (!number2)\n    return v;\n  const unit = value.replace(number2, \"\");\n  let defaultValue = maxDefaults.has(name) ? 1 : 0;\n  if (number2 !== value)\n    defaultValue *= 100;\n  return name + \"(\" + defaultValue + unit + \")\";\n}\nvar functionRegex = /([a-z-]*)\\(.*?\\)/g;\nvar filter = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v) => {\n  const functions = v.match(functionRegex);\n  return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n} });\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs\nvar int = __spreadProps(__spreadValues({}, number), {\n  transform: Math.round\n});\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs\nvar numberValueTypes = {\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  transformPerspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  zIndex: int,\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n  const { style, vars, transform, transformKeys: transformKeys2, transformOrigin } = state;\n  transformKeys2.length = 0;\n  let hasTransform2 = false;\n  let hasTransformOrigin = false;\n  let transformIsNone = true;\n  for (const key in latestValues) {\n    const value = latestValues[key];\n    if (isCSSVariable(key)) {\n      vars[key] = value;\n      continue;\n    }\n    const valueType = numberValueTypes[key];\n    const valueAsType = getValueAsType(value, valueType);\n    if (transformProps.has(key)) {\n      hasTransform2 = true;\n      transform[key] = valueAsType;\n      transformKeys2.push(key);\n      if (!transformIsNone)\n        continue;\n      if (value !== (valueType.default || 0))\n        transformIsNone = false;\n    } else if (key.startsWith(\"origin\")) {\n      hasTransformOrigin = true;\n      transformOrigin[key] = valueAsType;\n    } else {\n      style[key] = valueAsType;\n    }\n  }\n  if (!latestValues.transform) {\n    if (hasTransform2 || transformTemplate) {\n      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n    } else if (style.transform) {\n      style.transform = \"none\";\n    }\n  }\n  if (hasTransformOrigin) {\n    const { originX = \"50%\", originY = \"50%\", originZ = 0 } = transformOrigin;\n    style.transformOrigin = `${originX} ${originY} ${originZ}`;\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs\nvar createHtmlRenderState = () => ({\n  style: {},\n  transform: {},\n  transformKeys: [],\n  transformOrigin: {},\n  vars: {}\n});\n\n// ../../node_modules/framer-motion/dist/es/render/html/use-props.mjs\nfunction copyRawValuesOnly(target, source, props) {\n  for (const key in source) {\n    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState, isStatic) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    const state = createHtmlRenderState();\n    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);\n    return Object.assign({}, state.vars, state.style);\n  }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n  const styleProp = props.style || {};\n  const style = {};\n  copyRawValuesOnly(style, styleProp, props);\n  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n  return props.transformValues ? props.transformValues(style) : style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n  const htmlProps = {};\n  const style = useStyle(props, visualState, isStatic);\n  if (props.drag && props.dragListener !== false) {\n    htmlProps.draggable = false;\n    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n    style.touchAction = props.drag === true ? \"none\" : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n  }\n  htmlProps.style = style;\n  return htmlProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs\nvar animationProps = [\n  \"animate\",\n  \"exit\",\n  \"variants\",\n  \"whileHover\",\n  \"whileTap\",\n  \"whileFocus\",\n  \"whileDrag\",\n  \"whileInView\"\n];\nvar tapProps = [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"];\nvar panProps = [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"];\nvar inViewProps = [\n  \"whileInView\",\n  \"onViewportEnter\",\n  \"onViewportLeave\",\n  \"viewport\"\n];\nvar validMotionProps = /* @__PURE__ */ new Set([\n  \"initial\",\n  \"style\",\n  \"values\",\n  \"variants\",\n  \"transition\",\n  \"transformTemplate\",\n  \"transformValues\",\n  \"custom\",\n  \"inherit\",\n  \"layout\",\n  \"layoutId\",\n  \"layoutDependency\",\n  \"onLayoutAnimationStart\",\n  \"onLayoutAnimationComplete\",\n  \"onLayoutMeasure\",\n  \"onBeforeLayoutMeasure\",\n  \"onAnimationStart\",\n  \"onAnimationComplete\",\n  \"onUpdate\",\n  \"onDragStart\",\n  \"onDrag\",\n  \"onDragEnd\",\n  \"onMeasureDragConstraints\",\n  \"onDirectionLock\",\n  \"onDragTransitionEnd\",\n  \"drag\",\n  \"dragControls\",\n  \"dragListener\",\n  \"dragConstraints\",\n  \"dragDirectionLock\",\n  \"dragSnapToOrigin\",\n  \"_dragX\",\n  \"_dragY\",\n  \"dragElastic\",\n  \"dragMomentum\",\n  \"dragPropagation\",\n  \"dragTransition\",\n  \"onHoverStart\",\n  \"onHoverEnd\",\n  \"layoutScroll\",\n  ...inViewProps,\n  ...tapProps,\n  ...animationProps,\n  ...panProps\n]);\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs\nvar shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n  if (!isValidProp)\n    return;\n  shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\ntry {\n  loadExternalIsValidProp((init_is_prop_valid_esm(), __toCommonJS(is_prop_valid_esm_exports)).default);\n} catch (_a) {\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n  const filteredProps = {};\n  for (const key in props) {\n    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props[\"draggable\"] && key.startsWith(\"onDrag\")) {\n      filteredProps[key] = props[key];\n    }\n  }\n  return filteredProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/use-props.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs\nfunction calcOrigin(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n  return `${pxOriginX} ${pxOriginY}`;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/path.mjs\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n  attrs.pathLength = 1;\n  const keys2 = useDashCase ? dashKeys : camelKeys;\n  attrs[keys2.offset] = px.transform(-offset);\n  const pathLength = px.transform(length);\n  const pathSpacing = px.transform(spacing);\n  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs\nfunction buildSVGAttrs(state, _a, options, transformTemplate) {\n  var _b = _a, {\n    attrX,\n    attrY,\n    originX,\n    originY,\n    pathLength,\n    pathSpacing = 1,\n    pathOffset = 0\n  } = _b, latest = __objRest(_b, [\n    \"attrX\",\n    \"attrY\",\n    \"originX\",\n    \"originY\",\n    \"pathLength\",\n    \"pathSpacing\",\n    \"pathOffset\"\n  ]);\n  buildHTMLStyles(state, latest, options, transformTemplate);\n  state.attrs = state.style;\n  state.style = {};\n  const { attrs, style, dimensions } = state;\n  if (attrs.transform) {\n    if (dimensions)\n      style.transform = attrs.transform;\n    delete attrs.transform;\n  }\n  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);\n  }\n  if (attrX !== void 0)\n    attrs.x = attrX;\n  if (attrY !== void 0)\n    attrs.y = attrY;\n  if (pathLength !== void 0) {\n    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs\nvar createSvgRenderState = () => __spreadProps(__spreadValues({}, createHtmlRenderState()), {\n  attrs: {}\n});\n\n// ../../node_modules/framer-motion/dist/es/render/svg/use-props.mjs\nfunction useSVGProps(props, visualState) {\n  const visualProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    const state = createSvgRenderState();\n    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);\n    return __spreadProps(__spreadValues({}, state.attrs), {\n      style: __spreadValues({}, state.style)\n    });\n  }, [visualState]);\n  if (props.style) {\n    const rawStyles = {};\n    copyRawValuesOnly(rawStyles, props.style, props);\n    visualProps.style = __spreadValues(__spreadValues({}, rawStyles), visualProps.style);\n  }\n  return visualProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/use-render.mjs\nfunction createUseRender(forwardMotionProps = false) {\n  const useRender = (Component, props, projectionId, ref, { latestValues }, isStatic) => {\n    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;\n    const visualProps = useVisualProps(props, latestValues, isStatic);\n    const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n    const elementProps = __spreadProps(__spreadValues(__spreadValues({}, filteredProps), visualProps), {\n      ref\n    });\n    if (projectionId) {\n      elementProps[\"data-projection-id\"] = projectionId;\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Component, elementProps);\n  };\n  return useRender;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs\nvar camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/render.mjs\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n  for (const key in vars) {\n    element.style.setProperty(key, vars[key]);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs\nvar camelCaseAttributes = /* @__PURE__ */ new Set([\n  \"baseFrequency\",\n  \"diffuseConstant\",\n  \"kernelMatrix\",\n  \"kernelUnitLength\",\n  \"keySplines\",\n  \"keyTimes\",\n  \"limitingConeAngle\",\n  \"markerHeight\",\n  \"markerWidth\",\n  \"numOctaves\",\n  \"targetX\",\n  \"targetY\",\n  \"surfaceScale\",\n  \"specularConstant\",\n  \"specularExponent\",\n  \"stdDeviation\",\n  \"tableValues\",\n  \"viewBox\",\n  \"gradientTransform\",\n  \"pathLength\"\n]);\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/render.mjs\nfunction renderSVG(element, renderState, _styleProp, projection) {\n  renderHTML(element, renderState, void 0, projection);\n  for (const key in renderState.attrs) {\n    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs\nfunction scrapeMotionValuesFromProps(props) {\n  const { style } = props;\n  const newValues = {};\n  for (const key in style) {\n    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n      newValues[key] = style[key];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs\nfunction scrapeMotionValuesFromProps2(props) {\n  const newValues = scrapeMotionValuesFromProps(props);\n  for (const key in props) {\n    if (isMotionValue(props[key])) {\n      const targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n      newValues[targetKey] = props[key];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs\nfunction resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n  }\n  if (typeof definition === \"string\") {\n    definition = props.variants && props.variants[definition];\n  }\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n  }\n  return definition;\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs\nvar isKeyframesTarget = (v) => {\n  return Array.isArray(v);\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/resolve-value.mjs\nvar isCustomValue = (v) => {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = (v) => {\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n// ../../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs\nfunction resolveMotionValue(value) {\n  const unwrappedValue = isMotionValue(value) ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\nfunction makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props, context, presenceContext) {\n  const state = {\n    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),\n    renderState: createRenderState()\n  };\n  if (onMount) {\n    state.mount = (instance) => onMount(props, instance, state);\n  }\n  return state;\n}\nvar makeUseVisualState = (config) => (props, isStatic) => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionContext);\n  const presenceContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PresenceContext);\n  const make = () => makeState(config, props, context, presenceContext);\n  return isStatic ? make() : useConstant(make);\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n  const values = {};\n  const motionValues = scrapeMotionValues(props);\n  for (const key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n  let { initial, animate: animate3 } = props;\n  const isControllingVariants$1 = isControllingVariants(props);\n  const isVariantNode$1 = isVariantNode(props);\n  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {\n    if (initial === void 0)\n      initial = context.initial;\n    if (animate3 === void 0)\n      animate3 = context.animate;\n  }\n  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;\n  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n  const variantToSet = isInitialAnimationBlocked ? animate3 : initial;\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n    list.forEach((definition) => {\n      const resolved = resolveVariantFromProps(props, definition);\n      if (!resolved)\n        return;\n      const _a = resolved, { transitionEnd, transition } = _a, target = __objRest(_a, [\"transitionEnd\", \"transition\"]);\n      for (const key in target) {\n        let valueTarget = target[key];\n        if (Array.isArray(valueTarget)) {\n          const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;\n          valueTarget = valueTarget[index2];\n        }\n        if (valueTarget !== null) {\n          values[key] = valueTarget;\n        }\n      }\n      for (const key in transitionEnd)\n        values[key] = transitionEnd[key];\n    });\n  }\n  return values;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/config-motion.mjs\nvar svgMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,\n    createRenderState: createSvgRenderState,\n    onMount: (props, instance, { renderState, latestValues }) => {\n      try {\n        renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n      } catch (e) {\n        renderState.dimensions = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);\n      renderSVG(instance, renderState);\n    }\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/config-motion.mjs\nvar htmlMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps,\n    createRenderState: createHtmlRenderState\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs\nfunction createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures, createVisualElement, projectionNodeConstructor) {\n  const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;\n  return __spreadProps(__spreadValues({}, baseConfig), {\n    preloadedFeatures,\n    useRender: createUseRender(forwardMotionProps),\n    createVisualElement,\n    projectionNodeConstructor,\n    Component\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/types.mjs\nvar AnimationType;\n(function(AnimationType2) {\n  AnimationType2[\"Animate\"] = \"animate\";\n  AnimationType2[\"Hover\"] = \"whileHover\";\n  AnimationType2[\"Tap\"] = \"whileTap\";\n  AnimationType2[\"Drag\"] = \"whileDrag\";\n  AnimationType2[\"Focus\"] = \"whileFocus\";\n  AnimationType2[\"InView\"] = \"whileInView\";\n  AnimationType2[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\n// ../../node_modules/framer-motion/dist/es/events/use-dom-event.mjs\n\nfunction addDomEvent(target, eventName, handler, options = { passive: true }) {\n  target.addEventListener(eventName, handler, options);\n  return () => target.removeEventListener(eventName, handler);\n}\nfunction useDomEvent(ref, eventName, handler, options) {\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const element = ref.current;\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-focus-gesture.mjs\nfunction useFocusGesture({ whileFocus, visualElement }) {\n  const { animationState } = visualElement;\n  const onFocus = () => {\n    animationState && animationState.setActive(AnimationType.Focus, true);\n  };\n  const onBlur = () => {\n    animationState && animationState.setActive(AnimationType.Focus, false);\n  };\n  useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : void 0);\n  useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : void 0);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/utils/event-type.mjs\nfunction isMouseEvent(event) {\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n  return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n  const hasTouches = !!event.touches;\n  return hasTouches;\n}\n\n// ../../node_modules/framer-motion/dist/es/events/event-info.mjs\nfunction filterPrimaryPointer(eventHandler) {\n  return (event) => {\n    const isMouseEvent2 = event instanceof MouseEvent;\n    const isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType = \"page\") {\n  const primaryTouch = e.touches[0] || e.changedTouches[0];\n  const point2 = primaryTouch || defaultPagePoint;\n  return {\n    x: point2[pointType + \"X\"],\n    y: point2[pointType + \"Y\"]\n  };\n}\nfunction pointFromMouse(point2, pointType = \"page\") {\n  return {\n    x: point2[pointType + \"X\"],\n    y: point2[pointType + \"Y\"]\n  };\n}\nfunction extractEventInfo(event, pointType = \"page\") {\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\nvar wrapHandler = (handler, shouldFilterPrimaryPointer = false) => {\n  const listener = (event) => handler(event, extractEventInfo(event));\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n\n// ../../node_modules/framer-motion/dist/es/events/utils.mjs\nvar supportsPointerEvents = () => isBrowser && window.onpointerdown === null;\nvar supportsTouchEvents = () => isBrowser && window.ontouchstart === null;\nvar supportsMouseEvents = () => isBrowser && window.onmousedown === null;\n\n// ../../node_modules/framer-motion/dist/es/events/use-pointer-event.mjs\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n  return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs\nfunction createLock(name) {\n  let lock = null;\n  return () => {\n    const openLock = () => {\n      lock = null;\n    };\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n    return false;\n  };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag2) {\n  let lock = false;\n  if (drag2 === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag2 === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    const openHorizontal = globalHorizontalLock();\n    const openVertical = globalVerticalLock();\n    if (openHorizontal && openVertical) {\n      lock = () => {\n        openHorizontal();\n        openVertical();\n      };\n    } else {\n      if (openHorizontal)\n        openHorizontal();\n      if (openVertical)\n        openVertical();\n    }\n  }\n  return lock;\n}\nfunction isDragActive() {\n  const openGestureLock = getGlobalLock(true);\n  if (!openGestureLock)\n    return true;\n  openGestureLock();\n  return false;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-hover-gesture.mjs\nfunction createHoverEvent(visualElement, isActive, callback) {\n  return (event, info) => {\n    if (!isMouseEvent(event) || isDragActive())\n      return;\n    if (visualElement.animationState) {\n      visualElement.animationState.setActive(AnimationType.Hover, isActive);\n    }\n    callback && callback(event, info);\n  };\n}\nfunction useHoverGesture({ onHoverStart, onHoverEnd, whileHover, visualElement }) {\n  usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover ? createHoverEvent(visualElement, true, onHoverStart) : void 0, { passive: !onHoverStart });\n  usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover ? createHoverEvent(visualElement, false, onHoverEnd) : void 0, { passive: !onHoverEnd });\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs\nvar isNodeOrChild = (parent, child) => {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs\n\nfunction useUnmountEffect(callback) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => () => callback(), []);\n}\n\n// ../../node_modules/popmotion/node_modules/tslib/modules/index.js\nvar import_tslib = __toESM(require_tslib(), 1);\nvar {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __exportStar,\n  __createBinding,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn\n} = import_tslib.default;\n\n// ../../node_modules/hey-listen/dist/hey-listen.es.js\nvar warning = function() {\n};\nvar invariant = function() {\n};\nif (true) {\n  warning = function(check, message) {\n    if (!check && typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n  };\n  invariant = function(check, message) {\n    if (!check) {\n      throw new Error(message);\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/clamp.mjs\nvar clamp2 = (min, max, v) => Math.min(Math.max(v, min), max);\n\n// ../../node_modules/popmotion/dist/es/animations/utils/find-spring.mjs\nvar safeMin = 1e-3;\nvar minDuration = 0.01;\nvar maxDuration = 10;\nvar minDamping = 0.05;\nvar maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {\n  let envelope;\n  let derivative;\n  warning(duration <= maxDuration * 1e3, \"Spring duration must be 10 seconds or less\");\n  let dampingRatio = 1 - bounce;\n  dampingRatio = clamp2(minDamping, maxDamping, dampingRatio);\n  duration = clamp2(minDuration, maxDuration, duration / 1e3);\n  if (dampingRatio < 1) {\n    envelope = (undampedFreq2) => {\n      const exponentialDecay = undampedFreq2 * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const a2 = exponentialDecay - velocity;\n      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);\n      const c3 = Math.exp(-delta);\n      return safeMin - a2 / b2 * c3;\n    };\n    derivative = (undampedFreq2) => {\n      const exponentialDecay = undampedFreq2 * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const d2 = delta * velocity + velocity;\n      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;\n      const f2 = Math.exp(-delta);\n      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);\n      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;\n      return factor * ((d2 - e) * f2) / g2;\n    };\n  } else {\n    envelope = (undampedFreq2) => {\n      const a2 = Math.exp(-undampedFreq2 * duration);\n      const b2 = (undampedFreq2 - velocity) * duration + 1;\n      return -safeMin + a2 * b2;\n    };\n    derivative = (undampedFreq2) => {\n      const a2 = Math.exp(-undampedFreq2 * duration);\n      const b2 = (velocity - undampedFreq2) * (duration * duration);\n      return a2 * b2;\n    };\n  }\n  const initialGuess = 5 / duration;\n  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = duration * 1e3;\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration\n    };\n  } else {\n    const stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\nvar rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  let result = initialGuess;\n  for (let i2 = 1; i2 < rootIterations; i2++) {\n    result = result - envelope(result) / derivative(result);\n  }\n  return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\n// ../../node_modules/popmotion/dist/es/animations/generators/spring.mjs\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys2) {\n  return keys2.some((key) => options[key] !== void 0);\n}\nfunction getSpringOptions(options) {\n  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\nfunction spring(_a) {\n  var { from = 0, to = 1, restSpeed = 2, restDelta } = _a, options = __rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n  const state = { done: false, value: from };\n  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);\n  let resolveSpring = zero;\n  let resolveVelocity = zero;\n  function createSpring() {\n    const initialVelocity = velocity ? -(velocity / 1e3) : 0;\n    const initialDelta = to - from;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;\n    if (restDelta === void 0) {\n      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n    }\n    if (dampingRatio < 1) {\n      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n      resolveSpring = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n      resolveVelocity = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      resolveSpring = (t) => to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n      resolveSpring = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n  createSpring();\n  return {\n    next: (t) => {\n      const current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        const currentVelocity = resolveVelocity(t) * 1e3;\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? to : current;\n      return state;\n    },\n    flipTarget: () => {\n      velocity = -velocity;\n      [from, to] = [to, from];\n      createSpring();\n    }\n  };\n}\nspring.needsInterpolation = (a2, b2) => typeof a2 === \"string\" || typeof b2 === \"string\";\nvar zero = (_t) => 0;\n\n// ../../node_modules/popmotion/dist/es/utils/progress.mjs\nvar progress = (from, to, value) => {\n  const toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\n// ../../node_modules/popmotion/dist/es/utils/mix.mjs\nvar mix = (from, to, progress3) => -progress3 * from + progress3 * to + from;\n\n// ../../node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs\nfunction hueToRgb(p2, q, t) {\n  if (t < 0)\n    t += 1;\n  if (t > 1)\n    t -= 1;\n  if (t < 1 / 6)\n    return p2 + (q - p2) * 6 * t;\n  if (t < 1 / 2)\n    return q;\n  if (t < 2 / 3)\n    return p2 + (q - p2) * (2 / 3 - t) * 6;\n  return p2;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {\n  hue /= 360;\n  saturation /= 100;\n  lightness /= 100;\n  let red = 0;\n  let green = 0;\n  let blue = 0;\n  if (!saturation) {\n    red = green = blue = lightness;\n  } else {\n    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n    const p2 = 2 * lightness - q;\n    red = hueToRgb(p2, q, hue + 1 / 3);\n    green = hueToRgb(p2, q, hue);\n    blue = hueToRgb(p2, q, hue - 1 / 3);\n  }\n  return {\n    red: Math.round(red * 255),\n    green: Math.round(green * 255),\n    blue: Math.round(blue * 255),\n    alpha: alpha2\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/mix-color.mjs\nvar mixLinearColor = (from, to, v) => {\n  const fromExpo = from * from;\n  const toExpo = to * to;\n  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nvar colorTypes = [hex, rgba, hsla];\nvar getColorType = (v) => colorTypes.find((type) => type.test(v));\nvar notAnimatable = (color2) => `'${color2}' is not an animatable color. Use the equivalent color code instead.`;\nvar mixColor = (from, to) => {\n  let fromColorType = getColorType(from);\n  let toColorType = getColorType(to);\n  invariant(!!fromColorType, notAnimatable(from));\n  invariant(!!toColorType, notAnimatable(to));\n  let fromColor = fromColorType.parse(from);\n  let toColor = toColorType.parse(to);\n  if (fromColorType === hsla) {\n    fromColor = hslaToRgba(fromColor);\n    fromColorType = rgba;\n  }\n  if (toColorType === hsla) {\n    toColor = hslaToRgba(toColor);\n    toColorType = rgba;\n  }\n  const blended = Object.assign({}, fromColor);\n  return (v) => {\n    for (const key in blended) {\n      if (key !== \"alpha\") {\n        blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n      }\n    }\n    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n    return fromColorType.transform(blended);\n  };\n};\n\n// ../../node_modules/popmotion/dist/es/utils/inc.mjs\nvar isNum = (v) => typeof v === \"number\";\n\n// ../../node_modules/popmotion/dist/es/utils/pipe.mjs\nvar combineFunctions = (a2, b2) => (v) => b2(a2(v));\nvar pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n// ../../node_modules/popmotion/dist/es/utils/mix-complex.mjs\nfunction getMixer(origin, target) {\n  if (isNum(origin)) {\n    return (v) => mix(origin, target, v);\n  } else if (color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return mixComplex(origin, target);\n  }\n}\nvar mixArray = (from, to) => {\n  const output = [...from];\n  const numValues = output.length;\n  const blendValue = from.map((fromThis, i2) => getMixer(fromThis, to[i2]));\n  return (v) => {\n    for (let i2 = 0; i2 < numValues; i2++) {\n      output[i2] = blendValue[i2](v);\n    }\n    return output;\n  };\n};\nvar mixObject = (origin, target) => {\n  const output = Object.assign(Object.assign({}, origin), target);\n  const blendValue = {};\n  for (const key in output) {\n    if (origin[key] !== void 0 && target[key] !== void 0) {\n      blendValue[key] = getMixer(origin[key], target[key]);\n    }\n  }\n  return (v) => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n    return output;\n  };\n};\nfunction analyse2(value) {\n  const parsed = complex.parse(value);\n  const numValues = parsed.length;\n  let numNumbers = 0;\n  let numRGB = 0;\n  let numHSL = 0;\n  for (let i2 = 0; i2 < numValues; i2++) {\n    if (numNumbers || typeof parsed[i2] === \"number\") {\n      numNumbers++;\n    } else {\n      if (parsed[i2].hue !== void 0) {\n        numHSL++;\n      } else {\n        numRGB++;\n      }\n    }\n  }\n  return { parsed, numNumbers, numRGB, numHSL };\n}\nvar mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyse2(origin);\n  const targetStats = analyse2(target);\n  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n  } else {\n    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return (p2) => `${p2 > 0 ? target : origin}`;\n  }\n};\n\n// ../../node_modules/popmotion/dist/es/utils/interpolate.mjs\nvar mixNumber = (from, to) => (p2) => mix(from, to, p2);\nfunction detectMixerFactory(v) {\n  if (typeof v === \"number\") {\n    return mixNumber;\n  } else if (typeof v === \"string\") {\n    if (color.test(v)) {\n      return mixColor;\n    } else {\n      return mixComplex;\n    }\n  } else if (Array.isArray(v)) {\n    return mixArray;\n  } else if (typeof v === \"object\") {\n    return mixObject;\n  }\n}\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || detectMixerFactory(output[0]);\n  const numMixers = output.length - 1;\n  for (let i2 = 0; i2 < numMixers; i2++) {\n    let mixer = mixerFactory(output[i2], output[i2 + 1]);\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i2] : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n    mixers.push(mixer);\n  }\n  return mixers;\n}\nfunction fastInterpolate([from, to], [mixer]) {\n  return (v) => mixer(progress(from, to, v));\n}\nfunction slowInterpolate(input, mixers) {\n  const inputLength = input.length;\n  const lastInputIndex = inputLength - 1;\n  return (v) => {\n    let mixerIndex = 0;\n    let foundMixerIndex = false;\n    if (v <= input[0]) {\n      foundMixerIndex = true;\n    } else if (v >= input[lastInputIndex]) {\n      mixerIndex = lastInputIndex - 1;\n      foundMixerIndex = true;\n    }\n    if (!foundMixerIndex) {\n      let i2 = 1;\n      for (; i2 < inputLength; i2++) {\n        if (input[i2] > v || i2 === lastInputIndex) {\n          break;\n        }\n      }\n      mixerIndex = i2 - 1;\n    }\n    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n    return mixers[mixerIndex](progressInRange);\n  };\n}\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n  const inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, \"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.\");\n  if (input[0] > input[inputLength - 1]) {\n    input = [].concat(input);\n    output = [].concat(output);\n    input.reverse();\n    output.reverse();\n  }\n  const mixers = createMixers(output, ease, mixer);\n  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);\n  return isClamp ? (v) => interpolator(clamp2(input[0], input[inputLength - 1], v)) : interpolator;\n}\n\n// ../../node_modules/popmotion/dist/es/easing/utils.mjs\nvar reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);\nvar mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;\nvar createExpoIn = (power) => (p2) => Math.pow(p2, power);\nvar createBackIn = (power) => (p2) => p2 * p2 * ((power + 1) * p2 - power);\nvar createAnticipate = (power) => {\n  const backEasing = createBackIn(power);\n  return (p2) => (p2 *= 2) < 1 ? 0.5 * backEasing(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));\n};\n\n// ../../node_modules/popmotion/dist/es/easing/index.mjs\nvar DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nvar BOUNCE_FIRST_THRESHOLD = 4 / 11;\nvar BOUNCE_SECOND_THRESHOLD = 8 / 11;\nvar BOUNCE_THIRD_THRESHOLD = 9 / 10;\nvar linear = (p2) => p2;\nvar easeIn = createExpoIn(2);\nvar easeOut = reverseEasing(easeIn);\nvar easeInOut = mirrorEasing(easeIn);\nvar circIn = (p2) => 1 - Math.sin(Math.acos(p2));\nvar circOut = reverseEasing(circIn);\nvar circInOut = mirrorEasing(circOut);\nvar backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nvar backOut = reverseEasing(backIn);\nvar backInOut = mirrorEasing(backIn);\nvar anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nvar ca = 4356 / 361;\nvar cb = 35442 / 1805;\nvar cc = 16061 / 1805;\nvar bounceOut = (p2) => {\n  if (p2 === 1 || p2 === 0)\n    return p2;\n  const p22 = p2 * p2;\n  return p2 < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p22 : p2 < BOUNCE_SECOND_THRESHOLD ? 9.075 * p22 - 9.9 * p2 + 3.4 : p2 < BOUNCE_THIRD_THRESHOLD ? ca * p22 - cb * p2 + cc : 10.8 * p2 * p2 - 20.52 * p2 + 10.72;\n};\nvar bounceIn = reverseEasing(bounceOut);\nvar bounceInOut = (p2) => p2 < 0.5 ? 0.5 * (1 - bounceOut(1 - p2 * 2)) : 0.5 * bounceOut(p2 * 2 - 1) + 0.5;\n\n// ../../node_modules/popmotion/dist/es/animations/generators/keyframes.mjs\nfunction defaultEasing(values, easing) {\n  return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n  const numValues = values.length;\n  return values.map((_value, i2) => i2 !== 0 ? i2 / (numValues - 1) : 0);\n}\nfunction convertOffsetToTimes(offset, duration) {\n  return offset.map((o) => o * duration);\n}\nfunction keyframes({ from = 0, to = 1, ease, offset, duration = 300 }) {\n  const state = { done: false, value: from };\n  const values = Array.isArray(to) ? to : [from, to];\n  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);\n  function createInterpolator() {\n    return interpolate(times, values, {\n      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)\n    });\n  }\n  let interpolator = createInterpolator();\n  return {\n    next: (t) => {\n      state.value = interpolator(t);\n      state.done = t >= duration;\n      return state;\n    },\n    flipTarget: () => {\n      values.reverse();\n      interpolator = createInterpolator();\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/animations/generators/decay.mjs\nfunction decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {\n  const state = { done: false, value: from };\n  let amplitude = power * velocity;\n  const ideal = from + amplitude;\n  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);\n  if (target !== ideal)\n    amplitude = target - from;\n  return {\n    next: (t) => {\n      const delta = -amplitude * Math.exp(-t / timeConstant);\n      state.done = !(delta > restDelta || delta < -restDelta);\n      state.value = state.done ? target : target + delta;\n      return state;\n    },\n    flipTarget: () => {\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs\nvar types = { keyframes, spring, decay };\nfunction detectAnimationFromOptions(config) {\n  if (Array.isArray(config.to)) {\n    return keyframes;\n  } else if (types[config.type]) {\n    return types[config.type];\n  }\n  const keys2 = new Set(Object.keys(config));\n  if (keys2.has(\"ease\") || keys2.has(\"duration\") && !keys2.has(\"dampingRatio\")) {\n    return keyframes;\n  } else if (keys2.has(\"dampingRatio\") || keys2.has(\"stiffness\") || keys2.has(\"mass\") || keys2.has(\"damping\") || keys2.has(\"restSpeed\") || keys2.has(\"restDelta\")) {\n    return spring;\n  }\n  return keyframes;\n}\n\n// ../../node_modules/framesync/dist/es/on-next-frame.mjs\nvar defaultTimestep = 1 / 60 * 1e3;\nvar getCurrentTime = typeof performance !== \"undefined\" ? () => performance.now() : () => Date.now();\nvar onNextFrame = typeof window !== \"undefined\" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);\n\n// ../../node_modules/framesync/dist/es/create-render-step.mjs\nfunction createRenderStep(runNextFrame2) {\n  let toRun = [];\n  let toRunNextFrame = [];\n  let numToRun = 0;\n  let isProcessing2 = false;\n  let flushNextFrame = false;\n  const toKeepAlive = /* @__PURE__ */ new WeakSet();\n  const step = {\n    schedule: (callback, keepAlive = false, immediate = false) => {\n      const addToCurrentFrame = immediate && isProcessing2;\n      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n      if (keepAlive)\n        toKeepAlive.add(callback);\n      if (buffer.indexOf(callback) === -1) {\n        buffer.push(callback);\n        if (addToCurrentFrame && isProcessing2)\n          numToRun = toRun.length;\n      }\n      return callback;\n    },\n    cancel: (callback) => {\n      const index2 = toRunNextFrame.indexOf(callback);\n      if (index2 !== -1)\n        toRunNextFrame.splice(index2, 1);\n      toKeepAlive.delete(callback);\n    },\n    process: (frameData) => {\n      if (isProcessing2) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing2 = true;\n      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\n      toRunNextFrame.length = 0;\n      numToRun = toRun.length;\n      if (numToRun) {\n        for (let i2 = 0; i2 < numToRun; i2++) {\n          const callback = toRun[i2];\n          callback(frameData);\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame2();\n          }\n        }\n      }\n      isProcessing2 = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\n\n// ../../node_modules/framesync/dist/es/index.mjs\nvar maxElapsed = 40;\nvar useDefaultElapsed = true;\nvar runNextFrame = false;\nvar isProcessing = false;\nvar frame = {\n  delta: 0,\n  timestamp: 0\n};\nvar stepsOrder = [\n  \"read\",\n  \"update\",\n  \"preRender\",\n  \"render\",\n  \"postRender\"\n];\nvar steps = stepsOrder.reduce((acc, key) => {\n  acc[key] = createRenderStep(() => runNextFrame = true);\n  return acc;\n}, {});\nvar sync = stepsOrder.reduce((acc, key) => {\n  const step = steps[key];\n  acc[key] = (process2, keepAlive = false, immediate = false) => {\n    if (!runNextFrame)\n      startLoop();\n    return step.schedule(process2, keepAlive, immediate);\n  };\n  return acc;\n}, {});\nvar cancelSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = steps[key].cancel;\n  return acc;\n}, {});\nvar flushSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = () => steps[key].process(frame);\n  return acc;\n}, {});\nvar processStep = (stepId) => steps[stepId].process(frame);\nvar processFrame = (timestamp) => {\n  runNextFrame = false;\n  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\n  frame.timestamp = timestamp;\n  isProcessing = true;\n  stepsOrder.forEach(processStep);\n  isProcessing = false;\n  if (runNextFrame) {\n    useDefaultElapsed = false;\n    onNextFrame(processFrame);\n  }\n};\nvar startLoop = () => {\n  runNextFrame = true;\n  useDefaultElapsed = true;\n  if (!isProcessing)\n    onNextFrame(processFrame);\n};\nvar getFrameData = () => frame;\nvar es_default = sync;\n\n// ../../node_modules/popmotion/dist/es/animations/utils/elapsed.mjs\nfunction loopElapsed(elapsed, duration, delay2 = 0) {\n  return elapsed - duration - delay2;\n}\nfunction reverseElapsed(elapsed, duration, delay2 = 0, isForwardPlayback = true) {\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay2) : duration - (elapsed - duration) + delay2;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay2, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay2 : elapsed <= -delay2;\n}\n\n// ../../node_modules/popmotion/dist/es/animations/index.mjs\nvar framesync = (update) => {\n  const passTimestamp = ({ delta }) => update(delta);\n  return {\n    start: () => es_default.update(passTimestamp, true),\n    stop: () => cancelSync.update(passTimestamp)\n  };\n};\nfunction animate(_a) {\n  var _b, _c;\n  var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n  let { to } = options;\n  let driverControls;\n  let repeatCount = 0;\n  let computedDuration = options.duration;\n  let latest;\n  let isComplete = false;\n  let isForwardPlayback = true;\n  let interpolateFromNumber;\n  const animator = detectAnimationFromOptions(options);\n  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n    interpolateFromNumber = interpolate([0, 100], [from, to], {\n      clamp: false\n    });\n    from = 0;\n    to = 100;\n  }\n  const animation = animator(Object.assign(Object.assign({}, options), { from, to }));\n  function repeat() {\n    repeatCount++;\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\")\n        animation.flipTarget();\n    }\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n  function complete() {\n    driverControls.stop();\n    onComplete && onComplete();\n  }\n  function update(delta) {\n    if (!isForwardPlayback)\n      delta = -delta;\n    elapsed += delta;\n    if (!isComplete) {\n      const state = animation.next(Math.max(0, elapsed));\n      latest = state.value;\n      if (interpolateFromNumber)\n        latest = interpolateFromNumber(latest);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n    if (isComplete) {\n      if (repeatCount === 0)\n        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n  function play() {\n    onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n  autoplay && play();\n  return {\n    stop: () => {\n      onStop === null || onStop === void 0 ? void 0 : onStop();\n      driverControls.stop();\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/velocity-per-second.mjs\nfunction velocityPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1e3 / frameDuration) : 0;\n}\n\n// ../../node_modules/popmotion/dist/es/animations/inertia.mjs\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {\n  let currentAnimation;\n  function isOutOfBounds(v) {\n    return min !== void 0 && v < min || max !== void 0 && v > max;\n  }\n  function boundaryNearest(v) {\n    if (min === void 0)\n      return max;\n    if (max === void 0)\n      return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  }\n  function startAnimation2(options) {\n    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n    currentAnimation = animate(Object.assign(Object.assign({}, options), {\n      driver,\n      onUpdate: (v) => {\n        var _a;\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n      },\n      onComplete,\n      onStop\n    }));\n  }\n  function startSpring(options) {\n    startAnimation2(Object.assign({ type: \"spring\", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));\n  }\n  if (isOutOfBounds(from)) {\n    startSpring({ from, velocity, to: boundaryNearest(from) });\n  } else {\n    let target = power * velocity + from;\n    if (typeof modifyTarget !== \"undefined\")\n      target = modifyTarget(target);\n    const boundary = boundaryNearest(target);\n    const heading = boundary === min ? -1 : 1;\n    let prev;\n    let current;\n    const checkBoundary = (v) => {\n      prev = current;\n      current = v;\n      velocity = velocityPerSecond(v - prev, getFrameData().delta);\n      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {\n        startSpring({ from: v, to: boundary, velocity });\n      }\n    };\n    startAnimation2({\n      type: \"decay\",\n      from,\n      velocity,\n      timeConstant,\n      power,\n      restDelta,\n      modifyTarget,\n      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0\n    });\n  }\n  return {\n    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/is-point.mjs\nvar isPoint = (point2) => point2.hasOwnProperty(\"x\") && point2.hasOwnProperty(\"y\");\n\n// ../../node_modules/popmotion/dist/es/utils/is-point-3d.mjs\nvar isPoint3D = (point2) => isPoint(point2) && point2.hasOwnProperty(\"z\");\n\n// ../../node_modules/popmotion/dist/es/utils/distance.mjs\nvar distance1D = (a2, b2) => Math.abs(a2 - b2);\nfunction distance(a2, b2) {\n  if (isNum(a2) && isNum(b2)) {\n    return distance1D(a2, b2);\n  } else if (isPoint(a2) && isPoint(b2)) {\n    const xDelta = distance1D(a2.x, b2.x);\n    const yDelta = distance1D(a2.y, b2.y);\n    const zDelta = isPoint3D(a2) && isPoint3D(b2) ? distance1D(a2.z, b2.z) : 0;\n    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n  }\n}\n\n// ../../node_modules/popmotion/dist/es/easing/cubic-bezier.mjs\nvar a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\nvar b = (a1, a2) => 3 * a2 - 6 * a1;\nvar c2 = (a1) => 3 * a1;\nvar calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c2(a1)) * t;\nvar getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c2(a1);\nvar subdivisionPrecision = 1e-7;\nvar subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX;\n  let currentT;\n  let i2 = 0;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);\n  return currentT;\n}\nvar newtonIterations = 8;\nvar newtonMinSlope = 1e-3;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i2 = 0; i2 < newtonIterations; ++i2) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0) {\n      return aGuessT;\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  if (mX1 === mY1 && mX2 === mY2)\n    return linear;\n  const sampleValues = new Float32Array(kSplineTableSize);\n  for (let i2 = 0; i2 < kSplineTableSize; ++i2) {\n    sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);\n  }\n  function getTForX(aX) {\n    let intervalStart = 0;\n    let currentSample = 1;\n    const lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= newtonMinSlope) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs\nfunction useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement }) {\n  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  const isPressing = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n  const cancelPointerEndListeners = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const eventOptions = {\n    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)\n  };\n  function removePointerEndListener() {\n    cancelPointerEndListeners.current && cancelPointerEndListeners.current();\n    cancelPointerEndListeners.current = null;\n  }\n  function checkPointerEnd() {\n    removePointerEndListener();\n    isPressing.current = false;\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, false);\n    return !isDragActive();\n  }\n  function onPointerUp(event, info) {\n    if (!checkPointerEnd())\n      return;\n    !isNodeOrChild(visualElement.current, event.target) ? onTapCancel && onTapCancel(event, info) : onTap && onTap(event, info);\n  }\n  function onPointerCancel(event, info) {\n    if (!checkPointerEnd())\n      return;\n    onTapCancel && onTapCancel(event, info);\n  }\n  function onPointerDown(event, info) {\n    removePointerEndListener();\n    if (isPressing.current)\n      return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, true);\n    onTapStart && onTapStart(event, info);\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : void 0, eventOptions);\n  useUnmountEffect(removePointerEndListener);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/process.mjs\nvar defaultEnvironment = \"production\";\nvar env = typeof process === \"undefined\" || process.env === void 0 ? defaultEnvironment : \"development\" || 0;\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/utils/warn-once.mjs\nvar warned = /* @__PURE__ */ new Set();\nfunction warnOnce(condition, message, element) {\n  if (condition || warned.has(message))\n    return;\n  console.warn(message);\n  if (element)\n    console.warn(element);\n  warned.add(message);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs\nvar observerCallbacks = /* @__PURE__ */ new WeakMap();\nvar observers = /* @__PURE__ */ new WeakMap();\nvar fireObserverCallback = (entry) => {\n  const callback = observerCallbacks.get(entry.target);\n  callback && callback(entry);\n};\nvar fireAllObserverCallbacks = (entries) => {\n  entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_a) {\n  var _b = _a, { root } = _b, options = __objRest(_b, [\"root\"]);\n  const lookupRoot = root || document;\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n  const rootObservers = observers.get(lookupRoot);\n  const key = JSON.stringify(options);\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __spreadValues({ root }, options));\n  }\n  return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n  const rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return () => {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs\nfunction useViewport({ visualElement, whileInView, onViewportEnter, onViewportLeave, viewport = {} }) {\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n    hasEnteredView: false,\n    isInView: false\n  });\n  let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n  if (viewport.once && state.current.hasEnteredView)\n    shouldObserve = false;\n  const useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n  useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nvar thresholdNames = {\n  some: 0,\n  all: 1\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, { root, margin: rootMargin, amount = \"some\", once }) {\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!shouldObserve || !visualElement.current)\n      return;\n    const options = {\n      root: root === null || root === void 0 ? void 0 : root.current,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    const intersectionCallback = (entry) => {\n      const { isIntersecting } = entry;\n      if (state.isInView === isIntersecting)\n        return;\n      state.isInView = isIntersecting;\n      if (once && !isIntersecting && state.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        state.hasEnteredView = true;\n      }\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, isIntersecting);\n      }\n      const props = visualElement.getProps();\n      const callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(visualElement.current, options, intersectionCallback);\n  }, [shouldObserve, root, rootMargin, amount]);\n}\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, { fallback = true }) {\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!shouldObserve || !fallback)\n      return;\n    if (env !== \"production\") {\n      warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n    }\n    requestAnimationFrame(() => {\n      state.hasEnteredView = true;\n      const { onViewportEnter } = visualElement.getProps();\n      onViewportEnter && onViewportEnter(null);\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, true);\n      }\n    });\n  }, [shouldObserve]);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/make-renderless-component.mjs\nvar makeRenderlessComponent = (hook) => (props) => {\n  hook(props);\n  return null;\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/gestures.mjs\nvar gestureAnimations = {\n  inView: makeRenderlessComponent(useViewport),\n  tap: makeRenderlessComponent(useTapGesture),\n  focus: makeRenderlessComponent(useFocusGesture),\n  hover: makeRenderlessComponent(useHoverGesture)\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/animations.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs\n\nfunction usePresence() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PresenceContext);\n  if (context === null)\n    return [true, null];\n  const { isPresent, onExitComplete, register } = context;\n  const id2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useId)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => register(id2), []);\n  const safeToRemove = () => onExitComplete && onExitComplete(id2);\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/shallow-compare.mjs\nfunction shallowCompare(next, prev) {\n  if (!Array.isArray(prev))\n    return false;\n  const prevLength = prev.length;\n  if (prevLength !== next.length)\n    return false;\n  for (let i2 = 0; i2 < prevLength; i2++) {\n    if (prev[i2] !== next[i2])\n      return false;\n  }\n  return true;\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/time-conversion.mjs\nvar secondsToMilliseconds = (seconds) => seconds * 1e3;\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/easing.mjs\nvar easingLookup = {\n  linear,\n  easeIn,\n  easeInOut,\n  easeOut,\n  circIn,\n  circInOut,\n  circOut,\n  backIn,\n  backInOut,\n  backOut,\n  anticipate,\n  bounceIn,\n  bounceInOut,\n  bounceOut\n};\nvar easingDefinitionToFunction = (definition) => {\n  if (Array.isArray(definition)) {\n    invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n    const [x1, y1, x2, y2] = definition;\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);\n    return easingLookup[definition];\n  }\n  return definition;\n};\nvar isEasingArray = (ease) => {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs\nvar isAnimatable = (key, value) => {\n  if (key === \"zIndex\")\n    return false;\n  if (typeof value === \"number\" || Array.isArray(value))\n    return true;\n  if (typeof value === \"string\" && complex.test(value) && !value.startsWith(\"url(\")) {\n    return true;\n  }\n  return false;\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs\nvar underDampedSpring = () => ({\n  type: \"spring\",\n  stiffness: 500,\n  damping: 25,\n  restSpeed: 10\n});\nvar criticallyDampedSpring = (to) => ({\n  type: \"spring\",\n  stiffness: 550,\n  damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n  restSpeed: 10\n});\nvar linearTween = () => ({\n  type: \"keyframes\",\n  ease: \"linear\",\n  duration: 0.3\n});\nvar keyframes2 = (values) => ({\n  type: \"keyframes\",\n  duration: 0.8,\n  values\n});\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: criticallyDampedSpring,\n  scaleY: criticallyDampedSpring,\n  scale: criticallyDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: criticallyDampedSpring\n};\nvar getDefaultTransition = (valueKey, to) => {\n  let transitionFactory;\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes2;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n  return __spreadValues({ to }, transitionFactory(to));\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs\nvar defaultValueTypes = __spreadProps(__spreadValues({}, numberValueTypes), {\n  color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  filter,\n  WebkitFilter: filter\n});\nvar getDefaultValueType = (key) => defaultValueTypes[key];\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs\nfunction getAnimatableNone2(key, value) {\n  var _a;\n  let defaultValueType = getDefaultValueType(key);\n  if (defaultValueType !== filter)\n    defaultValueType = complex;\n  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs\nvar instantAnimationState = {\n  current: false\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/delay.mjs\nfunction delay(callback, timeout) {\n  const start = performance.now();\n  const checkElapsed = ({ timestamp }) => {\n    const elapsed = timestamp - start;\n    if (elapsed >= timeout) {\n      cancelSync.read(checkElapsed);\n      callback(elapsed - timeout);\n    }\n  };\n  es_default.read(checkElapsed, true);\n  return () => cancelSync.read(checkElapsed);\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/transitions.mjs\nfunction isTransitionDefined(_a) {\n  var _b = _a, { when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from } = _b, transition = __objRest(_b, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n  return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\nfunction convertTransitionToAnimationOptions(_a) {\n  var _b = _a, { ease, times, yoyo, flip, loop } = _b, transition = __objRest(_b, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n  const options = __spreadValues({}, transition);\n  if (times)\n    options[\"offset\"] = times;\n  if (transition.duration)\n    options[\"duration\"] = secondsToMilliseconds(transition.duration);\n  if (transition.repeatDelay)\n    options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n  if (ease) {\n    options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  }\n  if (transition.type === \"tween\")\n    options.type = \"keyframes\";\n  if (yoyo || loop || flip) {\n    warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n    legacyRepeatWarning = true;\n    if (yoyo) {\n      options.repeatType = \"reverse\";\n    } else if (loop) {\n      options.repeatType = \"loop\";\n    } else if (flip) {\n      options.repeatType = \"mirror\";\n    }\n    options.repeat = loop || yoyo || flip || transition.repeat;\n  }\n  if (transition.type !== \"spring\")\n    options.type = \"keyframes\";\n  return options;\n}\nfunction getDelayFromTransition(transition, key) {\n  var _a, _b;\n  const valueTransition = getValueTransition(transition, key) || {};\n  return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\nfunction hydrateKeyframes(options) {\n  if (Array.isArray(options.to) && options.to[0] === null) {\n    options.to = [...options.to];\n    options.to[0] = options.from;\n  }\n  return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n  if (Array.isArray(options.to) && transition.duration === void 0) {\n    transition.duration = 0.8;\n  }\n  hydrateKeyframes(options);\n  if (!isTransitionDefined(transition)) {\n    transition = __spreadValues(__spreadValues({}, transition), getDefaultTransition(key, options.to));\n  }\n  return __spreadValues(__spreadValues({}, options), convertTransitionToAnimationOptions(transition));\n}\nfunction getAnimation(key, value, target, transition, onComplete) {\n  const valueTransition = getValueTransition(transition, key) || {};\n  let origin = valueTransition.from !== void 0 ? valueTransition.from : value.get();\n  const isTargetAnimatable = isAnimatable(key, target);\n  if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n    origin = getAnimatableNone2(key, target);\n  } else if (isZero(origin) && typeof target === \"string\") {\n    origin = getZeroUnit(target);\n  } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n    target = getZeroUnit(origin);\n  }\n  const isOriginAnimatable = isAnimatable(key, origin);\n  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${key} from \"${origin}\" to \"${target}\". ${origin} is not an animatable value - to enable this animation set ${origin} to a value animatable to ${target} via the \\`style\\` property.`);\n  function start() {\n    const options = {\n      from: origin,\n      to: target,\n      velocity: value.getVelocity(),\n      onComplete,\n      onUpdate: (v) => value.set(v)\n    };\n    return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? inertia(__spreadValues(__spreadValues({}, options), valueTransition)) : animate(__spreadProps(__spreadValues({}, getPopmotionAnimationOptions(valueTransition, options, key)), {\n      onUpdate: (v) => {\n        options.onUpdate(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: () => {\n        options.onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      }\n    }));\n  }\n  function set() {\n    const finalTarget = resolveFinalValueInKeyframes(target);\n    value.set(finalTarget);\n    onComplete();\n    valueTransition.onUpdate && valueTransition.onUpdate(finalTarget);\n    valueTransition.onComplete && valueTransition.onComplete();\n    return { stop: () => {\n    } };\n  }\n  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\nfunction isZero(value) {\n  return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\nfunction getZeroUnit(potentialUnitType) {\n  return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone2(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\nfunction startAnimation(key, value, target, transition = {}) {\n  if (instantAnimationState.current) {\n    transition = { type: false };\n  }\n  return value.start((onComplete) => {\n    let controls;\n    const animation = getAnimation(key, value, target, transition, onComplete);\n    const delayBy = getDelayFromTransition(transition, key);\n    const start = () => controls = animation();\n    let cancelDelay;\n    if (delayBy) {\n      cancelDelay = delay(start, secondsToMilliseconds(delayBy));\n    } else {\n      start();\n    }\n    return () => {\n      cancelDelay && cancelDelay();\n      controls && controls.stop();\n    };\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs\nvar isNumericalString = (v) => /^\\-?\\d*\\.?\\d+$/.test(v);\n\n// ../../node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs\nvar isZeroValueString = (v) => /^0[^.\\s]+$/.test(v);\n\n// ../../node_modules/framer-motion/dist/es/utils/array.mjs\nfunction addUniqueItem(arr, item) {\n  if (arr.indexOf(item) === -1)\n    arr.push(item);\n}\nfunction removeItem(arr, item) {\n  const index2 = arr.indexOf(item);\n  if (index2 > -1)\n    arr.splice(index2, 1);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/subscription-manager.mjs\nvar SubscriptionManager = class {\n  constructor() {\n    this.subscriptions = [];\n  }\n  add(handler) {\n    addUniqueItem(this.subscriptions, handler);\n    return () => removeItem(this.subscriptions, handler);\n  }\n  notify(a2, b2, c3) {\n    const numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions)\n      return;\n    if (numSubscriptions === 1) {\n      this.subscriptions[0](a2, b2, c3);\n    } else {\n      for (let i2 = 0; i2 < numSubscriptions; i2++) {\n        const handler = this.subscriptions[i2];\n        handler && handler(a2, b2, c3);\n      }\n    }\n  }\n  getSize() {\n    return this.subscriptions.length;\n  }\n  clear() {\n    this.subscriptions.length = 0;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/value/index.mjs\nvar isFloat = (value) => {\n  return !isNaN(parseFloat(value));\n};\nvar MotionValue = class {\n  constructor(init) {\n    this.version = \"7.6.7\";\n    this.timeDelta = 0;\n    this.lastUpdated = 0;\n    this.updateSubscribers = new SubscriptionManager();\n    this.velocityUpdateSubscribers = new SubscriptionManager();\n    this.renderSubscribers = new SubscriptionManager();\n    this.canTrackVelocity = false;\n    this.updateAndNotify = (v, render = true) => {\n      this.prev = this.current;\n      this.current = v;\n      const { delta, timestamp } = getFrameData();\n      if (this.lastUpdated !== timestamp) {\n        this.timeDelta = delta;\n        this.lastUpdated = timestamp;\n        es_default.postRender(this.scheduleVelocityCheck);\n      }\n      if (this.prev !== this.current) {\n        this.updateSubscribers.notify(this.current);\n      }\n      if (this.velocityUpdateSubscribers.getSize()) {\n        this.velocityUpdateSubscribers.notify(this.getVelocity());\n      }\n      if (render) {\n        this.renderSubscribers.notify(this.current);\n      }\n    };\n    this.scheduleVelocityCheck = () => es_default.postRender(this.velocityCheck);\n    this.velocityCheck = ({ timestamp }) => {\n      if (timestamp !== this.lastUpdated) {\n        this.prev = this.current;\n        this.velocityUpdateSubscribers.notify(this.getVelocity());\n      }\n    };\n    this.hasAnimated = false;\n    this.prev = this.current = init;\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  onChange(subscription) {\n    return this.updateSubscribers.add(subscription);\n  }\n  clearListeners() {\n    this.updateSubscribers.clear();\n  }\n  onRenderRequest(subscription) {\n    subscription(this.get());\n    return this.renderSubscribers.add(subscription);\n  }\n  attach(passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  }\n  set(v, render = true) {\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  }\n  get() {\n    return this.current;\n  }\n  getPrevious() {\n    return this.prev;\n  }\n  getVelocity() {\n    return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  }\n  start(animation) {\n    this.stop();\n    return new Promise((resolve) => {\n      this.hasAnimated = true;\n      this.stopAnimation = animation(resolve);\n    }).then(() => this.clearAnimation());\n  }\n  stop() {\n    if (this.stopAnimation)\n      this.stopAnimation();\n    this.clearAnimation();\n  }\n  isAnimating() {\n    return !!this.stopAnimation;\n  }\n  clearAnimation() {\n    this.stopAnimation = null;\n  }\n  destroy() {\n    this.updateSubscribers.clear();\n    this.renderSubscribers.clear();\n    this.stop();\n  }\n};\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs\nvar testValueType = (v) => (type) => type.test(v);\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs\nvar auto = {\n  test: (v) => v === \"auto\",\n  parse: (v) => v\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\nvar findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs\nvar valueTypes = [...dimensionValueTypes, color, complex];\nvar findValueType = (v) => valueTypes.find(testValueType(v));\n\n// ../../node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs\nfunction getCurrent(visualElement) {\n  const current = {};\n  visualElement.values.forEach((value, key) => current[key] = value.get());\n  return current;\n}\nfunction getVelocity(visualElement) {\n  const velocity = {};\n  visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());\n  return velocity;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n  const props = visualElement.getProps();\n  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/setters.mjs\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\nfunction setTarget(visualElement, definition) {\n  const resolved = resolveVariant(visualElement, definition);\n  let _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {}, { transitionEnd = {}, transition = {} } = _a, target = __objRest(_a, [\"transitionEnd\", \"transition\"]);\n  target = __spreadValues(__spreadValues({}, target), transitionEnd);\n  for (const key in target) {\n    const value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b;\n  const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));\n  const numNewValues = newValueKeys.length;\n  if (!numNewValues)\n    return;\n  for (let i2 = 0; i2 < numNewValues; i2++) {\n    const key = newValueKeys[i2];\n    const targetValue = target[key];\n    let value = null;\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    if (value === void 0 || value === null)\n      continue;\n    if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone2(key, targetValue);\n    }\n    visualElement.addValue(key, motionValue(value));\n    if (origin[key] === void 0) {\n      origin[key] = value;\n    }\n    if (value !== null)\n      visualElement.setBaseTarget(key, value);\n  }\n}\nfunction getOriginFromTransition(key, transition) {\n  if (!transition)\n    return;\n  const valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n  var _a;\n  const origin = {};\n  for (const key in target) {\n    const transitionOrigin = getOriginFromTransition(key, transition);\n    origin[key] = transitionOrigin !== void 0 ? transitionOrigin : (_a = visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.get();\n  }\n  return origin;\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-will-change/is.mjs\nfunction isWillChangeMotionValue(value) {\n  return Boolean(isMotionValue(value) && value.add);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/animation.mjs\nfunction animateVisualElement(visualElement, definition, options = {}) {\n  visualElement.notify(\"AnimationStart\", definition);\n  let animation;\n  if (Array.isArray(definition)) {\n    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));\n    animation = Promise.all(animations2);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    const resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n  return animation.then(() => visualElement.notify(\"AnimationComplete\", definition));\n}\nfunction animateVariant(visualElement, variant, options = {}) {\n  var _a;\n  const resolved = resolveVariant(visualElement, variant, options.custom);\n  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  const getAnimation2 = resolved ? () => animateTarget(visualElement, resolved, options) : () => Promise.resolve();\n  const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? (forwardDelay = 0) => {\n    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  const { when } = transition;\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2];\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);\n  }\n}\nfunction animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {\n  var _a;\n  let _a2 = visualElement.makeTargetAnimatable(definition), { transition = visualElement.getDefaultTransition(), transitionEnd } = _a2, target = __objRest(_a2, [\"transition\", \"transitionEnd\"]);\n  const willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride)\n    transition = transitionOverride;\n  const animations2 = [];\n  const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n  for (const key in target) {\n    const value = visualElement.getValue(key);\n    const valueTarget = target[key];\n    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n    let valueTransition = __spreadValues({ delay: delay2 }, transition);\n    if (visualElement.shouldReduceMotion && transformProps.has(key)) {\n      valueTransition = __spreadProps(__spreadValues({}, valueTransition), {\n        type: false,\n        delay: 0\n      });\n    }\n    let animation = startAnimation(key, value, valueTarget, valueTransition);\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation = animation.then(() => willChange.remove(key));\n    }\n    animations2.push(animation);\n  }\n  return Promise.all(animations2).then(() => {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n  const animations2 = [];\n  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {\n    animations2.push(animateVariant(child, variant, __spreadProps(__spreadValues({}, options), {\n      delay: delayChildren + generateStaggerDuration(i2)\n    })).then(() => child.notify(\"AnimationComplete\", variant)));\n  });\n  return Promise.all(animations2);\n}\nfunction sortByTreeOrder(a2, b2) {\n  return a2.sortNodePosition(b2);\n}\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs\nvar variantPriorityOrder = [\n  AnimationType.Animate,\n  AnimationType.InView,\n  AnimationType.Focus,\n  AnimationType.Hover,\n  AnimationType.Tap,\n  AnimationType.Drag,\n  AnimationType.Exit\n];\nvar reversePriorityOrder = [...variantPriorityOrder].reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n  let animate3 = animateList(visualElement);\n  const state = createState();\n  let isInitialRender = true;\n  const buildResolvedTypeValues = (acc, definition) => {\n    const resolved = resolveVariant(visualElement, definition);\n    if (resolved) {\n      const _a = resolved, { transition, transitionEnd } = _a, target = __objRest(_a, [\"transition\", \"transitionEnd\"]);\n      acc = __spreadValues(__spreadValues(__spreadValues({}, acc), target), transitionEnd);\n    }\n    return acc;\n  };\n  function setAnimateFunction(makeAnimator) {\n    animate3 = makeAnimator(visualElement);\n  }\n  function animateChanges(options, changedActiveType) {\n    var _a;\n    const props = visualElement.getProps();\n    const context = visualElement.getVariantContext(true) || {};\n    const animations2 = [];\n    const removedKeys = /* @__PURE__ */ new Set();\n    let encounteredKeys = {};\n    let removedVariantIndex = Infinity;\n    for (let i2 = 0; i2 < numAnimationTypes; i2++) {\n      const type = reversePriorityOrder[i2];\n      const typeState = state[type];\n      const prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      const propIsVariant = isVariantLabel(prop);\n      const activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false)\n        removedVariantIndex = i2;\n      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      typeState.protectedKeys = __spreadValues({}, encounteredKeys);\n      if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop === \"boolean\") {\n        continue;\n      }\n      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n      let shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i2 > removedVariantIndex && propIsVariant;\n      const definitionList = Array.isArray(prop) ? prop : [prop];\n      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false)\n        resolvedValues = {};\n      const { prevResolvedValues = {} } = typeState;\n      const allKeys = __spreadValues(__spreadValues({}, prevResolvedValues), resolvedValues);\n      const markToAnimate = (key) => {\n        shouldAnimateType = true;\n        removedKeys.delete(key);\n        typeState.needsAnimating[key] = true;\n      };\n      for (const key in allKeys) {\n        const next = resolvedValues[key];\n        const prev = prevResolvedValues[key];\n        if (encounteredKeys.hasOwnProperty(key))\n          continue;\n        if (next !== prev) {\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev) || variantDidChange) {\n              markToAnimate(key);\n            } else {\n              typeState.protectedKeys[key] = true;\n            }\n          } else if (next !== void 0) {\n            markToAnimate(key);\n          } else {\n            removedKeys.add(key);\n          }\n        } else if (next !== void 0 && removedKeys.has(key)) {\n          markToAnimate(key);\n        } else {\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      if (typeState.isActive) {\n        encounteredKeys = __spreadValues(__spreadValues({}, encounteredKeys), resolvedValues);\n      }\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      if (shouldAnimateType && !isInherited) {\n        animations2.push(...definitionList.map((animation) => ({\n          animation,\n          options: __spreadValues({ type }, options)\n        })));\n      }\n    }\n    if (removedKeys.size) {\n      const fallbackAnimation = {};\n      removedKeys.forEach((key) => {\n        const fallbackTarget = visualElement.getBaseTarget(key);\n        if (fallbackTarget !== void 0) {\n          fallbackAnimation[key] = fallbackTarget;\n        }\n      });\n      animations2.push({ animation: fallbackAnimation });\n    }\n    let shouldAnimate = Boolean(animations2.length);\n    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n    isInitialRender = false;\n    return shouldAnimate ? animate3(animations2) : Promise.resolve();\n  }\n  function setActive(type, isActive, options) {\n    var _a;\n    if (state[type].isActive === isActive)\n      return Promise.resolve();\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\n      var _a2;\n      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    const animations2 = animateChanges(options, type);\n    for (const key in state) {\n      state[key].protectedKeys = {};\n    }\n    return animations2;\n  }\n  return {\n    animateChanges,\n    setActive,\n    setAnimateFunction,\n    getState: () => state\n  };\n}\nfunction checkVariantsDidChange(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (Array.isArray(next)) {\n    return !shallowCompare(next, prev);\n  }\n  return false;\n}\nfunction createTypeState(isActive = false) {\n  return {\n    isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction createState() {\n  return {\n    [AnimationType.Animate]: createTypeState(true),\n    [AnimationType.InView]: createTypeState(),\n    [AnimationType.Hover]: createTypeState(),\n    [AnimationType.Tap]: createTypeState(),\n    [AnimationType.Drag]: createTypeState(),\n    [AnimationType.Focus]: createTypeState(),\n    [AnimationType.Exit]: createTypeState()\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/animations.mjs\nvar animations = {\n  animation: makeRenderlessComponent(({ visualElement, animate: animate3 }) => {\n    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n    if (isAnimationControls(animate3)) {\n      (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => animate3.subscribe(visualElement), [animate3]);\n    }\n  }),\n  exit: makeRenderlessComponent((props) => {\n    const { custom, visualElement } = props;\n    const [isPresent, safeToRemove] = usePresence();\n    const presenceContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PresenceContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      visualElement.isPresent = isPresent;\n      const animation = visualElement.animationState && visualElement.animationState.setActive(AnimationType.Exit, !isPresent, {\n        custom: presenceContext && presenceContext.custom || custom\n      });\n      if (animation && !isPresent) {\n        animation.then(safeToRemove);\n      }\n    }, [isPresent]);\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/gestures/PanSession.mjs\nvar PanSession = class {\n  constructor(event, handlers, { transformPagePoint } = {}) {\n    this.startEvent = null;\n    this.lastMoveEvent = null;\n    this.lastMoveEventInfo = null;\n    this.handlers = {};\n    this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n        return;\n      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      const isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold)\n        return;\n      const { point: point3 } = info2;\n      const { timestamp: timestamp2 } = getFrameData();\n      this.history.push(__spreadProps(__spreadValues({}, point3), { timestamp: timestamp2 }));\n      const { onStart, onMove } = this.handlers;\n      if (!isPanStarted) {\n        onStart && onStart(this.lastMoveEvent, info2);\n        this.startEvent = this.lastMoveEvent;\n      }\n      onMove && onMove(this.lastMoveEvent, info2);\n    };\n    this.handlePointerMove = (event2, info2) => {\n      this.lastMoveEvent = event2;\n      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);\n      if (isMouseEvent(event2) && event2.buttons === 0) {\n        this.handlePointerUp(event2, info2);\n        return;\n      }\n      es_default.update(this.updatePoint, true);\n    };\n    this.handlePointerUp = (event2, info2) => {\n      this.end();\n      const { onEnd, onSessionEnd } = this.handlers;\n      const panInfo = getPanInfo(transformPoint(info2, this.transformPagePoint), this.history);\n      if (this.startEvent && onEnd) {\n        onEnd(event2, panInfo);\n      }\n      onSessionEnd && onSessionEnd(event2, panInfo);\n    };\n    if (isTouchEvent(event) && event.touches.length > 1)\n      return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    const info = extractEventInfo(event);\n    const initialInfo = transformPoint(info, this.transformPagePoint);\n    const { point: point2 } = initialInfo;\n    const { timestamp } = getFrameData();\n    this.history = [__spreadProps(__spreadValues({}, point2), { timestamp })];\n    const { onSessionStart } = handlers;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n  }\n};\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a2, b2) {\n  return { x: a2.x - b2.x, y: a2.y - b2.y };\n}\nfunction getPanInfo({ point: point2 }, history) {\n  return {\n    point: point2,\n    delta: subtractPoint(point2, lastDevicePoint(history)),\n    offset: subtractPoint(point2, startDevicePoint(history)),\n    velocity: getVelocity2(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity2(history, timeDelta) {\n  if (history.length < 2) {\n    return { x: 0, y: 0 };\n  }\n  let i2 = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n  while (i2 >= 0) {\n    timestampedPoint = history[i2];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n    i2--;\n  }\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 };\n  }\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n  if (time === 0) {\n    return { x: 0, y: 0 };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\nfunction isNear(value, target = 0, maxDistance = 0.01) {\n  return distance(value, target) < maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n  delta.origin = origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))\n    delta.scale = 1;\n  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate) || isNaN(delta.translate))\n    delta.translate = 0;\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);\n  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n  calcRelativeAxis(target.x, relative.x, parent.x);\n  calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n  target.min = layout.min - parent.min;\n  target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n  calcRelativeAxisPosition(target.x, layout.x, parent.x);\n  calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs\nfunction applyConstraints(point2, { min, max }, elastic) {\n  if (min !== void 0 && point2 < min) {\n    point2 = elastic ? mix(min, point2, elastic.min) : Math.max(point2, min);\n  } else if (max !== void 0 && point2 > max) {\n    point2 = elastic ? mix(max, point2, elastic.max) : Math.min(point2, max);\n  }\n  return point2;\n}\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== void 0 ? axis.min + min : void 0,\n    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0\n  };\n}\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  let min = constraintsAxis.min - layoutAxis.min;\n  let max = constraintsAxis.max - layoutAxis.max;\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    [min, max] = [max, min];\n  }\n  return { min, max };\n}\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\nfunction calcOrigin2(source, target) {\n  let origin = 0.5;\n  const sourceLength = calcLength(source);\n  const targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n  return clamp2(0, 1, origin);\n}\nfunction rebaseAxisConstraints(layout, constraints) {\n  const relativeConstraints = {};\n  if (constraints.min !== void 0) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n  if (constraints.max !== void 0) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n  return relativeConstraints;\n}\nvar defaultElastic = 0.35;\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\nfunction resolvePointElastic(dragElastic, label) {\n  var _a;\n  return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/models.mjs\nvar createAxisDelta = () => ({\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n});\nvar createDelta = () => ({\n  x: createAxisDelta(),\n  y: createAxisDelta()\n});\nvar createAxis = () => ({ min: 0, max: 0 });\nvar createBox = () => ({\n  x: createAxis(),\n  y: createAxis()\n});\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs\nfunction eachAxis(callback) {\n  return [callback(\"x\"), callback(\"y\")];\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs\nfunction convertBoundingBoxToBox({ top, left, right, bottom }) {\n  return {\n    x: { min: left, max: right },\n    y: { min: top, max: bottom }\n  };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n  return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\nfunction transformBoxPoints(point2, transformPoint2) {\n  if (!transformPoint2)\n    return point2;\n  const topLeft = transformPoint2({ x: point2.left, y: point2.top });\n  const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs\nfunction isIdentityScale(scale2) {\n  return scale2 === void 0 || scale2 === 1;\n}\nfunction hasScale({ scale: scale2, scaleX, scaleY }) {\n  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);\n}\nfunction hasTransform(values) {\n  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;\n}\nfunction has2DTranslate(values) {\n  return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n  return value && value !== \"0%\";\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs\nfunction scalePoint(point2, scale2, originPoint) {\n  const distanceFromOrigin = point2 - originPoint;\n  const scaled = scale2 * distanceFromOrigin;\n  return originPoint + scaled;\n}\nfunction applyPointDelta(point2, translate, scale2, originPoint, boxScale) {\n  if (boxScale !== void 0) {\n    point2 = scalePoint(point2, boxScale, originPoint);\n  }\n  return scalePoint(point2, scale2, originPoint) + translate;\n}\nfunction applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {\n  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction applyBoxDelta(box, { x, y }) {\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n  var _a, _b;\n  const treeLength = treePath.length;\n  if (!treeLength)\n    return;\n  treeScale.x = treeScale.y = 1;\n  let node;\n  let delta;\n  for (let i2 = 0; i2 < treeLength; i2++) {\n    node = treePath[i2];\n    delta = node.projectionDelta;\n    if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === \"contents\")\n      continue;\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });\n    }\n    if (delta) {\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale;\n      applyBoxDelta(box, delta);\n    }\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n}\nfunction translateAxis(axis, distance2) {\n  axis.min = axis.min + distance2;\n  axis.max = axis.max + distance2;\n}\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\n  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;\n  const originPoint = mix(axis.min, axis.max, axisOrigin);\n  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform, xKeys);\n  transformAxis(box.y, transform, yKeys);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/measure.mjs\nfunction measureViewportBox(instance, transformPoint2) {\n  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));\n}\nfunction measurePageBox(element, rootProjectionNode2, transformPagePoint) {\n  const viewportBox = measureViewportBox(element, transformPagePoint);\n  const { scroll: scroll2 } = rootProjectionNode2;\n  if (scroll2) {\n    translateAxis(viewportBox.x, scroll2.x);\n    translateAxis(viewportBox.y, scroll2.y);\n  }\n  return viewportBox;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs\nvar elementDragControls = /* @__PURE__ */ new WeakMap();\nvar VisualElementDragControls = class {\n  constructor(visualElement) {\n    this.openGlobalLock = null;\n    this.isDragging = false;\n    this.currentDirection = null;\n    this.originPoint = { x: 0, y: 0 };\n    this.constraints = false;\n    this.hasMutatedConstraints = false;\n    this.elastic = createBox();\n    this.visualElement = visualElement;\n  }\n  start(originEvent, { snapToCursor = false } = {}) {\n    if (this.visualElement.isPresent === false)\n      return;\n    const onSessionStart = (event) => {\n      this.stopAnimation();\n      if (snapToCursor) {\n        this.snapToCursor(extractEventInfo(event, \"page\").point);\n      }\n    };\n    const onStart = (event, info) => {\n      var _a;\n      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();\n      if (drag2 && !dragPropagation) {\n        if (this.openGlobalLock)\n          this.openGlobalLock();\n        this.openGlobalLock = getGlobalLock(drag2);\n        if (!this.openGlobalLock)\n          return;\n      }\n      this.isDragging = true;\n      this.currentDirection = null;\n      this.resolveConstraints();\n      if (this.visualElement.projection) {\n        this.visualElement.projection.isAnimationBlocked = true;\n        this.visualElement.projection.target = void 0;\n      }\n      eachAxis((axis) => {\n        var _a2, _b;\n        let current = this.getAxisMotionValue(axis).get() || 0;\n        if (percent.test(current)) {\n          const measuredAxis = (_b = (_a2 = this.visualElement.projection) === null || _a2 === void 0 ? void 0 : _a2.layout) === null || _b === void 0 ? void 0 : _b.layoutBox[axis];\n          if (measuredAxis) {\n            const length = calcLength(measuredAxis);\n            current = length * (parseFloat(current) / 100);\n          }\n        }\n        this.originPoint[axis] = current;\n      });\n      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);\n      (_a = this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Drag, true);\n    };\n    const onMove = (event, info) => {\n      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();\n      if (!dragPropagation && !this.openGlobalLock)\n        return;\n      const { offset } = info;\n      if (dragDirectionLock && this.currentDirection === null) {\n        this.currentDirection = getCurrentDirection(offset);\n        if (this.currentDirection !== null) {\n          onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(this.currentDirection);\n        }\n        return;\n      }\n      this.updateAxis(\"x\", info.point, offset);\n      this.updateAxis(\"y\", info.point, offset);\n      this.visualElement.render();\n      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);\n    };\n    const onSessionEnd = (event, info) => this.stop(event, info);\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart,\n      onStart,\n      onMove,\n      onSessionEnd\n    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });\n  }\n  stop(event, info) {\n    const isDragging = this.isDragging;\n    this.cancel();\n    if (!isDragging)\n      return;\n    const { velocity } = info;\n    this.startAnimation(velocity);\n    const { onDragEnd } = this.getProps();\n    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n  }\n  cancel() {\n    var _a, _b;\n    this.isDragging = false;\n    if (this.visualElement.projection) {\n      this.visualElement.projection.isAnimationBlocked = false;\n    }\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = void 0;\n    const { dragPropagation } = this.getProps();\n    if (!dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n  }\n  updateAxis(axis, _point, offset) {\n    const { drag: drag2 } = this.getProps();\n    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))\n      return;\n    const axisValue = this.getAxisMotionValue(axis);\n    let next = this.originPoint[axis] + offset[axis];\n    if (this.constraints && this.constraints[axis]) {\n      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n    }\n    axisValue.set(next);\n  }\n  resolveConstraints() {\n    const { dragConstraints, dragElastic } = this.getProps();\n    const { layout } = this.visualElement.projection || {};\n    const prevConstraints = this.constraints;\n    if (dragConstraints && isRefObject(dragConstraints)) {\n      if (!this.constraints) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    } else {\n      if (dragConstraints && layout) {\n        this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n      } else {\n        this.constraints = false;\n      }\n    }\n    this.elastic = resolveDragElastic(dragElastic);\n    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {\n      eachAxis((axis) => {\n        if (this.getAxisMotionValue(axis)) {\n          this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n        }\n      });\n    }\n  }\n  resolveRefConstraints() {\n    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n    if (!constraints || !isRefObject(constraints))\n      return false;\n    const constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    const { projection } = this.visualElement;\n    if (!projection || !projection.layout)\n      return false;\n    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n    if (onMeasureDragConstraints) {\n      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n      this.hasMutatedConstraints = !!userConstraints;\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToBox(userConstraints);\n      }\n    }\n    return measuredConstraints;\n  }\n  startAnimation(velocity) {\n    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();\n    const constraints = this.constraints || {};\n    const momentumAnimations = eachAxis((axis) => {\n      var _a;\n      if (!shouldDrag(axis, drag2, this.currentDirection)) {\n        return;\n      }\n      let transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n      if (dragSnapToOrigin)\n        transition = { min: 0, max: 0 };\n      const bounceStiffness = dragElastic ? 200 : 1e6;\n      const bounceDamping = dragElastic ? 40 : 1e7;\n      const inertia2 = __spreadValues(__spreadValues({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness,\n        bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition);\n      return this.startAxisValueAnimation(axis, inertia2);\n    });\n    return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n  }\n  startAxisValueAnimation(axis, transition) {\n    const axisValue = this.getAxisMotionValue(axis);\n    return startAnimation(axis, axisValue, 0, transition);\n  }\n  stopAnimation() {\n    eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n  }\n  getAxisMotionValue(axis) {\n    var _a, _b;\n    const dragKey = \"_drag\" + axis.toUpperCase();\n    const externalMotionValue = this.visualElement.getProps()[dragKey];\n    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);\n  }\n  snapToCursor(point2) {\n    eachAxis((axis) => {\n      const { drag: drag2 } = this.getProps();\n      if (!shouldDrag(axis, drag2, this.currentDirection))\n        return;\n      const { projection } = this.visualElement;\n      const axisValue = this.getAxisMotionValue(axis);\n      if (projection && projection.layout) {\n        const { min, max } = projection.layout.layoutBox[axis];\n        axisValue.set(point2[axis] - mix(min, max, 0.5));\n      }\n    });\n  }\n  scalePositionWithinConstraints() {\n    var _a;\n    if (!this.visualElement.current)\n      return;\n    const { drag: drag2, dragConstraints } = this.getProps();\n    const { projection } = this.visualElement;\n    if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n      return;\n    this.stopAnimation();\n    const boxProgress = { x: 0, y: 0 };\n    eachAxis((axis) => {\n      const axisValue = this.getAxisMotionValue(axis);\n      if (axisValue) {\n        const latest = axisValue.get();\n        boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);\n      }\n    });\n    const { transformTemplate } = this.visualElement.getProps();\n    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n    (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n    projection.updateLayout();\n    this.resolveConstraints();\n    eachAxis((axis) => {\n      if (!shouldDrag(axis, drag2, null))\n        return;\n      const axisValue = this.getAxisMotionValue(axis);\n      const { min, max } = this.constraints[axis];\n      axisValue.set(mix(min, max, boxProgress[axis]));\n    });\n  }\n  addListeners() {\n    var _a;\n    if (!this.visualElement.current)\n      return;\n    elementDragControls.set(this.visualElement, this);\n    const element = this.visualElement.current;\n    const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\n      const { drag: drag2, dragListener = true } = this.getProps();\n      drag2 && dragListener && this.start(event);\n    });\n    const measureDragConstraints = () => {\n      const { dragConstraints } = this.getProps();\n      if (isRefObject(dragConstraints)) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    };\n    const { projection } = this.visualElement;\n    const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n    if (projection && !projection.layout) {\n      (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n      projection.updateLayout();\n    }\n    measureDragConstraints();\n    const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n    const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged }) => {\n      if (this.isDragging && hasLayoutChanged) {\n        eachAxis((axis) => {\n          const motionValue2 = this.getAxisMotionValue(axis);\n          if (!motionValue2)\n            return;\n          this.originPoint[axis] += delta[axis].translate;\n          motionValue2.set(motionValue2.get() + delta[axis].translate);\n        });\n        this.visualElement.render();\n      }\n    });\n    return () => {\n      stopResizeListener();\n      stopPointerListener();\n      stopMeasureLayoutListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n    };\n  }\n  getProps() {\n    const props = this.visualElement.getProps();\n    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;\n    return __spreadProps(__spreadValues({}, props), {\n      drag: drag2,\n      dragDirectionLock,\n      dragPropagation,\n      dragConstraints,\n      dragElastic,\n      dragMomentum\n    });\n  }\n};\nfunction shouldDrag(direction, drag2, currentDirection) {\n  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);\n}\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n  let direction = null;\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n  return direction;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs\nfunction useDrag(props) {\n  const { dragControls: groupDragControls, visualElement } = props;\n  const dragControls = useConstant(() => new VisualElementDragControls(visualElement));\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => groupDragControls && groupDragControls.subscribe(dragControls), [dragControls, groupDragControls]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => dragControls.addListeners(), [dragControls]);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-pan-gesture.mjs\n\nfunction usePanGesture({ onPan, onPanStart, onPanEnd, onPanSessionStart, visualElement }) {\n  const hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  const panSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const { transformPagePoint } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionConfigContext);\n  const handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: (event, info) => {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint\n    });\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(() => panSession.current && panSession.current.end());\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/drag.mjs\nvar drag = {\n  pan: makeRenderlessComponent(usePanGesture),\n  drag: makeRenderlessComponent(useDrag)\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs\nfunction isCSSVariable2(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n  const match = cssVariableRegex.exec(current);\n  if (!match)\n    return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n  const [token, fallback] = parseCSSVariable(current);\n  if (!token)\n    return;\n  const resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariable2(fallback)) {\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var target = __objRest(_a, []);\n  const element = visualElement.current;\n  if (!(element instanceof Element))\n    return { target, transitionEnd };\n  if (transitionEnd) {\n    transitionEnd = __spreadValues({}, transitionEnd);\n  }\n  visualElement.values.forEach((value) => {\n    const current = value.get();\n    if (!isCSSVariable2(current))\n      return;\n    const resolved = getVariableValue(current, element);\n    if (resolved)\n      value.set(resolved);\n  });\n  for (const key in target) {\n    const current = target[key];\n    if (!isCSSVariable2(current))\n      continue;\n    const resolved = getVariableValue(current, element);\n    if (!resolved)\n      continue;\n    target[key] = resolved;\n    if (transitionEnd && transitionEnd[key] === void 0) {\n      transitionEnd[key] = current;\n    }\n  }\n  return { target, transitionEnd };\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs\nvar positionalKeys = /* @__PURE__ */ new Set([\n  \"width\",\n  \"height\",\n  \"top\",\n  \"left\",\n  \"right\",\n  \"bottom\",\n  \"x\",\n  \"y\"\n]);\nvar isPositionalKey = (key) => positionalKeys.has(key);\nvar hasPositionalKey = (target) => {\n  return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = (value, to) => {\n  value.set(to, false);\n  value.set(to);\n};\nvar isNumOrPxType = (v) => v === number || v === px;\nvar BoundingBoxDimension;\n(function(BoundingBoxDimension2) {\n  BoundingBoxDimension2[\"width\"] = \"width\";\n  BoundingBoxDimension2[\"height\"] = \"height\";\n  BoundingBoxDimension2[\"left\"] = \"left\";\n  BoundingBoxDimension2[\"right\"] = \"right\";\n  BoundingBoxDimension2[\"top\"] = \"top\";\n  BoundingBoxDimension2[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nvar getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n  if (transform === \"none\" || !transform)\n    return 0;\n  const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n  if (matrix3d) {\n    return getPosFromMatrix(matrix3d[1], pos3);\n  } else {\n    const matrix = transform.match(/^matrix\\((.+)\\)$/);\n    if (matrix) {\n      return getPosFromMatrix(matrix[1], pos2);\n    } else {\n      return 0;\n    }\n  }\n};\nvar transformKeys = /* @__PURE__ */ new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n  const removedTransforms = [];\n  nonTranslationalTransformKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    if (value !== void 0) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  if (removedTransforms.length)\n    visualElement.render();\n  return removedTransforms;\n}\nvar positionalValues = {\n  width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n  height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n  top: (_bbox, { top }) => parseFloat(top),\n  left: (_bbox, { left }) => parseFloat(left),\n  bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n  right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\nvar convertChangedValueTypes = (target, visualElement, changedKeys) => {\n  const originBbox = visualElement.measureViewportBox();\n  const element = visualElement.current;\n  const elementComputedStyle = getComputedStyle(element);\n  const { display } = elementComputedStyle;\n  const origin = {};\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  changedKeys.forEach((key) => {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  });\n  visualElement.render();\n  const targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    setAndResetVelocity(value, origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\nvar checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\n  target = __spreadValues({}, target);\n  transitionEnd = __spreadValues({}, transitionEnd);\n  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n  let removedTransformValues = [];\n  let hasAttemptedToRemoveTransformValues = false;\n  const changedValueTypeKeys = [];\n  targetPositionalKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key))\n      return;\n    let from = origin[key];\n    let fromType = findDimensionValueType(from);\n    const to = target[key];\n    let toType;\n    if (isKeyframesTarget(to)) {\n      const numKeyframes = to.length;\n      const fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n      for (let i2 = fromIndex; i2 < numKeyframes; i2++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i2]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i2]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n    if (fromType !== toType) {\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        const current = value.get();\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n  if (changedValueTypeKeys.length) {\n    const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(([key, value]) => {\n        visualElement.getValue(key).set(value);\n      });\n    }\n    visualElement.render();\n    if (isBrowser && scrollY !== null) {\n      window.scrollTo({ top: scrollY });\n    }\n    return { target: convertedTarget, transitionEnd };\n  } else {\n    return { target, transitionEnd };\n  }\n};\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs\nvar parseDomVariant = (visualElement, target, origin, transitionEnd) => {\n  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\n// ../../node_modules/framer-motion/dist/es/render/VisualElement.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs\nvar prefersReducedMotion = { current: null };\nvar hasReducedMotionListener = { current: false };\n\n// ../../node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs\nfunction initPrefersReducedMotion() {\n  hasReducedMotionListener.current = true;\n  if (!isBrowser)\n    return;\n  if (window.matchMedia) {\n    const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;\n    motionMediaQuery.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.current = false;\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/motion-values.mjs\nfunction updateMotionValuesFromProps(element, next, prev) {\n  const { willChange } = next;\n  for (const key in next) {\n    const nextValue = next[key];\n    const prevValue = prev[key];\n    if (isMotionValue(nextValue)) {\n      element.addValue(key, nextValue);\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.add(key);\n      }\n      if (true) {\n        warnOnce(nextValue.version === \"7.6.7\", `Attempting to mix Framer Motion versions ${nextValue.version} with 7.6.7 may not work as expected.`);\n      }\n    } else if (isMotionValue(prevValue)) {\n      element.addValue(key, motionValue(nextValue));\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.remove(key);\n      }\n    } else if (prevValue !== nextValue) {\n      if (element.hasValue(key)) {\n        const existingValue = element.getValue(key);\n        !existingValue.hasAnimated && existingValue.set(nextValue);\n      } else {\n        const latestValue = element.getStaticValue(key);\n        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue));\n      }\n    }\n  }\n  for (const key in prev) {\n    if (next[key] === void 0)\n      element.removeValue(key);\n  }\n  return next;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/VisualElement.mjs\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\nvar propEventHandlers = [\n  \"AnimationStart\",\n  \"AnimationComplete\",\n  \"Update\",\n  \"Unmount\",\n  \"BeforeLayoutMeasure\",\n  \"LayoutMeasure\",\n  \"LayoutAnimationStart\",\n  \"LayoutAnimationComplete\"\n];\nvar VisualElement = class {\n  constructor({ parent, props, reducedMotionConfig, visualState }, options = {}) {\n    this.current = null;\n    this.children = /* @__PURE__ */ new Set();\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    this.shouldReduceMotion = null;\n    this.values = /* @__PURE__ */ new Map();\n    this.isPresent = true;\n    this.valueSubscriptions = /* @__PURE__ */ new Map();\n    this.prevMotionValues = {};\n    this.events = {};\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n    this.render = () => {\n      if (!this.current)\n        return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n    this.scheduleRender = () => es_default.render(this.render, false, true);\n    const { latestValues, renderState } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = __spreadValues({}, latestValues);\n    this.initialValues = props.initial ? __spreadValues({}, latestValues) : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.options = options;\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n    if (this.isVariantNode) {\n      this.variantChildren = /* @__PURE__ */ new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    const _a = this.scrapeMotionValuesFromProps(props), { willChange } = _a, initialMotionValues = __objRest(_a, [\"willChange\"]);\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n      if (latestValues[key] !== void 0 && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n        if (isWillChangeMotionValue(willChange)) {\n          willChange.add(key);\n        }\n      }\n    }\n  }\n  scrapeMotionValuesFromProps(_props) {\n    return {};\n  }\n  mount(instance) {\n    var _a;\n    this.current = instance;\n    if (this.projection) {\n      this.projection.mount(instance);\n    }\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.addVariantChild(this);\n    }\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    if (!hasReducedMotionListener.current) {\n      initPrefersReducedMotion();\n    }\n    this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? false : this.reducedMotionConfig === \"always\" ? true : prefersReducedMotion.current;\n    if (this.parent)\n      this.parent.children.add(this);\n    this.setProps(this.props);\n  }\n  unmount() {\n    var _a, _b, _c;\n    (_a = this.projection) === null || _a === void 0 ? void 0 : _a.unmount();\n    cancelSync.update(this.notifyUpdate);\n    cancelSync.render(this.render);\n    this.valueSubscriptions.forEach((remove) => remove());\n    (_b = this.removeFromVariantTree) === null || _b === void 0 ? void 0 : _b.call(this);\n    (_c = this.parent) === null || _c === void 0 ? void 0 : _c.children.delete(this);\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n    this.current = null;\n  }\n  bindToMotionValue(key, value) {\n    const removeOnChange = value.onChange((latestValue) => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && es_default.update(this.notifyUpdate, false, true);\n    });\n    const removeOnRenderRequest = value.onRenderRequest(this.scheduleRender);\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      removeOnRenderRequest();\n    });\n  }\n  sortNodePosition(other) {\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type)\n      return 0;\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n  loadFeatures(renderedProps, isStrict, preloadedFeatures, projectionId, ProjectionNodeConstructor, initialLayoutGroupConfig) {\n    const features = [];\n    if (env !== \"production\" && preloadedFeatures && isStrict) {\n      invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n    }\n    for (let i2 = 0; i2 < numFeatures; i2++) {\n      const name = featureNames[i2];\n      const { isEnabled, Component } = featureDefinitions[name];\n      if (isEnabled(renderedProps) && Component) {\n        features.push((0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Component, __spreadProps(__spreadValues({\n          key: name\n        }, renderedProps), {\n          visualElement: this\n        })));\n      }\n    }\n    if (!this.projection && ProjectionNodeConstructor) {\n      this.projection = new ProjectionNodeConstructor(projectionId, this.latestValues, this.parent && this.parent.projection);\n      const { layoutId, layout, drag: drag2, dragConstraints, layoutScroll } = renderedProps;\n      this.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),\n        visualElement: this,\n        scheduleRender: () => this.scheduleRender(),\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig: initialLayoutGroupConfig,\n        layoutScroll\n      });\n    }\n    return features;\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.options, this.props);\n  }\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  makeTargetAnimatable(target, canMutate = true) {\n    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);\n  }\n  setProps(props) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n    this.props = props;\n    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {\n      const key = propEventHandlers[i2];\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n      const listener = props[\"on\" + key];\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props), this.prevMotionValues);\n  }\n  getProps() {\n    return this.props;\n  }\n  getVariant(name) {\n    var _a;\n    return (_a = this.props.variants) === null || _a === void 0 ? void 0 : _a[name];\n  }\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    var _a;\n    return this.isVariantNode ? this : (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getClosestVariantNode();\n  }\n  getVariantContext(startAtParent = false) {\n    var _a, _b;\n    if (startAtParent)\n      return (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getVariantContext();\n    if (!this.isControllingVariants) {\n      const context2 = ((_b = this.parent) === null || _b === void 0 ? void 0 : _b.getVariantContext()) || {};\n      if (this.props.initial !== void 0) {\n        context2.initial = this.props.initial;\n      }\n      return context2;\n    }\n    const context = {};\n    for (let i2 = 0; i2 < numVariantProps; i2++) {\n      const name = variantProps2[i2];\n      const prop = this.props[name];\n      if (isVariantLabel(prop) || prop === false) {\n        context[name] = prop;\n      }\n    }\n    return context;\n  }\n  addVariantChild(child) {\n    var _a;\n    const closestVariantNode = this.getClosestVariantNode();\n    if (closestVariantNode) {\n      (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  addValue(key, value) {\n    if (this.hasValue(key))\n      this.removeValue(key);\n    this.values.set(key, value);\n    this.latestValues[key] = value.get();\n    this.bindToMotionValue(key, value);\n  }\n  removeValue(key) {\n    var _a;\n    this.values.delete(key);\n    (_a = this.valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n    this.valueSubscriptions.delete(key);\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  hasValue(key) {\n    return this.values.has(key);\n  }\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n    let value = this.values.get(key);\n    if (value === void 0 && defaultValue !== void 0) {\n      value = motionValue(defaultValue);\n      this.addValue(key, value);\n    }\n    return value;\n  }\n  readValue(key) {\n    return this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.readValueFromInstance(this.current, key, this.options);\n  }\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  getBaseTarget(key) {\n    var _a;\n    const { initial } = this.props;\n    const valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : void 0;\n    if (initial && valueFromInitial !== void 0) {\n      return valueFromInitial;\n    }\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== void 0 && !isMotionValue(target))\n      return target;\n    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    return this.events[eventName].add(callback);\n  }\n  notify(eventName, ...args) {\n    var _a;\n    (_a = this.events[eventName]) === null || _a === void 0 ? void 0 : _a.notify(...args);\n  }\n};\nvar variantProps2 = [\"initial\", ...variantPriorityOrder];\nvar numVariantProps = variantProps2.length;\n\n// ../../node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs\nvar DOMVisualElement = class extends VisualElement {\n  sortInstanceNodePosition(a2, b2) {\n    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;\n  }\n  getBaseTargetFromProps(props, key) {\n    var _a;\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  }\n  removeValueFromRenderState(key, { vars, style }) {\n    delete vars[key];\n    delete style[key];\n  }\n  makeTargetAnimatableFromInstance(_a, { transformValues }, isMounted) {\n    var _b = _a, { transition, transitionEnd } = _b, target = __objRest(_b, [\"transition\", \"transitionEnd\"]);\n    let origin = getOrigin(target, transition || {}, this);\n    if (transformValues) {\n      if (transitionEnd)\n        transitionEnd = transformValues(transitionEnd);\n      if (target)\n        target = transformValues(target);\n      if (origin)\n        origin = transformValues(origin);\n    }\n    if (isMounted) {\n      checkTargetForNewValues(this, target, origin);\n      const parsed = parseDomVariant(this, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n    return __spreadValues({\n      transition,\n      transitionEnd\n    }, target);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs\nfunction getComputedStyle2(element) {\n  return window.getComputedStyle(element);\n}\nvar HTMLVisualElement = class extends DOMVisualElement {\n  readValueFromInstance(instance, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle2(instance);\n      const value = (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  }\n  measureInstanceViewportBox(instance, { transformPagePoint }) {\n    return measureViewportBox(instance, transformPagePoint);\n  }\n  build(renderState, latestValues, options, props) {\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  }\n  scrapeMotionValuesFromProps(props) {\n    return scrapeMotionValuesFromProps(props);\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderHTML(instance, renderState, styleProp, projection);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs\nvar SVGVisualElement = class extends DOMVisualElement {\n  getBaseTargetFromProps(props, key) {\n    return props[key];\n  }\n  readValueFromInstance(instance, key) {\n    var _a;\n    if (transformProps.has(key)) {\n      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n    }\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return instance.getAttribute(key);\n  }\n  measureInstanceViewportBox() {\n    return createBox();\n  }\n  scrapeMotionValuesFromProps(props) {\n    return scrapeMotionValuesFromProps2(props);\n  }\n  build(renderState, latestValues, options, props) {\n    buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderSVG(instance, renderState, styleProp, projection);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs\nvar createDomVisualElement = (Component, options) => {\n  return isSVGComponent(Component) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs\nfunction pixelsToPercent(pixels, axis) {\n  if (axis.max === axis.min)\n    return 0;\n  return pixels / (axis.max - axis.min) * 100;\n}\nvar correctBorderRadius = {\n  correct: (latest, node) => {\n    if (!node.target)\n      return latest;\n    if (typeof latest === \"string\") {\n      if (px.test(latest)) {\n        latest = parseFloat(latest);\n      } else {\n        return latest;\n      }\n    }\n    const x = pixelsToPercent(latest, node.target.x);\n    const y = pixelsToPercent(latest, node.target.y);\n    return `${x}% ${y}%`;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs\nvar varToken = \"_$css\";\nvar correctBoxShadow = {\n  correct: (latest, { treeScale, projectionDelta }) => {\n    const original = latest;\n    const containsCSSVariables = latest.includes(\"var(\");\n    const cssVariables = [];\n    if (containsCSSVariables) {\n      latest = latest.replace(cssVariableRegex, (match) => {\n        cssVariables.push(match);\n        return varToken;\n      });\n    }\n    const shadow = complex.parse(latest);\n    if (shadow.length > 5)\n      return original;\n    const template = complex.createTransformer(latest);\n    const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    const xScale = projectionDelta.x.scale * treeScale.x;\n    const yScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    const averageScale = mix(xScale, yScale, 0.5);\n    if (typeof shadow[2 + offset] === \"number\")\n      shadow[2 + offset] /= averageScale;\n    if (typeof shadow[3 + offset] === \"number\")\n      shadow[3 + offset] /= averageScale;\n    let output = template(shadow);\n    if (containsCSSVariables) {\n      let i2 = 0;\n      output = output.replace(varToken, () => {\n        const cssVariable = cssVariables[i2];\n        i2++;\n        return cssVariable;\n      });\n    }\n    return output;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\nvar MeasureLayoutWithContext = class extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  componentDidMount() {\n    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n    const { projection } = visualElement;\n    addScaleCorrector(defaultScaleCorrectors);\n    if (projection) {\n      if (layoutGroup.group)\n        layoutGroup.group.add(projection);\n      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n      projection.root.didUpdate();\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions(__spreadProps(__spreadValues({}, projection.options), {\n        onExitComplete: () => this.safeToRemove()\n      }));\n    }\n    globalProjectionState.hasEverUpdated = true;\n  }\n  getSnapshotBeforeUpdate(prevProps) {\n    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;\n    const projection = visualElement.projection;\n    if (!projection)\n      return null;\n    projection.isPresent = isPresent;\n    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        es_default.postRender(() => {\n          var _a;\n          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n    return null;\n  }\n  componentDidUpdate() {\n    const { projection } = this.props.visualElement;\n    if (projection) {\n      projection.root.didUpdate();\n      if (!projection.currentAnimation && projection.isLead()) {\n        this.safeToRemove();\n      }\n    }\n  }\n  componentWillUnmount() {\n    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;\n    const { projection } = visualElement;\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\n        layoutGroup.group.remove(projection);\n      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)\n        promoteContext.deregister(projection);\n    }\n  }\n  safeToRemove() {\n    const { safeToRemove } = this.props;\n    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n  }\n  render() {\n    return null;\n  }\n};\nfunction MeasureLayout(props) {\n  const [isPresent, safeToRemove] = usePresence();\n  const layoutGroup = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LayoutGroupContext);\n  return react__WEBPACK_IMPORTED_MODULE_1__.createElement(MeasureLayoutWithContext, __spreadProps(__spreadValues({}, props), { layoutGroup, switchLayoutGroup: (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove }));\n}\nvar defaultScaleCorrectors = {\n  borderRadius: __spreadProps(__spreadValues({}, correctBorderRadius), {\n    applyTo: [\n      \"borderTopLeftRadius\",\n      \"borderTopRightRadius\",\n      \"borderBottomLeftRadius\",\n      \"borderBottomRightRadius\"\n    ]\n  }),\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/index.mjs\nvar layoutFeatures = {\n  measureLayout: MeasureLayout\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/animate.mjs\nfunction animate2(from, to, transition = {}) {\n  const value = isMotionValue(from) ? from : motionValue(from);\n  startAnimation(\"\", value, to, transition);\n  return {\n    stop: () => value.stop(),\n    isAnimating: () => value.isAnimating()\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nvar asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nvar isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress3, shouldCrossfadeOpacity, isOnlyMember) {\n  var _a, _b, _c, _d;\n  if (shouldCrossfadeOpacity) {\n    target.opacity = mix(\n      0,\n      (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1,\n      easeCrossfadeIn(progress3)\n    );\n    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress3));\n  } else if (isOnlyMember) {\n    target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress3);\n  }\n  for (let i2 = 0; i2 < numBorders; i2++) {\n    const borderLabel = `border${borders[i2]}Radius`;\n    let followRadius = getRadius(follow, borderLabel);\n    let leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === void 0 && leadRadius === void 0)\n      continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n    if (canMix) {\n      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress3), 0);\n      if (percent.test(leadRadius) || percent.test(followRadius)) {\n        target[borderLabel] += \"%\";\n      }\n    } else {\n      target[borderLabel] = leadRadius;\n    }\n  }\n  if (follow.rotate || lead.rotate) {\n    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress3);\n  }\n}\nfunction getRadius(values, radiusName) {\n  var _a;\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n  return (p2) => {\n    if (p2 < min)\n      return 0;\n    if (p2 > max)\n      return 1;\n    return easing(progress(min, max, p2));\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/copy.mjs\nfunction copyAxisInto(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\nfunction copyBoxInto(box, originBox) {\n  copyAxisInto(box.x, originBox.x);\n  copyAxisInto(box.y, originBox.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs\nfunction removePointDelta(point2, translate, scale2, originPoint, boxScale) {\n  point2 -= translate;\n  point2 = scalePoint(point2, 1 / scale2, originPoint);\n  if (boxScale !== void 0) {\n    point2 = scalePoint(point2, 1 / boxScale, originPoint);\n  }\n  return point2;\n}\nfunction removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n  if (percent.test(translate)) {\n    translate = parseFloat(translate);\n    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);\n    translate = relativeProgress - sourceAxis.min;\n  }\n  if (typeof translate !== \"number\")\n    return;\n  let originPoint = mix(originAxis.min, originAxis.max, origin);\n  if (axis === originAxis)\n    originPoint -= translate;\n  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\nvar xKeys2 = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys2 = [\"y\", \"scaleY\", \"originY\"];\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n  removeAxisTransforms(box.x, transforms, xKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);\n  removeAxisTransforms(box.y, transforms, yKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/utils.mjs\nfunction isAxisDeltaZero(delta) {\n  return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction boxEquals(a2, b2) {\n  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;\n}\nfunction aspectRatio(box) {\n  return calcLength(box.x) / calcLength(box.y);\n}\nfunction isCloseTo(a2, b2, max = 0.1) {\n  return distance(a2, b2) <= max;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/shared/stack.mjs\nvar NodeStack = class {\n  constructor() {\n    this.members = [];\n  }\n  add(node) {\n    addUniqueItem(this.members, node);\n    node.scheduleRender();\n  }\n  remove(node) {\n    removeItem(this.members, node);\n    if (node === this.prevLead) {\n      this.prevLead = void 0;\n    }\n    if (node === this.lead) {\n      const prevLead = this.members[this.members.length - 1];\n      if (prevLead) {\n        this.promote(prevLead);\n      }\n    }\n  }\n  relegate(node) {\n    const indexOfNode = this.members.findIndex((member) => node === member);\n    if (indexOfNode === 0)\n      return false;\n    let prevLead;\n    for (let i2 = indexOfNode; i2 >= 0; i2--) {\n      const member = this.members[i2];\n      if (member.isPresent !== false) {\n        prevLead = member;\n        break;\n      }\n    }\n    if (prevLead) {\n      this.promote(prevLead);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  promote(node, preserveFollowOpacity) {\n    var _a;\n    const prevLead = this.lead;\n    if (node === prevLead)\n      return;\n    this.prevLead = prevLead;\n    this.lead = node;\n    node.show();\n    if (prevLead) {\n      prevLead.instance && prevLead.scheduleRender();\n      node.scheduleRender();\n      node.resumeFrom = prevLead;\n      if (preserveFollowOpacity) {\n        node.resumeFrom.preserveOpacity = true;\n      }\n      if (prevLead.snapshot) {\n        node.snapshot = prevLead.snapshot;\n        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;\n        node.snapshot.isShared = true;\n      }\n      if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {\n        node.isLayoutDirty = true;\n      }\n      const { crossfade } = node.options;\n      if (crossfade === false) {\n        prevLead.hide();\n      }\n    }\n  }\n  exitAnimationComplete() {\n    this.members.forEach((node) => {\n      var _a, _b, _c, _d, _e;\n      (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n      (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);\n    });\n  }\n  scheduleRender() {\n    this.members.forEach((node) => {\n      node.instance && node.scheduleRender(false);\n    });\n  }\n  removeLeadSnapshot() {\n    if (this.lead && this.lead.snapshot) {\n      this.lead.snapshot = void 0;\n    }\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/transform.mjs\nvar identityProjection = \"translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)\";\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n  const xTranslate = delta.x.translate / treeScale.x;\n  const yTranslate = delta.y.translate / treeScale.y;\n  let transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;\n  transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n  if (latestTransform) {\n    const { rotate, rotateX, rotateY } = latestTransform;\n    if (rotate)\n      transform += `rotate(${rotate}deg) `;\n    if (rotateX)\n      transform += `rotateX(${rotateX}deg) `;\n    if (rotateY)\n      transform += `rotateY(${rotateY}deg) `;\n  }\n  const elementScaleX = delta.x.scale * treeScale.x;\n  const elementScaleY = delta.y.scale * treeScale.y;\n  transform += `scale(${elementScaleX}, ${elementScaleY})`;\n  return transform === identityProjection ? \"none\" : transform;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs\nvar compareByDepth = (a2, b2) => a2.depth - b2.depth;\n\n// ../../node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs\nvar FlatTree = class {\n  constructor() {\n    this.children = [];\n    this.isDirty = false;\n  }\n  add(child) {\n    addUniqueItem(this.children, child);\n    this.isDirty = true;\n  }\n  remove(child) {\n    removeItem(this.children, child);\n    this.isDirty = true;\n  }\n  forEach(callback) {\n    this.isDirty && this.children.sort(compareByDepth);\n    this.isDirty = false;\n    this.children.forEach(callback);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\nvar animationTarget = 1e3;\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {\n  return class ProjectionNode {\n    constructor(elementId, latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\n      this.children = /* @__PURE__ */ new Set();\n      this.options = {};\n      this.isTreeAnimating = false;\n      this.isAnimationBlocked = false;\n      this.isLayoutDirty = false;\n      this.updateManuallyBlocked = false;\n      this.updateBlockedByResize = false;\n      this.isUpdating = false;\n      this.isSVG = false;\n      this.needsReset = false;\n      this.shouldResetTransform = false;\n      this.treeScale = { x: 1, y: 1 };\n      this.eventHandlers = /* @__PURE__ */ new Map();\n      this.potentialNodes = /* @__PURE__ */ new Map();\n      this.checkUpdateFailed = () => {\n        if (this.isUpdating) {\n          this.isUpdating = false;\n          this.clearAllSnapshots();\n        }\n      };\n      this.updateProjection = () => {\n        this.nodes.forEach(resolveTargetDelta);\n        this.nodes.forEach(calcProjection);\n      };\n      this.hasProjected = false;\n      this.isVisible = true;\n      this.animationProgress = 0;\n      this.sharedNodes = /* @__PURE__ */ new Map();\n      this.elementId = elementId;\n      this.latestValues = latestValues;\n      this.root = parent ? parent.root || parent : this;\n      this.path = parent ? [...parent.path, parent] : [];\n      this.parent = parent;\n      this.depth = parent ? parent.depth + 1 : 0;\n      elementId && this.root.registerPotentialNode(elementId, this);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        this.path[i2].shouldResetTransform = true;\n      }\n      if (this.root === this)\n        this.nodes = new FlatTree();\n    }\n    addEventListener(name, handler) {\n      if (!this.eventHandlers.has(name)) {\n        this.eventHandlers.set(name, new SubscriptionManager());\n      }\n      return this.eventHandlers.get(name).add(handler);\n    }\n    notifyListeners(name, ...args) {\n      const subscriptionManager = this.eventHandlers.get(name);\n      subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify(...args);\n    }\n    hasListeners(name) {\n      return this.eventHandlers.has(name);\n    }\n    registerPotentialNode(id2, node) {\n      this.potentialNodes.set(id2, node);\n    }\n    mount(instance, isLayoutDirty = false) {\n      var _a;\n      if (this.instance)\n        return;\n      this.isSVG = instance instanceof SVGElement && instance.tagName !== \"svg\";\n      this.instance = instance;\n      const { layoutId, layout, visualElement } = this.options;\n      if (visualElement && !visualElement.current) {\n        visualElement.mount(instance);\n      }\n      this.root.nodes.add(this);\n      (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);\n      this.elementId && this.root.potentialNodes.delete(this.elementId);\n      if (isLayoutDirty && (layout || layoutId)) {\n        this.isLayoutDirty = true;\n      }\n      if (attachResizeListener) {\n        let cancelDelay;\n        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;\n        attachResizeListener(instance, () => {\n          this.root.updateBlockedByResize = true;\n          cancelDelay && cancelDelay();\n          cancelDelay = delay(resizeUnblockUpdate, 250);\n          if (globalProjectionState.hasAnimatedSinceResize) {\n            globalProjectionState.hasAnimatedSinceResize = false;\n            this.nodes.forEach(finishAnimation);\n          }\n        });\n      }\n      if (layoutId) {\n        this.root.registerSharedNode(layoutId, this);\n      }\n      if (this.options.animate !== false && visualElement && (layoutId || layout)) {\n        this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {\n          var _a2, _b, _c, _d, _e;\n          if (this.isTreeAnimationBlocked()) {\n            this.target = void 0;\n            this.relativeTarget = void 0;\n            return;\n          }\n          const layoutTransition = (_b = (_a2 = this.options.transition) !== null && _a2 !== void 0 ? _a2 : visualElement.getDefaultTransition()) !== null && _b !== void 0 ? _b : defaultLayoutTransition;\n          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();\n          const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;\n          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n          if (((_c = this.resumeFrom) === null || _c === void 0 ? void 0 : _c.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {\n            if (this.resumeFrom) {\n              this.resumingFrom = this.resumeFrom;\n              this.resumingFrom.resumingFrom = void 0;\n            }\n            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n            const animationOptions = __spreadProps(__spreadValues({}, getValueTransition(layoutTransition, \"layout\")), {\n              onPlay: onLayoutAnimationStart,\n              onComplete: onLayoutAnimationComplete\n            });\n            if (visualElement.shouldReduceMotion) {\n              animationOptions.delay = 0;\n              animationOptions.type = false;\n            }\n            this.startAnimation(animationOptions);\n          } else {\n            if (!hasLayoutChanged && this.animationProgress === 0) {\n              finishAnimation(this);\n            }\n            this.isLead() && ((_e = (_d = this.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d));\n          }\n          this.targetLayout = newLayout;\n        });\n      }\n    }\n    unmount() {\n      var _a, _b;\n      this.options.layoutId && this.willUpdate();\n      this.root.nodes.remove(this);\n      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);\n      (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);\n      this.instance = void 0;\n      cancelSync.preRender(this.updateProjection);\n    }\n    blockUpdate() {\n      this.updateManuallyBlocked = true;\n    }\n    unblockUpdate() {\n      this.updateManuallyBlocked = false;\n    }\n    isUpdateBlocked() {\n      return this.updateManuallyBlocked || this.updateBlockedByResize;\n    }\n    isTreeAnimationBlocked() {\n      var _a;\n      return this.isAnimationBlocked || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) || false;\n    }\n    startUpdate() {\n      var _a;\n      if (this.isUpdateBlocked())\n        return;\n      this.isUpdating = true;\n      (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);\n    }\n    willUpdate(shouldNotifyListeners = true) {\n      var _a, _b, _c;\n      if (this.root.isUpdateBlocked()) {\n        (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n        return;\n      }\n      !this.root.isUpdating && this.root.startUpdate();\n      if (this.isLayoutDirty)\n        return;\n      this.isLayoutDirty = true;\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        node.shouldResetTransform = true;\n        node.updateScroll();\n      }\n      const { layoutId, layout } = this.options;\n      if (layoutId === void 0 && !layout)\n        return;\n      const transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;\n      this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n      this.updateSnapshot();\n      shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n    }\n    didUpdate() {\n      const updateWasBlocked = this.isUpdateBlocked();\n      if (updateWasBlocked) {\n        this.unblockUpdate();\n        this.clearAllSnapshots();\n        this.nodes.forEach(clearMeasurements);\n        return;\n      }\n      if (!this.isUpdating)\n        return;\n      this.isUpdating = false;\n      if (this.potentialNodes.size) {\n        this.potentialNodes.forEach(mountNodeEarly);\n        this.potentialNodes.clear();\n      }\n      this.nodes.forEach(resetTransformStyle);\n      this.nodes.forEach(updateLayout);\n      this.nodes.forEach(notifyLayoutUpdate);\n      this.clearAllSnapshots();\n      flushSync.update();\n      flushSync.preRender();\n      flushSync.render();\n    }\n    clearAllSnapshots() {\n      this.nodes.forEach(clearSnapshot);\n      this.sharedNodes.forEach(removeLeadSnapshots);\n    }\n    scheduleUpdateProjection() {\n      es_default.preRender(this.updateProjection, false, true);\n    }\n    scheduleCheckAfterUnmount() {\n      es_default.postRender(() => {\n        if (this.isLayoutDirty) {\n          this.root.didUpdate();\n        } else {\n          this.root.checkUpdateFailed();\n        }\n      });\n    }\n    updateSnapshot() {\n      if (this.snapshot || !this.instance)\n        return;\n      this.snapshot = this.measure();\n    }\n    updateLayout() {\n      var _a;\n      if (!this.instance)\n        return;\n      this.updateScroll();\n      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {\n        return;\n      }\n      if (this.resumeFrom && !this.resumeFrom.instance) {\n        for (let i2 = 0; i2 < this.path.length; i2++) {\n          const node = this.path[i2];\n          node.updateScroll();\n        }\n      }\n      const prevLayout = this.layout;\n      this.layout = this.measure(false);\n      this.layoutCorrected = createBox();\n      this.isLayoutDirty = false;\n      this.projectionDelta = void 0;\n      this.notifyListeners(\"measure\", this.layout.layoutBox);\n      (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.layoutBox);\n    }\n    updateScroll() {\n      if (this.options.layoutScroll && this.instance) {\n        this.isScrollRoot = checkIsScrollRoot(this.instance);\n        this.scroll = measureScroll(this.instance);\n      }\n    }\n    resetTransform() {\n      var _a;\n      if (!resetTransform)\n        return;\n      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;\n      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n      const transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n      const transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {\n        resetTransform(this.instance, transformTemplateValue);\n        this.shouldResetTransform = false;\n        this.scheduleRender();\n      }\n    }\n    measure(removeTransform = true) {\n      const pageBox = this.measurePageBox();\n      let layoutBox = this.removeElementScroll(pageBox);\n      if (removeTransform) {\n        layoutBox = this.removeTransform(layoutBox);\n      }\n      roundBox(layoutBox);\n      return {\n        measuredBox: pageBox,\n        layoutBox,\n        latestValues: {}\n      };\n    }\n    measurePageBox() {\n      const { visualElement } = this.options;\n      if (!visualElement)\n        return createBox();\n      const box = visualElement.measureViewportBox();\n      const { scroll: scroll2 } = this.root;\n      if (scroll2) {\n        translateAxis(box.x, scroll2.x);\n        translateAxis(box.y, scroll2.y);\n      }\n      return box;\n    }\n    removeElementScroll(box) {\n      const boxWithoutScroll = createBox();\n      copyBoxInto(boxWithoutScroll, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        const { scroll: scroll2, options, isScrollRoot } = node;\n        if (node !== this.root && scroll2 && options.layoutScroll) {\n          if (isScrollRoot) {\n            copyBoxInto(boxWithoutScroll, box);\n            const { scroll: rootScroll } = this.root;\n            if (rootScroll) {\n              translateAxis(boxWithoutScroll.x, -rootScroll.x);\n              translateAxis(boxWithoutScroll.y, -rootScroll.y);\n            }\n          }\n          translateAxis(boxWithoutScroll.x, scroll2.x);\n          translateAxis(boxWithoutScroll.y, scroll2.y);\n        }\n      }\n      return boxWithoutScroll;\n    }\n    applyTransform(box, transformOnly = false) {\n      const withTransforms = createBox();\n      copyBoxInto(withTransforms, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {\n          transformBox(withTransforms, {\n            x: -node.scroll.x,\n            y: -node.scroll.y\n          });\n        }\n        if (!hasTransform(node.latestValues))\n          continue;\n        transformBox(withTransforms, node.latestValues);\n      }\n      if (hasTransform(this.latestValues)) {\n        transformBox(withTransforms, this.latestValues);\n      }\n      return withTransforms;\n    }\n    removeTransform(box) {\n      var _a;\n      const boxWithoutTransform = createBox();\n      copyBoxInto(boxWithoutTransform, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        if (!node.instance)\n          continue;\n        if (!hasTransform(node.latestValues))\n          continue;\n        hasScale(node.latestValues) && node.updateSnapshot();\n        const sourceBox = createBox();\n        const nodeBox = node.measurePageBox();\n        copyBoxInto(sourceBox, nodeBox);\n        removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layoutBox, sourceBox);\n      }\n      if (hasTransform(this.latestValues)) {\n        removeBoxTransforms(boxWithoutTransform, this.latestValues);\n      }\n      return boxWithoutTransform;\n    }\n    setTargetDelta(delta) {\n      this.targetDelta = delta;\n      this.root.scheduleUpdateProjection();\n    }\n    setOptions(options) {\n      this.options = __spreadProps(__spreadValues(__spreadValues({}, this.options), options), {\n        crossfade: options.crossfade !== void 0 ? options.crossfade : true\n      });\n    }\n    clearMeasurements() {\n      this.scroll = void 0;\n      this.layout = void 0;\n      this.snapshot = void 0;\n      this.prevTransformTemplateValue = void 0;\n      this.targetDelta = void 0;\n      this.target = void 0;\n      this.isLayoutDirty = false;\n    }\n    resolveTargetDelta() {\n      var _a;\n      const { layout, layoutId } = this.options;\n      if (!this.layout || !(layout || layoutId))\n        return;\n      if (!this.targetDelta && !this.relativeTarget) {\n        const relativeParent = this.getClosestProjectingParent();\n        if (relativeParent && relativeParent.layout) {\n          this.relativeParent = relativeParent;\n          this.relativeTarget = createBox();\n          this.relativeTargetOrigin = createBox();\n          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n        } else {\n          this.relativeParent = this.relativeTarget = void 0;\n        }\n      }\n      if (!this.relativeTarget && !this.targetDelta)\n        return;\n      if (!this.target) {\n        this.target = createBox();\n        this.targetWithTransforms = createBox();\n      }\n      if (this.relativeTarget && this.relativeTargetOrigin && ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {\n        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n      } else if (this.targetDelta) {\n        if (Boolean(this.resumingFrom)) {\n          this.target = this.applyTransform(this.layout.layoutBox);\n        } else {\n          copyBoxInto(this.target, this.layout.layoutBox);\n        }\n        applyBoxDelta(this.target, this.targetDelta);\n      } else {\n        copyBoxInto(this.target, this.layout.layoutBox);\n      }\n      if (this.attemptToResolveRelativeTarget) {\n        this.attemptToResolveRelativeTarget = false;\n        const relativeParent = this.getClosestProjectingParent();\n        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target) {\n          this.relativeParent = relativeParent;\n          this.relativeTarget = createBox();\n          this.relativeTargetOrigin = createBox();\n          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n        } else {\n          this.relativeParent = this.relativeTarget = void 0;\n        }\n      }\n    }\n    getClosestProjectingParent() {\n      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues))\n        return void 0;\n      if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {\n        return this.parent;\n      } else {\n        return this.parent.getClosestProjectingParent();\n      }\n    }\n    calcProjection() {\n      var _a;\n      const { layout, layoutId } = this.options;\n      this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);\n      if (!this.isTreeAnimating) {\n        this.targetDelta = this.relativeTarget = void 0;\n      }\n      if (!this.layout || !(layout || layoutId))\n        return;\n      const lead = this.getLead();\n      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);\n      const { target } = lead;\n      if (!target)\n        return;\n      if (!this.projectionDelta) {\n        this.projectionDelta = createDelta();\n        this.projectionDeltaWithTransform = createDelta();\n      }\n      const prevTreeScaleX = this.treeScale.x;\n      const prevTreeScaleY = this.treeScale.y;\n      const prevProjectionTransform = this.projectionTransform;\n      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);\n      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {\n        this.hasProjected = true;\n        this.scheduleRender();\n        this.notifyListeners(\"projectionUpdate\", target);\n      }\n    }\n    hide() {\n      this.isVisible = false;\n    }\n    show() {\n      this.isVisible = true;\n    }\n    scheduleRender(notifyAll2 = true) {\n      var _a, _b, _c;\n      (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);\n      notifyAll2 && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());\n      if (this.resumingFrom && !this.resumingFrom.instance) {\n        this.resumingFrom = void 0;\n      }\n    }\n    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n      var _a;\n      const snapshot = this.snapshot;\n      const snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};\n      const mixedValues = __spreadValues({}, this.latestValues);\n      const targetDelta = createDelta();\n      this.relativeTarget = this.relativeTargetOrigin = void 0;\n      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n      const relativeLayout = createBox();\n      const isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;\n      const isOnlyMember = (((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.members.length) || 0) <= 1;\n      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));\n      this.animationProgress = 0;\n      this.mixTargetDelta = (latest) => {\n        var _a2;\n        const progress3 = latest / 1e3;\n        mixAxisDelta(targetDelta.x, delta.x, progress3);\n        mixAxisDelta(targetDelta.y, delta.y, progress3);\n        this.setTargetDelta(targetDelta);\n        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && ((_a2 = this.relativeParent) === null || _a2 === void 0 ? void 0 : _a2.layout)) {\n          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress3);\n        }\n        if (isSharedLayoutAnimation) {\n          this.animationValues = mixedValues;\n          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress3, shouldCrossfadeOpacity, isOnlyMember);\n        }\n        this.root.scheduleUpdateProjection();\n        this.scheduleRender();\n        this.animationProgress = progress3;\n      };\n      this.mixTargetDelta(0);\n    }\n    startAnimation(options) {\n      var _a, _b;\n      this.notifyListeners(\"animationStart\");\n      (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n      if (this.resumingFrom) {\n        (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();\n      }\n      if (this.pendingAnimation) {\n        cancelSync.update(this.pendingAnimation);\n        this.pendingAnimation = void 0;\n      }\n      this.pendingAnimation = es_default.update(() => {\n        globalProjectionState.hasAnimatedSinceResize = true;\n        this.currentAnimation = animate2(0, animationTarget, __spreadProps(__spreadValues({}, options), {\n          onUpdate: (latest) => {\n            var _a2;\n            this.mixTargetDelta(latest);\n            (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, latest);\n          },\n          onComplete: () => {\n            var _a2;\n            (_a2 = options.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(options);\n            this.completeAnimation();\n          }\n        }));\n        if (this.resumingFrom) {\n          this.resumingFrom.currentAnimation = this.currentAnimation;\n        }\n        this.pendingAnimation = void 0;\n      });\n    }\n    completeAnimation() {\n      var _a;\n      if (this.resumingFrom) {\n        this.resumingFrom.currentAnimation = void 0;\n        this.resumingFrom.preserveOpacity = void 0;\n      }\n      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();\n      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;\n      this.notifyListeners(\"animationComplete\");\n    }\n    finishAnimation() {\n      var _a;\n      if (this.currentAnimation) {\n        (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);\n        this.currentAnimation.stop();\n      }\n      this.completeAnimation();\n    }\n    applyTransformsToTarget() {\n      const lead = this.getLead();\n      let { targetWithTransforms, target, layout, latestValues } = lead;\n      if (!targetWithTransforms || !target || !layout)\n        return;\n      if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n        target = this.target || createBox();\n        const xLength = calcLength(this.layout.layoutBox.x);\n        target.x.min = lead.target.x.min;\n        target.x.max = target.x.min + xLength;\n        const yLength = calcLength(this.layout.layoutBox.y);\n        target.y.min = lead.target.y.min;\n        target.y.max = target.y.min + yLength;\n      }\n      copyBoxInto(targetWithTransforms, target);\n      transformBox(targetWithTransforms, latestValues);\n      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n    }\n    registerSharedNode(layoutId, node) {\n      var _a, _b, _c;\n      if (!this.sharedNodes.has(layoutId)) {\n        this.sharedNodes.set(layoutId, new NodeStack());\n      }\n      const stack = this.sharedNodes.get(layoutId);\n      stack.add(node);\n      node.promote({\n        transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,\n        preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)\n      });\n    }\n    isLead() {\n      const stack = this.getStack();\n      return stack ? stack.lead === this : true;\n    }\n    getLead() {\n      var _a;\n      const { layoutId } = this.options;\n      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n    }\n    getPrevLead() {\n      var _a;\n      const { layoutId } = this.options;\n      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;\n    }\n    getStack() {\n      const { layoutId } = this.options;\n      if (layoutId)\n        return this.root.sharedNodes.get(layoutId);\n    }\n    promote({ needsReset, transition, preserveFollowOpacity } = {}) {\n      const stack = this.getStack();\n      if (stack)\n        stack.promote(this, preserveFollowOpacity);\n      if (needsReset) {\n        this.projectionDelta = void 0;\n        this.needsReset = true;\n      }\n      if (transition)\n        this.setOptions({ transition });\n    }\n    relegate() {\n      const stack = this.getStack();\n      if (stack) {\n        return stack.relegate(this);\n      } else {\n        return false;\n      }\n    }\n    resetRotation() {\n      const { visualElement } = this.options;\n      if (!visualElement)\n        return;\n      let hasRotate = false;\n      const resetValues = {};\n      for (let i2 = 0; i2 < transformAxes.length; i2++) {\n        const axis = transformAxes[i2];\n        const key = \"rotate\" + axis;\n        if (!visualElement.getStaticValue(key)) {\n          continue;\n        }\n        hasRotate = true;\n        resetValues[key] = visualElement.getStaticValue(key);\n        visualElement.setStaticValue(key, 0);\n      }\n      if (!hasRotate)\n        return;\n      visualElement === null || visualElement === void 0 ? void 0 : visualElement.render();\n      for (const key in resetValues) {\n        visualElement.setStaticValue(key, resetValues[key]);\n      }\n      visualElement.scheduleRender();\n    }\n    getProjectionStyles(styleProp = {}) {\n      var _a, _b, _c;\n      const styles = {};\n      if (!this.instance || this.isSVG)\n        return styles;\n      if (!this.isVisible) {\n        return { visibility: \"hidden\" };\n      } else {\n        styles.visibility = \"\";\n      }\n      const transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n      if (this.needsReset) {\n        this.needsReset = false;\n        styles.opacity = \"\";\n        styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n        styles.transform = transformTemplate ? transformTemplate(this.latestValues, \"\") : \"none\";\n        return styles;\n      }\n      const lead = this.getLead();\n      if (!this.projectionDelta || !this.layout || !lead.target) {\n        const emptyStyles = {};\n        if (this.options.layoutId) {\n          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;\n          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n        }\n        if (this.hasProjected && !hasTransform(this.latestValues)) {\n          emptyStyles.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n          this.hasProjected = false;\n        }\n        return emptyStyles;\n      }\n      const valuesToRender = lead.animationValues || lead.latestValues;\n      this.applyTransformsToTarget();\n      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n      if (transformTemplate) {\n        styles.transform = transformTemplate(valuesToRender, styles.transform);\n      }\n      const { x, y } = this.projectionDelta;\n      styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n      if (lead.animationValues) {\n        styles.opacity = lead === this ? (_c = (_b = valuesToRender.opacity) !== null && _b !== void 0 ? _b : this.latestValues.opacity) !== null && _c !== void 0 ? _c : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;\n      } else {\n        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : \"\" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;\n      }\n      for (const key in scaleCorrectors) {\n        if (valuesToRender[key] === void 0)\n          continue;\n        const { correct, applyTo } = scaleCorrectors[key];\n        const corrected = correct(valuesToRender[key], lead);\n        if (applyTo) {\n          const num = applyTo.length;\n          for (let i2 = 0; i2 < num; i2++) {\n            styles[applyTo[i2]] = corrected;\n          }\n        } else {\n          styles[key] = corrected;\n        }\n      }\n      if (this.options.layoutId) {\n        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || \"\" : \"none\";\n      }\n      return styles;\n    }\n    clearSnapshot() {\n      this.resumeFrom = this.snapshot = void 0;\n    }\n    resetTree() {\n      this.root.nodes.forEach((node) => {\n        var _a;\n        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n      });\n      this.root.nodes.forEach(clearMeasurements);\n      this.root.sharedNodes.clear();\n    }\n  };\n}\nfunction updateLayout(node) {\n  node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n  var _a, _b, _c;\n  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\n  if (node.isLead() && node.layout && snapshot && node.hasListeners(\"didUpdate\")) {\n    const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\n    const { animationType } = node.options;\n    if (animationType === \"size\") {\n      eachAxis((axis) => {\n        const axisSnapshot = snapshot.isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n        const length = calcLength(axisSnapshot);\n        axisSnapshot.min = layout[axis].min;\n        axisSnapshot.max = axisSnapshot.min + length;\n      });\n    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\n      eachAxis((axis) => {\n        const axisSnapshot = snapshot.isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n        const length = calcLength(layout[axis]);\n        axisSnapshot.max = axisSnapshot.min + length;\n      });\n    }\n    const layoutDelta = createDelta();\n    calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\n    const visualDelta = createDelta();\n    if (snapshot.isShared) {\n      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n    } else {\n      calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n    }\n    const hasLayoutChanged = !isDeltaZero(layoutDelta);\n    let hasRelativeTargetChanged = false;\n    if (!node.resumeFrom) {\n      const relativeParent = node.getClosestProjectingParent();\n      if (relativeParent && !relativeParent.resumeFrom) {\n        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n        if (parentSnapshot && parentLayout) {\n          const relativeSnapshot = createBox();\n          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n          const relativeLayout = createBox();\n          calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n          if (!boxEquals(relativeSnapshot, relativeLayout)) {\n            hasRelativeTargetChanged = true;\n          }\n        }\n      }\n    }\n    node.notifyListeners(\"didUpdate\", {\n      layout,\n      snapshot,\n      delta: visualDelta,\n      layoutDelta,\n      hasLayoutChanged,\n      hasRelativeTargetChanged\n    });\n  } else if (node.isLead()) {\n    (_c = (_b = node.options).onExitComplete) === null || _c === void 0 ? void 0 : _c.call(_b);\n  }\n  node.options.transition = void 0;\n}\nfunction clearSnapshot(node) {\n  node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n  node.clearMeasurements();\n}\nfunction resetTransformStyle(node) {\n  const { visualElement } = node.options;\n  if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {\n    visualElement.notify(\"BeforeLayoutMeasure\");\n  }\n  node.resetTransform();\n}\nfunction finishAnimation(node) {\n  node.finishAnimation();\n  node.targetDelta = node.relativeTarget = node.target = void 0;\n}\nfunction resolveTargetDelta(node) {\n  node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n  node.calcProjection();\n}\nfunction resetRotation(node) {\n  node.resetRotation();\n}\nfunction removeLeadSnapshots(stack) {\n  stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p2) {\n  output.translate = mix(delta.translate, 0, p2);\n  output.scale = mix(delta.scale, 1, p2);\n  output.origin = delta.origin;\n  output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p2) {\n  output.min = mix(from.min, to.min, p2);\n  output.max = mix(from.max, to.max, p2);\n}\nfunction mixBox(output, from, to, p2) {\n  mixAxis(output.x, from.x, to.x, p2);\n  mixAxis(output.y, from.y, to.y, p2);\n}\nfunction hasOpacityCrossfade(node) {\n  return node.animationValues && node.animationValues.opacityExit !== void 0;\n}\nvar defaultLayoutTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\nfunction mountNodeEarly(node, id2) {\n  let searchNode = node.root;\n  for (let i2 = node.path.length - 1; i2 >= 0; i2--) {\n    if (Boolean(node.path[i2].instance)) {\n      searchNode = node.path[i2];\n      break;\n    }\n  }\n  const searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;\n  const element = searchElement.querySelector(`[data-projection-id=\"${id2}\"]`);\n  if (element)\n    node.mount(element, true);\n}\nfunction roundAxis(axis) {\n  axis.min = Math.round(axis.min);\n  axis.max = Math.round(axis.max);\n}\nfunction roundBox(box) {\n  roundAxis(box.x);\n  roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\n  return animationType === \"position\" || animationType === \"preserve-aspect\" && !isCloseTo(aspectRatio(snapshot), aspectRatio(layout), 0.2);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs\nvar DocumentProjectionNode = createProjectionNode({\n  attachResizeListener: (ref, notify) => addDomEvent(ref, \"resize\", notify),\n  measureScroll: () => ({\n    x: document.documentElement.scrollLeft || document.body.scrollLeft,\n    y: document.documentElement.scrollTop || document.body.scrollTop\n  }),\n  checkIsScrollRoot: () => true\n});\n\n// ../../node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs\nvar rootProjectionNode = {\n  current: void 0\n};\nvar HTMLProjectionNode = createProjectionNode({\n  measureScroll: (instance) => ({\n    x: instance.scrollLeft,\n    y: instance.scrollTop\n  }),\n  defaultParent: () => {\n    if (!rootProjectionNode.current) {\n      const documentNode = new DocumentProjectionNode(0, {});\n      documentNode.mount(window);\n      documentNode.setOptions({ layoutScroll: true });\n      rootProjectionNode.current = documentNode;\n    }\n    return rootProjectionNode.current;\n  },\n  resetTransform: (instance, value) => {\n    instance.style.transform = value !== void 0 ? value : \"none\";\n  },\n  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \"fixed\")\n});\n\n// ../../node_modules/framer-motion/dist/es/render/dom/motion.mjs\nvar featureBundle = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, animations), gestureAnimations), drag), layoutFeatures);\nvar motion = /* @__PURE__ */ createMotionProxy((Component, config) => createDomMotionConfig(Component, config, featureBundle, createDomVisualElement, HTMLProjectionNode));\n\n// ../../node_modules/@motionone/utils/dist/clamp.es.js\nvar clamp3 = (min, max, v) => Math.min(Math.max(v, min), max);\n\n// ../../node_modules/@motionone/utils/dist/is-number.es.js\nvar isNumber = (value) => typeof value === \"number\";\n\n// ../../node_modules/@motionone/utils/dist/is-easing-list.es.js\nvar isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\n\n// ../../node_modules/@motionone/utils/dist/wrap.es.js\nvar wrap = (min, max, v) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\n// ../../node_modules/@motionone/utils/dist/easing.es.js\nfunction getEasingForSegment(easing, i2) {\n  return isEasingList(easing) ? easing[wrap(0, easing.length, i2)] : easing;\n}\n\n// ../../node_modules/@motionone/utils/dist/mix.es.js\nvar mix2 = (min, max, progress3) => -progress3 * min + progress3 * max + min;\n\n// ../../node_modules/@motionone/utils/dist/noop.es.js\nvar noopReturn = (v) => v;\n\n// ../../node_modules/@motionone/utils/dist/progress.es.js\nvar progress2 = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\n// ../../node_modules/@motionone/utils/dist/offset.es.js\nfunction fillOffset(offset, remaining) {\n  const min = offset[offset.length - 1];\n  for (let i2 = 1; i2 <= remaining; i2++) {\n    const offsetProgress = progress2(0, remaining, i2);\n    offset.push(mix2(min, 1, offsetProgress));\n  }\n}\nfunction defaultOffset2(length) {\n  const offset = [0];\n  fillOffset(offset, length - 1);\n  return offset;\n}\n\n// ../../node_modules/@motionone/utils/dist/interpolate.es.js\nfunction interpolate2(output, input = defaultOffset2(output.length), easing = noopReturn) {\n  const length = output.length;\n  const remainder = length - input.length;\n  remainder > 0 && fillOffset(input, remainder);\n  return (t) => {\n    let i2 = 0;\n    for (; i2 < length - 2; i2++) {\n      if (t < input[i2 + 1])\n        break;\n    }\n    let progressInRange = clamp3(0, 1, progress2(input[i2], input[i2 + 1], t));\n    const segmentEasing = getEasingForSegment(easing, i2);\n    progressInRange = segmentEasing(progressInRange);\n    return mix2(output[i2], output[i2 + 1], progressInRange);\n  };\n}\n\n// ../../node_modules/@motionone/utils/dist/is-function.es.js\nvar isFunction = (value) => typeof value === \"function\";\n\n// ../../node_modules/@motionone/utils/dist/is-string.es.js\nvar isString2 = (value) => typeof value === \"string\";\n\n// ../../node_modules/@motionone/utils/dist/velocity.es.js\nfunction velocityPerSecond2(velocity, frameDuration) {\n  return frameDuration ? velocity * (1e3 / frameDuration) : 0;\n}\n\n// ../../node_modules/@motionone/dom/dist/utils/resolve-elements.es.js\nfunction resolveElements(elements, selectorCache) {\n  var _a;\n  if (typeof elements === \"string\") {\n    if (selectorCache) {\n      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = document.querySelectorAll(elements);\n      elements = selectorCache[elements];\n    } else {\n      elements = document.querySelectorAll(elements);\n    }\n  } else if (elements instanceof Element) {\n    elements = [elements];\n  }\n  return Array.from(elements || []);\n}\n\n// ../../node_modules/tslib/modules/index.js\nvar import_tslib4 = __toESM(require_tslib2(), 1);\nvar {\n  __extends: __extends2,\n  __assign: __assign2,\n  __rest: __rest2,\n  __decorate: __decorate2,\n  __param: __param2,\n  __metadata: __metadata2,\n  __awaiter: __awaiter2,\n  __generator: __generator2,\n  __exportStar: __exportStar2,\n  __createBinding: __createBinding2,\n  __values: __values2,\n  __read: __read2,\n  __spread: __spread2,\n  __spreadArrays: __spreadArrays2,\n  __spreadArray: __spreadArray2,\n  __await: __await2,\n  __asyncGenerator: __asyncGenerator2,\n  __asyncDelegator: __asyncDelegator2,\n  __asyncValues: __asyncValues2,\n  __makeTemplateObject: __makeTemplateObject2,\n  __importStar: __importStar2,\n  __importDefault: __importDefault2,\n  __classPrivateFieldGet: __classPrivateFieldGet2,\n  __classPrivateFieldSet: __classPrivateFieldSet2,\n  __classPrivateFieldIn: __classPrivateFieldIn2\n} = import_tslib4.default;\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/handle-element.es.js\nvar resizeHandlers = /* @__PURE__ */ new WeakMap();\nvar observer;\nfunction getElementSize(target, borderBoxSize) {\n  if (borderBoxSize) {\n    const { inlineSize, blockSize } = borderBoxSize[0];\n    return { width: inlineSize, height: blockSize };\n  } else if (target instanceof SVGElement && \"getBBox\" in target) {\n    return target.getBBox();\n  } else {\n    return {\n      width: target.offsetWidth,\n      height: target.offsetHeight\n    };\n  }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize }) {\n  var _a;\n  (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n    handler({\n      target,\n      contentSize: contentRect,\n      get size() {\n        return getElementSize(target, borderBoxSize);\n      }\n    });\n  });\n}\nfunction notifyAll(entries) {\n  entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n  if (typeof ResizeObserver === \"undefined\")\n    return;\n  observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n  if (!observer)\n    createResizeObserver();\n  const elements = resolveElements(target);\n  elements.forEach((element) => {\n    let elementHandlers = resizeHandlers.get(element);\n    if (!elementHandlers) {\n      elementHandlers = /* @__PURE__ */ new Set();\n      resizeHandlers.set(element, elementHandlers);\n    }\n    elementHandlers.add(handler);\n    observer === null || observer === void 0 ? void 0 : observer.observe(element);\n  });\n  return () => {\n    elements.forEach((element) => {\n      const elementHandlers = resizeHandlers.get(element);\n      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n        observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n      }\n    });\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/handle-window.es.js\nvar windowCallbacks = /* @__PURE__ */ new Set();\nvar windowResizeHandler;\nfunction createWindowResizeHandler() {\n  windowResizeHandler = () => {\n    const size = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n    const info = {\n      target: window,\n      size,\n      contentSize: size\n    };\n    windowCallbacks.forEach((callback) => callback(info));\n  };\n  window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n  windowCallbacks.add(callback);\n  if (!windowResizeHandler)\n    createWindowResizeHandler();\n  return () => {\n    windowCallbacks.delete(callback);\n    if (!windowCallbacks.size && windowResizeHandler) {\n      windowResizeHandler = void 0;\n    }\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/index.es.js\nfunction resize(a2, b2) {\n  return isFunction(a2) ? resizeWindow(a2) : resizeElement(a2, b2);\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/info.es.js\nvar maxElapsed2 = 50;\nvar createAxisInfo = () => ({\n  current: 0,\n  offset: [],\n  progress: 0,\n  scrollLength: 0,\n  targetOffset: 0,\n  targetLength: 0,\n  containerLength: 0,\n  velocity: 0\n});\nvar createScrollInfo = () => ({\n  time: 0,\n  x: createAxisInfo(),\n  y: createAxisInfo()\n});\nvar keys = {\n  x: {\n    length: \"Width\",\n    position: \"Left\"\n  },\n  y: {\n    length: \"Height\",\n    position: \"Top\"\n  }\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n  const axis = info[axisName];\n  const { length, position } = keys[axisName];\n  const prev = axis.current;\n  const prevTime = info.time;\n  axis.current = element[\"scroll\" + position];\n  axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n  axis.offset.length = 0;\n  axis.offset[0] = 0;\n  axis.offset[1] = axis.scrollLength;\n  axis.progress = progress2(0, axis.scrollLength, axis.current);\n  const elapsed = time - prevTime;\n  axis.velocity = elapsed > maxElapsed2 ? 0 : velocityPerSecond2(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n  updateAxisInfo(element, \"x\", info, time);\n  updateAxisInfo(element, \"y\", info, time);\n  info.time = time;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/inset.es.js\nfunction calcInset(element, container) {\n  let inset = { x: 0, y: 0 };\n  let current = element;\n  while (current && current !== container) {\n    if (current instanceof HTMLElement) {\n      inset.x += current.offsetLeft;\n      inset.y += current.offsetTop;\n      current = current.offsetParent;\n    } else if (current instanceof SVGGraphicsElement && \"getBBox\" in current) {\n      const { top, left } = current.getBBox();\n      inset.x += left;\n      inset.y += top;\n      while (current && current.tagName !== \"svg\") {\n        current = current.parentNode;\n      }\n    }\n  }\n  return inset;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/presets.es.js\nvar ScrollOffset = {\n  Enter: [\n    [0, 1],\n    [1, 1]\n  ],\n  Exit: [\n    [0, 0],\n    [1, 0]\n  ],\n  Any: [\n    [1, 0],\n    [0, 1]\n  ],\n  All: [\n    [0, 0],\n    [1, 1]\n  ]\n};\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/edge.es.js\nvar namedEdges = {\n  start: 0,\n  center: 0.5,\n  end: 1\n};\nfunction resolveEdge(edge, length, inset = 0) {\n  let delta = 0;\n  if (namedEdges[edge] !== void 0) {\n    edge = namedEdges[edge];\n  }\n  if (isString2(edge)) {\n    const asNumber2 = parseFloat(edge);\n    if (edge.endsWith(\"px\")) {\n      delta = asNumber2;\n    } else if (edge.endsWith(\"%\")) {\n      edge = asNumber2 / 100;\n    } else if (edge.endsWith(\"vw\")) {\n      delta = asNumber2 / 100 * document.documentElement.clientWidth;\n    } else if (edge.endsWith(\"vh\")) {\n      delta = asNumber2 / 100 * document.documentElement.clientHeight;\n    } else {\n      edge = asNumber2;\n    }\n  }\n  if (isNumber(edge)) {\n    delta = length * edge;\n  }\n  return inset + delta;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/offset.es.js\nvar defaultOffset3 = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset3;\n  let targetPoint = 0;\n  let containerPoint = 0;\n  if (isNumber(offset)) {\n    offsetDefinition = [offset, offset];\n  } else if (isString2(offset)) {\n    offset = offset.trim();\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n    }\n  }\n  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/index.es.js\nvar point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n  let { offset: offsetDefinition = ScrollOffset.All } = options;\n  const { target = container, axis = \"y\" } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset = target !== container ? calcInset(target, container) : point;\n  const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight } : { width: target.clientWidth, height: target.clientHeight };\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  info[axis].offset.length = 0;\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n  for (let i2 = 0; i2 < numOffsets; i2++) {\n    const offset = resolveOffset(offsetDefinition[i2], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i2]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i2] = offset;\n  }\n  if (hasChanged) {\n    info[axis].interpolate = interpolate2(defaultOffset2(numOffsets), info[axis].offset);\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/on-scroll-handler.es.js\nfunction measure(container, target = container, info) {\n  info.x.targetOffset = 0;\n  info.y.targetOffset = 0;\n  if (target !== container) {\n    let node = target;\n    while (node && node != container) {\n      info.x.targetOffset += node.offsetLeft;\n      info.y.targetOffset += node.offsetTop;\n      node = node.offsetParent;\n    }\n  }\n  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;\n  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;\n  info.x.containerLength = container.clientWidth;\n  info.y.containerLength = container.clientHeight;\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n  const axis = options.axis || \"y\";\n  return {\n    measure: () => measure(element, options.target, info),\n    update: (time) => {\n      updateScrollInfo(element, info, time);\n      if (options.offset || options.target) {\n        resolveOffsets(element, info, options);\n      }\n    },\n    notify: isFunction(onScroll) ? () => onScroll(info) : scrubAnimation(onScroll, info[axis])\n  };\n}\nfunction scrubAnimation(controls, axisInfo) {\n  controls.pause();\n  controls.forEachNative((animation, { easing }) => {\n    var _a, _b;\n    if (animation.updateDuration) {\n      if (!easing)\n        animation.easing = noopReturn;\n      animation.updateDuration(1);\n    } else {\n      const timingOptions = { duration: 1e3 };\n      if (!easing)\n        timingOptions.easing = \"linear\";\n      (_b = (_a = animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming) === null || _b === void 0 ? void 0 : _b.call(_a, timingOptions);\n    }\n  });\n  return () => {\n    controls.currentTime = axisInfo.progress;\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/index.es.js\nvar scrollListeners = /* @__PURE__ */ new WeakMap();\nvar resizeListeners = /* @__PURE__ */ new WeakMap();\nvar onScrollHandlers = /* @__PURE__ */ new WeakMap();\nvar getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction scroll(onScroll, _a = {}) {\n  var { container = document.documentElement } = _a, options = __rest2(_a, [\"container\"]);\n  let containerHandlers = onScrollHandlers.get(container);\n  if (!containerHandlers) {\n    containerHandlers = /* @__PURE__ */ new Set();\n    onScrollHandlers.set(container, containerHandlers);\n  }\n  const info = createScrollInfo();\n  const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n  containerHandlers.add(containerHandler);\n  if (!scrollListeners.has(container)) {\n    const listener2 = () => {\n      const time = performance.now();\n      for (const handler of containerHandlers)\n        handler.measure();\n      for (const handler of containerHandlers)\n        handler.update(time);\n      for (const handler of containerHandlers)\n        handler.notify();\n    };\n    scrollListeners.set(container, listener2);\n    const target = getEventTarget(container);\n    window.addEventListener(\"resize\", listener2, { passive: true });\n    if (container !== document.documentElement) {\n      resizeListeners.set(container, resize(container, listener2));\n    }\n    target.addEventListener(\"scroll\", listener2, { passive: true });\n  }\n  const listener = scrollListeners.get(container);\n  const onLoadProcesss = requestAnimationFrame(listener);\n  return () => {\n    var _a2;\n    if (typeof onScroll !== \"function\")\n      onScroll.stop();\n    cancelAnimationFrame(onLoadProcesss);\n    const containerHandlers2 = onScrollHandlers.get(container);\n    if (!containerHandlers2)\n      return;\n    containerHandlers2.delete(containerHandler);\n    if (containerHandlers2.size)\n      return;\n    const listener2 = scrollListeners.get(container);\n    scrollListeners.delete(container);\n    if (listener2) {\n      getEventTarget(container).removeEventListener(\"scroll\", listener2);\n      (_a2 = resizeListeners.get(container)) === null || _a2 === void 0 ? void 0 : _a2();\n      window.removeEventListener(\"resize\", listener2);\n    }\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-scroll.mjs\n\nvar createScrollMotionValues = () => ({\n  scrollX: motionValue(0),\n  scrollY: motionValue(0),\n  scrollXProgress: motionValue(0),\n  scrollYProgress: motionValue(0)\n});\nfunction useScroll(_a = {}) {\n  var _b = _a, { container, target, layoutEffect = true } = _b, options = __objRest(_b, [\"container\", \"target\", \"layoutEffect\"]);\n  const values = useConstant(createScrollMotionValues);\n  const useLifecycleEffect = layoutEffect ? useIsomorphicLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n  useLifecycleEffect(() => {\n    return scroll(({ x, y }) => {\n      values.scrollX.set(x.current);\n      values.scrollXProgress.set(x.progress);\n      values.scrollY.set(y.current);\n      values.scrollYProgress.set(y.progress);\n    }, __spreadProps(__spreadValues({}, options), {\n      container: (container === null || container === void 0 ? void 0 : container.current) || void 0,\n      target: (target === null || target === void 0 ? void 0 : target.current) || void 0\n    }));\n  }, []);\n  return values;\n}\n\n// src/Menu.tsx\n\nvar Menu = () => {\n  const { scrollYProgress } = useScroll();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n    className: \"hidden sm:block\",\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.div, {\n        className: \"progress-bar\",\n        style: { scaleX: scrollYProgress }\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"flex flex-row items-center justify-between bg-gradient-to-r from-blue-400 to-blue-500\",\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"/\",\n              children: \"Pylar\\u2122 AI\"\n            })\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"/blog\",\n              children: \"Daily Work\"\n            })\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"/what-is-pylar\",\n              children: \"About\"\n            })\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"/pylar-license\",\n              children: \"The License\"\n            })\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"https://pencil.domains\",\n              target: \"_blank\",\n              rel: \"noreferrer\",\n              children: \"Pencil Domains\"\n            })\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n            className: \"hidden py-2 px-4 font-bold text-white md:block\",\n            style: {\n              display: \"flex\",\n              justifyContent: \"center\",\n              alignItems: \"center\"\n            },\n            children: [\n              \" \",\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n                className: \"hidden py-2 px-4 font-bold text-white md:block\",\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n                  href: \"http://twitter.com/superdatas\",\n                  target: \"_blank\",\n                  rel: \"noopener noreferrer\",\n                  children: \"Twitter\"\n                })\n              }),\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n                href: \"http://github.com/miguelgargallo/next13-gallery-image-turbo\",\n                target: \"_blank\",\n                rel: \"noopener noreferrer\",\n                className: \"hidden py-2 px-4 font-bold text-white md:block\",\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"picture\", {\n                  children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                    src: \"https://img.shields.io/github/stars/miguelgargallo/Next13-gallery-image-turbo?style=social\",\n                    alt: \"Landscape picture\",\n                    width: 100,\n                    height: 20\n                  })\n                })\n              }),\n              \" \",\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Version, {})\n            ]\n          })\n        ]\n      })\n    ]\n  });\n};\n\n// src/MenuPylar.tsx\n\nvar MenuPylar = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    className: \"flex hidden flex-row items-center justify-between bg-gradient-to-r from-blue-400 to-blue-500 sm:block\",\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n      className: \"flex flex-row\",\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"/blog\",\n            children: \"Our Daily Work\"\n          })\n        }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"/what-is-pylar\",\n            children: \"What is Pylar AI\"\n          })\n        }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"/pylar-license\",\n            children: \"License\"\n          })\n        })\n      ]\n    })\n  });\n};\n\n// src/TitlePylar.tsx\n\nvar TitlePylar = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"h1\", {\n        className: \"py-8 text-center text-5xl font-bold\",\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.5, duration: 1.5 },\n            children: \"P\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.6, duration: 1.5 },\n            children: \"y\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.7, duration: 1.5 },\n            children: \"l\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.8, duration: 1.5 },\n            children: \"a\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.9, duration: 1.5 },\n            children: \"r\\u2122\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1, duration: 1.5 },\n            children: \"\\xA0\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1.1, duration: 1.5 },\n            children: \"A\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1.2, duration: 1.5 },\n            children: \"I\"\n          })\n        ]\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(motion.h2, {\n        className: \"py-8 text-center text-4xl font-bold\",\n        initial: { opacity: 0 },\n        animate: { opacity: 1 },\n        transition: { delay: 1.4, duration: 1.5 },\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"Py\"\n          }),\n          \"thon\",\n          \" \",\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"L\"\n          }),\n          \"earning\",\n          \" \",\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"A\"\n          }),\n          \"rtificial\",\n          \" \",\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"R\"\n          }),\n          \"esearch\\u2122\",\n          \" \",\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-black\",\n            children: \" \"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"A\"\n          }),\n          \"rtificial\",\n          \" \",\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"I\"\n          }),\n          \"ntelligence\",\n          \" \"\n        ]\n      })\n    ]\n  });\n};\n\n// src/ListPylar.tsx\n\nvar ListPylar = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    className: \"mt-8 flex flex-row justify-center\",\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n      className: \"flex w-3/4 flex-col\",\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n          className: \"text-2xl font-bold\",\n          children: \"Welcome to the Pylar AI Blog\"\n        }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n          className: \"mt-4 text-lg\",\n          children: [\n            \"Pylar AI is:\",\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"ul\", {\n              className: \"list-inside list-disc\",\n              children: [\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n                  children: \"Generative art results\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n                  children: \"What is generative art? Generative art is a form of art that uses a computer to create art. The computer is programmed to create art based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n                  children: \"Promt Engineering design\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n                  children: \"Promt Engineering is a form of engineering that uses a computer to create engineering. The computer is programmed to create engineering based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n                  children: \"StableDiffusion 2.0 modified\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n                  children: \"StableDiffusion 2.0 is a computer program that is used to create art based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                })\n              ]\n            })\n          ]\n        })\n      ]\n    })\n  });\n};\n\n// src/Footer.tsx\n\nvar Footer = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"footer\", {\n    className: \"bg-white py-8 text-center\",\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"a\", {\n          children: [\n            \"Made with \\u2764\\uFE0F by\",\n            \" \",\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"https://twitter.com/miguelgargallo\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hover:text-blue text-indigo-600\",\n              children: \"Miguel Gargallo\"\n            }),\n            \".\"\n          ]\n        })\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"a\", {\n          children: [\n            \"2022 \\xA9\",\n            \" \",\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"https://huggingface.co/spaces/superdatas/LICENSE\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hover:text-blue text-indigo-600\",\n              children: \"Pylar\\u2122 AI creative ML license\"\n            }),\n            \".\"\n          ]\n        })\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"hidden sm:block\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n          className: \"flex w-full items-center justify-center\",\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://huggingface.co/spaces/superdatas/LICENSE\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            className: \"hidden p-2 md:block\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"picture\", {\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                src: \"https://huggingface.co/front/assets/huggingface_logo.svg\",\n                alt: \"Landscape picture\",\n                width: 40,\n                height: 20\n              })\n            })\n          })\n        })\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n        children: \"Thanks for your time.\"\n      })\n    ]\n  });\n};\n\n// src/Scrollable.tsx\n\nvar Scrollable = () => {\n  const { scrollYProgress } = useScroll();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.div, {\n    className: \"progress-bar\",\n    style: { scaleX: scrollYProgress }\n  });\n};\n\n// src/BlogPylar/blog.tsx\n\nvar ELEMENTS2 = 5;\nvar blog = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: \"95\",\n      height: \"95\",\n      stroke: \"#FFF\",\n      \"stroke-width\": \"0\",\n      viewBox: \"0 0 95 95\",\n      className: \"m-2 rounded-xl py-2 shadow-md hover:shadow-xl\",\n      style: k(ELEMENTS2),\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M32.816,12.95,30.349,8.568h4.78a.439.439,0,0,1,.346.2l.931,1.534c.558.92,1.225,2.02,1.607,2.648ZM23.975,39.495a.339.339,0,0,1-.315.207H18.772l7.595-13.635a.731.731,0,0,0-.636-1.087h0L12.787,25l-2.574-4.456H29.076c.011,0,.02,0,.031,0a.677.677,0,0,0,.217-.045l.047-.02a.722.722,0,0,0,.346-.313l3.108-5.745h5.13Zm-6.468-.518-.613-1.009c-.785-1.3-1.791-2.955-1.9-3.137a.385.385,0,0,1,.024-.355l4.457-8.027,5.019-.006ZM8.948,30.444,6.453,26.011,8.968,21.3l2.522,4.367C10.706,27.14,9.483,29.442,8.948,30.444Zm-3.348.69H2.881a.443.443,0,0,1-.343-.2L1.726,29.6C1.147,28.641.409,27.425,0,26.752H5.2l2.466,4.383ZM14.037.208A.338.338,0,0,1,14.351,0h4.91L11.646,13.636c-.006.011-.01.023-.016.035s-.021.046-.03.07-.015.046-.021.069-.011.044-.014.066a.648.648,0,0,0-.008.081c0,.012,0,.023,0,.036s0,.018,0,.027a.591.591,0,0,0,.008.079.538.538,0,0,0,.012.066c.006.023.013.045.021.068s.016.045.025.066.021.041.033.062.023.04.037.059a.644.644,0,0,0,.045.055c.016.017.031.035.048.051s.035.029.053.043a.634.634,0,0,0,.063.045l.023.016c.008,0,.018.006.027.011a.729.729,0,0,0,.119.048c.015,0,.029.01.044.013a.7.7,0,0,0,.164.021h.33l12.619-.017c.334.58.957,1.673,1.489,2.6q.612,1.072,1.01,1.768H8.949c-.008,0-.016,0-.024,0a.725.725,0,0,0-.631.382L5.185,25.29H.059Zm6.479.534.456.75c.8,1.321,1.932,3.185,2.052,3.379A.383.383,0,0,1,23,5.227l-4.457,8.027-5.017.006Zm8.546,8.511,2.5,4.435-2.545,4.7c-.3-.529-.68-1.189-1.034-1.808-.7-1.224-1.208-2.115-1.495-2.613C27.028,12.977,28.462,10.349,29.062,9.253Z\",\n        id: \"Fill-1\",\n        className: \"fill-yellow-500\"\n      })\n    })\n  });\n};\n\n// src/BlogPylar/post12032022.tsx\n\nvar ELEMENTS3 = 5;\nvar post12032022 = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: \"95\",\n      height: \"95\",\n      stroke: \"#FFF\",\n      \"stroke-width\": \"0\",\n      viewBox: \"0 0 95 95\",\n      className: \"m-2 rounded-xl py-2 shadow-md hover:shadow-xl\",\n      style: k(ELEMENTS3),\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M32.816,12.95,30.349,8.568h4.78a.439.439,0,0,1,.346.2l.931,1.534c.558.92,1.225,2.02,1.607,2.648ZM23.975,39.495a.339.339,0,0,1-.315.207H18.772l7.595-13.635a.731.731,0,0,0-.636-1.087h0L12.787,25l-2.574-4.456H29.076c.011,0,.02,0,.031,0a.677.677,0,0,0,.217-.045l.047-.02a.722.722,0,0,0,.346-.313l3.108-5.745h5.13Zm-6.468-.518-.613-1.009c-.785-1.3-1.791-2.955-1.9-3.137a.385.385,0,0,1,.024-.355l4.457-8.027,5.019-.006ZM8.948,30.444,6.453,26.011,8.968,21.3l2.522,4.367C10.706,27.14,9.483,29.442,8.948,30.444Zm-3.348.69H2.881a.443.443,0,0,1-.343-.2L1.726,29.6C1.147,28.641.409,27.425,0,26.752H5.2l2.466,4.383ZM14.037.208A.338.338,0,0,1,14.351,0h4.91L11.646,13.636c-.006.011-.01.023-.016.035s-.021.046-.03.07-.015.046-.021.069-.011.044-.014.066a.648.648,0,0,0-.008.081c0,.012,0,.023,0,.036s0,.018,0,.027a.591.591,0,0,0,.008.079.538.538,0,0,0,.012.066c.006.023.013.045.021.068s.016.045.025.066.021.041.033.062.023.04.037.059a.644.644,0,0,0,.045.055c.016.017.031.035.048.051s.035.029.053.043a.634.634,0,0,0,.063.045l.023.016c.008,0,.018.006.027.011a.729.729,0,0,0,.119.048c.015,0,.029.01.044.013a.7.7,0,0,0,.164.021h.33l12.619-.017c.334.58.957,1.673,1.489,2.6q.612,1.072,1.01,1.768H8.949c-.008,0-.016,0-.024,0a.725.725,0,0,0-.631.382L5.185,25.29H.059Zm6.479.534.456.75c.8,1.321,1.932,3.185,2.052,3.379A.383.383,0,0,1,23,5.227l-4.457,8.027-5.017.006Zm8.546,8.511,2.5,4.435-2.545,4.7c-.3-.529-.68-1.189-1.034-1.808-.7-1.224-1.208-2.115-1.495-2.613C27.028,12.977,28.462,10.349,29.062,9.253Z\",\n        id: \"Fill-1\",\n        className: \"fill-yellow-500\"\n      })\n    })\n  });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNLQUFzSztBQUM5SyxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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TTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNO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YTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLHNCQUFzQixzREFBSTtBQUMxQjtBQUNBLGtDQUFrQyxzREFBSTtBQUN0QztBQUNBLG9DQUFvQyxzREFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzREFBSTtBQUMxQyx3Q0FBd0Msc0RBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLHNCQUFzQixzREFBSTtBQUMxQjtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNnRDtBQUNoRDtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCLHlCQUF5QixzREFBSTtBQUM3QjtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7O0FBRUE7QUFDZ0Q7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5QixzREFBSTtBQUM3Qiw4QkFBOEIsc0RBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNnRDtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHNEQUFJO0FBQzdCLDhCQUE4QixzREFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBV0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3BhY2thZ2VzL3VpL2Rpc3QvaW5kZXgubWpzP2YwMWQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEyLCBiMikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIyIHx8IChiMiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYjIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEyLCBwcm9wLCBiMltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiMikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiMiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhMiwgcHJvcCwgYjJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGEyO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEyLCBiMikgPT4gX19kZWZQcm9wcyhhMiwgX19nZXRPd25Qcm9wRGVzY3MoYjIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fZXNtID0gKGZuLCByZXMpID0+IGZ1bmN0aW9uIF9faW5pdCgpIHtcbiAgcmV0dXJuIGZuICYmIChyZXMgPSAoMCwgZm5bX19nZXRPd25Qcm9wTmFtZXMoZm4pWzBdXSkoZm4gPSAwKSksIHJlcztcbn07XG52YXIgX19jb21tb25KUyA9IChjYjIsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYjJbX19nZXRPd25Qcm9wTmFtZXMoY2IyKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9tZW1vaXplL2Rpc3QvbWVtb2l6ZS5lc20uanNcbmZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAoY2FjaGVbYXJnXSA9PT0gdm9pZCAwKVxuICAgICAgY2FjaGVbYXJnXSA9IGZuKGFyZyk7XG4gICAgcmV0dXJuIGNhY2hlW2FyZ107XG4gIH07XG59XG52YXIgbWVtb2l6ZV9lc21fZGVmYXVsdDtcbnZhciBpbml0X21lbW9pemVfZXNtID0gX19lc20oe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9tZW1vaXplL2Rpc3QvbWVtb2l6ZS5lc20uanNcIigpIHtcbiAgICBtZW1vaXplX2VzbV9kZWZhdWx0ID0gbWVtb2l6ZTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9pcy1wcm9wLXZhbGlkL2Rpc3QvaXMtcHJvcC12YWxpZC5lc20uanNcbnZhciBpc19wcm9wX3ZhbGlkX2VzbV9leHBvcnRzID0ge307XG5fX2V4cG9ydChpc19wcm9wX3ZhbGlkX2VzbV9leHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGlzX3Byb3BfdmFsaWRfZXNtX2RlZmF1bHRcbn0pO1xudmFyIHJlYWN0UHJvcHNSZWdleCwgaW5kZXgsIGlzX3Byb3BfdmFsaWRfZXNtX2RlZmF1bHQ7XG52YXIgaW5pdF9pc19wcm9wX3ZhbGlkX2VzbSA9IF9fZXNtKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vaXMtcHJvcC12YWxpZC9kaXN0L2lzLXByb3AtdmFsaWQuZXNtLmpzXCIoKSB7XG4gICAgaW5pdF9tZW1vaXplX2VzbSgpO1xuICAgIHJlYWN0UHJvcHNSZWdleCA9IC9eKChjaGlsZHJlbnxkYW5nZXJvdXNseVNldElubmVySFRNTHxrZXl8cmVmfGF1dG9Gb2N1c3xkZWZhdWx0VmFsdWV8ZGVmYXVsdENoZWNrZWR8aW5uZXJIVE1MfHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ3xzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmd8dmFsdWVMaW5rfGFjY2VwdHxhY2NlcHRDaGFyc2V0fGFjY2Vzc0tleXxhY3Rpb258YWxsb3d8YWxsb3dVc2VyTWVkaWF8YWxsb3dQYXltZW50UmVxdWVzdHxhbGxvd0Z1bGxTY3JlZW58YWxsb3dUcmFuc3BhcmVuY3l8YWx0fGFzeW5jfGF1dG9Db21wbGV0ZXxhdXRvUGxheXxjYXB0dXJlfGNlbGxQYWRkaW5nfGNlbGxTcGFjaW5nfGNoYWxsZW5nZXxjaGFyU2V0fGNoZWNrZWR8Y2l0ZXxjbGFzc0lEfGNsYXNzTmFtZXxjb2xzfGNvbFNwYW58Y29udGVudHxjb250ZW50RWRpdGFibGV8Y29udGV4dE1lbnV8Y29udHJvbHN8Y29udHJvbHNMaXN0fGNvb3Jkc3xjcm9zc09yaWdpbnxkYXRhfGRhdGVUaW1lfGRlY29kaW5nfGRlZmF1bHR8ZGVmZXJ8ZGlyfGRpc2FibGVkfGRpc2FibGVQaWN0dXJlSW5QaWN0dXJlfGRvd25sb2FkfGRyYWdnYWJsZXxlbmNUeXBlfGZvcm18Zm9ybUFjdGlvbnxmb3JtRW5jVHlwZXxmb3JtTWV0aG9kfGZvcm1Ob1ZhbGlkYXRlfGZvcm1UYXJnZXR8ZnJhbWVCb3JkZXJ8aGVhZGVyc3xoZWlnaHR8aGlkZGVufGhpZ2h8aHJlZnxocmVmTGFuZ3xodG1sRm9yfGh0dHBFcXVpdnxpZHxpbnB1dE1vZGV8aW50ZWdyaXR5fGlzfGtleVBhcmFtc3xrZXlUeXBlfGtpbmR8bGFiZWx8bGFuZ3xsaXN0fGxvYWRpbmd8bG9vcHxsb3d8bWFyZ2luSGVpZ2h0fG1hcmdpbldpZHRofG1heHxtYXhMZW5ndGh8bWVkaWF8bWVkaWFHcm91cHxtZXRob2R8bWlufG1pbkxlbmd0aHxtdWx0aXBsZXxtdXRlZHxuYW1lfG5vbmNlfG5vVmFsaWRhdGV8b3BlbnxvcHRpbXVtfHBhdHRlcm58cGxhY2Vob2xkZXJ8cGxheXNJbmxpbmV8cG9zdGVyfHByZWxvYWR8cHJvZmlsZXxyYWRpb0dyb3VwfHJlYWRPbmx5fHJlZmVycmVyUG9saWN5fHJlbHxyZXF1aXJlZHxyZXZlcnNlZHxyb2xlfHJvd3N8cm93U3BhbnxzYW5kYm94fHNjb3BlfHNjb3BlZHxzY3JvbGxpbmd8c2VhbWxlc3N8c2VsZWN0ZWR8c2hhcGV8c2l6ZXxzaXplc3xzbG90fHNwYW58c3BlbGxDaGVja3xzcmN8c3JjRG9jfHNyY0xhbmd8c3JjU2V0fHN0YXJ0fHN0ZXB8c3R5bGV8c3VtbWFyeXx0YWJJbmRleHx0YXJnZXR8dGl0bGV8dHlwZXx1c2VNYXB8dmFsdWV8d2lkdGh8d21vZGV8d3JhcHxhYm91dHxkYXRhdHlwZXxpbmxpc3R8cHJlZml4fHByb3BlcnR5fHJlc291cmNlfHR5cGVvZnx2b2NhYnxhdXRvQ2FwaXRhbGl6ZXxhdXRvQ29ycmVjdHxhdXRvU2F2ZXxjb2xvcnxpbmVydHxpdGVtUHJvcHxpdGVtU2NvcGV8aXRlbVR5cGV8aXRlbUlEfGl0ZW1SZWZ8b258cmVzdWx0c3xzZWN1cml0eXx1bnNlbGVjdGFibGV8YWNjZW50SGVpZ2h0fGFjY3VtdWxhdGV8YWRkaXRpdmV8YWxpZ25tZW50QmFzZWxpbmV8YWxsb3dSZW9yZGVyfGFscGhhYmV0aWN8YW1wbGl0dWRlfGFyYWJpY0Zvcm18YXNjZW50fGF0dHJpYnV0ZU5hbWV8YXR0cmlidXRlVHlwZXxhdXRvUmV2ZXJzZXxhemltdXRofGJhc2VGcmVxdWVuY3l8YmFzZWxpbmVTaGlmdHxiYXNlUHJvZmlsZXxiYm94fGJlZ2lufGJpYXN8Ynl8Y2FsY01vZGV8Y2FwSGVpZ2h0fGNsaXB8Y2xpcFBhdGhVbml0c3xjbGlwUGF0aHxjbGlwUnVsZXxjb2xvckludGVycG9sYXRpb258Y29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc3xjb2xvclByb2ZpbGV8Y29sb3JSZW5kZXJpbmd8Y29udGVudFNjcmlwdFR5cGV8Y29udGVudFN0eWxlVHlwZXxjdXJzb3J8Y3h8Y3l8ZHxkZWNlbGVyYXRlfGRlc2NlbnR8ZGlmZnVzZUNvbnN0YW50fGRpcmVjdGlvbnxkaXNwbGF5fGRpdmlzb3J8ZG9taW5hbnRCYXNlbGluZXxkdXJ8ZHh8ZHl8ZWRnZU1vZGV8ZWxldmF0aW9ufGVuYWJsZUJhY2tncm91bmR8ZW5kfGV4cG9uZW50fGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWR8ZmlsbHxmaWxsT3BhY2l0eXxmaWxsUnVsZXxmaWx0ZXJ8ZmlsdGVyUmVzfGZpbHRlclVuaXRzfGZsb29kQ29sb3J8Zmxvb2RPcGFjaXR5fGZvY3VzYWJsZXxmb250RmFtaWx5fGZvbnRTaXplfGZvbnRTaXplQWRqdXN0fGZvbnRTdHJldGNofGZvbnRTdHlsZXxmb250VmFyaWFudHxmb250V2VpZ2h0fGZvcm1hdHxmcm9tfGZyfGZ4fGZ5fGcxfGcyfGdseXBoTmFtZXxnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbHxnbHlwaE9yaWVudGF0aW9uVmVydGljYWx8Z2x5cGhSZWZ8Z3JhZGllbnRUcmFuc2Zvcm18Z3JhZGllbnRVbml0c3xoYW5naW5nfGhvcml6QWR2WHxob3Jpek9yaWdpblh8aWRlb2dyYXBoaWN8aW1hZ2VSZW5kZXJpbmd8aW58aW4yfGludGVyY2VwdHxrfGsxfGsyfGszfGs0fGtlcm5lbE1hdHJpeHxrZXJuZWxVbml0TGVuZ3RofGtlcm5pbmd8a2V5UG9pbnRzfGtleVNwbGluZXN8a2V5VGltZXN8bGVuZ3RoQWRqdXN0fGxldHRlclNwYWNpbmd8bGlnaHRpbmdDb2xvcnxsaW1pdGluZ0NvbmVBbmdsZXxsb2NhbHxtYXJrZXJFbmR8bWFya2VyTWlkfG1hcmtlclN0YXJ0fG1hcmtlckhlaWdodHxtYXJrZXJVbml0c3xtYXJrZXJXaWR0aHxtYXNrfG1hc2tDb250ZW50VW5pdHN8bWFza1VuaXRzfG1hdGhlbWF0aWNhbHxtb2RlfG51bU9jdGF2ZXN8b2Zmc2V0fG9wYWNpdHl8b3BlcmF0b3J8b3JkZXJ8b3JpZW50fG9yaWVudGF0aW9ufG9yaWdpbnxvdmVyZmxvd3xvdmVybGluZVBvc2l0aW9ufG92ZXJsaW5lVGhpY2tuZXNzfHBhbm9zZTF8cGFpbnRPcmRlcnxwYXRoTGVuZ3RofHBhdHRlcm5Db250ZW50VW5pdHN8cGF0dGVyblRyYW5zZm9ybXxwYXR0ZXJuVW5pdHN8cG9pbnRlckV2ZW50c3xwb2ludHN8cG9pbnRzQXRYfHBvaW50c0F0WXxwb2ludHNBdFp8cHJlc2VydmVBbHBoYXxwcmVzZXJ2ZUFzcGVjdFJhdGlvfHByaW1pdGl2ZVVuaXRzfHJ8cmFkaXVzfHJlZlh8cmVmWXxyZW5kZXJpbmdJbnRlbnR8cmVwZWF0Q291bnR8cmVwZWF0RHVyfHJlcXVpcmVkRXh0ZW5zaW9uc3xyZXF1aXJlZEZlYXR1cmVzfHJlc3RhcnR8cmVzdWx0fHJvdGF0ZXxyeHxyeXxzY2FsZXxzZWVkfHNoYXBlUmVuZGVyaW5nfHNsb3BlfHNwYWNpbmd8c3BlY3VsYXJDb25zdGFudHxzcGVjdWxhckV4cG9uZW50fHNwZWVkfHNwcmVhZE1ldGhvZHxzdGFydE9mZnNldHxzdGREZXZpYXRpb258c3RlbWh8c3RlbXZ8c3RpdGNoVGlsZXN8c3RvcENvbG9yfHN0b3BPcGFjaXR5fHN0cmlrZXRocm91Z2hQb3NpdGlvbnxzdHJpa2V0aHJvdWdoVGhpY2tuZXNzfHN0cmluZ3xzdHJva2V8c3Ryb2tlRGFzaGFycmF5fHN0cm9rZURhc2hvZmZzZXR8c3Ryb2tlTGluZWNhcHxzdHJva2VMaW5lam9pbnxzdHJva2VNaXRlcmxpbWl0fHN0cm9rZU9wYWNpdHl8c3Ryb2tlV2lkdGh8c3VyZmFjZVNjYWxlfHN5c3RlbUxhbmd1YWdlfHRhYmxlVmFsdWVzfHRhcmdldFh8dGFyZ2V0WXx0ZXh0QW5jaG9yfHRleHREZWNvcmF0aW9ufHRleHRSZW5kZXJpbmd8dGV4dExlbmd0aHx0b3x0cmFuc2Zvcm18dTF8dTJ8dW5kZXJsaW5lUG9zaXRpb258dW5kZXJsaW5lVGhpY2tuZXNzfHVuaWNvZGV8dW5pY29kZUJpZGl8dW5pY29kZVJhbmdlfHVuaXRzUGVyRW18dkFscGhhYmV0aWN8dkhhbmdpbmd8dklkZW9ncmFwaGljfHZNYXRoZW1hdGljYWx8dmFsdWVzfHZlY3RvckVmZmVjdHx2ZXJzaW9ufHZlcnRBZHZZfHZlcnRPcmlnaW5YfHZlcnRPcmlnaW5ZfHZpZXdCb3h8dmlld1RhcmdldHx2aXNpYmlsaXR5fHdpZHRoc3x3b3JkU3BhY2luZ3x3cml0aW5nTW9kZXx4fHhIZWlnaHR8eDF8eDJ8eENoYW5uZWxTZWxlY3Rvcnx4bGlua0FjdHVhdGV8eGxpbmtBcmNyb2xlfHhsaW5rSHJlZnx4bGlua1JvbGV8eGxpbmtTaG93fHhsaW5rVGl0bGV8eGxpbmtUeXBlfHhtbEJhc2V8eG1sbnN8eG1sbnNYbGlua3x4bWxMYW5nfHhtbFNwYWNlfHl8eTF8eTJ8eUNoYW5uZWxTZWxlY3Rvcnx6fHpvb21BbmRQYW58Zm9yfGNsYXNzfGF1dG9mb2N1cyl8KChbRGRdW0FhXVtUdF1bQWFdfFtBYV1bUnJdW0lpXVtBYV18eCktLiopKSQvO1xuICAgIGluZGV4ID0gbWVtb2l6ZV9lc21fZGVmYXVsdChcbiAgICAgIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHJlYWN0UHJvcHNSZWdleC50ZXN0KHByb3ApIHx8IHByb3AuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIHByb3AuY2hhckNvZGVBdCgxKSA9PT0gMTEwICYmIHByb3AuY2hhckNvZGVBdCgyKSA8IDkxO1xuICAgICAgfVxuICAgICk7XG4gICAgaXNfcHJvcF92YWxpZF9lc21fZGVmYXVsdCA9IGluZGV4O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanNcbnZhciByZXF1aXJlX3RzbGliID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgX19leHRlbmRzMztcbiAgICB2YXIgX19hc3NpZ24zO1xuICAgIHZhciBfX3Jlc3QzO1xuICAgIHZhciBfX2RlY29yYXRlMztcbiAgICB2YXIgX19wYXJhbTM7XG4gICAgdmFyIF9fbWV0YWRhdGEzO1xuICAgIHZhciBfX2F3YWl0ZXIzO1xuICAgIHZhciBfX2dlbmVyYXRvcjM7XG4gICAgdmFyIF9fZXhwb3J0U3RhcjM7XG4gICAgdmFyIF9fdmFsdWVzMztcbiAgICB2YXIgX19yZWFkMztcbiAgICB2YXIgX19zcHJlYWQzO1xuICAgIHZhciBfX3NwcmVhZEFycmF5czM7XG4gICAgdmFyIF9fc3ByZWFkQXJyYXkzO1xuICAgIHZhciBfX2F3YWl0MztcbiAgICB2YXIgX19hc3luY0dlbmVyYXRvcjM7XG4gICAgdmFyIF9fYXN5bmNEZWxlZ2F0b3IzO1xuICAgIHZhciBfX2FzeW5jVmFsdWVzMztcbiAgICB2YXIgX19tYWtlVGVtcGxhdGVPYmplY3QzO1xuICAgIHZhciBfX2ltcG9ydFN0YXIzO1xuICAgIHZhciBfX2ltcG9ydERlZmF1bHQzO1xuICAgIHZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MztcbiAgICB2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDM7XG4gICAgdmFyIF9fY2xhc3NQcml2YXRlRmllbGRJbjM7XG4gICAgdmFyIF9fY3JlYXRlQmluZGluZzM7XG4gICAgKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xuICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uKGV4cG9ydHMyKSB7XG4gICAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzMikpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMyLCBwcmV2aW91cykge1xuICAgICAgICBpZiAoZXhwb3J0czIgIT09IHJvb3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwb3J0czIuX19lc01vZHVsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpZDIsIHYpIHtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0czJbaWQyXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQyLCB2KSA6IHY7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSkoZnVuY3Rpb24oZXhwb3J0ZXIpIHtcbiAgICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgIGQyLl9fcHJvdG9fXyA9IGIyO1xuICAgICAgfSB8fCBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gYjIpXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiMiwgcDIpKVxuICAgICAgICAgICAgZDJbcDJdID0gYjJbcDJdO1xuICAgICAgfTtcbiAgICAgIF9fZXh0ZW5kczMgPSBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiMiAhPT0gXCJmdW5jdGlvblwiICYmIGIyICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIyKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZDIsIGIyKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQyO1xuICAgICAgICB9XG4gICAgICAgIGQyLnByb3RvdHlwZSA9IGIyID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiMikgOiAoX18ucHJvdG90eXBlID0gYjIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgICB9O1xuICAgICAgX19hc3NpZ24zID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkyID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkyIDwgbjsgaTIrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaTJdO1xuICAgICAgICAgIGZvciAodmFyIHAyIGluIHMpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHAyKSlcbiAgICAgICAgICAgICAgdFtwMl0gPSBzW3AyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH07XG4gICAgICBfX3Jlc3QzID0gZnVuY3Rpb24ocywgZSkge1xuICAgICAgICB2YXIgdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBzKVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcDIpICYmIGUuaW5kZXhPZihwMikgPCAwKVxuICAgICAgICAgICAgdFtwMl0gPSBzW3AyXTtcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIGZvciAodmFyIGkyID0gMCwgcDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpMiA8IHAyLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwMltpMl0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcDJbaTJdKSlcbiAgICAgICAgICAgICAgdFtwMltpMl1dID0gc1twMltpMl1dO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9O1xuICAgICAgX19kZWNvcmF0ZTMgPSBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgICAgICB2YXIgYzMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYzMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQyO1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSlcbiAgICAgICAgICAgIGlmIChkMiA9IGRlY29yYXRvcnNbaTJdKVxuICAgICAgICAgICAgICByID0gKGMzIDwgMyA/IGQyKHIpIDogYzMgPiAzID8gZDIodGFyZ2V0LCBrZXksIHIpIDogZDIodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgICAgICByZXR1cm4gYzMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgICAgIH07XG4gICAgICBfX3BhcmFtMyA9IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIF9fbWV0YWRhdGEzID0gZnVuY3Rpb24obWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xuICAgICAgfTtcbiAgICAgIF9fYXdhaXRlcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIF9fZ2VuZXJhdG9yMyA9IGZ1bmN0aW9uKHRoaXNBcmcsIGJvZHkpIHtcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodFswXSAmIDEpXG4gICAgICAgICAgICB0aHJvdyB0WzFdO1xuICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmMiwgeSwgdCwgZzI7XG4gICAgICAgIHJldHVybiBnMiA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZzJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KSwgZzI7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICAgIGlmIChmMilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICAgIHdoaWxlIChfKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGYyID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpXG4gICAgICAgICAgICAgICAgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodFsyXSlcbiAgICAgICAgICAgICAgICAgICAgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgb3AgPSBbNiwgZV07XG4gICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgZjIgPSB0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BbMF0gJiA1KVxuICAgICAgICAgICAgdGhyb3cgb3BbMV07XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fZXhwb3J0U3RhcjMgPSBmdW5jdGlvbihtLCBvKSB7XG4gICAgICAgIGZvciAodmFyIHAyIGluIG0pXG4gICAgICAgICAgaWYgKHAyICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHAyKSlcbiAgICAgICAgICAgIF9fY3JlYXRlQmluZGluZzMobywgbSwgcDIpO1xuICAgICAgfTtcbiAgICAgIF9fY3JlYXRlQmluZGluZzMgPSBPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24obywgbSwgazIsIGsyMikge1xuICAgICAgICBpZiAoazIyID09PSB2b2lkIDApXG4gICAgICAgICAgazIyID0gazI7XG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrMik7XG4gICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtW2syXTtcbiAgICAgICAgICB9IH07XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyMiwgZGVzYyk7XG4gICAgICB9IDogZnVuY3Rpb24obywgbSwgazIsIGsyMikge1xuICAgICAgICBpZiAoazIyID09PSB2b2lkIDApXG4gICAgICAgICAgazIyID0gazI7XG4gICAgICAgIG9bazIyXSA9IG1bazJdO1xuICAgICAgfTtcbiAgICAgIF9fdmFsdWVzMyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpMiA9IDA7XG4gICAgICAgIGlmIChtKVxuICAgICAgICAgIHJldHVybiBtLmNhbGwobyk7XG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChvICYmIGkyID49IG8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baTIrK10sIGRvbmU6ICFvIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgfTtcbiAgICAgIF9fcmVhZDMgPSBmdW5jdGlvbihvLCBuKSB7XG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB2YXIgaTIgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaTIubmV4dCgpKS5kb25lKVxuICAgICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBlID0geyBlcnJvciB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaTJbXCJyZXR1cm5cIl0pKVxuICAgICAgICAgICAgICBtLmNhbGwoaTIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgICAgdGhyb3cgZS5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgfTtcbiAgICAgIF9fc3ByZWFkMyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpMiA9IDA7IGkyIDwgYXJndW1lbnRzLmxlbmd0aDsgaTIrKylcbiAgICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQzKGFyZ3VtZW50c1tpMl0pKTtcbiAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgfTtcbiAgICAgIF9fc3ByZWFkQXJyYXlzMyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBzID0gMCwgaTIgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkyIDwgaWw7IGkyKyspXG4gICAgICAgICAgcyArPSBhcmd1bWVudHNbaTJdLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrMiA9IDAsIGkyID0gMDsgaTIgPCBpbDsgaTIrKylcbiAgICAgICAgICBmb3IgKHZhciBhMiA9IGFyZ3VtZW50c1tpMl0sIGogPSAwLCBqbCA9IGEyLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsyKyspXG4gICAgICAgICAgICByW2syXSA9IGEyW2pdO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH07XG4gICAgICBfX3NwcmVhZEFycmF5MyA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpMiA8IGw7IGkyKyspIHtcbiAgICAgICAgICAgIGlmIChhciB8fCAhKGkyIGluIGZyb20pKSB7XG4gICAgICAgICAgICAgIGlmICghYXIpXG4gICAgICAgICAgICAgICAgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpMik7XG4gICAgICAgICAgICAgIGFyW2kyXSA9IGZyb21baTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG4gICAgICB9O1xuICAgICAgX19hd2FpdDMgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdDMgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdDModik7XG4gICAgICB9O1xuICAgICAgX19hc3luY0dlbmVyYXRvcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICB2YXIgZzIgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGkyLCBxID0gW107XG4gICAgICAgIHJldHVybiBpMiA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpMltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgaTI7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICAgIGlmIChnMltuXSlcbiAgICAgICAgICAgIGkyW25dID0gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oYTIsIGIyKSB7XG4gICAgICAgICAgICAgICAgcS5wdXNoKFtuLCB2LCBhMiwgYjJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RlcChnMltuXSh2KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgc2V0dGxlKHFbMF1bM10sIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHtcbiAgICAgICAgICByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdDMgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VtZShcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VtZShcInRocm93XCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZjIsIHYpIHtcbiAgICAgICAgICBpZiAoZjIodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpXG4gICAgICAgICAgICByZXN1bWUocVswXVswXSwgcVswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX2FzeW5jRGVsZWdhdG9yMyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdmFyIGkyLCBwMjtcbiAgICAgICAgcmV0dXJuIGkyID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpMltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGkyO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYyKSB7XG4gICAgICAgICAgaTJbbl0gPSBvW25dID8gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIChwMiA9ICFwMikgPyB7IHZhbHVlOiBfX2F3YWl0MyhvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZjIgPyBmMih2KSA6IHY7XG4gICAgICAgICAgfSA6IGYyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19hc3luY1ZhbHVlczMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTI7XG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlczMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaTIgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaTJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGkyKTtcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgICAgaTJbbl0gPSBvW25dICYmIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQyLCB2KSB7XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odjIpIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyB2YWx1ZTogdjIsIGRvbmU6IGQyIH0pO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX21ha2VUZW1wbGF0ZU9iamVjdDMgPSBmdW5jdGlvbihjb29rZWQsIHJhdykge1xuICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvb2tlZC5yYXcgPSByYXc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcbiAgICAgIH07XG4gICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xuICAgICAgfSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgfTtcbiAgICAgIF9faW1wb3J0U3RhcjMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAodmFyIGsyIGluIG1vZClcbiAgICAgICAgICAgIGlmIChrMiAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgazIpKVxuICAgICAgICAgICAgICBfX2NyZWF0ZUJpbmRpbmczKHJlc3VsdCwgbW9kLCBrMik7XG4gICAgICAgIH1cbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfX2ltcG9ydERlZmF1bHQzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbiAgICAgIH07XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MyA9IGZ1bmN0aW9uKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZjIpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmMilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYyIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZjIgOiBraW5kID09PSBcImFcIiA/IGYyLmNhbGwocmVjZWl2ZXIpIDogZjIgPyBmMi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG4gICAgICB9O1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldDMgPSBmdW5jdGlvbihyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmMikge1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJtXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmMilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYyIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgICAgICByZXR1cm4ga2luZCA9PT0gXCJhXCIgPyBmMi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmMiA/IGYyLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSwgdmFsdWU7XG4gICAgICB9O1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEluMyA9IGZ1bmN0aW9uKHN0YXRlLCByZWNlaXZlcikge1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgdHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcbiAgICAgIH07XG4gICAgICBleHBvcnRlcihcIl9fZXh0ZW5kc1wiLCBfX2V4dGVuZHMzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24zKTtcbiAgICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2RlY29yYXRlXCIsIF9fZGVjb3JhdGUzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtMyk7XG4gICAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YTMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2F3YWl0ZXJcIiwgX19hd2FpdGVyMyk7XG4gICAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yMyk7XG4gICAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19jcmVhdGVCaW5kaW5nXCIsIF9fY3JlYXRlQmluZGluZzMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlczMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkMyk7XG4gICAgICBleHBvcnRlcihcIl9fc3ByZWFkXCIsIF9fc3ByZWFkMyk7XG4gICAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzMyk7XG4gICAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlcIiwgX19zcHJlYWRBcnJheTMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2F3YWl0XCIsIF9fYXdhaXQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yMyk7XG4gICAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2FzeW5jVmFsdWVzXCIsIF9fYXN5bmNWYWx1ZXMzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19pbXBvcnRTdGFyXCIsIF9faW1wb3J0U3RhcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2ltcG9ydERlZmF1bHRcIiwgX19pbXBvcnREZWZhdWx0Myk7XG4gICAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZEluXCIsIF9fY2xhc3NQcml2YXRlRmllbGRJbjMpO1xuICAgIH0pO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzXG52YXIgcmVxdWlyZV90c2xpYjIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgX19leHRlbmRzMztcbiAgICB2YXIgX19hc3NpZ24zO1xuICAgIHZhciBfX3Jlc3QzO1xuICAgIHZhciBfX2RlY29yYXRlMztcbiAgICB2YXIgX19wYXJhbTM7XG4gICAgdmFyIF9fbWV0YWRhdGEzO1xuICAgIHZhciBfX2F3YWl0ZXIzO1xuICAgIHZhciBfX2dlbmVyYXRvcjM7XG4gICAgdmFyIF9fZXhwb3J0U3RhcjM7XG4gICAgdmFyIF9fdmFsdWVzMztcbiAgICB2YXIgX19yZWFkMztcbiAgICB2YXIgX19zcHJlYWQzO1xuICAgIHZhciBfX3NwcmVhZEFycmF5czM7XG4gICAgdmFyIF9fc3ByZWFkQXJyYXkzO1xuICAgIHZhciBfX2F3YWl0MztcbiAgICB2YXIgX19hc3luY0dlbmVyYXRvcjM7XG4gICAgdmFyIF9fYXN5bmNEZWxlZ2F0b3IzO1xuICAgIHZhciBfX2FzeW5jVmFsdWVzMztcbiAgICB2YXIgX19tYWtlVGVtcGxhdGVPYmplY3QzO1xuICAgIHZhciBfX2ltcG9ydFN0YXIzO1xuICAgIHZhciBfX2ltcG9ydERlZmF1bHQzO1xuICAgIHZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MztcbiAgICB2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDM7XG4gICAgdmFyIF9fY2xhc3NQcml2YXRlRmllbGRJbjM7XG4gICAgdmFyIF9fY3JlYXRlQmluZGluZzM7XG4gICAgKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xuICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uKGV4cG9ydHMyKSB7XG4gICAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzMikpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMyLCBwcmV2aW91cykge1xuICAgICAgICBpZiAoZXhwb3J0czIgIT09IHJvb3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwb3J0czIuX19lc01vZHVsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpZDIsIHYpIHtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0czJbaWQyXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQyLCB2KSA6IHY7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSkoZnVuY3Rpb24oZXhwb3J0ZXIpIHtcbiAgICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgIGQyLl9fcHJvdG9fXyA9IGIyO1xuICAgICAgfSB8fCBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gYjIpXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiMiwgcDIpKVxuICAgICAgICAgICAgZDJbcDJdID0gYjJbcDJdO1xuICAgICAgfTtcbiAgICAgIF9fZXh0ZW5kczMgPSBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiMiAhPT0gXCJmdW5jdGlvblwiICYmIGIyICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIyKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZDIsIGIyKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQyO1xuICAgICAgICB9XG4gICAgICAgIGQyLnByb3RvdHlwZSA9IGIyID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiMikgOiAoX18ucHJvdG90eXBlID0gYjIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgICB9O1xuICAgICAgX19hc3NpZ24zID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkyID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkyIDwgbjsgaTIrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaTJdO1xuICAgICAgICAgIGZvciAodmFyIHAyIGluIHMpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHAyKSlcbiAgICAgICAgICAgICAgdFtwMl0gPSBzW3AyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH07XG4gICAgICBfX3Jlc3QzID0gZnVuY3Rpb24ocywgZSkge1xuICAgICAgICB2YXIgdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBzKVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcDIpICYmIGUuaW5kZXhPZihwMikgPCAwKVxuICAgICAgICAgICAgdFtwMl0gPSBzW3AyXTtcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIGZvciAodmFyIGkyID0gMCwgcDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpMiA8IHAyLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwMltpMl0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcDJbaTJdKSlcbiAgICAgICAgICAgICAgdFtwMltpMl1dID0gc1twMltpMl1dO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9O1xuICAgICAgX19kZWNvcmF0ZTMgPSBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgICAgICB2YXIgYzMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYzMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQyO1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSlcbiAgICAgICAgICAgIGlmIChkMiA9IGRlY29yYXRvcnNbaTJdKVxuICAgICAgICAgICAgICByID0gKGMzIDwgMyA/IGQyKHIpIDogYzMgPiAzID8gZDIodGFyZ2V0LCBrZXksIHIpIDogZDIodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgICAgICByZXR1cm4gYzMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgICAgIH07XG4gICAgICBfX3BhcmFtMyA9IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIF9fbWV0YWRhdGEzID0gZnVuY3Rpb24obWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xuICAgICAgfTtcbiAgICAgIF9fYXdhaXRlcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIF9fZ2VuZXJhdG9yMyA9IGZ1bmN0aW9uKHRoaXNBcmcsIGJvZHkpIHtcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodFswXSAmIDEpXG4gICAgICAgICAgICB0aHJvdyB0WzFdO1xuICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmMiwgeSwgdCwgZzI7XG4gICAgICAgIHJldHVybiBnMiA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZzJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KSwgZzI7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICAgIGlmIChmMilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICAgIHdoaWxlIChnMiAmJiAoZzIgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXylcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChmMiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KVxuICAgICAgICAgICAgICAgIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pXG4gICAgICAgICAgICAgICAgICAgIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGYyID0gdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wWzBdICYgNSlcbiAgICAgICAgICAgIHRocm93IG9wWzFdO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX2V4cG9ydFN0YXIzID0gZnVuY3Rpb24obSwgbykge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBtKVxuICAgICAgICAgIGlmIChwMiAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwMikpXG4gICAgICAgICAgICBfX2NyZWF0ZUJpbmRpbmczKG8sIG0sIHAyKTtcbiAgICAgIH07XG4gICAgICBfX2NyZWF0ZUJpbmRpbmczID0gT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uKG8sIG0sIGsyLCBrMjIpIHtcbiAgICAgICAgaWYgKGsyMiA9PT0gdm9pZCAwKVxuICAgICAgICAgIGsyMiA9IGsyO1xuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgazIpO1xuICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbVtrMl07XG4gICAgICAgICAgfSB9O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMjIsIGRlc2MpO1xuICAgICAgfSA6IGZ1bmN0aW9uKG8sIG0sIGsyLCBrMjIpIHtcbiAgICAgICAgaWYgKGsyMiA9PT0gdm9pZCAwKVxuICAgICAgICAgIGsyMiA9IGsyO1xuICAgICAgICBvW2syMl0gPSBtW2syXTtcbiAgICAgIH07XG4gICAgICBfX3ZhbHVlczMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaTIgPSAwO1xuICAgICAgICBpZiAobSlcbiAgICAgICAgICByZXR1cm4gbS5jYWxsKG8pO1xuICAgICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAobyAmJiBpMiA+PSBvLmxlbmd0aClcbiAgICAgICAgICAgICAgICBvID0gdm9pZCAwO1xuICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2kyKytdLCBkb25lOiAhbyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIH07XG4gICAgICBfX3JlYWQzID0gZnVuY3Rpb24obywgbikge1xuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICAgIGlmICghbSlcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgdmFyIGkyID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkyLm5leHQoKSkuZG9uZSlcbiAgICAgICAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgZSA9IHsgZXJyb3IgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGkyW1wicmV0dXJuXCJdKSlcbiAgICAgICAgICAgICAgbS5jYWxsKGkyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcjtcbiAgICAgIH07XG4gICAgICBfX3NwcmVhZDMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaTIgPSAwOyBpMiA8IGFyZ3VtZW50cy5sZW5ndGg7IGkyKyspXG4gICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkMyhhcmd1bWVudHNbaTJdKSk7XG4gICAgICAgIHJldHVybiBhcjtcbiAgICAgIH07XG4gICAgICBfX3NwcmVhZEFycmF5czMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkyID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpMiA8IGlsOyBpMisrKVxuICAgICAgICAgIHMgKz0gYXJndW1lbnRzW2kyXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgazIgPSAwLCBpMiA9IDA7IGkyIDwgaWw7IGkyKyspXG4gICAgICAgICAgZm9yICh2YXIgYTIgPSBhcmd1bWVudHNbaTJdLCBqID0gMCwgamwgPSBhMi5sZW5ndGg7IGogPCBqbDsgaisrLCBrMisrKVxuICAgICAgICAgICAgcltrMl0gPSBhMltqXTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgICAgX19zcHJlYWRBcnJheTMgPSBmdW5jdGlvbih0bywgZnJvbSwgcGFjaykge1xuICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgICAgIGZvciAodmFyIGkyID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaTIgPCBsOyBpMisrKSB7XG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpMiBpbiBmcm9tKSkge1xuICAgICAgICAgICAgICBpZiAoIWFyKVxuICAgICAgICAgICAgICAgIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaTIpO1xuICAgICAgICAgICAgICBhcltpMl0gPSBmcm9tW2kyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xuICAgICAgfTtcbiAgICAgIF9fYXdhaXQzID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQzID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQzKHYpO1xuICAgICAgfTtcbiAgICAgIF9fYXN5bmNHZW5lcmF0b3IzID0gZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgdmFyIGcyID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpMiwgcSA9IFtdO1xuICAgICAgICByZXR1cm4gaTIgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaTJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGkyO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICBpZiAoZzJbbl0pXG4gICAgICAgICAgICBpMltuXSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGEyLCBiMikge1xuICAgICAgICAgICAgICAgIHEucHVzaChbbiwgdiwgYTIsIGIyXSkgPiAxIHx8IHJlc3VtZShuLCB2KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZzJbbl0odikpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHNldHRsZShxWzBdWzNdLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7XG4gICAgICAgICAgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQzID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICAgICAgICByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHtcbiAgICAgICAgICByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYyLCB2KSB7XG4gICAgICAgICAgaWYgKGYyKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKVxuICAgICAgICAgICAgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19hc3luY0RlbGVnYXRvcjMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBpMiwgcDI7XG4gICAgICAgIHJldHVybiBpMiA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KSwgdmVyYihcInJldHVyblwiKSwgaTJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBpMjtcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmMikge1xuICAgICAgICAgIGkyW25dID0gb1tuXSA/IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiAocDIgPSAhcDIpID8geyB2YWx1ZTogX19hd2FpdDMob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYyID8gZjIodikgOiB2O1xuICAgICAgICAgIH0gOiBmMjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fYXN5bmNWYWx1ZXMzID0gZnVuY3Rpb24obykge1xuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGkyO1xuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzMyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkyID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGkyW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBpMik7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICAgIGkyW25dID0gb1tuXSAmJiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkMiwgdikge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYyKSB7XG4gICAgICAgICAgICByZXNvbHZlKHsgdmFsdWU6IHYyLCBkb25lOiBkMiB9KTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19tYWtlVGVtcGxhdGVPYmplY3QzID0gZnVuY3Rpb24oY29va2VkLCByYXcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb29rZWQucmF3ID0gcmF3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29rZWQ7XG4gICAgICB9O1xuICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbihvLCB2KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbiAgICAgIH0gOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgIH07XG4gICAgICBfX2ltcG9ydFN0YXIzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBrMiBpbiBtb2QpXG4gICAgICAgICAgICBpZiAoazIgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGsyKSlcbiAgICAgICAgICAgICAgX19jcmVhdGVCaW5kaW5nMyhyZXN1bHQsIG1vZCwgazIpO1xuICAgICAgICB9XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX19pbXBvcnREZWZhdWx0MyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG4gICAgICB9O1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldDMgPSBmdW5jdGlvbihyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYyKSB7XG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZjIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmMiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYyIDoga2luZCA9PT0gXCJhXCIgPyBmMi5jYWxsKHJlY2VpdmVyKSA6IGYyID8gZjIudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xuICAgICAgfTtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQzID0gZnVuY3Rpb24ocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZjIpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwibVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZjIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmMiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwiYVwiID8gZjIuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZjIgPyBmMi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSksIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRJbjMgPSBmdW5jdGlvbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8IHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG4gICAgICB9O1xuICAgICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzMyk7XG4gICAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduMyk7XG4gICAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlMyk7XG4gICAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbTMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyMyk7XG4gICAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmczKTtcbiAgICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19yZWFkXCIsIF9fcmVhZDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5c1wiLCBfX3NwcmVhZEFycmF5czMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5XCIsIF9fc3ByZWFkQXJyYXkzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0Myk7XG4gICAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzMyk7XG4gICAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0Myk7XG4gICAgICBleHBvcnRlcihcIl9faW1wb3J0U3RhclwiLCBfX2ltcG9ydFN0YXIzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZFNldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0Myk7XG4gICAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRJblwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4zKTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9tZXNoZ3JhZC9kaXN0L2luZGV4Lm1qc1xudmFyIGkgPSAoKSA9PiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAzNjApO1xudmFyIGMgPSAobikgPT4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKG4gKiAxMDApICUgMTAwKTtcbnZhciBnID0gKG4sIHQsIGUpID0+IE1hdGgucm91bmQodCAvIGUgKiAobiAqIDEwMCkgJSAxMDApO1xudmFyIGQgPSAobikgPT4ge1xuICBpZiAoISFuKSB7XG4gICAgbiA9IG4ucmVwbGFjZSgvIy9nLCBcIlwiKSwgbi5sZW5ndGggPT09IDMgJiYgKG4gPSBuLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihiMikge1xuICAgICAgcmV0dXJuIGIyICsgYjI7XG4gICAgfSkuam9pbihcIlwiKSk7XG4gICAgdmFyIHQgPSAvXihbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KVtcXGRhLXpdezAsMH0kL2kuZXhlYyhuKTtcbiAgICBpZiAoISF0KSB7XG4gICAgICB2YXIgZSA9IHBhcnNlSW50KHRbMV0sIDE2KSwgciA9IHBhcnNlSW50KHRbMl0sIDE2KSwgYTIgPSBwYXJzZUludCh0WzNdLCAxNik7XG4gICAgICBlIC89IDI1NSwgciAvPSAyNTUsIGEyIC89IDI1NTtcbiAgICAgIHZhciBvID0gTWF0aC5tYXgoZSwgciwgYTIpLCBzID0gTWF0aC5taW4oZSwgciwgYTIpLCB1ID0gKG8gKyBzKSAvIDI7XG4gICAgICBpZiAobyA9PSBzKVxuICAgICAgICB1ID0gMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgbSA9IG8gLSBzO1xuICAgICAgICBzd2l0Y2ggKG8pIHtcbiAgICAgICAgICBjYXNlIGU6XG4gICAgICAgICAgICB1ID0gKHIgLSBhMikgLyBtICsgKHIgPCBhMiA/IDYgOiAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcjpcbiAgICAgICAgICAgIHUgPSAoYTIgLSBlKSAvIG0gKyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhMjpcbiAgICAgICAgICAgIHUgPSAoZSAtIHIpIC8gbSArIDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB1IC89IDY7XG4gICAgICB9XG4gICAgICByZXR1cm4gdSA9IE1hdGgucm91bmQoMzYwICogdSksIHU7XG4gICAgfVxuICB9XG59O1xudmFyIHAgPSAobiwgdCkgPT4gQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAoZSwgcikgPT4gciA9PT0gMCA/IGBoc2woJHt0fSwgMTAwJSwgODAlKWAgOiByIDwgbiAvIDEuNCA/IGBoc2woJHt0IC0gMzAgKiAoMSAtIDIgKiAociAlIDIpKSAqIChyID4gMiA/IHIgLyAyIDogcil9LCAxMDAlLCAkezc2IC0gciAqICgxIC0gMiAqIChyICUgMikpICogMS43NX0lKWAgOiBgaHNsKCR7dCAtIDE1MCAqICgxIC0gMiAqIChyICUgMikpfSwgMTAwJSwgJHs3NiAtIHIgKiAoMSAtIDIgKiAociAlIDIpKSAqIDEuMjV9JSlgKTtcbnZhciBNID0gKG4sIHQsIGUpID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IG4gfSwgKHIsIGEyKSA9PiBgcmFkaWFsLWdyYWRpZW50KGF0ICR7ZSA/IGcoYTIsIGUsIG4pIDogYyhhMil9JSAke2UgPyBnKGEyICogMTAsIGUsIG4pIDogYyhhMiAqIDEwKX0lLCAke3RbYTJdfSAwcHgsIHRyYW5zcGFyZW50IDUwJSlcbmApO1xudmFyIGYgPSAobiwgdCwgZSkgPT4ge1xuICBsZXQgciA9IHAobiwgdCB8fCBpKCkpLCBhMiA9IE0obiwgciwgZSB8fCB2b2lkIDApO1xuICByZXR1cm4gW3JbMF0sIGEyLmpvaW4oXCIsXCIpXTtcbn07XG52YXIgayA9IChuLCB0LCBlKSA9PiB7XG4gIGxldCBbciwgYTJdID0gZihuLCBkKHQpID8gZCh0KSA6IHZvaWQgMCwgZSB8fCB2b2lkIDApO1xuICByZXR1cm4geyBiYWNrZ3JvdW5kQ29sb3I6IHIsIGJhY2tncm91bmRJbWFnZTogYTIgfTtcbn07XG5cbi8vIHNyYy9WZXJzaW9uLnRzeFxuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRUxFTUVOVFMgPSA4O1xudmFyIFZlcnNpb24gPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiYnV0dG9uXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibS0yIGhpZGRlbiByb3VuZGVkLWZ1bGwgcHktMiBweC00IHRleHQteHMgZm9udC1ib2xkIHRleHQtYmxhY2sgc2hhZG93LW1kIGhvdmVyOnNoYWRvdy14bCBtZDpibG9ja1wiLFxuICAgIHN0eWxlOiBrKEVMRU1FTlRTKSxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcImFcIiwge1xuICAgICAgaHJlZjogXCJodHRwOi8vZ2l0aHViLmNvbS9taWd1ZWxnYXJnYWxsby9uZXh0MTMtZ2FsbGVyeS1pbWFnZS10dXJib1wiLFxuICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgIGNoaWxkcmVuOiBcInYxLjAuMlwiXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9pbmRleC5tanNcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29uZmlnQ29udGV4dC5tanNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBNb3Rpb25Db25maWdDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gIHRyYW5zZm9ybVBhZ2VQb2ludDogKHAyKSA9PiBwMixcbiAgaXNTdGF0aWM6IGZhbHNlLFxuICByZWR1Y2VkTW90aW9uOiBcIm5ldmVyXCJcbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29udGV4dC9pbmRleC5tanNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIsIHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBNb3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDIoe30pO1xuZnVuY3Rpb24gdXNlVmlzdWFsRWxlbWVudENvbnRleHQoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KE1vdGlvbkNvbnRleHQpLnZpc3VhbEVsZW1lbnQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3VzZS12aXN1YWwtZWxlbWVudC5tanNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIsIHVzZVJlZiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L1ByZXNlbmNlQ29udGV4dC5tanNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBQcmVzZW5jZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MyhudWxsKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtaXNvbW9ycGhpYy1lZmZlY3QubWpzXG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLWJyb3dzZXIubWpzXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1pc29tb3JwaGljLWVmZmVjdC5tanNcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gaXNCcm93c2VyID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTGF6eUNvbnRleHQubWpzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTGF6eUNvbnRleHQgPSBjcmVhdGVDb250ZXh0NCh7IHN0cmljdDogZmFsc2UgfSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3VzZS12aXN1YWwtZWxlbWVudC5tanNcbmZ1bmN0aW9uIHVzZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50LCB2aXN1YWxTdGF0ZSwgcHJvcHMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQpIHtcbiAgY29uc3QgcGFyZW50ID0gdXNlVmlzdWFsRWxlbWVudENvbnRleHQoKTtcbiAgY29uc3QgbGF6eUNvbnRleHQgPSB1c2VDb250ZXh0MihMYXp5Q29udGV4dCk7XG4gIGNvbnN0IHByZXNlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQyKFByZXNlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHJlZHVjZWRNb3Rpb25Db25maWcgPSB1c2VDb250ZXh0MihNb3Rpb25Db25maWdDb250ZXh0KS5yZWR1Y2VkTW90aW9uO1xuICBjb25zdCB2aXN1YWxFbGVtZW50UmVmID0gdXNlUmVmKCk7XG4gIGNyZWF0ZVZpc3VhbEVsZW1lbnQgPSBjcmVhdGVWaXN1YWxFbGVtZW50IHx8IGxhenlDb250ZXh0LnJlbmRlcmVyO1xuICBpZiAoIXZpc3VhbEVsZW1lbnRSZWYuY3VycmVudCAmJiBjcmVhdGVWaXN1YWxFbGVtZW50KSB7XG4gICAgdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50ID0gY3JlYXRlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgIHZpc3VhbFN0YXRlLFxuICAgICAgcGFyZW50LFxuICAgICAgcHJvcHMsXG4gICAgICBwcmVzZW5jZUlkOiBwcmVzZW5jZUNvbnRleHQgPyBwcmVzZW5jZUNvbnRleHQuaWQgOiB2b2lkIDAsXG4gICAgICBibG9ja0luaXRpYWxBbmltYXRpb246IHByZXNlbmNlQ29udGV4dCA/IHByZXNlbmNlQ29udGV4dC5pbml0aWFsID09PSBmYWxzZSA6IGZhbHNlLFxuICAgICAgcmVkdWNlZE1vdGlvbkNvbmZpZ1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHZpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQ7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZpc3VhbEVsZW1lbnQgJiYgdmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgfSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGlmICh2aXN1YWxFbGVtZW50ICYmIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuYW5pbWF0ZUNoYW5nZXMoKTtcbiAgICB9XG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+ICgpID0+IHZpc3VhbEVsZW1lbnQgJiYgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJVbm1vdW50XCIpLCBbXSk7XG4gIHJldHVybiB2aXN1YWxFbGVtZW50O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtbW90aW9uLXJlZi5tanNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtcmVmLW9iamVjdC5tanNcbmZ1bmN0aW9uIGlzUmVmT2JqZWN0KHJlZikge1xuICByZXR1cm4gdHlwZW9mIHJlZiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVmLCBcImN1cnJlbnRcIik7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3VzZS1tb3Rpb24tcmVmLm1qc1xuZnVuY3Rpb24gdXNlTW90aW9uUmVmKHZpc3VhbFN0YXRlLCB2aXN1YWxFbGVtZW50LCBleHRlcm5hbFJlZikge1xuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgKGluc3RhbmNlKSA9PiB7XG4gICAgICBpbnN0YW5jZSAmJiB2aXN1YWxTdGF0ZS5tb3VudCAmJiB2aXN1YWxTdGF0ZS5tb3VudChpbnN0YW5jZSk7XG4gICAgICBpZiAodmlzdWFsRWxlbWVudCkge1xuICAgICAgICBpbnN0YW5jZSA/IHZpc3VhbEVsZW1lbnQubW91bnQoaW5zdGFuY2UpIDogdmlzdWFsRWxlbWVudC51bm1vdW50KCk7XG4gICAgICB9XG4gICAgICBpZiAoZXh0ZXJuYWxSZWYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHRlcm5hbFJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZXh0ZXJuYWxSZWYoaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVmT2JqZWN0KGV4dGVybmFsUmVmKSkge1xuICAgICAgICAgIGV4dGVybmFsUmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW3Zpc3VhbEVsZW1lbnRdXG4gICk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db250ZXh0L2NyZWF0ZS5tanNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDMsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvaXMtdmFyaWFudC1sYWJlbC5tanNcbmZ1bmN0aW9uIGlzVmFyaWFudExhYmVsKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkodik7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGlvbi1jb250cm9scy5tanNcbmZ1bmN0aW9uIGlzQW5pbWF0aW9uQ29udHJvbHModikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHYuc3RhcnQgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvaXMtY29udHJvbGxpbmctdmFyaWFudHMubWpzXG52YXIgdmFyaWFudFByb3BzID0gW1xuICBcImluaXRpYWxcIixcbiAgXCJhbmltYXRlXCIsXG4gIFwiZXhpdFwiLFxuICBcIndoaWxlSG92ZXJcIixcbiAgXCJ3aGlsZURyYWdcIixcbiAgXCJ3aGlsZVRhcFwiLFxuICBcIndoaWxlRm9jdXNcIixcbiAgXCJ3aGlsZUluVmlld1wiXG5dO1xuZnVuY3Rpb24gaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSB7XG4gIHJldHVybiBpc0FuaW1hdGlvbkNvbnRyb2xzKHByb3BzLmFuaW1hdGUpIHx8IHZhcmlhbnRQcm9wcy5zb21lKChuYW1lKSA9PiBpc1ZhcmlhbnRMYWJlbChwcm9wc1tuYW1lXSkpO1xufVxuZnVuY3Rpb24gaXNWYXJpYW50Tm9kZShwcm9wcykge1xuICByZXR1cm4gQm9vbGVhbihpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpIHx8IHByb3BzLnZhcmlhbnRzKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbnRleHQvdXRpbHMubWpzXG5mdW5jdGlvbiBnZXRDdXJyZW50VHJlZVZhcmlhbnRzKHByb3BzLCBjb250ZXh0KSB7XG4gIGlmIChpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpKSB7XG4gICAgY29uc3QgeyBpbml0aWFsLCBhbmltYXRlOiBhbmltYXRlMyB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXRpYWw6IGluaXRpYWwgPT09IGZhbHNlIHx8IGlzVmFyaWFudExhYmVsKGluaXRpYWwpID8gaW5pdGlhbCA6IHZvaWQgMCxcbiAgICAgIGFuaW1hdGU6IGlzVmFyaWFudExhYmVsKGFuaW1hdGUzKSA/IGFuaW1hdGUzIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcHJvcHMuaW5oZXJpdCAhPT0gZmFsc2UgPyBjb250ZXh0IDoge307XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db250ZXh0L2NyZWF0ZS5tanNcbmZ1bmN0aW9uIHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQocHJvcHMpIHtcbiAgY29uc3QgeyBpbml0aWFsLCBhbmltYXRlOiBhbmltYXRlMyB9ID0gZ2V0Q3VycmVudFRyZWVWYXJpYW50cyhwcm9wcywgdXNlQ29udGV4dDMoTW90aW9uQ29udGV4dCkpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiAoeyBpbml0aWFsLCBhbmltYXRlOiBhbmltYXRlMyB9KSwgW3ZhcmlhbnRMYWJlbHNBc0RlcGVuZGVuY3koaW5pdGlhbCksIHZhcmlhbnRMYWJlbHNBc0RlcGVuZGVuY3koYW5pbWF0ZTMpXSk7XG59XG5mdW5jdGlvbiB2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KHByb3ApIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocHJvcCkgPyBwcm9wLmpvaW4oXCIgXCIpIDogcHJvcDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvZGVmaW5pdGlvbnMubWpzXG52YXIgY3JlYXRlRGVmaW5pdGlvbiA9IChwcm9wTmFtZXMpID0+ICh7XG4gIGlzRW5hYmxlZDogKHByb3BzKSA9PiBwcm9wTmFtZXMuc29tZSgobmFtZSkgPT4gISFwcm9wc1tuYW1lXSlcbn0pO1xudmFyIGZlYXR1cmVEZWZpbml0aW9ucyA9IHtcbiAgbWVhc3VyZUxheW91dDogY3JlYXRlRGVmaW5pdGlvbihbXCJsYXlvdXRcIiwgXCJsYXlvdXRJZFwiLCBcImRyYWdcIl0pLFxuICBhbmltYXRpb246IGNyZWF0ZURlZmluaXRpb24oW1xuICAgIFwiYW5pbWF0ZVwiLFxuICAgIFwiZXhpdFwiLFxuICAgIFwidmFyaWFudHNcIixcbiAgICBcIndoaWxlSG92ZXJcIixcbiAgICBcIndoaWxlVGFwXCIsXG4gICAgXCJ3aGlsZUZvY3VzXCIsXG4gICAgXCJ3aGlsZURyYWdcIixcbiAgICBcIndoaWxlSW5WaWV3XCJcbiAgXSksXG4gIGV4aXQ6IGNyZWF0ZURlZmluaXRpb24oW1wiZXhpdFwiXSksXG4gIGRyYWc6IGNyZWF0ZURlZmluaXRpb24oW1wiZHJhZ1wiLCBcImRyYWdDb250cm9sc1wiXSksXG4gIGZvY3VzOiBjcmVhdGVEZWZpbml0aW9uKFtcIndoaWxlRm9jdXNcIl0pLFxuICBob3ZlcjogY3JlYXRlRGVmaW5pdGlvbihbXCJ3aGlsZUhvdmVyXCIsIFwib25Ib3ZlclN0YXJ0XCIsIFwib25Ib3ZlckVuZFwiXSksXG4gIHRhcDogY3JlYXRlRGVmaW5pdGlvbihbXCJ3aGlsZVRhcFwiLCBcIm9uVGFwXCIsIFwib25UYXBTdGFydFwiLCBcIm9uVGFwQ2FuY2VsXCJdKSxcbiAgcGFuOiBjcmVhdGVEZWZpbml0aW9uKFtcbiAgICBcIm9uUGFuXCIsXG4gICAgXCJvblBhblN0YXJ0XCIsXG4gICAgXCJvblBhblNlc3Npb25TdGFydFwiLFxuICAgIFwib25QYW5FbmRcIlxuICBdKSxcbiAgaW5WaWV3OiBjcmVhdGVEZWZpbml0aW9uKFtcbiAgICBcIndoaWxlSW5WaWV3XCIsXG4gICAgXCJvblZpZXdwb3J0RW50ZXJcIixcbiAgICBcIm9uVmlld3BvcnRMZWF2ZVwiXG4gIF0pXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9sb2FkLWZlYXR1cmVzLm1qc1xuZnVuY3Rpb24gbG9hZEZlYXR1cmVzKGZlYXR1cmVzKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIGZlYXR1cmVzKSB7XG4gICAgaWYgKGtleSA9PT0gXCJwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yXCIpIHtcbiAgICAgIGZlYXR1cmVEZWZpbml0aW9ucy5wcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yID0gZmVhdHVyZXNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmVhdHVyZURlZmluaXRpb25zW2tleV0uQ29tcG9uZW50ID0gZmVhdHVyZXNba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtY29uc3RhbnQubWpzXG5pbXBvcnQgeyB1c2VSZWYgYXMgdXNlUmVmMiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlQ29uc3RhbnQoaW5pdCkge1xuICBjb25zdCByZWYgPSB1c2VSZWYyKG51bGwpO1xuICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICByZWYuY3VycmVudCA9IGluaXQoKTtcbiAgfVxuICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL3N0YXRlLm1qc1xudmFyIGdsb2JhbFByb2plY3Rpb25TdGF0ZSA9IHtcbiAgaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZTogdHJ1ZSxcbiAgaGFzRXZlclVwZGF0ZWQ6IGZhbHNlXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9pZC5tanNcbnZhciBpZCA9IDE7XG5mdW5jdGlvbiB1c2VQcm9qZWN0aW9uSWQoKSB7XG4gIHJldHVybiB1c2VDb25zdGFudCgoKSA9PiB7XG4gICAgaWYgKGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNFdmVyVXBkYXRlZCkge1xuICAgICAgcmV0dXJuIGlkKys7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L0xheW91dEdyb3VwQ29udGV4dC5tanNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDUgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBMYXlvdXRHcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0NSh7fSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL1Zpc3VhbEVsZW1lbnRIYW5kbGVyLm1qc1xuaW1wb3J0IFJlYWN0X19kZWZhdWx0IGZyb20gXCJyZWFjdFwiO1xudmFyIFZpc3VhbEVsZW1lbnRIYW5kbGVyID0gY2xhc3MgZXh0ZW5kcyBSZWFjdF9fZGVmYXVsdC5Db21wb25lbnQge1xuICBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHtcbiAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQsIHByb3BzIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICh2aXN1YWxFbGVtZW50KVxuICAgICAgdmlzdWFsRWxlbWVudC5zZXRQcm9wcyhwcm9wcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L1N3aXRjaExheW91dEdyb3VwQ29udGV4dC5tanNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDYgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0Nih7fSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3N5bWJvbC5tanNcbnZhciBtb3Rpb25Db21wb25lbnRTeW1ib2wgPSBTeW1ib2wuZm9yKFwibW90aW9uQ29tcG9uZW50U3ltYm9sXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9pbmRleC5tanNcbmZ1bmN0aW9uIGNyZWF0ZU1vdGlvbkNvbXBvbmVudCh7IHByZWxvYWRlZEZlYXR1cmVzLCBjcmVhdGVWaXN1YWxFbGVtZW50LCBwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yLCB1c2VSZW5kZXIsIHVzZVZpc3VhbFN0YXRlLCBDb21wb25lbnQgfSkge1xuICBwcmVsb2FkZWRGZWF0dXJlcyAmJiBsb2FkRmVhdHVyZXMocHJlbG9hZGVkRmVhdHVyZXMpO1xuICBmdW5jdGlvbiBNb3Rpb25Db21wb25lbnQocHJvcHMsIGV4dGVybmFsUmVmKSB7XG4gICAgY29uc3QgY29uZmlnQW5kUHJvcHMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB1c2VDb250ZXh0NChNb3Rpb25Db25maWdDb250ZXh0KSksIHByb3BzKSwge1xuICAgICAgbGF5b3V0SWQ6IHVzZUxheW91dElkKHByb3BzKVxuICAgIH0pO1xuICAgIGNvbnN0IHsgaXNTdGF0aWMgfSA9IGNvbmZpZ0FuZFByb3BzO1xuICAgIGxldCBmZWF0dXJlcyA9IG51bGw7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQocHJvcHMpO1xuICAgIGNvbnN0IHByb2plY3Rpb25JZCA9IGlzU3RhdGljID8gdm9pZCAwIDogdXNlUHJvamVjdGlvbklkKCk7XG4gICAgY29uc3QgdmlzdWFsU3RhdGUgPSB1c2VWaXN1YWxTdGF0ZShwcm9wcywgaXNTdGF0aWMpO1xuICAgIGlmICghaXNTdGF0aWMgJiYgaXNCcm93c2VyKSB7XG4gICAgICBjb250ZXh0LnZpc3VhbEVsZW1lbnQgPSB1c2VWaXN1YWxFbGVtZW50KENvbXBvbmVudCwgdmlzdWFsU3RhdGUsIGNvbmZpZ0FuZFByb3BzLCBjcmVhdGVWaXN1YWxFbGVtZW50KTtcbiAgICAgIGNvbnN0IGxhenlTdHJpY3RNb2RlID0gdXNlQ29udGV4dDQoTGF6eUNvbnRleHQpLnN0cmljdDtcbiAgICAgIGNvbnN0IGluaXRpYWxMYXlvdXRHcm91cENvbmZpZyA9IHVzZUNvbnRleHQ0KFN3aXRjaExheW91dEdyb3VwQ29udGV4dCk7XG4gICAgICBpZiAoY29udGV4dC52aXN1YWxFbGVtZW50KSB7XG4gICAgICAgIGZlYXR1cmVzID0gY29udGV4dC52aXN1YWxFbGVtZW50LmxvYWRGZWF0dXJlcyhcbiAgICAgICAgICBjb25maWdBbmRQcm9wcyxcbiAgICAgICAgICBsYXp5U3RyaWN0TW9kZSxcbiAgICAgICAgICBwcmVsb2FkZWRGZWF0dXJlcyxcbiAgICAgICAgICBwcm9qZWN0aW9uSWQsXG4gICAgICAgICAgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciB8fCBmZWF0dXJlRGVmaW5pdGlvbnMucHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvcixcbiAgICAgICAgICBpbml0aWFsTGF5b3V0R3JvdXBDb25maWdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBWaXN1YWxFbGVtZW50SGFuZGxlcixcbiAgICAgIHsgdmlzdWFsRWxlbWVudDogY29udGV4dC52aXN1YWxFbGVtZW50LCBwcm9wczogY29uZmlnQW5kUHJvcHMgfSxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNb3Rpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIHVzZVJlbmRlcihDb21wb25lbnQsIHByb3BzLCBwcm9qZWN0aW9uSWQsIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgY29udGV4dC52aXN1YWxFbGVtZW50LCBleHRlcm5hbFJlZiksIHZpc3VhbFN0YXRlLCBpc1N0YXRpYywgY29udGV4dC52aXN1YWxFbGVtZW50KSlcbiAgICApO1xuICB9XG4gIGNvbnN0IEZvcndhcmRSZWZDb21wb25lbnQgPSBmb3J3YXJkUmVmKE1vdGlvbkNvbXBvbmVudCk7XG4gIEZvcndhcmRSZWZDb21wb25lbnRbbW90aW9uQ29tcG9uZW50U3ltYm9sXSA9IENvbXBvbmVudDtcbiAgcmV0dXJuIEZvcndhcmRSZWZDb21wb25lbnQ7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRJZCh7IGxheW91dElkIH0pIHtcbiAgY29uc3QgbGF5b3V0R3JvdXBJZCA9IHVzZUNvbnRleHQ0KExheW91dEdyb3VwQ29udGV4dCkuaWQ7XG4gIHJldHVybiBsYXlvdXRHcm91cElkICYmIGxheW91dElkICE9PSB2b2lkIDAgPyBsYXlvdXRHcm91cElkICsgXCItXCIgKyBsYXlvdXRJZCA6IGxheW91dElkO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vbW90aW9uLXByb3h5Lm1qc1xuZnVuY3Rpb24gY3JlYXRlTW90aW9uUHJveHkoY3JlYXRlQ29uZmlnKSB7XG4gIGZ1bmN0aW9uIGN1c3RvbShDb21wb25lbnQsIGN1c3RvbU1vdGlvbkNvbXBvbmVudENvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU1vdGlvbkNvbXBvbmVudChjcmVhdGVDb25maWcoQ29tcG9uZW50LCBjdXN0b21Nb3Rpb25Db21wb25lbnRDb25maWcpKTtcbiAgfVxuICBpZiAodHlwZW9mIFByb3h5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGN1c3RvbTtcbiAgfVxuICBjb25zdCBjb21wb25lbnRDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiBuZXcgUHJveHkoY3VzdG9tLCB7XG4gICAgZ2V0OiAoX3RhcmdldCwga2V5KSA9PiB7XG4gICAgICBpZiAoIWNvbXBvbmVudENhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbXBvbmVudENhY2hlLnNldChrZXksIGN1c3RvbShrZXkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wb25lbnRDYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvbG93ZXJjYXNlLWVsZW1lbnRzLm1qc1xudmFyIGxvd2VyY2FzZVNWR0VsZW1lbnRzID0gW1xuICBcImFuaW1hdGVcIixcbiAgXCJjaXJjbGVcIixcbiAgXCJkZWZzXCIsXG4gIFwiZGVzY1wiLFxuICBcImVsbGlwc2VcIixcbiAgXCJnXCIsXG4gIFwiaW1hZ2VcIixcbiAgXCJsaW5lXCIsXG4gIFwiZmlsdGVyXCIsXG4gIFwibWFya2VyXCIsXG4gIFwibWFza1wiLFxuICBcIm1ldGFkYXRhXCIsXG4gIFwicGF0aFwiLFxuICBcInBhdHRlcm5cIixcbiAgXCJwb2x5Z29uXCIsXG4gIFwicG9seWxpbmVcIixcbiAgXCJyZWN0XCIsXG4gIFwic3RvcFwiLFxuICBcInN2Z1wiLFxuICBcInN3aXRjaFwiLFxuICBcInN5bWJvbFwiLFxuICBcInRleHRcIixcbiAgXCJ0c3BhblwiLFxuICBcInVzZVwiLFxuICBcInZpZXdcIlxuXTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2lzLXN2Zy1jb21wb25lbnQubWpzXG5mdW5jdGlvbiBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgIT09IFwic3RyaW5nXCIgfHwgQ29tcG9uZW50LmluY2x1ZGVzKFwiLVwiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChsb3dlcmNhc2VTVkdFbGVtZW50cy5pbmRleE9mKENvbXBvbmVudCkgPiAtMSB8fCAvW0EtWl0vLnRlc3QoQ29tcG9uZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3VzZS1yZW5kZXIubWpzXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQyIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXNlLXByb3BzLm1qc1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vMiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWNvcnJlY3Rpb24ubWpzXG52YXIgc2NhbGVDb3JyZWN0b3JzID0ge307XG5mdW5jdGlvbiBhZGRTY2FsZUNvcnJlY3Rvcihjb3JyZWN0b3JzKSB7XG4gIE9iamVjdC5hc3NpZ24oc2NhbGVDb3JyZWN0b3JzLCBjb3JyZWN0b3JzKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy90cmFuc2Zvcm0ubWpzXG52YXIgdHJhbnNmb3JtUHJvcE9yZGVyID0gW1xuICBcInRyYW5zZm9ybVBlcnNwZWN0aXZlXCIsXG4gIFwieFwiLFxuICBcInlcIixcbiAgXCJ6XCIsXG4gIFwidHJhbnNsYXRlWFwiLFxuICBcInRyYW5zbGF0ZVlcIixcbiAgXCJ0cmFuc2xhdGVaXCIsXG4gIFwic2NhbGVcIixcbiAgXCJzY2FsZVhcIixcbiAgXCJzY2FsZVlcIixcbiAgXCJyb3RhdGVcIixcbiAgXCJyb3RhdGVYXCIsXG4gIFwicm90YXRlWVwiLFxuICBcInJvdGF0ZVpcIixcbiAgXCJza2V3XCIsXG4gIFwic2tld1hcIixcbiAgXCJza2V3WVwiXG5dO1xudmFyIHRyYW5zZm9ybVByb3BzID0gbmV3IFNldCh0cmFuc2Zvcm1Qcm9wT3JkZXIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9pcy1mb3JjZWQtbW90aW9uLXZhbHVlLm1qc1xuZnVuY3Rpb24gaXNGb3JjZWRNb3Rpb25WYWx1ZShrZXksIHsgbGF5b3V0LCBsYXlvdXRJZCB9KSB7XG4gIHJldHVybiB0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSB8fCBrZXkuc3RhcnRzV2l0aChcIm9yaWdpblwiKSB8fCAobGF5b3V0IHx8IGxheW91dElkICE9PSB2b2lkIDApICYmICghIXNjYWxlQ29ycmVjdG9yc1trZXldIHx8IGtleSA9PT0gXCJvcGFjaXR5XCIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanNcbnZhciBpc01vdGlvblZhbHVlID0gKHZhbHVlKSA9PiAhISh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuZ2V0VmVsb2NpdHkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL2J1aWxkLXRyYW5zZm9ybS5tanNcbnZhciB0cmFuc2xhdGVBbGlhcyA9IHtcbiAgeDogXCJ0cmFuc2xhdGVYXCIsXG4gIHk6IFwidHJhbnNsYXRlWVwiLFxuICB6OiBcInRyYW5zbGF0ZVpcIixcbiAgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IFwicGVyc3BlY3RpdmVcIlxufTtcbnZhciBzb3J0VHJhbnNmb3JtUHJvcHMgPSAoYTIsIGIyKSA9PiB0cmFuc2Zvcm1Qcm9wT3JkZXIuaW5kZXhPZihhMikgLSB0cmFuc2Zvcm1Qcm9wT3JkZXIuaW5kZXhPZihiMik7XG5mdW5jdGlvbiBidWlsZFRyYW5zZm9ybSh7IHRyYW5zZm9ybSwgdHJhbnNmb3JtS2V5czogdHJhbnNmb3JtS2V5czIgfSwgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbiA9IHRydWUsIGFsbG93VHJhbnNmb3JtTm9uZSA9IHRydWUgfSwgdHJhbnNmb3JtSXNEZWZhdWx0LCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICBsZXQgdHJhbnNmb3JtU3RyaW5nID0gXCJcIjtcbiAgdHJhbnNmb3JtS2V5czIuc29ydChzb3J0VHJhbnNmb3JtUHJvcHMpO1xuICBmb3IgKGNvbnN0IGtleSBvZiB0cmFuc2Zvcm1LZXlzMikge1xuICAgIHRyYW5zZm9ybVN0cmluZyArPSBgJHt0cmFuc2xhdGVBbGlhc1trZXldIHx8IGtleX0oJHt0cmFuc2Zvcm1ba2V5XX0pIGA7XG4gIH1cbiAgaWYgKGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uICYmICF0cmFuc2Zvcm0ueikge1xuICAgIHRyYW5zZm9ybVN0cmluZyArPSBcInRyYW5zbGF0ZVooMClcIjtcbiAgfVxuICB0cmFuc2Zvcm1TdHJpbmcgPSB0cmFuc2Zvcm1TdHJpbmcudHJpbSgpO1xuICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICB0cmFuc2Zvcm1TdHJpbmcgPSB0cmFuc2Zvcm1UZW1wbGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybUlzRGVmYXVsdCA/IFwiXCIgOiB0cmFuc2Zvcm1TdHJpbmcpO1xuICB9IGVsc2UgaWYgKGFsbG93VHJhbnNmb3JtTm9uZSAmJiB0cmFuc2Zvcm1Jc0RlZmF1bHQpIHtcbiAgICB0cmFuc2Zvcm1TdHJpbmcgPSBcIm5vbmVcIjtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtU3RyaW5nO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvaXMtY3NzLXZhcmlhYmxlLm1qc1xuZnVuY3Rpb24gaXNDU1NWYXJpYWJsZShrZXkpIHtcbiAgcmV0dXJuIGtleS5zdGFydHNXaXRoKFwiLS1cIik7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9nZXQtYXMtdHlwZS5tanNcbnZhciBnZXRWYWx1ZUFzVHlwZSA9ICh2YWx1ZSwgdHlwZSkgPT4ge1xuICByZXR1cm4gdHlwZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB0eXBlLnRyYW5zZm9ybSh2YWx1ZSkgOiB2YWx1ZTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL3V0aWxzLm1qc1xudmFyIGNsYW1wID0gKG1pbiwgbWF4KSA9PiAodikgPT4gTWF0aC5tYXgoTWF0aC5taW4odiwgbWF4KSwgbWluKTtcbnZhciBzYW5pdGl6ZSA9ICh2KSA9PiB2ICUgMSA/IE51bWJlcih2LnRvRml4ZWQoNSkpIDogdjtcbnZhciBmbG9hdFJlZ2V4ID0gLygtKT8oW1xcZF0qXFwuP1tcXGRdKSsvZztcbnZhciBjb2xvclJlZ2V4ID0gLygjWzAtOWEtZl17Nn18I1swLTlhLWZdezN9fCMoPzpbMC05YS1mXXsyfSl7Miw0fXwocmdifGhzbClhP1xcKCgtP1tcXGRcXC5dKyU/WyxcXHNdKyl7Mn0oLT9bXFxkXFwuXSslPylcXHMqW1xcLFxcL10/XFxzKltcXGRcXC5dKiU/XFwpKS9naTtcbnZhciBzaW5nbGVDb2xvclJlZ2V4ID0gL14oI1swLTlhLWZdezN9fCMoPzpbMC05YS1mXXsyfSl7Miw0fXwocmdifGhzbClhP1xcKCgtP1tcXGRcXC5dKyU/WyxcXHNdKyl7Mn0oLT9bXFxkXFwuXSslPylcXHMqW1xcLFxcL10/XFxzKltcXGRcXC5dKiU/XFwpKSQvaTtcbmZ1bmN0aW9uIGlzU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9udW1iZXJzL2luZGV4Lm1qc1xudmFyIG51bWJlciA9IHtcbiAgdGVzdDogKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiLFxuICBwYXJzZTogcGFyc2VGbG9hdCxcbiAgdHJhbnNmb3JtOiAodikgPT4gdlxufTtcbnZhciBhbHBoYSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyKSwgeyB0cmFuc2Zvcm06IGNsYW1wKDAsIDEpIH0pO1xudmFyIHNjYWxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBudW1iZXIpLCB7IGRlZmF1bHQ6IDEgfSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL251bWJlcnMvdW5pdHMubWpzXG52YXIgY3JlYXRlVW5pdFR5cGUgPSAodW5pdCkgPT4gKHtcbiAgdGVzdDogKHYpID0+IGlzU3RyaW5nKHYpICYmIHYuZW5kc1dpdGgodW5pdCkgJiYgdi5zcGxpdChcIiBcIikubGVuZ3RoID09PSAxLFxuICBwYXJzZTogcGFyc2VGbG9hdCxcbiAgdHJhbnNmb3JtOiAodikgPT4gYCR7dn0ke3VuaXR9YFxufSk7XG52YXIgZGVncmVlcyA9IGNyZWF0ZVVuaXRUeXBlKFwiZGVnXCIpO1xudmFyIHBlcmNlbnQgPSBjcmVhdGVVbml0VHlwZShcIiVcIik7XG52YXIgcHggPSBjcmVhdGVVbml0VHlwZShcInB4XCIpO1xudmFyIHZoID0gY3JlYXRlVW5pdFR5cGUoXCJ2aFwiKTtcbnZhciB2dyA9IGNyZWF0ZVVuaXRUeXBlKFwidndcIik7XG52YXIgcHJvZ3Jlc3NQZXJjZW50YWdlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwZXJjZW50KSwgeyBwYXJzZTogKHYpID0+IHBlcmNlbnQucGFyc2UodikgLyAxMDAsIHRyYW5zZm9ybTogKHYpID0+IHBlcmNlbnQudHJhbnNmb3JtKHYgKiAxMDApIH0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci91dGlscy5tanNcbnZhciBpc0NvbG9yU3RyaW5nID0gKHR5cGUsIHRlc3RQcm9wKSA9PiAodikgPT4ge1xuICByZXR1cm4gQm9vbGVhbihpc1N0cmluZyh2KSAmJiBzaW5nbGVDb2xvclJlZ2V4LnRlc3QodikgJiYgdi5zdGFydHNXaXRoKHR5cGUpIHx8IHRlc3RQcm9wICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2LCB0ZXN0UHJvcCkpO1xufTtcbnZhciBzcGxpdENvbG9yID0gKGFOYW1lLCBiTmFtZSwgY05hbWUpID0+ICh2KSA9PiB7XG4gIGlmICghaXNTdHJpbmcodikpXG4gICAgcmV0dXJuIHY7XG4gIGNvbnN0IFthMiwgYjIsIGMzLCBhbHBoYTJdID0gdi5tYXRjaChmbG9hdFJlZ2V4KTtcbiAgcmV0dXJuIHtcbiAgICBbYU5hbWVdOiBwYXJzZUZsb2F0KGEyKSxcbiAgICBbYk5hbWVdOiBwYXJzZUZsb2F0KGIyKSxcbiAgICBbY05hbWVdOiBwYXJzZUZsb2F0KGMzKSxcbiAgICBhbHBoYTogYWxwaGEyICE9PSB2b2lkIDAgPyBwYXJzZUZsb2F0KGFscGhhMikgOiAxXG4gIH07XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9oc2xhLm1qc1xudmFyIGhzbGEgPSB7XG4gIHRlc3Q6IGlzQ29sb3JTdHJpbmcoXCJoc2xcIiwgXCJodWVcIiksXG4gIHBhcnNlOiBzcGxpdENvbG9yKFwiaHVlXCIsIFwic2F0dXJhdGlvblwiLCBcImxpZ2h0bmVzc1wiKSxcbiAgdHJhbnNmb3JtOiAoeyBodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgYWxwaGE6IGFscGhhJDEgPSAxIH0pID0+IHtcbiAgICByZXR1cm4gXCJoc2xhKFwiICsgTWF0aC5yb3VuZChodWUpICsgXCIsIFwiICsgcGVyY2VudC50cmFuc2Zvcm0oc2FuaXRpemUoc2F0dXJhdGlvbikpICsgXCIsIFwiICsgcGVyY2VudC50cmFuc2Zvcm0oc2FuaXRpemUobGlnaHRuZXNzKSkgKyBcIiwgXCIgKyBzYW5pdGl6ZShhbHBoYS50cmFuc2Zvcm0oYWxwaGEkMSkpICsgXCIpXCI7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbG9yL3JnYmEubWpzXG52YXIgY2xhbXBSZ2JVbml0ID0gY2xhbXAoMCwgMjU1KTtcbnZhciByZ2JVbml0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBudW1iZXIpLCB7IHRyYW5zZm9ybTogKHYpID0+IE1hdGgucm91bmQoY2xhbXBSZ2JVbml0KHYpKSB9KTtcbnZhciByZ2JhID0ge1xuICB0ZXN0OiBpc0NvbG9yU3RyaW5nKFwicmdiXCIsIFwicmVkXCIpLFxuICBwYXJzZTogc3BsaXRDb2xvcihcInJlZFwiLCBcImdyZWVuXCIsIFwiYmx1ZVwiKSxcbiAgdHJhbnNmb3JtOiAoeyByZWQsIGdyZWVuLCBibHVlLCBhbHBoYTogYWxwaGEkMSA9IDEgfSkgPT4gXCJyZ2JhKFwiICsgcmdiVW5pdC50cmFuc2Zvcm0ocmVkKSArIFwiLCBcIiArIHJnYlVuaXQudHJhbnNmb3JtKGdyZWVuKSArIFwiLCBcIiArIHJnYlVuaXQudHJhbnNmb3JtKGJsdWUpICsgXCIsIFwiICsgc2FuaXRpemUoYWxwaGEudHJhbnNmb3JtKGFscGhhJDEpKSArIFwiKVwiXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9oZXgubWpzXG5mdW5jdGlvbiBwYXJzZUhleCh2KSB7XG4gIGxldCByID0gXCJcIjtcbiAgbGV0IGcyID0gXCJcIjtcbiAgbGV0IGIyID0gXCJcIjtcbiAgbGV0IGEyID0gXCJcIjtcbiAgaWYgKHYubGVuZ3RoID4gNSkge1xuICAgIHIgPSB2LnN1YnN0cigxLCAyKTtcbiAgICBnMiA9IHYuc3Vic3RyKDMsIDIpO1xuICAgIGIyID0gdi5zdWJzdHIoNSwgMik7XG4gICAgYTIgPSB2LnN1YnN0cig3LCAyKTtcbiAgfSBlbHNlIHtcbiAgICByID0gdi5zdWJzdHIoMSwgMSk7XG4gICAgZzIgPSB2LnN1YnN0cigyLCAxKTtcbiAgICBiMiA9IHYuc3Vic3RyKDMsIDEpO1xuICAgIGEyID0gdi5zdWJzdHIoNCwgMSk7XG4gICAgciArPSByO1xuICAgIGcyICs9IGcyO1xuICAgIGIyICs9IGIyO1xuICAgIGEyICs9IGEyO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVkOiBwYXJzZUludChyLCAxNiksXG4gICAgZ3JlZW46IHBhcnNlSW50KGcyLCAxNiksXG4gICAgYmx1ZTogcGFyc2VJbnQoYjIsIDE2KSxcbiAgICBhbHBoYTogYTIgPyBwYXJzZUludChhMiwgMTYpIC8gMjU1IDogMVxuICB9O1xufVxudmFyIGhleCA9IHtcbiAgdGVzdDogaXNDb2xvclN0cmluZyhcIiNcIiksXG4gIHBhcnNlOiBwYXJzZUhleCxcbiAgdHJhbnNmb3JtOiByZ2JhLnRyYW5zZm9ybVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvY29sb3IvaW5kZXgubWpzXG52YXIgY29sb3IgPSB7XG4gIHRlc3Q6ICh2KSA9PiByZ2JhLnRlc3QodikgfHwgaGV4LnRlc3QodikgfHwgaHNsYS50ZXN0KHYpLFxuICBwYXJzZTogKHYpID0+IHtcbiAgICBpZiAocmdiYS50ZXN0KHYpKSB7XG4gICAgICByZXR1cm4gcmdiYS5wYXJzZSh2KTtcbiAgICB9IGVsc2UgaWYgKGhzbGEudGVzdCh2KSkge1xuICAgICAgcmV0dXJuIGhzbGEucGFyc2Uodik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBoZXgucGFyc2Uodik7XG4gICAgfVxuICB9LFxuICB0cmFuc2Zvcm06ICh2KSA9PiB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHYpID8gdiA6IHYuaGFzT3duUHJvcGVydHkoXCJyZWRcIikgPyByZ2JhLnRyYW5zZm9ybSh2KSA6IGhzbGEudHJhbnNmb3JtKHYpO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb21wbGV4L2luZGV4Lm1qc1xudmFyIGNvbG9yVG9rZW4gPSBcIiR7Y31cIjtcbnZhciBudW1iZXJUb2tlbiA9IFwiJHtufVwiO1xuZnVuY3Rpb24gdGVzdCh2KSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgcmV0dXJuIGlzTmFOKHYpICYmIGlzU3RyaW5nKHYpICYmICgoX2IgPSAoX2EgPSB2Lm1hdGNoKGZsb2F0UmVnZXgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSArICgoX2QgPSAoX2MgPSB2Lm1hdGNoKGNvbG9yUmVnZXgpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKSA+IDA7XG59XG5mdW5jdGlvbiBhbmFseXNlKHYpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKVxuICAgIHYgPSBgJHt2fWA7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBsZXQgbnVtQ29sb3JzID0gMDtcbiAgY29uc3QgY29sb3JzID0gdi5tYXRjaChjb2xvclJlZ2V4KTtcbiAgaWYgKGNvbG9ycykge1xuICAgIG51bUNvbG9ycyA9IGNvbG9ycy5sZW5ndGg7XG4gICAgdiA9IHYucmVwbGFjZShjb2xvclJlZ2V4LCBjb2xvclRva2VuKTtcbiAgICB2YWx1ZXMucHVzaCguLi5jb2xvcnMubWFwKGNvbG9yLnBhcnNlKSk7XG4gIH1cbiAgY29uc3QgbnVtYmVycyA9IHYubWF0Y2goZmxvYXRSZWdleCk7XG4gIGlmIChudW1iZXJzKSB7XG4gICAgdiA9IHYucmVwbGFjZShmbG9hdFJlZ2V4LCBudW1iZXJUb2tlbik7XG4gICAgdmFsdWVzLnB1c2goLi4ubnVtYmVycy5tYXAobnVtYmVyLnBhcnNlKSk7XG4gIH1cbiAgcmV0dXJuIHsgdmFsdWVzLCBudW1Db2xvcnMsIHRva2VuaXNlZDogdiB9O1xufVxuZnVuY3Rpb24gcGFyc2Uodikge1xuICByZXR1cm4gYW5hbHlzZSh2KS52YWx1ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1lcih2KSB7XG4gIGNvbnN0IHsgdmFsdWVzLCBudW1Db2xvcnMsIHRva2VuaXNlZCB9ID0gYW5hbHlzZSh2KTtcbiAgY29uc3QgbnVtVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuICh2MikgPT4ge1xuICAgIGxldCBvdXRwdXQgPSB0b2tlbmlzZWQ7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bVZhbHVlczsgaTIrKykge1xuICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoaTIgPCBudW1Db2xvcnMgPyBjb2xvclRva2VuIDogbnVtYmVyVG9rZW4sIGkyIDwgbnVtQ29sb3JzID8gY29sb3IudHJhbnNmb3JtKHYyW2kyXSkgOiBzYW5pdGl6ZSh2MltpMl0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cbnZhciBjb252ZXJ0TnVtYmVyc1RvWmVybyA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiA/IDAgOiB2O1xuZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZU5vbmUodikge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2KTtcbiAgY29uc3QgdHJhbnNmb3JtZXIgPSBjcmVhdGVUcmFuc2Zvcm1lcih2KTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKHBhcnNlZC5tYXAoY29udmVydE51bWJlcnNUb1plcm8pKTtcbn1cbnZhciBjb21wbGV4ID0geyB0ZXN0LCBwYXJzZSwgY3JlYXRlVHJhbnNmb3JtZXIsIGdldEFuaW1hdGFibGVOb25lIH07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbXBsZXgvZmlsdGVyLm1qc1xudmFyIG1heERlZmF1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiYnJpZ2h0bmVzc1wiLCBcImNvbnRyYXN0XCIsIFwic2F0dXJhdGVcIiwgXCJvcGFjaXR5XCJdKTtcbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdEZpbHRlcih2KSB7XG4gIGxldCBbbmFtZSwgdmFsdWVdID0gdi5zbGljZSgwLCAtMSkuc3BsaXQoXCIoXCIpO1xuICBpZiAobmFtZSA9PT0gXCJkcm9wLXNoYWRvd1wiKVxuICAgIHJldHVybiB2O1xuICBjb25zdCBbbnVtYmVyMl0gPSB2YWx1ZS5tYXRjaChmbG9hdFJlZ2V4KSB8fCBbXTtcbiAgaWYgKCFudW1iZXIyKVxuICAgIHJldHVybiB2O1xuICBjb25zdCB1bml0ID0gdmFsdWUucmVwbGFjZShudW1iZXIyLCBcIlwiKTtcbiAgbGV0IGRlZmF1bHRWYWx1ZSA9IG1heERlZmF1bHRzLmhhcyhuYW1lKSA/IDEgOiAwO1xuICBpZiAobnVtYmVyMiAhPT0gdmFsdWUpXG4gICAgZGVmYXVsdFZhbHVlICo9IDEwMDtcbiAgcmV0dXJuIG5hbWUgKyBcIihcIiArIGRlZmF1bHRWYWx1ZSArIHVuaXQgKyBcIilcIjtcbn1cbnZhciBmdW5jdGlvblJlZ2V4ID0gLyhbYS16LV0qKVxcKC4qP1xcKS9nO1xudmFyIGZpbHRlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tcGxleCksIHsgZ2V0QW5pbWF0YWJsZU5vbmU6ICh2KSA9PiB7XG4gIGNvbnN0IGZ1bmN0aW9ucyA9IHYubWF0Y2goZnVuY3Rpb25SZWdleCk7XG4gIHJldHVybiBmdW5jdGlvbnMgPyBmdW5jdGlvbnMubWFwKGFwcGx5RGVmYXVsdEZpbHRlcikuam9pbihcIiBcIikgOiB2O1xufSB9KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3R5cGUtaW50Lm1qc1xudmFyIGludCA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG51bWJlciksIHtcbiAgdHJhbnNmb3JtOiBNYXRoLnJvdW5kXG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL251bWJlci5tanNcbnZhciBudW1iZXJWYWx1ZVR5cGVzID0ge1xuICBib3JkZXJXaWR0aDogcHgsXG4gIGJvcmRlclRvcFdpZHRoOiBweCxcbiAgYm9yZGVyUmlnaHRXaWR0aDogcHgsXG4gIGJvcmRlckJvdHRvbVdpZHRoOiBweCxcbiAgYm9yZGVyTGVmdFdpZHRoOiBweCxcbiAgYm9yZGVyUmFkaXVzOiBweCxcbiAgcmFkaXVzOiBweCxcbiAgYm9yZGVyVG9wTGVmdFJhZGl1czogcHgsXG4gIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBweCxcbiAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IHB4LFxuICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBweCxcbiAgd2lkdGg6IHB4LFxuICBtYXhXaWR0aDogcHgsXG4gIGhlaWdodDogcHgsXG4gIG1heEhlaWdodDogcHgsXG4gIHNpemU6IHB4LFxuICB0b3A6IHB4LFxuICByaWdodDogcHgsXG4gIGJvdHRvbTogcHgsXG4gIGxlZnQ6IHB4LFxuICBwYWRkaW5nOiBweCxcbiAgcGFkZGluZ1RvcDogcHgsXG4gIHBhZGRpbmdSaWdodDogcHgsXG4gIHBhZGRpbmdCb3R0b206IHB4LFxuICBwYWRkaW5nTGVmdDogcHgsXG4gIG1hcmdpbjogcHgsXG4gIG1hcmdpblRvcDogcHgsXG4gIG1hcmdpblJpZ2h0OiBweCxcbiAgbWFyZ2luQm90dG9tOiBweCxcbiAgbWFyZ2luTGVmdDogcHgsXG4gIHJvdGF0ZTogZGVncmVlcyxcbiAgcm90YXRlWDogZGVncmVlcyxcbiAgcm90YXRlWTogZGVncmVlcyxcbiAgcm90YXRlWjogZGVncmVlcyxcbiAgc2NhbGUsXG4gIHNjYWxlWDogc2NhbGUsXG4gIHNjYWxlWTogc2NhbGUsXG4gIHNjYWxlWjogc2NhbGUsXG4gIHNrZXc6IGRlZ3JlZXMsXG4gIHNrZXdYOiBkZWdyZWVzLFxuICBza2V3WTogZGVncmVlcyxcbiAgZGlzdGFuY2U6IHB4LFxuICB0cmFuc2xhdGVYOiBweCxcbiAgdHJhbnNsYXRlWTogcHgsXG4gIHRyYW5zbGF0ZVo6IHB4LFxuICB4OiBweCxcbiAgeTogcHgsXG4gIHo6IHB4LFxuICBwZXJzcGVjdGl2ZTogcHgsXG4gIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBweCxcbiAgb3BhY2l0eTogYWxwaGEsXG4gIG9yaWdpblg6IHByb2dyZXNzUGVyY2VudGFnZSxcbiAgb3JpZ2luWTogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICBvcmlnaW5aOiBweCxcbiAgekluZGV4OiBpbnQsXG4gIGZpbGxPcGFjaXR5OiBhbHBoYSxcbiAgc3Ryb2tlT3BhY2l0eTogYWxwaGEsXG4gIG51bU9jdGF2ZXM6IGludFxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9idWlsZC1zdHlsZXMubWpzXG5mdW5jdGlvbiBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgY29uc3QgeyBzdHlsZSwgdmFycywgdHJhbnNmb3JtLCB0cmFuc2Zvcm1LZXlzOiB0cmFuc2Zvcm1LZXlzMiwgdHJhbnNmb3JtT3JpZ2luIH0gPSBzdGF0ZTtcbiAgdHJhbnNmb3JtS2V5czIubGVuZ3RoID0gMDtcbiAgbGV0IGhhc1RyYW5zZm9ybTIgPSBmYWxzZTtcbiAgbGV0IGhhc1RyYW5zZm9ybU9yaWdpbiA9IGZhbHNlO1xuICBsZXQgdHJhbnNmb3JtSXNOb25lID0gdHJ1ZTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbGF0ZXN0VmFsdWVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBsYXRlc3RWYWx1ZXNba2V5XTtcbiAgICBpZiAoaXNDU1NWYXJpYWJsZShrZXkpKSB7XG4gICAgICB2YXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZVR5cGUgPSBudW1iZXJWYWx1ZVR5cGVzW2tleV07XG4gICAgY29uc3QgdmFsdWVBc1R5cGUgPSBnZXRWYWx1ZUFzVHlwZSh2YWx1ZSwgdmFsdWVUeXBlKTtcbiAgICBpZiAodHJhbnNmb3JtUHJvcHMuaGFzKGtleSkpIHtcbiAgICAgIGhhc1RyYW5zZm9ybTIgPSB0cnVlO1xuICAgICAgdHJhbnNmb3JtW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgIHRyYW5zZm9ybUtleXMyLnB1c2goa2V5KTtcbiAgICAgIGlmICghdHJhbnNmb3JtSXNOb25lKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gKHZhbHVlVHlwZS5kZWZhdWx0IHx8IDApKVxuICAgICAgICB0cmFuc2Zvcm1Jc05vbmUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGtleS5zdGFydHNXaXRoKFwib3JpZ2luXCIpKSB7XG4gICAgICBoYXNUcmFuc2Zvcm1PcmlnaW4gPSB0cnVlO1xuICAgICAgdHJhbnNmb3JtT3JpZ2luW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVba2V5XSA9IHZhbHVlQXNUeXBlO1xuICAgIH1cbiAgfVxuICBpZiAoIWxhdGVzdFZhbHVlcy50cmFuc2Zvcm0pIHtcbiAgICBpZiAoaGFzVHJhbnNmb3JtMiB8fCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgc3R5bGUudHJhbnNmb3JtID0gYnVpbGRUcmFuc2Zvcm0oc3RhdGUsIG9wdGlvbnMsIHRyYW5zZm9ybUlzTm9uZSwgdHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUudHJhbnNmb3JtKSB7XG4gICAgICBzdHlsZS50cmFuc2Zvcm0gPSBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1RyYW5zZm9ybU9yaWdpbikge1xuICAgIGNvbnN0IHsgb3JpZ2luWCA9IFwiNTAlXCIsIG9yaWdpblkgPSBcIjUwJVwiLCBvcmlnaW5aID0gMCB9ID0gdHJhbnNmb3JtT3JpZ2luO1xuICAgIHN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGAke29yaWdpblh9ICR7b3JpZ2luWX0gJHtvcmlnaW5afWA7XG4gIH1cbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qc1xudmFyIGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSA9ICgpID0+ICh7XG4gIHN0eWxlOiB7fSxcbiAgdHJhbnNmb3JtOiB7fSxcbiAgdHJhbnNmb3JtS2V5czogW10sXG4gIHRyYW5zZm9ybU9yaWdpbjoge30sXG4gIHZhcnM6IHt9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91c2UtcHJvcHMubWpzXG5mdW5jdGlvbiBjb3B5UmF3VmFsdWVzT25seSh0YXJnZXQsIHNvdXJjZSwgcHJvcHMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKCFpc01vdGlvblZhbHVlKHNvdXJjZVtrZXldKSAmJiAhaXNGb3JjZWRNb3Rpb25WYWx1ZShrZXksIHByb3BzKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUluaXRpYWxNb3Rpb25WYWx1ZXMoeyB0cmFuc2Zvcm1UZW1wbGF0ZSB9LCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpIHtcbiAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSgpO1xuICAgIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgdmlzdWFsU3RhdGUsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246ICFpc1N0YXRpYyB9LCB0cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnZhcnMsIHN0YXRlLnN0eWxlKTtcbiAgfSwgW3Zpc3VhbFN0YXRlXSk7XG59XG5mdW5jdGlvbiB1c2VTdHlsZShwcm9wcywgdmlzdWFsU3RhdGUsIGlzU3RhdGljKSB7XG4gIGNvbnN0IHN0eWxlUHJvcCA9IHByb3BzLnN0eWxlIHx8IHt9O1xuICBjb25zdCBzdHlsZSA9IHt9O1xuICBjb3B5UmF3VmFsdWVzT25seShzdHlsZSwgc3R5bGVQcm9wLCBwcm9wcyk7XG4gIE9iamVjdC5hc3NpZ24oc3R5bGUsIHVzZUluaXRpYWxNb3Rpb25WYWx1ZXMocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykpO1xuICByZXR1cm4gcHJvcHMudHJhbnNmb3JtVmFsdWVzID8gcHJvcHMudHJhbnNmb3JtVmFsdWVzKHN0eWxlKSA6IHN0eWxlO1xufVxuZnVuY3Rpb24gdXNlSFRNTFByb3BzKHByb3BzLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpIHtcbiAgY29uc3QgaHRtbFByb3BzID0ge307XG4gIGNvbnN0IHN0eWxlID0gdXNlU3R5bGUocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYyk7XG4gIGlmIChwcm9wcy5kcmFnICYmIHByb3BzLmRyYWdMaXN0ZW5lciAhPT0gZmFsc2UpIHtcbiAgICBodG1sUHJvcHMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgc3R5bGUudXNlclNlbGVjdCA9IHN0eWxlLldlYmtpdFVzZXJTZWxlY3QgPSBzdHlsZS5XZWJraXRUb3VjaENhbGxvdXQgPSBcIm5vbmVcIjtcbiAgICBzdHlsZS50b3VjaEFjdGlvbiA9IHByb3BzLmRyYWcgPT09IHRydWUgPyBcIm5vbmVcIiA6IGBwYW4tJHtwcm9wcy5kcmFnID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCJ9YDtcbiAgfVxuICBodG1sUHJvcHMuc3R5bGUgPSBzdHlsZTtcbiAgcmV0dXJuIGh0bWxQcm9wcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdmFsaWQtcHJvcC5tanNcbnZhciBhbmltYXRpb25Qcm9wcyA9IFtcbiAgXCJhbmltYXRlXCIsXG4gIFwiZXhpdFwiLFxuICBcInZhcmlhbnRzXCIsXG4gIFwid2hpbGVIb3ZlclwiLFxuICBcIndoaWxlVGFwXCIsXG4gIFwid2hpbGVGb2N1c1wiLFxuICBcIndoaWxlRHJhZ1wiLFxuICBcIndoaWxlSW5WaWV3XCJcbl07XG52YXIgdGFwUHJvcHMgPSBbXCJ3aGlsZVRhcFwiLCBcIm9uVGFwXCIsIFwib25UYXBTdGFydFwiLCBcIm9uVGFwQ2FuY2VsXCJdO1xudmFyIHBhblByb3BzID0gW1wib25QYW5cIiwgXCJvblBhblN0YXJ0XCIsIFwib25QYW5TZXNzaW9uU3RhcnRcIiwgXCJvblBhbkVuZFwiXTtcbnZhciBpblZpZXdQcm9wcyA9IFtcbiAgXCJ3aGlsZUluVmlld1wiLFxuICBcIm9uVmlld3BvcnRFbnRlclwiLFxuICBcIm9uVmlld3BvcnRMZWF2ZVwiLFxuICBcInZpZXdwb3J0XCJcbl07XG52YXIgdmFsaWRNb3Rpb25Qcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJpbml0aWFsXCIsXG4gIFwic3R5bGVcIixcbiAgXCJ2YWx1ZXNcIixcbiAgXCJ2YXJpYW50c1wiLFxuICBcInRyYW5zaXRpb25cIixcbiAgXCJ0cmFuc2Zvcm1UZW1wbGF0ZVwiLFxuICBcInRyYW5zZm9ybVZhbHVlc1wiLFxuICBcImN1c3RvbVwiLFxuICBcImluaGVyaXRcIixcbiAgXCJsYXlvdXRcIixcbiAgXCJsYXlvdXRJZFwiLFxuICBcImxheW91dERlcGVuZGVuY3lcIixcbiAgXCJvbkxheW91dEFuaW1hdGlvblN0YXJ0XCIsXG4gIFwib25MYXlvdXRBbmltYXRpb25Db21wbGV0ZVwiLFxuICBcIm9uTGF5b3V0TWVhc3VyZVwiLFxuICBcIm9uQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICBcIm9uQW5pbWF0aW9uU3RhcnRcIixcbiAgXCJvbkFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gIFwib25VcGRhdGVcIixcbiAgXCJvbkRyYWdTdGFydFwiLFxuICBcIm9uRHJhZ1wiLFxuICBcIm9uRHJhZ0VuZFwiLFxuICBcIm9uTWVhc3VyZURyYWdDb25zdHJhaW50c1wiLFxuICBcIm9uRGlyZWN0aW9uTG9ja1wiLFxuICBcIm9uRHJhZ1RyYW5zaXRpb25FbmRcIixcbiAgXCJkcmFnXCIsXG4gIFwiZHJhZ0NvbnRyb2xzXCIsXG4gIFwiZHJhZ0xpc3RlbmVyXCIsXG4gIFwiZHJhZ0NvbnN0cmFpbnRzXCIsXG4gIFwiZHJhZ0RpcmVjdGlvbkxvY2tcIixcbiAgXCJkcmFnU25hcFRvT3JpZ2luXCIsXG4gIFwiX2RyYWdYXCIsXG4gIFwiX2RyYWdZXCIsXG4gIFwiZHJhZ0VsYXN0aWNcIixcbiAgXCJkcmFnTW9tZW50dW1cIixcbiAgXCJkcmFnUHJvcGFnYXRpb25cIixcbiAgXCJkcmFnVHJhbnNpdGlvblwiLFxuICBcIm9uSG92ZXJTdGFydFwiLFxuICBcIm9uSG92ZXJFbmRcIixcbiAgXCJsYXlvdXRTY3JvbGxcIixcbiAgLi4uaW5WaWV3UHJvcHMsXG4gIC4uLnRhcFByb3BzLFxuICAuLi5hbmltYXRpb25Qcm9wcyxcbiAgLi4ucGFuUHJvcHNcbl0pO1xuZnVuY3Rpb24gaXNWYWxpZE1vdGlvblByb3Aoa2V5KSB7XG4gIHJldHVybiB2YWxpZE1vdGlvblByb3BzLmhhcyhrZXkpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvZmlsdGVyLXByb3BzLm1qc1xudmFyIHNob3VsZEZvcndhcmQgPSAoa2V5KSA9PiAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KTtcbmZ1bmN0aW9uIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wKGlzVmFsaWRQcm9wKSB7XG4gIGlmICghaXNWYWxpZFByb3ApXG4gICAgcmV0dXJuO1xuICBzaG91bGRGb3J3YXJkID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblwiKSA/ICFpc1ZhbGlkTW90aW9uUHJvcChrZXkpIDogaXNWYWxpZFByb3Aoa2V5KTtcbn1cbnRyeSB7XG4gIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wKChpbml0X2lzX3Byb3BfdmFsaWRfZXNtKCksIF9fdG9Db21tb25KUyhpc19wcm9wX3ZhbGlkX2VzbV9leHBvcnRzKSkuZGVmYXVsdCk7XG59IGNhdGNoIChfYSkge1xufVxuZnVuY3Rpb24gZmlsdGVyUHJvcHMocHJvcHMsIGlzRG9tLCBmb3J3YXJkTW90aW9uUHJvcHMpIHtcbiAgY29uc3QgZmlsdGVyZWRQcm9wcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIGlmIChzaG91bGRGb3J3YXJkKGtleSkgfHwgZm9yd2FyZE1vdGlvblByb3BzID09PSB0cnVlICYmIGlzVmFsaWRNb3Rpb25Qcm9wKGtleSkgfHwgIWlzRG9tICYmICFpc1ZhbGlkTW90aW9uUHJvcChrZXkpIHx8IHByb3BzW1wiZHJhZ2dhYmxlXCJdICYmIGtleS5zdGFydHNXaXRoKFwib25EcmFnXCIpKSB7XG4gICAgICBmaWx0ZXJlZFByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsdGVyZWRQcm9wcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3VzZS1wcm9wcy5tanNcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzMgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3RyYW5zZm9ybS1vcmlnaW4ubWpzXG5mdW5jdGlvbiBjYWxjT3JpZ2luKG9yaWdpbiwgb2Zmc2V0LCBzaXplKSB7XG4gIHJldHVybiB0eXBlb2Ygb3JpZ2luID09PSBcInN0cmluZ1wiID8gb3JpZ2luIDogcHgudHJhbnNmb3JtKG9mZnNldCArIHNpemUgKiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gY2FsY1NWR1RyYW5zZm9ybU9yaWdpbihkaW1lbnNpb25zLCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gIGNvbnN0IHB4T3JpZ2luWCA9IGNhbGNPcmlnaW4ob3JpZ2luWCwgZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLndpZHRoKTtcbiAgY29uc3QgcHhPcmlnaW5ZID0gY2FsY09yaWdpbihvcmlnaW5ZLCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgcmV0dXJuIGAke3B4T3JpZ2luWH0gJHtweE9yaWdpbll9YDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3BhdGgubWpzXG52YXIgZGFzaEtleXMgPSB7XG4gIG9mZnNldDogXCJzdHJva2UtZGFzaG9mZnNldFwiLFxuICBhcnJheTogXCJzdHJva2UtZGFzaGFycmF5XCJcbn07XG52YXIgY2FtZWxLZXlzID0ge1xuICBvZmZzZXQ6IFwic3Ryb2tlRGFzaG9mZnNldFwiLFxuICBhcnJheTogXCJzdHJva2VEYXNoYXJyYXlcIlxufTtcbmZ1bmN0aW9uIGJ1aWxkU1ZHUGF0aChhdHRycywgbGVuZ3RoLCBzcGFjaW5nID0gMSwgb2Zmc2V0ID0gMCwgdXNlRGFzaENhc2UgPSB0cnVlKSB7XG4gIGF0dHJzLnBhdGhMZW5ndGggPSAxO1xuICBjb25zdCBrZXlzMiA9IHVzZURhc2hDYXNlID8gZGFzaEtleXMgOiBjYW1lbEtleXM7XG4gIGF0dHJzW2tleXMyLm9mZnNldF0gPSBweC50cmFuc2Zvcm0oLW9mZnNldCk7XG4gIGNvbnN0IHBhdGhMZW5ndGggPSBweC50cmFuc2Zvcm0obGVuZ3RoKTtcbiAgY29uc3QgcGF0aFNwYWNpbmcgPSBweC50cmFuc2Zvcm0oc3BhY2luZyk7XG4gIGF0dHJzW2tleXMyLmFycmF5XSA9IGAke3BhdGhMZW5ndGh9ICR7cGF0aFNwYWNpbmd9YDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL2J1aWxkLWF0dHJzLm1qc1xuZnVuY3Rpb24gYnVpbGRTVkdBdHRycyhzdGF0ZSwgX2EsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gIHZhciBfYiA9IF9hLCB7XG4gICAgYXR0clgsXG4gICAgYXR0clksXG4gICAgb3JpZ2luWCxcbiAgICBvcmlnaW5ZLFxuICAgIHBhdGhMZW5ndGgsXG4gICAgcGF0aFNwYWNpbmcgPSAxLFxuICAgIHBhdGhPZmZzZXQgPSAwXG4gIH0gPSBfYiwgbGF0ZXN0ID0gX19vYmpSZXN0KF9iLCBbXG4gICAgXCJhdHRyWFwiLFxuICAgIFwiYXR0cllcIixcbiAgICBcIm9yaWdpblhcIixcbiAgICBcIm9yaWdpbllcIixcbiAgICBcInBhdGhMZW5ndGhcIixcbiAgICBcInBhdGhTcGFjaW5nXCIsXG4gICAgXCJwYXRoT2Zmc2V0XCJcbiAgXSk7XG4gIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgbGF0ZXN0LCBvcHRpb25zLCB0cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gIHN0YXRlLmF0dHJzID0gc3RhdGUuc3R5bGU7XG4gIHN0YXRlLnN0eWxlID0ge307XG4gIGNvbnN0IHsgYXR0cnMsIHN0eWxlLCBkaW1lbnNpb25zIH0gPSBzdGF0ZTtcbiAgaWYgKGF0dHJzLnRyYW5zZm9ybSkge1xuICAgIGlmIChkaW1lbnNpb25zKVxuICAgICAgc3R5bGUudHJhbnNmb3JtID0gYXR0cnMudHJhbnNmb3JtO1xuICAgIGRlbGV0ZSBhdHRycy50cmFuc2Zvcm07XG4gIH1cbiAgaWYgKGRpbWVuc2lvbnMgJiYgKG9yaWdpblggIT09IHZvaWQgMCB8fCBvcmlnaW5ZICE9PSB2b2lkIDAgfHwgc3R5bGUudHJhbnNmb3JtKSkge1xuICAgIHN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGNhbGNTVkdUcmFuc2Zvcm1PcmlnaW4oZGltZW5zaW9ucywgb3JpZ2luWCAhPT0gdm9pZCAwID8gb3JpZ2luWCA6IDAuNSwgb3JpZ2luWSAhPT0gdm9pZCAwID8gb3JpZ2luWSA6IDAuNSk7XG4gIH1cbiAgaWYgKGF0dHJYICE9PSB2b2lkIDApXG4gICAgYXR0cnMueCA9IGF0dHJYO1xuICBpZiAoYXR0clkgIT09IHZvaWQgMClcbiAgICBhdHRycy55ID0gYXR0clk7XG4gIGlmIChwYXRoTGVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICBidWlsZFNWR1BhdGgoYXR0cnMsIHBhdGhMZW5ndGgsIHBhdGhTcGFjaW5nLCBwYXRoT2Zmc2V0LCBmYWxzZSk7XG4gIH1cbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL2NyZWF0ZS1yZW5kZXItc3RhdGUubWpzXG52YXIgY3JlYXRlU3ZnUmVuZGVyU3RhdGUgPSAoKSA9PiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBjcmVhdGVIdG1sUmVuZGVyU3RhdGUoKSksIHtcbiAgYXR0cnM6IHt9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3VzZS1wcm9wcy5tanNcbmZ1bmN0aW9uIHVzZVNWR1Byb3BzKHByb3BzLCB2aXN1YWxTdGF0ZSkge1xuICBjb25zdCB2aXN1YWxQcm9wcyA9IHVzZU1lbW8zKCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZVN2Z1JlbmRlclN0YXRlKCk7XG4gICAgYnVpbGRTVkdBdHRycyhzdGF0ZSwgdmlzdWFsU3RhdGUsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IGZhbHNlIH0sIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgc3RhdGUuYXR0cnMpLCB7XG4gICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoe30sIHN0YXRlLnN0eWxlKVxuICAgIH0pO1xuICB9LCBbdmlzdWFsU3RhdGVdKTtcbiAgaWYgKHByb3BzLnN0eWxlKSB7XG4gICAgY29uc3QgcmF3U3R5bGVzID0ge307XG4gICAgY29weVJhd1ZhbHVlc09ubHkocmF3U3R5bGVzLCBwcm9wcy5zdHlsZSwgcHJvcHMpO1xuICAgIHZpc3VhbFByb3BzLnN0eWxlID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHJhd1N0eWxlcyksIHZpc3VhbFByb3BzLnN0eWxlKTtcbiAgfVxuICByZXR1cm4gdmlzdWFsUHJvcHM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91c2UtcmVuZGVyLm1qc1xuZnVuY3Rpb24gY3JlYXRlVXNlUmVuZGVyKGZvcndhcmRNb3Rpb25Qcm9wcyA9IGZhbHNlKSB7XG4gIGNvbnN0IHVzZVJlbmRlciA9IChDb21wb25lbnQsIHByb3BzLCBwcm9qZWN0aW9uSWQsIHJlZiwgeyBsYXRlc3RWYWx1ZXMgfSwgaXNTdGF0aWMpID0+IHtcbiAgICBjb25zdCB1c2VWaXN1YWxQcm9wcyA9IGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudCkgPyB1c2VTVkdQcm9wcyA6IHVzZUhUTUxQcm9wcztcbiAgICBjb25zdCB2aXN1YWxQcm9wcyA9IHVzZVZpc3VhbFByb3BzKHByb3BzLCBsYXRlc3RWYWx1ZXMsIGlzU3RhdGljKTtcbiAgICBjb25zdCBmaWx0ZXJlZFByb3BzID0gZmlsdGVyUHJvcHMocHJvcHMsIHR5cGVvZiBDb21wb25lbnQgPT09IFwic3RyaW5nXCIsIGZvcndhcmRNb3Rpb25Qcm9wcyk7XG4gICAgY29uc3QgZWxlbWVudFByb3BzID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZmlsdGVyZWRQcm9wcyksIHZpc3VhbFByb3BzKSwge1xuICAgICAgcmVmXG4gICAgfSk7XG4gICAgaWYgKHByb2plY3Rpb25JZCkge1xuICAgICAgZWxlbWVudFByb3BzW1wiZGF0YS1wcm9qZWN0aW9uLWlkXCJdID0gcHJvamVjdGlvbklkO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudDIoQ29tcG9uZW50LCBlbGVtZW50UHJvcHMpO1xuICB9O1xuICByZXR1cm4gdXNlUmVuZGVyO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvY2FtZWwtdG8tZGFzaC5tanNcbnZhciBjYW1lbFRvRGFzaCA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvcmVuZGVyLm1qc1xuZnVuY3Rpb24gcmVuZGVySFRNTChlbGVtZW50LCB7IHN0eWxlLCB2YXJzIH0sIHN0eWxlUHJvcCwgcHJvamVjdGlvbikge1xuICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlLCBwcm9qZWN0aW9uICYmIHByb2plY3Rpb24uZ2V0UHJvamVjdGlvblN0eWxlcyhzdHlsZVByb3ApKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YXJzW2tleV0pO1xuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9jYW1lbC1jYXNlLWF0dHJzLm1qc1xudmFyIGNhbWVsQ2FzZUF0dHJpYnV0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYmFzZUZyZXF1ZW5jeVwiLFxuICBcImRpZmZ1c2VDb25zdGFudFwiLFxuICBcImtlcm5lbE1hdHJpeFwiLFxuICBcImtlcm5lbFVuaXRMZW5ndGhcIixcbiAgXCJrZXlTcGxpbmVzXCIsXG4gIFwia2V5VGltZXNcIixcbiAgXCJsaW1pdGluZ0NvbmVBbmdsZVwiLFxuICBcIm1hcmtlckhlaWdodFwiLFxuICBcIm1hcmtlcldpZHRoXCIsXG4gIFwibnVtT2N0YXZlc1wiLFxuICBcInRhcmdldFhcIixcbiAgXCJ0YXJnZXRZXCIsXG4gIFwic3VyZmFjZVNjYWxlXCIsXG4gIFwic3BlY3VsYXJDb25zdGFudFwiLFxuICBcInNwZWN1bGFyRXhwb25lbnRcIixcbiAgXCJzdGREZXZpYXRpb25cIixcbiAgXCJ0YWJsZVZhbHVlc1wiLFxuICBcInZpZXdCb3hcIixcbiAgXCJncmFkaWVudFRyYW5zZm9ybVwiLFxuICBcInBhdGhMZW5ndGhcIlxuXSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9yZW5kZXIubWpzXG5mdW5jdGlvbiByZW5kZXJTVkcoZWxlbWVudCwgcmVuZGVyU3RhdGUsIF9zdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgcmVuZGVySFRNTChlbGVtZW50LCByZW5kZXJTdGF0ZSwgdm9pZCAwLCBwcm9qZWN0aW9uKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmVuZGVyU3RhdGUuYXR0cnMpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSghY2FtZWxDYXNlQXR0cmlidXRlcy5oYXMoa2V5KSA/IGNhbWVsVG9EYXNoKGtleSkgOiBrZXksIHJlbmRlclN0YXRlLmF0dHJzW2tleV0pO1xuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvc2NyYXBlLW1vdGlvbi12YWx1ZXMubWpzXG5mdW5jdGlvbiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpIHtcbiAgY29uc3QgeyBzdHlsZSB9ID0gcHJvcHM7XG4gIGNvbnN0IG5ld1ZhbHVlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZSkge1xuICAgIGlmIChpc01vdGlvblZhbHVlKHN0eWxlW2tleV0pIHx8IGlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykpIHtcbiAgICAgIG5ld1ZhbHVlc1trZXldID0gc3R5bGVba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1ZhbHVlcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qc1xuZnVuY3Rpb24gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMihwcm9wcykge1xuICBjb25zdCBuZXdWYWx1ZXMgPSBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIGlmIChpc01vdGlvblZhbHVlKHByb3BzW2tleV0pKSB7XG4gICAgICBjb25zdCB0YXJnZXRLZXkgPSBrZXkgPT09IFwieFwiIHx8IGtleSA9PT0gXCJ5XCIgPyBcImF0dHJcIiArIGtleS50b1VwcGVyQ2FzZSgpIDoga2V5O1xuICAgICAgbmV3VmFsdWVzW3RhcmdldEtleV0gPSBwcm9wc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3VmFsdWVzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLXN0YXRlLm1qc1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9yZXNvbHZlLXZhcmlhbnRzLm1qc1xuZnVuY3Rpb24gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24sIGN1c3RvbSwgY3VycmVudFZhbHVlcyA9IHt9LCBjdXJyZW50VmVsb2NpdHkgPSB7fSkge1xuICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uKGN1c3RvbSAhPT0gdm9pZCAwID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBjdXJyZW50VmFsdWVzLCBjdXJyZW50VmVsb2NpdHkpO1xuICB9XG4gIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgIGRlZmluaXRpb24gPSBwcm9wcy52YXJpYW50cyAmJiBwcm9wcy52YXJpYW50c1tkZWZpbml0aW9uXTtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uKGN1c3RvbSAhPT0gdm9pZCAwID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBjdXJyZW50VmFsdWVzLCBjdXJyZW50VmVsb2NpdHkpO1xuICB9XG4gIHJldHVybiBkZWZpbml0aW9uO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy1rZXlmcmFtZXMtdGFyZ2V0Lm1qc1xudmFyIGlzS2V5ZnJhbWVzVGFyZ2V0ID0gKHYpID0+IHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3Jlc29sdmUtdmFsdWUubWpzXG52YXIgaXNDdXN0b21WYWx1ZSA9ICh2KSA9PiB7XG4gIHJldHVybiBCb29sZWFuKHYgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdi5taXggJiYgdi50b1ZhbHVlKTtcbn07XG52YXIgcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyA9ICh2KSA9PiB7XG4gIHJldHVybiBpc0tleWZyYW1lc1RhcmdldCh2KSA/IHZbdi5sZW5ndGggLSAxXSB8fCAwIDogdjtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXRpbHMvcmVzb2x2ZS1tb3Rpb24tdmFsdWUubWpzXG5mdW5jdGlvbiByZXNvbHZlTW90aW9uVmFsdWUodmFsdWUpIHtcbiAgY29uc3QgdW53cmFwcGVkVmFsdWUgPSBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlLmdldCgpIDogdmFsdWU7XG4gIHJldHVybiBpc0N1c3RvbVZhbHVlKHVud3JhcHBlZFZhbHVlKSA/IHVud3JhcHBlZFZhbHVlLnRvVmFsdWUoKSA6IHVud3JhcHBlZFZhbHVlO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLXN0YXRlLm1qc1xuZnVuY3Rpb24gbWFrZVN0YXRlKHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMzLCBjcmVhdGVSZW5kZXJTdGF0ZSwgb25Nb3VudCB9LCBwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0KSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGxhdGVzdFZhbHVlczogbWFrZUxhdGVzdFZhbHVlcyhwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0LCBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMzKSxcbiAgICByZW5kZXJTdGF0ZTogY3JlYXRlUmVuZGVyU3RhdGUoKVxuICB9O1xuICBpZiAob25Nb3VudCkge1xuICAgIHN0YXRlLm1vdW50ID0gKGluc3RhbmNlKSA9PiBvbk1vdW50KHByb3BzLCBpbnN0YW5jZSwgc3RhdGUpO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbnZhciBtYWtlVXNlVmlzdWFsU3RhdGUgPSAoY29uZmlnKSA9PiAocHJvcHMsIGlzU3RhdGljKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0NShNb3Rpb25Db250ZXh0KTtcbiAgY29uc3QgcHJlc2VuY2VDb250ZXh0ID0gdXNlQ29udGV4dDUoUHJlc2VuY2VDb250ZXh0KTtcbiAgY29uc3QgbWFrZSA9ICgpID0+IG1ha2VTdGF0ZShjb25maWcsIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpO1xuICByZXR1cm4gaXNTdGF0aWMgPyBtYWtlKCkgOiB1c2VDb25zdGFudChtYWtlKTtcbn07XG5mdW5jdGlvbiBtYWtlTGF0ZXN0VmFsdWVzKHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQsIHNjcmFwZU1vdGlvblZhbHVlcykge1xuICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgY29uc3QgbW90aW9uVmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzKHByb3BzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbW90aW9uVmFsdWVzKSB7XG4gICAgdmFsdWVzW2tleV0gPSByZXNvbHZlTW90aW9uVmFsdWUobW90aW9uVmFsdWVzW2tleV0pO1xuICB9XG4gIGxldCB7IGluaXRpYWwsIGFuaW1hdGU6IGFuaW1hdGUzIH0gPSBwcm9wcztcbiAgY29uc3QgaXNDb250cm9sbGluZ1ZhcmlhbnRzJDEgPSBpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpO1xuICBjb25zdCBpc1ZhcmlhbnROb2RlJDEgPSBpc1ZhcmlhbnROb2RlKHByb3BzKTtcbiAgaWYgKGNvbnRleHQgJiYgaXNWYXJpYW50Tm9kZSQxICYmICFpc0NvbnRyb2xsaW5nVmFyaWFudHMkMSAmJiBwcm9wcy5pbmhlcml0ICE9PSBmYWxzZSkge1xuICAgIGlmIChpbml0aWFsID09PSB2b2lkIDApXG4gICAgICBpbml0aWFsID0gY29udGV4dC5pbml0aWFsO1xuICAgIGlmIChhbmltYXRlMyA9PT0gdm9pZCAwKVxuICAgICAgYW5pbWF0ZTMgPSBjb250ZXh0LmFuaW1hdGU7XG4gIH1cbiAgbGV0IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPSBwcmVzZW5jZUNvbnRleHQgPyBwcmVzZW5jZUNvbnRleHQuaW5pdGlhbCA9PT0gZmFsc2UgOiBmYWxzZTtcbiAgaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZCA9IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgfHwgaW5pdGlhbCA9PT0gZmFsc2U7XG4gIGNvbnN0IHZhcmlhbnRUb1NldCA9IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPyBhbmltYXRlMyA6IGluaXRpYWw7XG4gIGlmICh2YXJpYW50VG9TZXQgJiYgdHlwZW9mIHZhcmlhbnRUb1NldCAhPT0gXCJib29sZWFuXCIgJiYgIWlzQW5pbWF0aW9uQ29udHJvbHModmFyaWFudFRvU2V0KSkge1xuICAgIGNvbnN0IGxpc3QgPSBBcnJheS5pc0FycmF5KHZhcmlhbnRUb1NldCkgPyB2YXJpYW50VG9TZXQgOiBbdmFyaWFudFRvU2V0XTtcbiAgICBsaXN0LmZvckVhY2goKGRlZmluaXRpb24pID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24pO1xuICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgX2EgPSByZXNvbHZlZCwgeyB0cmFuc2l0aW9uRW5kLCB0cmFuc2l0aW9uIH0gPSBfYSwgdGFyZ2V0ID0gX19vYmpSZXN0KF9hLCBbXCJ0cmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvblwiXSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgbGV0IHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlVGFyZ2V0KSkge1xuICAgICAgICAgIGNvbnN0IGluZGV4MiA9IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPyB2YWx1ZVRhcmdldC5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICB2YWx1ZVRhcmdldCA9IHZhbHVlVGFyZ2V0W2luZGV4Ml07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZVRhcmdldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHJhbnNpdGlvbkVuZClcbiAgICAgICAgdmFsdWVzW2tleV0gPSB0cmFuc2l0aW9uRW5kW2tleV07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL2NvbmZpZy1tb3Rpb24ubWpzXG52YXIgc3ZnTW90aW9uQ29uZmlnID0ge1xuICB1c2VWaXN1YWxTdGF0ZTogbWFrZVVzZVZpc3VhbFN0YXRlKHtcbiAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczIsXG4gICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZVN2Z1JlbmRlclN0YXRlLFxuICAgIG9uTW91bnQ6IChwcm9wcywgaW5zdGFuY2UsIHsgcmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcyB9KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZW5kZXJTdGF0ZS5kaW1lbnNpb25zID0gdHlwZW9mIGluc3RhbmNlLmdldEJCb3ggPT09IFwiZnVuY3Rpb25cIiA/IGluc3RhbmNlLmdldEJCb3goKSA6IGluc3RhbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZW5kZXJTdGF0ZS5kaW1lbnNpb25zID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGJ1aWxkU1ZHQXR0cnMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogZmFsc2UgfSwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgcmVuZGVyU1ZHKGluc3RhbmNlLCByZW5kZXJTdGF0ZSk7XG4gICAgfVxuICB9KVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC9jb25maWctbW90aW9uLm1qc1xudmFyIGh0bWxNb3Rpb25Db25maWcgPSB7XG4gIHVzZVZpc3VhbFN0YXRlOiBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyxcbiAgICBjcmVhdGVSZW5kZXJTdGF0ZTogY3JlYXRlSHRtbFJlbmRlclN0YXRlXG4gIH0pXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvY3JlYXRlLWNvbmZpZy5tanNcbmZ1bmN0aW9uIGNyZWF0ZURvbU1vdGlvbkNvbmZpZyhDb21wb25lbnQsIHsgZm9yd2FyZE1vdGlvblByb3BzID0gZmFsc2UgfSwgcHJlbG9hZGVkRmVhdHVyZXMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQsIHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IpIHtcbiAgY29uc3QgYmFzZUNvbmZpZyA9IGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudCkgPyBzdmdNb3Rpb25Db25maWcgOiBodG1sTW90aW9uQ29uZmlnO1xuICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYmFzZUNvbmZpZyksIHtcbiAgICBwcmVsb2FkZWRGZWF0dXJlcyxcbiAgICB1c2VSZW5kZXI6IGNyZWF0ZVVzZVJlbmRlcihmb3J3YXJkTW90aW9uUHJvcHMpLFxuICAgIGNyZWF0ZVZpc3VhbEVsZW1lbnQsXG4gICAgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvcixcbiAgICBDb21wb25lbnRcbiAgfSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL3R5cGVzLm1qc1xudmFyIEFuaW1hdGlvblR5cGU7XG4oZnVuY3Rpb24oQW5pbWF0aW9uVHlwZTIpIHtcbiAgQW5pbWF0aW9uVHlwZTJbXCJBbmltYXRlXCJdID0gXCJhbmltYXRlXCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiSG92ZXJcIl0gPSBcIndoaWxlSG92ZXJcIjtcbiAgQW5pbWF0aW9uVHlwZTJbXCJUYXBcIl0gPSBcIndoaWxlVGFwXCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiRHJhZ1wiXSA9IFwid2hpbGVEcmFnXCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiRm9jdXNcIl0gPSBcIndoaWxlRm9jdXNcIjtcbiAgQW5pbWF0aW9uVHlwZTJbXCJJblZpZXdcIl0gPSBcIndoaWxlSW5WaWV3XCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiRXhpdFwiXSA9IFwiZXhpdFwiO1xufSkoQW5pbWF0aW9uVHlwZSB8fCAoQW5pbWF0aW9uVHlwZSA9IHt9KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL3VzZS1kb20tZXZlbnQubWpzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MyB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gYWRkRG9tRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfSkge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIHVzZURvbUV2ZW50KHJlZiwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSByZWYuY3VycmVudDtcbiAgICBpZiAoaGFuZGxlciAmJiBlbGVtZW50KSB7XG4gICAgICByZXR1cm4gYWRkRG9tRXZlbnQoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIFtyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9uc10pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS1mb2N1cy1nZXN0dXJlLm1qc1xuZnVuY3Rpb24gdXNlRm9jdXNHZXN0dXJlKHsgd2hpbGVGb2N1cywgdmlzdWFsRWxlbWVudCB9KSB7XG4gIGNvbnN0IHsgYW5pbWF0aW9uU3RhdGUgfSA9IHZpc3VhbEVsZW1lbnQ7XG4gIGNvbnN0IG9uRm9jdXMgPSAoKSA9PiB7XG4gICAgYW5pbWF0aW9uU3RhdGUgJiYgYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuRm9jdXMsIHRydWUpO1xuICB9O1xuICBjb25zdCBvbkJsdXIgPSAoKSA9PiB7XG4gICAgYW5pbWF0aW9uU3RhdGUgJiYgYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuRm9jdXMsIGZhbHNlKTtcbiAgfTtcbiAgdXNlRG9tRXZlbnQodmlzdWFsRWxlbWVudCwgXCJmb2N1c1wiLCB3aGlsZUZvY3VzID8gb25Gb2N1cyA6IHZvaWQgMCk7XG4gIHVzZURvbUV2ZW50KHZpc3VhbEVsZW1lbnQsIFwiYmx1clwiLCB3aGlsZUZvY3VzID8gb25CbHVyIDogdm9pZCAwKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy91dGlscy9ldmVudC10eXBlLm1qc1xuZnVuY3Rpb24gaXNNb3VzZUV2ZW50KGV2ZW50KSB7XG4gIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGV2ZW50IGluc3RhbmNlb2YgUG9pbnRlckV2ZW50KSB7XG4gICAgcmV0dXJuICEhKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpO1xuICB9XG4gIHJldHVybiBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQ7XG59XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgaGFzVG91Y2hlcyA9ICEhZXZlbnQudG91Y2hlcztcbiAgcmV0dXJuIGhhc1RvdWNoZXM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL2V2ZW50LWluZm8ubWpzXG5mdW5jdGlvbiBmaWx0ZXJQcmltYXJ5UG9pbnRlcihldmVudEhhbmRsZXIpIHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGNvbnN0IGlzTW91c2VFdmVudDIgPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQ7XG4gICAgY29uc3QgaXNQcmltYXJ5UG9pbnRlciA9ICFpc01vdXNlRXZlbnQyIHx8IGlzTW91c2VFdmVudDIgJiYgZXZlbnQuYnV0dG9uID09PSAwO1xuICAgIGlmIChpc1ByaW1hcnlQb2ludGVyKSB7XG4gICAgICBldmVudEhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBkZWZhdWx0UGFnZVBvaW50ID0geyBwYWdlWDogMCwgcGFnZVk6IDAgfTtcbmZ1bmN0aW9uIHBvaW50RnJvbVRvdWNoKGUsIHBvaW50VHlwZSA9IFwicGFnZVwiKSB7XG4gIGNvbnN0IHByaW1hcnlUb3VjaCA9IGUudG91Y2hlc1swXSB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICBjb25zdCBwb2ludDIgPSBwcmltYXJ5VG91Y2ggfHwgZGVmYXVsdFBhZ2VQb2ludDtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludDJbcG9pbnRUeXBlICsgXCJYXCJdLFxuICAgIHk6IHBvaW50Mltwb2ludFR5cGUgKyBcIllcIl1cbiAgfTtcbn1cbmZ1bmN0aW9uIHBvaW50RnJvbU1vdXNlKHBvaW50MiwgcG9pbnRUeXBlID0gXCJwYWdlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludDJbcG9pbnRUeXBlICsgXCJYXCJdLFxuICAgIHk6IHBvaW50Mltwb2ludFR5cGUgKyBcIllcIl1cbiAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudEluZm8oZXZlbnQsIHBvaW50VHlwZSA9IFwicGFnZVwiKSB7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IGlzVG91Y2hFdmVudChldmVudCkgPyBwb2ludEZyb21Ub3VjaChldmVudCwgcG9pbnRUeXBlKSA6IHBvaW50RnJvbU1vdXNlKGV2ZW50LCBwb2ludFR5cGUpXG4gIH07XG59XG52YXIgd3JhcEhhbmRsZXIgPSAoaGFuZGxlciwgc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBsaXN0ZW5lciA9IChldmVudCkgPT4gaGFuZGxlcihldmVudCwgZXh0cmFjdEV2ZW50SW5mbyhldmVudCkpO1xuICByZXR1cm4gc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIgPyBmaWx0ZXJQcmltYXJ5UG9pbnRlcihsaXN0ZW5lcikgOiBsaXN0ZW5lcjtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL3V0aWxzLm1qc1xudmFyIHN1cHBvcnRzUG9pbnRlckV2ZW50cyA9ICgpID0+IGlzQnJvd3NlciAmJiB3aW5kb3cub25wb2ludGVyZG93biA9PT0gbnVsbDtcbnZhciBzdXBwb3J0c1RvdWNoRXZlbnRzID0gKCkgPT4gaXNCcm93c2VyICYmIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09IG51bGw7XG52YXIgc3VwcG9ydHNNb3VzZUV2ZW50cyA9ICgpID0+IGlzQnJvd3NlciAmJiB3aW5kb3cub25tb3VzZWRvd24gPT09IG51bGw7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL3VzZS1wb2ludGVyLWV2ZW50Lm1qc1xudmFyIG1vdXNlRXZlbnROYW1lcyA9IHtcbiAgcG9pbnRlcmRvd246IFwibW91c2Vkb3duXCIsXG4gIHBvaW50ZXJtb3ZlOiBcIm1vdXNlbW92ZVwiLFxuICBwb2ludGVydXA6IFwibW91c2V1cFwiLFxuICBwb2ludGVyY2FuY2VsOiBcIm1vdXNlY2FuY2VsXCIsXG4gIHBvaW50ZXJvdmVyOiBcIm1vdXNlb3ZlclwiLFxuICBwb2ludGVyb3V0OiBcIm1vdXNlb3V0XCIsXG4gIHBvaW50ZXJlbnRlcjogXCJtb3VzZWVudGVyXCIsXG4gIHBvaW50ZXJsZWF2ZTogXCJtb3VzZWxlYXZlXCJcbn07XG52YXIgdG91Y2hFdmVudE5hbWVzID0ge1xuICBwb2ludGVyZG93bjogXCJ0b3VjaHN0YXJ0XCIsXG4gIHBvaW50ZXJtb3ZlOiBcInRvdWNobW92ZVwiLFxuICBwb2ludGVydXA6IFwidG91Y2hlbmRcIixcbiAgcG9pbnRlcmNhbmNlbDogXCJ0b3VjaGNhbmNlbFwiXG59O1xuZnVuY3Rpb24gZ2V0UG9pbnRlckV2ZW50TmFtZShuYW1lKSB7XG4gIGlmIChzdXBwb3J0c1BvaW50ZXJFdmVudHMoKSkge1xuICAgIHJldHVybiBuYW1lO1xuICB9IGVsc2UgaWYgKHN1cHBvcnRzVG91Y2hFdmVudHMoKSkge1xuICAgIHJldHVybiB0b3VjaEV2ZW50TmFtZXNbbmFtZV07XG4gIH0gZWxzZSBpZiAoc3VwcG9ydHNNb3VzZUV2ZW50cygpKSB7XG4gICAgcmV0dXJuIG1vdXNlRXZlbnROYW1lc1tuYW1lXTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGFkZFBvaW50ZXJFdmVudCh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICByZXR1cm4gYWRkRG9tRXZlbnQodGFyZ2V0LCBnZXRQb2ludGVyRXZlbnROYW1lKGV2ZW50TmFtZSksIHdyYXBIYW5kbGVyKGhhbmRsZXIsIGV2ZW50TmFtZSA9PT0gXCJwb2ludGVyZG93blwiKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB1c2VQb2ludGVyRXZlbnQocmVmLCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVzZURvbUV2ZW50KHJlZiwgZ2V0UG9pbnRlckV2ZW50TmFtZShldmVudE5hbWUpLCBoYW5kbGVyICYmIHdyYXBIYW5kbGVyKGhhbmRsZXIsIGV2ZW50TmFtZSA9PT0gXCJwb2ludGVyZG93blwiKSwgb3B0aW9ucyk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91dGlscy9sb2NrLm1qc1xuZnVuY3Rpb24gY3JlYXRlTG9jayhuYW1lKSB7XG4gIGxldCBsb2NrID0gbnVsbDtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBvcGVuTG9jayA9ICgpID0+IHtcbiAgICAgIGxvY2sgPSBudWxsO1xuICAgIH07XG4gICAgaWYgKGxvY2sgPT09IG51bGwpIHtcbiAgICAgIGxvY2sgPSBuYW1lO1xuICAgICAgcmV0dXJuIG9wZW5Mb2NrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG52YXIgZ2xvYmFsSG9yaXpvbnRhbExvY2sgPSBjcmVhdGVMb2NrKFwiZHJhZ0hvcml6b250YWxcIik7XG52YXIgZ2xvYmFsVmVydGljYWxMb2NrID0gY3JlYXRlTG9jayhcImRyYWdWZXJ0aWNhbFwiKTtcbmZ1bmN0aW9uIGdldEdsb2JhbExvY2soZHJhZzIpIHtcbiAgbGV0IGxvY2sgPSBmYWxzZTtcbiAgaWYgKGRyYWcyID09PSBcInlcIikge1xuICAgIGxvY2sgPSBnbG9iYWxWZXJ0aWNhbExvY2soKTtcbiAgfSBlbHNlIGlmIChkcmFnMiA9PT0gXCJ4XCIpIHtcbiAgICBsb2NrID0gZ2xvYmFsSG9yaXpvbnRhbExvY2soKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvcGVuSG9yaXpvbnRhbCA9IGdsb2JhbEhvcml6b250YWxMb2NrKCk7XG4gICAgY29uc3Qgb3BlblZlcnRpY2FsID0gZ2xvYmFsVmVydGljYWxMb2NrKCk7XG4gICAgaWYgKG9wZW5Ib3Jpem9udGFsICYmIG9wZW5WZXJ0aWNhbCkge1xuICAgICAgbG9jayA9ICgpID0+IHtcbiAgICAgICAgb3Blbkhvcml6b250YWwoKTtcbiAgICAgICAgb3BlblZlcnRpY2FsKCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3Blbkhvcml6b250YWwpXG4gICAgICAgIG9wZW5Ib3Jpem9udGFsKCk7XG4gICAgICBpZiAob3BlblZlcnRpY2FsKVxuICAgICAgICBvcGVuVmVydGljYWwoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvY2s7XG59XG5mdW5jdGlvbiBpc0RyYWdBY3RpdmUoKSB7XG4gIGNvbnN0IG9wZW5HZXN0dXJlTG9jayA9IGdldEdsb2JhbExvY2sodHJ1ZSk7XG4gIGlmICghb3Blbkdlc3R1cmVMb2NrKVxuICAgIHJldHVybiB0cnVlO1xuICBvcGVuR2VzdHVyZUxvY2soKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS1ob3Zlci1nZXN0dXJlLm1qc1xuZnVuY3Rpb24gY3JlYXRlSG92ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBpc0FjdGl2ZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIChldmVudCwgaW5mbykgPT4ge1xuICAgIGlmICghaXNNb3VzZUV2ZW50KGV2ZW50KSB8fCBpc0RyYWdBY3RpdmUoKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkge1xuICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5Ib3ZlciwgaXNBY3RpdmUpO1xuICAgIH1cbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhldmVudCwgaW5mbyk7XG4gIH07XG59XG5mdW5jdGlvbiB1c2VIb3Zlckdlc3R1cmUoeyBvbkhvdmVyU3RhcnQsIG9uSG92ZXJFbmQsIHdoaWxlSG92ZXIsIHZpc3VhbEVsZW1lbnQgfSkge1xuICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudCwgXCJwb2ludGVyZW50ZXJcIiwgb25Ib3ZlclN0YXJ0IHx8IHdoaWxlSG92ZXIgPyBjcmVhdGVIb3ZlckV2ZW50KHZpc3VhbEVsZW1lbnQsIHRydWUsIG9uSG92ZXJTdGFydCkgOiB2b2lkIDAsIHsgcGFzc2l2ZTogIW9uSG92ZXJTdGFydCB9KTtcbiAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmxlYXZlXCIsIG9uSG92ZXJFbmQgfHwgd2hpbGVIb3ZlciA/IGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudCwgZmFsc2UsIG9uSG92ZXJFbmQpIDogdm9pZCAwLCB7IHBhc3NpdmU6ICFvbkhvdmVyRW5kIH0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS10YXAtZ2VzdHVyZS5tanNcbmltcG9ydCB7IHVzZVJlZiBhcyB1c2VSZWYzIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXRpbHMvaXMtbm9kZS1vci1jaGlsZC5tanNcbnZhciBpc05vZGVPckNoaWxkID0gKHBhcmVudCwgY2hpbGQpID0+IHtcbiAgaWYgKCFjaGlsZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChwYXJlbnQgPT09IGNoaWxkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlzTm9kZU9yQ2hpbGQocGFyZW50LCBjaGlsZC5wYXJlbnRFbGVtZW50KTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtdW5tb3VudC1lZmZlY3QubWpzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NCB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlVW5tb3VudEVmZmVjdChjYWxsYmFjaykge1xuICByZXR1cm4gdXNlRWZmZWN0NCgoKSA9PiAoKSA9PiBjYWxsYmFjaygpLCBbXSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vbm9kZV9tb2R1bGVzL3RzbGliL21vZHVsZXMvaW5kZXguanNcbnZhciBpbXBvcnRfdHNsaWIgPSBfX3RvRVNNKHJlcXVpcmVfdHNsaWIoKSwgMSk7XG52YXIge1xuICBfX2V4dGVuZHMsXG4gIF9fYXNzaWduLFxuICBfX3Jlc3QsXG4gIF9fZGVjb3JhdGUsXG4gIF9fcGFyYW0sXG4gIF9fbWV0YWRhdGEsXG4gIF9fYXdhaXRlcixcbiAgX19nZW5lcmF0b3IsXG4gIF9fZXhwb3J0U3RhcixcbiAgX19jcmVhdGVCaW5kaW5nLFxuICBfX3ZhbHVlcyxcbiAgX19yZWFkLFxuICBfX3NwcmVhZCxcbiAgX19zcHJlYWRBcnJheXMsXG4gIF9fc3ByZWFkQXJyYXksXG4gIF9fYXdhaXQsXG4gIF9fYXN5bmNHZW5lcmF0b3IsXG4gIF9fYXN5bmNEZWxlZ2F0b3IsXG4gIF9fYXN5bmNWYWx1ZXMsXG4gIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxuICBfX2ltcG9ydFN0YXIsXG4gIF9faW1wb3J0RGVmYXVsdCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEluXG59ID0gaW1wb3J0X3RzbGliLmRlZmF1bHQ7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9oZXktbGlzdGVuL2Rpc3QvaGV5LWxpc3Rlbi5lcy5qc1xudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHtcbn07XG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oKSB7XG59O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNoZWNrICYmIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICB9O1xuICBpbnZhcmlhbnQgPSBmdW5jdGlvbihjaGVjaywgbWVzc2FnZSkge1xuICAgIGlmICghY2hlY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9jbGFtcC5tanNcbnZhciBjbGFtcDIgPSAobWluLCBtYXgsIHYpID0+IE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL3V0aWxzL2ZpbmQtc3ByaW5nLm1qc1xudmFyIHNhZmVNaW4gPSAxZS0zO1xudmFyIG1pbkR1cmF0aW9uID0gMC4wMTtcbnZhciBtYXhEdXJhdGlvbiA9IDEwO1xudmFyIG1pbkRhbXBpbmcgPSAwLjA1O1xudmFyIG1heERhbXBpbmcgPSAxO1xuZnVuY3Rpb24gZmluZFNwcmluZyh7IGR1cmF0aW9uID0gODAwLCBib3VuY2UgPSAwLjI1LCB2ZWxvY2l0eSA9IDAsIG1hc3MgPSAxIH0pIHtcbiAgbGV0IGVudmVsb3BlO1xuICBsZXQgZGVyaXZhdGl2ZTtcbiAgd2FybmluZyhkdXJhdGlvbiA8PSBtYXhEdXJhdGlvbiAqIDFlMywgXCJTcHJpbmcgZHVyYXRpb24gbXVzdCBiZSAxMCBzZWNvbmRzIG9yIGxlc3NcIik7XG4gIGxldCBkYW1waW5nUmF0aW8gPSAxIC0gYm91bmNlO1xuICBkYW1waW5nUmF0aW8gPSBjbGFtcDIobWluRGFtcGluZywgbWF4RGFtcGluZywgZGFtcGluZ1JhdGlvKTtcbiAgZHVyYXRpb24gPSBjbGFtcDIobWluRHVyYXRpb24sIG1heER1cmF0aW9uLCBkdXJhdGlvbiAvIDFlMyk7XG4gIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgZW52ZWxvcGUgPSAodW5kYW1wZWRGcmVxMikgPT4ge1xuICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWNheSA9IHVuZGFtcGVkRnJlcTIgKiBkYW1waW5nUmF0aW87XG4gICAgICBjb25zdCBkZWx0YSA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgIGNvbnN0IGEyID0gZXhwb25lbnRpYWxEZWNheSAtIHZlbG9jaXR5O1xuICAgICAgY29uc3QgYjIgPSBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRGcmVxMiwgZGFtcGluZ1JhdGlvKTtcbiAgICAgIGNvbnN0IGMzID0gTWF0aC5leHAoLWRlbHRhKTtcbiAgICAgIHJldHVybiBzYWZlTWluIC0gYTIgLyBiMiAqIGMzO1xuICAgIH07XG4gICAgZGVyaXZhdGl2ZSA9ICh1bmRhbXBlZEZyZXEyKSA9PiB7XG4gICAgICBjb25zdCBleHBvbmVudGlhbERlY2F5ID0gdW5kYW1wZWRGcmVxMiAqIGRhbXBpbmdSYXRpbztcbiAgICAgIGNvbnN0IGRlbHRhID0gZXhwb25lbnRpYWxEZWNheSAqIGR1cmF0aW9uO1xuICAgICAgY29uc3QgZDIgPSBkZWx0YSAqIHZlbG9jaXR5ICsgdmVsb2NpdHk7XG4gICAgICBjb25zdCBlID0gTWF0aC5wb3coZGFtcGluZ1JhdGlvLCAyKSAqIE1hdGgucG93KHVuZGFtcGVkRnJlcTIsIDIpICogZHVyYXRpb247XG4gICAgICBjb25zdCBmMiA9IE1hdGguZXhwKC1kZWx0YSk7XG4gICAgICBjb25zdCBnMiA9IGNhbGNBbmd1bGFyRnJlcShNYXRoLnBvdyh1bmRhbXBlZEZyZXEyLCAyKSwgZGFtcGluZ1JhdGlvKTtcbiAgICAgIGNvbnN0IGZhY3RvciA9IC1lbnZlbG9wZSh1bmRhbXBlZEZyZXEyKSArIHNhZmVNaW4gPiAwID8gLTEgOiAxO1xuICAgICAgcmV0dXJuIGZhY3RvciAqICgoZDIgLSBlKSAqIGYyKSAvIGcyO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZW52ZWxvcGUgPSAodW5kYW1wZWRGcmVxMikgPT4ge1xuICAgICAgY29uc3QgYTIgPSBNYXRoLmV4cCgtdW5kYW1wZWRGcmVxMiAqIGR1cmF0aW9uKTtcbiAgICAgIGNvbnN0IGIyID0gKHVuZGFtcGVkRnJlcTIgLSB2ZWxvY2l0eSkgKiBkdXJhdGlvbiArIDE7XG4gICAgICByZXR1cm4gLXNhZmVNaW4gKyBhMiAqIGIyO1xuICAgIH07XG4gICAgZGVyaXZhdGl2ZSA9ICh1bmRhbXBlZEZyZXEyKSA9PiB7XG4gICAgICBjb25zdCBhMiA9IE1hdGguZXhwKC11bmRhbXBlZEZyZXEyICogZHVyYXRpb24pO1xuICAgICAgY29uc3QgYjIgPSAodmVsb2NpdHkgLSB1bmRhbXBlZEZyZXEyKSAqIChkdXJhdGlvbiAqIGR1cmF0aW9uKTtcbiAgICAgIHJldHVybiBhMiAqIGIyO1xuICAgIH07XG4gIH1cbiAgY29uc3QgaW5pdGlhbEd1ZXNzID0gNSAvIGR1cmF0aW9uO1xuICBjb25zdCB1bmRhbXBlZEZyZXEgPSBhcHByb3hpbWF0ZVJvb3QoZW52ZWxvcGUsIGRlcml2YXRpdmUsIGluaXRpYWxHdWVzcyk7XG4gIGR1cmF0aW9uID0gZHVyYXRpb24gKiAxZTM7XG4gIGlmIChpc05hTih1bmRhbXBlZEZyZXEpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0aWZmbmVzczogMTAwLFxuICAgICAgZGFtcGluZzogMTAsXG4gICAgICBkdXJhdGlvblxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RpZmZuZXNzID0gTWF0aC5wb3codW5kYW1wZWRGcmVxLCAyKSAqIG1hc3M7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0aWZmbmVzcyxcbiAgICAgIGRhbXBpbmc6IGRhbXBpbmdSYXRpbyAqIDIgKiBNYXRoLnNxcnQobWFzcyAqIHN0aWZmbmVzcyksXG4gICAgICBkdXJhdGlvblxuICAgIH07XG4gIH1cbn1cbnZhciByb290SXRlcmF0aW9ucyA9IDEyO1xuZnVuY3Rpb24gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpIHtcbiAgbGV0IHJlc3VsdCA9IGluaXRpYWxHdWVzcztcbiAgZm9yIChsZXQgaTIgPSAxOyBpMiA8IHJvb3RJdGVyYXRpb25zOyBpMisrKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0IC0gZW52ZWxvcGUocmVzdWx0KSAvIGRlcml2YXRpdmUocmVzdWx0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcSwgZGFtcGluZ1JhdGlvKSB7XG4gIHJldHVybiB1bmRhbXBlZEZyZXEgKiBNYXRoLnNxcnQoMSAtIGRhbXBpbmdSYXRpbyAqIGRhbXBpbmdSYXRpbyk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL2dlbmVyYXRvcnMvc3ByaW5nLm1qc1xudmFyIGR1cmF0aW9uS2V5cyA9IFtcImR1cmF0aW9uXCIsIFwiYm91bmNlXCJdO1xudmFyIHBoeXNpY3NLZXlzID0gW1wic3RpZmZuZXNzXCIsIFwiZGFtcGluZ1wiLCBcIm1hc3NcIl07XG5mdW5jdGlvbiBpc1NwcmluZ1R5cGUob3B0aW9ucywga2V5czIpIHtcbiAgcmV0dXJuIGtleXMyLnNvbWUoKGtleSkgPT4gb3B0aW9uc1trZXldICE9PSB2b2lkIDApO1xufVxuZnVuY3Rpb24gZ2V0U3ByaW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gIGxldCBzcHJpbmdPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHZlbG9jaXR5OiAwLCBzdGlmZm5lc3M6IDEwMCwgZGFtcGluZzogMTAsIG1hc3M6IDEsIGlzUmVzb2x2ZWRGcm9tRHVyYXRpb246IGZhbHNlIH0sIG9wdGlvbnMpO1xuICBpZiAoIWlzU3ByaW5nVHlwZShvcHRpb25zLCBwaHlzaWNzS2V5cykgJiYgaXNTcHJpbmdUeXBlKG9wdGlvbnMsIGR1cmF0aW9uS2V5cykpIHtcbiAgICBjb25zdCBkZXJpdmVkID0gZmluZFNwcmluZyhvcHRpb25zKTtcbiAgICBzcHJpbmdPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNwcmluZ09wdGlvbnMpLCBkZXJpdmVkKSwgeyB2ZWxvY2l0eTogMCwgbWFzczogMSB9KTtcbiAgICBzcHJpbmdPcHRpb25zLmlzUmVzb2x2ZWRGcm9tRHVyYXRpb24gPSB0cnVlO1xuICB9XG4gIHJldHVybiBzcHJpbmdPcHRpb25zO1xufVxuZnVuY3Rpb24gc3ByaW5nKF9hKSB7XG4gIHZhciB7IGZyb20gPSAwLCB0byA9IDEsIHJlc3RTcGVlZCA9IDIsIHJlc3REZWx0YSB9ID0gX2EsIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcImZyb21cIiwgXCJ0b1wiLCBcInJlc3RTcGVlZFwiLCBcInJlc3REZWx0YVwiXSk7XG4gIGNvbnN0IHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IGZyb20gfTtcbiAgbGV0IHsgc3RpZmZuZXNzLCBkYW1waW5nLCBtYXNzLCB2ZWxvY2l0eSwgZHVyYXRpb24sIGlzUmVzb2x2ZWRGcm9tRHVyYXRpb24gfSA9IGdldFNwcmluZ09wdGlvbnMob3B0aW9ucyk7XG4gIGxldCByZXNvbHZlU3ByaW5nID0gemVybztcbiAgbGV0IHJlc29sdmVWZWxvY2l0eSA9IHplcm87XG4gIGZ1bmN0aW9uIGNyZWF0ZVNwcmluZygpIHtcbiAgICBjb25zdCBpbml0aWFsVmVsb2NpdHkgPSB2ZWxvY2l0eSA/IC0odmVsb2NpdHkgLyAxZTMpIDogMDtcbiAgICBjb25zdCBpbml0aWFsRGVsdGEgPSB0byAtIGZyb207XG4gICAgY29uc3QgZGFtcGluZ1JhdGlvID0gZGFtcGluZyAvICgyICogTWF0aC5zcXJ0KHN0aWZmbmVzcyAqIG1hc3MpKTtcbiAgICBjb25zdCB1bmRhbXBlZEFuZ3VsYXJGcmVxID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpIC8gMWUzO1xuICAgIGlmIChyZXN0RGVsdGEgPT09IHZvaWQgMCkge1xuICAgICAgcmVzdERlbHRhID0gTWF0aC5taW4oTWF0aC5hYnModG8gLSBmcm9tKSAvIDEwMCwgMC40KTtcbiAgICB9XG4gICAgaWYgKGRhbXBpbmdSYXRpbyA8IDEpIHtcbiAgICAgIGNvbnN0IGFuZ3VsYXJGcmVxID0gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkQW5ndWxhckZyZXEsIGRhbXBpbmdSYXRpbyk7XG4gICAgICByZXNvbHZlU3ByaW5nID0gKHQpID0+IHtcbiAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICByZXR1cm4gdG8gLSBlbnZlbG9wZSAqICgoaW5pdGlhbFZlbG9jaXR5ICsgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgLyBhbmd1bGFyRnJlcSAqIE1hdGguc2luKGFuZ3VsYXJGcmVxICogdCkgKyBpbml0aWFsRGVsdGEgKiBNYXRoLmNvcyhhbmd1bGFyRnJlcSAqIHQpKTtcbiAgICAgIH07XG4gICAgICByZXNvbHZlVmVsb2NpdHkgPSAodCkgPT4ge1xuICAgICAgICBjb25zdCBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgIHJldHVybiBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogZW52ZWxvcGUgKiAoTWF0aC5zaW4oYW5ndWxhckZyZXEgKiB0KSAqIChpbml0aWFsVmVsb2NpdHkgKyBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAvIGFuZ3VsYXJGcmVxICsgaW5pdGlhbERlbHRhICogTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSkgLSBlbnZlbG9wZSAqIChNYXRoLmNvcyhhbmd1bGFyRnJlcSAqIHQpICogKGluaXRpYWxWZWxvY2l0eSArIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpIC0gYW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEgKiBNYXRoLnNpbihhbmd1bGFyRnJlcSAqIHQpKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkYW1waW5nUmF0aW8gPT09IDEpIHtcbiAgICAgIHJlc29sdmVTcHJpbmcgPSAodCkgPT4gdG8gLSBNYXRoLmV4cCgtdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpICogKGluaXRpYWxEZWx0YSArIChpbml0aWFsVmVsb2NpdHkgKyB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAqIHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkYW1wZWRBbmd1bGFyRnJlcSA9IHVuZGFtcGVkQW5ndWxhckZyZXEgKiBNYXRoLnNxcnQoZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvIC0gMSk7XG4gICAgICByZXNvbHZlU3ByaW5nID0gKHQpID0+IHtcbiAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICBjb25zdCBmcmVxRm9yVCA9IE1hdGgubWluKGRhbXBlZEFuZ3VsYXJGcmVxICogdCwgMzAwKTtcbiAgICAgICAgcmV0dXJuIHRvIC0gZW52ZWxvcGUgKiAoKGluaXRpYWxWZWxvY2l0eSArIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpICogTWF0aC5zaW5oKGZyZXFGb3JUKSArIGRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhICogTWF0aC5jb3NoKGZyZXFGb3JUKSkgLyBkYW1wZWRBbmd1bGFyRnJlcTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNyZWF0ZVNwcmluZygpO1xuICByZXR1cm4ge1xuICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gcmVzb2x2ZVNwcmluZyh0KTtcbiAgICAgIGlmICghaXNSZXNvbHZlZEZyb21EdXJhdGlvbikge1xuICAgICAgICBjb25zdCBjdXJyZW50VmVsb2NpdHkgPSByZXNvbHZlVmVsb2NpdHkodCkgKiAxZTM7XG4gICAgICAgIGNvbnN0IGlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCA9IE1hdGguYWJzKGN1cnJlbnRWZWxvY2l0eSkgPD0gcmVzdFNwZWVkO1xuICAgICAgICBjb25zdCBpc0JlbG93RGlzcGxhY2VtZW50VGhyZXNob2xkID0gTWF0aC5hYnModG8gLSBjdXJyZW50KSA8PSByZXN0RGVsdGE7XG4gICAgICAgIHN0YXRlLmRvbmUgPSBpc0JlbG93VmVsb2NpdHlUaHJlc2hvbGQgJiYgaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmRvbmUgPSB0ID49IGR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgc3RhdGUudmFsdWUgPSBzdGF0ZS5kb25lID8gdG8gOiBjdXJyZW50O1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZmxpcFRhcmdldDogKCkgPT4ge1xuICAgICAgdmVsb2NpdHkgPSAtdmVsb2NpdHk7XG4gICAgICBbZnJvbSwgdG9dID0gW3RvLCBmcm9tXTtcbiAgICAgIGNyZWF0ZVNwcmluZygpO1xuICAgIH1cbiAgfTtcbn1cbnNwcmluZy5uZWVkc0ludGVycG9sYXRpb24gPSAoYTIsIGIyKSA9PiB0eXBlb2YgYTIgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGIyID09PSBcInN0cmluZ1wiO1xudmFyIHplcm8gPSAoX3QpID0+IDA7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9wcm9ncmVzcy5tanNcbnZhciBwcm9ncmVzcyA9IChmcm9tLCB0bywgdmFsdWUpID0+IHtcbiAgY29uc3QgdG9Gcm9tRGlmZmVyZW5jZSA9IHRvIC0gZnJvbTtcbiAgcmV0dXJuIHRvRnJvbURpZmZlcmVuY2UgPT09IDAgPyAxIDogKHZhbHVlIC0gZnJvbSkgLyB0b0Zyb21EaWZmZXJlbmNlO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC5tanNcbnZhciBtaXggPSAoZnJvbSwgdG8sIHByb2dyZXNzMykgPT4gLXByb2dyZXNzMyAqIGZyb20gKyBwcm9ncmVzczMgKiB0byArIGZyb207XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9oc2xhLXRvLXJnYmEubWpzXG5mdW5jdGlvbiBodWVUb1JnYihwMiwgcSwgdCkge1xuICBpZiAodCA8IDApXG4gICAgdCArPSAxO1xuICBpZiAodCA+IDEpXG4gICAgdCAtPSAxO1xuICBpZiAodCA8IDEgLyA2KVxuICAgIHJldHVybiBwMiArIChxIC0gcDIpICogNiAqIHQ7XG4gIGlmICh0IDwgMSAvIDIpXG4gICAgcmV0dXJuIHE7XG4gIGlmICh0IDwgMiAvIDMpXG4gICAgcmV0dXJuIHAyICsgKHEgLSBwMikgKiAoMiAvIDMgLSB0KSAqIDY7XG4gIHJldHVybiBwMjtcbn1cbmZ1bmN0aW9uIGhzbGFUb1JnYmEoeyBodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgYWxwaGE6IGFscGhhMiB9KSB7XG4gIGh1ZSAvPSAzNjA7XG4gIHNhdHVyYXRpb24gLz0gMTAwO1xuICBsaWdodG5lc3MgLz0gMTAwO1xuICBsZXQgcmVkID0gMDtcbiAgbGV0IGdyZWVuID0gMDtcbiAgbGV0IGJsdWUgPSAwO1xuICBpZiAoIXNhdHVyYXRpb24pIHtcbiAgICByZWQgPSBncmVlbiA9IGJsdWUgPSBsaWdodG5lc3M7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcSA9IGxpZ2h0bmVzcyA8IDAuNSA/IGxpZ2h0bmVzcyAqICgxICsgc2F0dXJhdGlvbikgOiBsaWdodG5lc3MgKyBzYXR1cmF0aW9uIC0gbGlnaHRuZXNzICogc2F0dXJhdGlvbjtcbiAgICBjb25zdCBwMiA9IDIgKiBsaWdodG5lc3MgLSBxO1xuICAgIHJlZCA9IGh1ZVRvUmdiKHAyLCBxLCBodWUgKyAxIC8gMyk7XG4gICAgZ3JlZW4gPSBodWVUb1JnYihwMiwgcSwgaHVlKTtcbiAgICBibHVlID0gaHVlVG9SZ2IocDIsIHEsIGh1ZSAtIDEgLyAzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlZDogTWF0aC5yb3VuZChyZWQgKiAyNTUpLFxuICAgIGdyZWVuOiBNYXRoLnJvdW5kKGdyZWVuICogMjU1KSxcbiAgICBibHVlOiBNYXRoLnJvdW5kKGJsdWUgKiAyNTUpLFxuICAgIGFscGhhOiBhbHBoYTJcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC1jb2xvci5tanNcbnZhciBtaXhMaW5lYXJDb2xvciA9IChmcm9tLCB0bywgdikgPT4ge1xuICBjb25zdCBmcm9tRXhwbyA9IGZyb20gKiBmcm9tO1xuICBjb25zdCB0b0V4cG8gPSB0byAqIHRvO1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHYgKiAodG9FeHBvIC0gZnJvbUV4cG8pICsgZnJvbUV4cG8pKTtcbn07XG52YXIgY29sb3JUeXBlcyA9IFtoZXgsIHJnYmEsIGhzbGFdO1xudmFyIGdldENvbG9yVHlwZSA9ICh2KSA9PiBjb2xvclR5cGVzLmZpbmQoKHR5cGUpID0+IHR5cGUudGVzdCh2KSk7XG52YXIgbm90QW5pbWF0YWJsZSA9IChjb2xvcjIpID0+IGAnJHtjb2xvcjJ9JyBpcyBub3QgYW4gYW5pbWF0YWJsZSBjb2xvci4gVXNlIHRoZSBlcXVpdmFsZW50IGNvbG9yIGNvZGUgaW5zdGVhZC5gO1xudmFyIG1peENvbG9yID0gKGZyb20sIHRvKSA9PiB7XG4gIGxldCBmcm9tQ29sb3JUeXBlID0gZ2V0Q29sb3JUeXBlKGZyb20pO1xuICBsZXQgdG9Db2xvclR5cGUgPSBnZXRDb2xvclR5cGUodG8pO1xuICBpbnZhcmlhbnQoISFmcm9tQ29sb3JUeXBlLCBub3RBbmltYXRhYmxlKGZyb20pKTtcbiAgaW52YXJpYW50KCEhdG9Db2xvclR5cGUsIG5vdEFuaW1hdGFibGUodG8pKTtcbiAgbGV0IGZyb21Db2xvciA9IGZyb21Db2xvclR5cGUucGFyc2UoZnJvbSk7XG4gIGxldCB0b0NvbG9yID0gdG9Db2xvclR5cGUucGFyc2UodG8pO1xuICBpZiAoZnJvbUNvbG9yVHlwZSA9PT0gaHNsYSkge1xuICAgIGZyb21Db2xvciA9IGhzbGFUb1JnYmEoZnJvbUNvbG9yKTtcbiAgICBmcm9tQ29sb3JUeXBlID0gcmdiYTtcbiAgfVxuICBpZiAodG9Db2xvclR5cGUgPT09IGhzbGEpIHtcbiAgICB0b0NvbG9yID0gaHNsYVRvUmdiYSh0b0NvbG9yKTtcbiAgICB0b0NvbG9yVHlwZSA9IHJnYmE7XG4gIH1cbiAgY29uc3QgYmxlbmRlZCA9IE9iamVjdC5hc3NpZ24oe30sIGZyb21Db2xvcik7XG4gIHJldHVybiAodikgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGJsZW5kZWQpIHtcbiAgICAgIGlmIChrZXkgIT09IFwiYWxwaGFcIikge1xuICAgICAgICBibGVuZGVkW2tleV0gPSBtaXhMaW5lYXJDb2xvcihmcm9tQ29sb3Jba2V5XSwgdG9Db2xvcltrZXldLCB2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYmxlbmRlZC5hbHBoYSA9IG1peChmcm9tQ29sb3IuYWxwaGEsIHRvQ29sb3IuYWxwaGEsIHYpO1xuICAgIHJldHVybiBmcm9tQ29sb3JUeXBlLnRyYW5zZm9ybShibGVuZGVkKTtcbiAgfTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9pbmMubWpzXG52YXIgaXNOdW0gPSAodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9waXBlLm1qc1xudmFyIGNvbWJpbmVGdW5jdGlvbnMgPSAoYTIsIGIyKSA9PiAodikgPT4gYjIoYTIodikpO1xudmFyIHBpcGUgPSAoLi4udHJhbnNmb3JtZXJzKSA9PiB0cmFuc2Zvcm1lcnMucmVkdWNlKGNvbWJpbmVGdW5jdGlvbnMpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvbWl4LWNvbXBsZXgubWpzXG5mdW5jdGlvbiBnZXRNaXhlcihvcmlnaW4sIHRhcmdldCkge1xuICBpZiAoaXNOdW0ob3JpZ2luKSkge1xuICAgIHJldHVybiAodikgPT4gbWl4KG9yaWdpbiwgdGFyZ2V0LCB2KTtcbiAgfSBlbHNlIGlmIChjb2xvci50ZXN0KG9yaWdpbikpIHtcbiAgICByZXR1cm4gbWl4Q29sb3Iob3JpZ2luLCB0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtaXhDb21wbGV4KG9yaWdpbiwgdGFyZ2V0KTtcbiAgfVxufVxudmFyIG1peEFycmF5ID0gKGZyb20sIHRvKSA9PiB7XG4gIGNvbnN0IG91dHB1dCA9IFsuLi5mcm9tXTtcbiAgY29uc3QgbnVtVmFsdWVzID0gb3V0cHV0Lmxlbmd0aDtcbiAgY29uc3QgYmxlbmRWYWx1ZSA9IGZyb20ubWFwKChmcm9tVGhpcywgaTIpID0+IGdldE1peGVyKGZyb21UaGlzLCB0b1tpMl0pKTtcbiAgcmV0dXJuICh2KSA9PiB7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bVZhbHVlczsgaTIrKykge1xuICAgICAgb3V0cHV0W2kyXSA9IGJsZW5kVmFsdWVbaTJdKHYpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufTtcbnZhciBtaXhPYmplY3QgPSAob3JpZ2luLCB0YXJnZXQpID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcmlnaW4pLCB0YXJnZXQpO1xuICBjb25zdCBibGVuZFZhbHVlID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG91dHB1dCkge1xuICAgIGlmIChvcmlnaW5ba2V5XSAhPT0gdm9pZCAwICYmIHRhcmdldFtrZXldICE9PSB2b2lkIDApIHtcbiAgICAgIGJsZW5kVmFsdWVba2V5XSA9IGdldE1peGVyKG9yaWdpbltrZXldLCB0YXJnZXRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAodikgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGJsZW5kVmFsdWUpIHtcbiAgICAgIG91dHB1dFtrZXldID0gYmxlbmRWYWx1ZVtrZXldKHYpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufTtcbmZ1bmN0aW9uIGFuYWx5c2UyKHZhbHVlKSB7XG4gIGNvbnN0IHBhcnNlZCA9IGNvbXBsZXgucGFyc2UodmFsdWUpO1xuICBjb25zdCBudW1WYWx1ZXMgPSBwYXJzZWQubGVuZ3RoO1xuICBsZXQgbnVtTnVtYmVycyA9IDA7XG4gIGxldCBudW1SR0IgPSAwO1xuICBsZXQgbnVtSFNMID0gMDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bVZhbHVlczsgaTIrKykge1xuICAgIGlmIChudW1OdW1iZXJzIHx8IHR5cGVvZiBwYXJzZWRbaTJdID09PSBcIm51bWJlclwiKSB7XG4gICAgICBudW1OdW1iZXJzKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJzZWRbaTJdLmh1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG51bUhTTCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnVtUkdCKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHBhcnNlZCwgbnVtTnVtYmVycywgbnVtUkdCLCBudW1IU0wgfTtcbn1cbnZhciBtaXhDb21wbGV4ID0gKG9yaWdpbiwgdGFyZ2V0KSA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlID0gY29tcGxleC5jcmVhdGVUcmFuc2Zvcm1lcih0YXJnZXQpO1xuICBjb25zdCBvcmlnaW5TdGF0cyA9IGFuYWx5c2UyKG9yaWdpbik7XG4gIGNvbnN0IHRhcmdldFN0YXRzID0gYW5hbHlzZTIodGFyZ2V0KTtcbiAgY29uc3QgY2FuSW50ZXJwb2xhdGUgPSBvcmlnaW5TdGF0cy5udW1IU0wgPT09IHRhcmdldFN0YXRzLm51bUhTTCAmJiBvcmlnaW5TdGF0cy5udW1SR0IgPT09IHRhcmdldFN0YXRzLm51bVJHQiAmJiBvcmlnaW5TdGF0cy5udW1OdW1iZXJzID49IHRhcmdldFN0YXRzLm51bU51bWJlcnM7XG4gIGlmIChjYW5JbnRlcnBvbGF0ZSkge1xuICAgIHJldHVybiBwaXBlKG1peEFycmF5KG9yaWdpblN0YXRzLnBhcnNlZCwgdGFyZ2V0U3RhdHMucGFyc2VkKSwgdGVtcGxhdGUpO1xuICB9IGVsc2Uge1xuICAgIHdhcm5pbmcodHJ1ZSwgYENvbXBsZXggdmFsdWVzICcke29yaWdpbn0nIGFuZCAnJHt0YXJnZXR9JyB0b28gZGlmZmVyZW50IHRvIG1peC4gRW5zdXJlIGFsbCBjb2xvcnMgYXJlIG9mIHRoZSBzYW1lIHR5cGUsIGFuZCB0aGF0IGVhY2ggY29udGFpbnMgdGhlIHNhbWUgcXVhbnRpdHkgb2YgbnVtYmVyIGFuZCBjb2xvciB2YWx1ZXMuIEZhbGxpbmcgYmFjayB0byBpbnN0YW50IHRyYW5zaXRpb24uYCk7XG4gICAgcmV0dXJuIChwMikgPT4gYCR7cDIgPiAwID8gdGFyZ2V0IDogb3JpZ2lufWA7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9pbnRlcnBvbGF0ZS5tanNcbnZhciBtaXhOdW1iZXIgPSAoZnJvbSwgdG8pID0+IChwMikgPT4gbWl4KGZyb20sIHRvLCBwMik7XG5mdW5jdGlvbiBkZXRlY3RNaXhlckZhY3Rvcnkodikge1xuICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gbWl4TnVtYmVyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGNvbG9yLnRlc3QodikpIHtcbiAgICAgIHJldHVybiBtaXhDb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1peENvbXBsZXg7XG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gbWl4QXJyYXk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbWl4T2JqZWN0O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVNaXhlcnMob3V0cHV0LCBlYXNlLCBjdXN0b21NaXhlcikge1xuICBjb25zdCBtaXhlcnMgPSBbXTtcbiAgY29uc3QgbWl4ZXJGYWN0b3J5ID0gY3VzdG9tTWl4ZXIgfHwgZGV0ZWN0TWl4ZXJGYWN0b3J5KG91dHB1dFswXSk7XG4gIGNvbnN0IG51bU1peGVycyA9IG91dHB1dC5sZW5ndGggLSAxO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtTWl4ZXJzOyBpMisrKSB7XG4gICAgbGV0IG1peGVyID0gbWl4ZXJGYWN0b3J5KG91dHB1dFtpMl0sIG91dHB1dFtpMiArIDFdKTtcbiAgICBpZiAoZWFzZSkge1xuICAgICAgY29uc3QgZWFzaW5nRnVuY3Rpb24gPSBBcnJheS5pc0FycmF5KGVhc2UpID8gZWFzZVtpMl0gOiBlYXNlO1xuICAgICAgbWl4ZXIgPSBwaXBlKGVhc2luZ0Z1bmN0aW9uLCBtaXhlcik7XG4gICAgfVxuICAgIG1peGVycy5wdXNoKG1peGVyKTtcbiAgfVxuICByZXR1cm4gbWl4ZXJzO1xufVxuZnVuY3Rpb24gZmFzdEludGVycG9sYXRlKFtmcm9tLCB0b10sIFttaXhlcl0pIHtcbiAgcmV0dXJuICh2KSA9PiBtaXhlcihwcm9ncmVzcyhmcm9tLCB0bywgdikpO1xufVxuZnVuY3Rpb24gc2xvd0ludGVycG9sYXRlKGlucHV0LCBtaXhlcnMpIHtcbiAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIGNvbnN0IGxhc3RJbnB1dEluZGV4ID0gaW5wdXRMZW5ndGggLSAxO1xuICByZXR1cm4gKHYpID0+IHtcbiAgICBsZXQgbWl4ZXJJbmRleCA9IDA7XG4gICAgbGV0IGZvdW5kTWl4ZXJJbmRleCA9IGZhbHNlO1xuICAgIGlmICh2IDw9IGlucHV0WzBdKSB7XG4gICAgICBmb3VuZE1peGVySW5kZXggPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodiA+PSBpbnB1dFtsYXN0SW5wdXRJbmRleF0pIHtcbiAgICAgIG1peGVySW5kZXggPSBsYXN0SW5wdXRJbmRleCAtIDE7XG4gICAgICBmb3VuZE1peGVySW5kZXggPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWZvdW5kTWl4ZXJJbmRleCkge1xuICAgICAgbGV0IGkyID0gMTtcbiAgICAgIGZvciAoOyBpMiA8IGlucHV0TGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGlmIChpbnB1dFtpMl0gPiB2IHx8IGkyID09PSBsYXN0SW5wdXRJbmRleCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtaXhlckluZGV4ID0gaTIgLSAxO1xuICAgIH1cbiAgICBjb25zdCBwcm9ncmVzc0luUmFuZ2UgPSBwcm9ncmVzcyhpbnB1dFttaXhlckluZGV4XSwgaW5wdXRbbWl4ZXJJbmRleCArIDFdLCB2KTtcbiAgICByZXR1cm4gbWl4ZXJzW21peGVySW5kZXhdKHByb2dyZXNzSW5SYW5nZSk7XG4gIH07XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShpbnB1dCwgb3V0cHV0LCB7IGNsYW1wOiBpc0NsYW1wID0gdHJ1ZSwgZWFzZSwgbWl4ZXIgfSA9IHt9KSB7XG4gIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBpbnZhcmlhbnQoaW5wdXRMZW5ndGggPT09IG91dHB1dC5sZW5ndGgsIFwiQm90aCBpbnB1dCBhbmQgb3V0cHV0IHJhbmdlcyBtdXN0IGJlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgaW52YXJpYW50KCFlYXNlIHx8ICFBcnJheS5pc0FycmF5KGVhc2UpIHx8IGVhc2UubGVuZ3RoID09PSBpbnB1dExlbmd0aCAtIDEsIFwiQXJyYXkgb2YgZWFzaW5nIGZ1bmN0aW9ucyBtdXN0IGJlIG9mIGxlbmd0aCBgaW5wdXQubGVuZ3RoIC0gMWAsIGFzIGl0IGFwcGxpZXMgdG8gdGhlIHRyYW5zaXRpb25zICoqYmV0d2VlbioqIHRoZSBkZWZpbmVkIHZhbHVlcy5cIik7XG4gIGlmIChpbnB1dFswXSA+IGlucHV0W2lucHV0TGVuZ3RoIC0gMV0pIHtcbiAgICBpbnB1dCA9IFtdLmNvbmNhdChpbnB1dCk7XG4gICAgb3V0cHV0ID0gW10uY29uY2F0KG91dHB1dCk7XG4gICAgaW5wdXQucmV2ZXJzZSgpO1xuICAgIG91dHB1dC5yZXZlcnNlKCk7XG4gIH1cbiAgY29uc3QgbWl4ZXJzID0gY3JlYXRlTWl4ZXJzKG91dHB1dCwgZWFzZSwgbWl4ZXIpO1xuICBjb25zdCBpbnRlcnBvbGF0b3IgPSBpbnB1dExlbmd0aCA9PT0gMiA/IGZhc3RJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKSA6IHNsb3dJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKTtcbiAgcmV0dXJuIGlzQ2xhbXAgPyAodikgPT4gaW50ZXJwb2xhdG9yKGNsYW1wMihpbnB1dFswXSwgaW5wdXRbaW5wdXRMZW5ndGggLSAxXSwgdikpIDogaW50ZXJwb2xhdG9yO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvZWFzaW5nL3V0aWxzLm1qc1xudmFyIHJldmVyc2VFYXNpbmcgPSAoZWFzaW5nKSA9PiAocDIpID0+IDEgLSBlYXNpbmcoMSAtIHAyKTtcbnZhciBtaXJyb3JFYXNpbmcgPSAoZWFzaW5nKSA9PiAocDIpID0+IHAyIDw9IDAuNSA/IGVhc2luZygyICogcDIpIC8gMiA6ICgyIC0gZWFzaW5nKDIgKiAoMSAtIHAyKSkpIC8gMjtcbnZhciBjcmVhdGVFeHBvSW4gPSAocG93ZXIpID0+IChwMikgPT4gTWF0aC5wb3cocDIsIHBvd2VyKTtcbnZhciBjcmVhdGVCYWNrSW4gPSAocG93ZXIpID0+IChwMikgPT4gcDIgKiBwMiAqICgocG93ZXIgKyAxKSAqIHAyIC0gcG93ZXIpO1xudmFyIGNyZWF0ZUFudGljaXBhdGUgPSAocG93ZXIpID0+IHtcbiAgY29uc3QgYmFja0Vhc2luZyA9IGNyZWF0ZUJhY2tJbihwb3dlcik7XG4gIHJldHVybiAocDIpID0+IChwMiAqPSAyKSA8IDEgPyAwLjUgKiBiYWNrRWFzaW5nKHAyKSA6IDAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHAyIC0gMSkpKTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9lYXNpbmcvaW5kZXgubWpzXG52YXIgREVGQVVMVF9PVkVSU0hPT1RfU1RSRU5HVEggPSAxLjUyNTtcbnZhciBCT1VOQ0VfRklSU1RfVEhSRVNIT0xEID0gNCAvIDExO1xudmFyIEJPVU5DRV9TRUNPTkRfVEhSRVNIT0xEID0gOCAvIDExO1xudmFyIEJPVU5DRV9USElSRF9USFJFU0hPTEQgPSA5IC8gMTA7XG52YXIgbGluZWFyID0gKHAyKSA9PiBwMjtcbnZhciBlYXNlSW4gPSBjcmVhdGVFeHBvSW4oMik7XG52YXIgZWFzZU91dCA9IHJldmVyc2VFYXNpbmcoZWFzZUluKTtcbnZhciBlYXNlSW5PdXQgPSBtaXJyb3JFYXNpbmcoZWFzZUluKTtcbnZhciBjaXJjSW4gPSAocDIpID0+IDEgLSBNYXRoLnNpbihNYXRoLmFjb3MocDIpKTtcbnZhciBjaXJjT3V0ID0gcmV2ZXJzZUVhc2luZyhjaXJjSW4pO1xudmFyIGNpcmNJbk91dCA9IG1pcnJvckVhc2luZyhjaXJjT3V0KTtcbnZhciBiYWNrSW4gPSBjcmVhdGVCYWNrSW4oREVGQVVMVF9PVkVSU0hPT1RfU1RSRU5HVEgpO1xudmFyIGJhY2tPdXQgPSByZXZlcnNlRWFzaW5nKGJhY2tJbik7XG52YXIgYmFja0luT3V0ID0gbWlycm9yRWFzaW5nKGJhY2tJbik7XG52YXIgYW50aWNpcGF0ZSA9IGNyZWF0ZUFudGljaXBhdGUoREVGQVVMVF9PVkVSU0hPT1RfU1RSRU5HVEgpO1xudmFyIGNhID0gNDM1NiAvIDM2MTtcbnZhciBjYiA9IDM1NDQyIC8gMTgwNTtcbnZhciBjYyA9IDE2MDYxIC8gMTgwNTtcbnZhciBib3VuY2VPdXQgPSAocDIpID0+IHtcbiAgaWYgKHAyID09PSAxIHx8IHAyID09PSAwKVxuICAgIHJldHVybiBwMjtcbiAgY29uc3QgcDIyID0gcDIgKiBwMjtcbiAgcmV0dXJuIHAyIDwgQk9VTkNFX0ZJUlNUX1RIUkVTSE9MRCA/IDcuNTYyNSAqIHAyMiA6IHAyIDwgQk9VTkNFX1NFQ09ORF9USFJFU0hPTEQgPyA5LjA3NSAqIHAyMiAtIDkuOSAqIHAyICsgMy40IDogcDIgPCBCT1VOQ0VfVEhJUkRfVEhSRVNIT0xEID8gY2EgKiBwMjIgLSBjYiAqIHAyICsgY2MgOiAxMC44ICogcDIgKiBwMiAtIDIwLjUyICogcDIgKyAxMC43Mjtcbn07XG52YXIgYm91bmNlSW4gPSByZXZlcnNlRWFzaW5nKGJvdW5jZU91dCk7XG52YXIgYm91bmNlSW5PdXQgPSAocDIpID0+IHAyIDwgMC41ID8gMC41ICogKDEgLSBib3VuY2VPdXQoMSAtIHAyICogMikpIDogMC41ICogYm91bmNlT3V0KHAyICogMiAtIDEpICsgMC41O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy9nZW5lcmF0b3JzL2tleWZyYW1lcy5tanNcbmZ1bmN0aW9uIGRlZmF1bHRFYXNpbmcodmFsdWVzLCBlYXNpbmcpIHtcbiAgcmV0dXJuIHZhbHVlcy5tYXAoKCkgPT4gZWFzaW5nIHx8IGVhc2VJbk91dCkuc3BsaWNlKDAsIHZhbHVlcy5sZW5ndGggLSAxKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPZmZzZXQodmFsdWVzKSB7XG4gIGNvbnN0IG51bVZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiB2YWx1ZXMubWFwKChfdmFsdWUsIGkyKSA9PiBpMiAhPT0gMCA/IGkyIC8gKG51bVZhbHVlcyAtIDEpIDogMCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0VG9UaW1lcyhvZmZzZXQsIGR1cmF0aW9uKSB7XG4gIHJldHVybiBvZmZzZXQubWFwKChvKSA9PiBvICogZHVyYXRpb24pO1xufVxuZnVuY3Rpb24ga2V5ZnJhbWVzKHsgZnJvbSA9IDAsIHRvID0gMSwgZWFzZSwgb2Zmc2V0LCBkdXJhdGlvbiA9IDMwMCB9KSB7XG4gIGNvbnN0IHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IGZyb20gfTtcbiAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh0bykgPyB0byA6IFtmcm9tLCB0b107XG4gIGNvbnN0IHRpbWVzID0gY29udmVydE9mZnNldFRvVGltZXMob2Zmc2V0ICYmIG9mZnNldC5sZW5ndGggPT09IHZhbHVlcy5sZW5ndGggPyBvZmZzZXQgOiBkZWZhdWx0T2Zmc2V0KHZhbHVlcyksIGR1cmF0aW9uKTtcbiAgZnVuY3Rpb24gY3JlYXRlSW50ZXJwb2xhdG9yKCkge1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aW1lcywgdmFsdWVzLCB7XG4gICAgICBlYXNlOiBBcnJheS5pc0FycmF5KGVhc2UpID8gZWFzZSA6IGRlZmF1bHRFYXNpbmcodmFsdWVzLCBlYXNlKVxuICAgIH0pO1xuICB9XG4gIGxldCBpbnRlcnBvbGF0b3IgPSBjcmVhdGVJbnRlcnBvbGF0b3IoKTtcbiAgcmV0dXJuIHtcbiAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgc3RhdGUudmFsdWUgPSBpbnRlcnBvbGF0b3IodCk7XG4gICAgICBzdGF0ZS5kb25lID0gdCA+PSBkdXJhdGlvbjtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGZsaXBUYXJnZXQ6ICgpID0+IHtcbiAgICAgIHZhbHVlcy5yZXZlcnNlKCk7XG4gICAgICBpbnRlcnBvbGF0b3IgPSBjcmVhdGVJbnRlcnBvbGF0b3IoKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL2dlbmVyYXRvcnMvZGVjYXkubWpzXG5mdW5jdGlvbiBkZWNheSh7IHZlbG9jaXR5ID0gMCwgZnJvbSA9IDAsIHBvd2VyID0gMC44LCB0aW1lQ29uc3RhbnQgPSAzNTAsIHJlc3REZWx0YSA9IDAuNSwgbW9kaWZ5VGFyZ2V0IH0pIHtcbiAgY29uc3Qgc3RhdGUgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogZnJvbSB9O1xuICBsZXQgYW1wbGl0dWRlID0gcG93ZXIgKiB2ZWxvY2l0eTtcbiAgY29uc3QgaWRlYWwgPSBmcm9tICsgYW1wbGl0dWRlO1xuICBjb25zdCB0YXJnZXQgPSBtb2RpZnlUYXJnZXQgPT09IHZvaWQgMCA/IGlkZWFsIDogbW9kaWZ5VGFyZ2V0KGlkZWFsKTtcbiAgaWYgKHRhcmdldCAhPT0gaWRlYWwpXG4gICAgYW1wbGl0dWRlID0gdGFyZ2V0IC0gZnJvbTtcbiAgcmV0dXJuIHtcbiAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgY29uc3QgZGVsdGEgPSAtYW1wbGl0dWRlICogTWF0aC5leHAoLXQgLyB0aW1lQ29uc3RhbnQpO1xuICAgICAgc3RhdGUuZG9uZSA9ICEoZGVsdGEgPiByZXN0RGVsdGEgfHwgZGVsdGEgPCAtcmVzdERlbHRhKTtcbiAgICAgIHN0YXRlLnZhbHVlID0gc3RhdGUuZG9uZSA/IHRhcmdldCA6IHRhcmdldCArIGRlbHRhO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZmxpcFRhcmdldDogKCkgPT4ge1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvdXRpbHMvZGV0ZWN0LWFuaW1hdGlvbi1mcm9tLW9wdGlvbnMubWpzXG52YXIgdHlwZXMgPSB7IGtleWZyYW1lcywgc3ByaW5nLCBkZWNheSB9O1xuZnVuY3Rpb24gZGV0ZWN0QW5pbWF0aW9uRnJvbU9wdGlvbnMoY29uZmlnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy50bykpIHtcbiAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICB9IGVsc2UgaWYgKHR5cGVzW2NvbmZpZy50eXBlXSkge1xuICAgIHJldHVybiB0eXBlc1tjb25maWcudHlwZV07XG4gIH1cbiAgY29uc3Qga2V5czIgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGNvbmZpZykpO1xuICBpZiAoa2V5czIuaGFzKFwiZWFzZVwiKSB8fCBrZXlzMi5oYXMoXCJkdXJhdGlvblwiKSAmJiAha2V5czIuaGFzKFwiZGFtcGluZ1JhdGlvXCIpKSB7XG4gICAgcmV0dXJuIGtleWZyYW1lcztcbiAgfSBlbHNlIGlmIChrZXlzMi5oYXMoXCJkYW1waW5nUmF0aW9cIikgfHwga2V5czIuaGFzKFwic3RpZmZuZXNzXCIpIHx8IGtleXMyLmhhcyhcIm1hc3NcIikgfHwga2V5czIuaGFzKFwiZGFtcGluZ1wiKSB8fCBrZXlzMi5oYXMoXCJyZXN0U3BlZWRcIikgfHwga2V5czIuaGFzKFwicmVzdERlbHRhXCIpKSB7XG4gICAgcmV0dXJuIHNwcmluZztcbiAgfVxuICByZXR1cm4ga2V5ZnJhbWVzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVzeW5jL2Rpc3QvZXMvb24tbmV4dC1mcmFtZS5tanNcbnZhciBkZWZhdWx0VGltZXN0ZXAgPSAxIC8gNjAgKiAxZTM7XG52YXIgZ2V0Q3VycmVudFRpbWUgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgPyAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKSA6ICgpID0+IERhdGUubm93KCk7XG52YXIgb25OZXh0RnJhbWUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gKGNhbGxiYWNrKSA9PiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSA6IChjYWxsYmFjaykgPT4gc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjayhnZXRDdXJyZW50VGltZSgpKSwgZGVmYXVsdFRpbWVzdGVwKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lc3luYy9kaXN0L2VzL2NyZWF0ZS1yZW5kZXItc3RlcC5tanNcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclN0ZXAocnVuTmV4dEZyYW1lMikge1xuICBsZXQgdG9SdW4gPSBbXTtcbiAgbGV0IHRvUnVuTmV4dEZyYW1lID0gW107XG4gIGxldCBudW1Ub1J1biA9IDA7XG4gIGxldCBpc1Byb2Nlc3NpbmcyID0gZmFsc2U7XG4gIGxldCBmbHVzaE5leHRGcmFtZSA9IGZhbHNlO1xuICBjb25zdCB0b0tlZXBBbGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICBjb25zdCBzdGVwID0ge1xuICAgIHNjaGVkdWxlOiAoY2FsbGJhY2ssIGtlZXBBbGl2ZSA9IGZhbHNlLCBpbW1lZGlhdGUgPSBmYWxzZSkgPT4ge1xuICAgICAgY29uc3QgYWRkVG9DdXJyZW50RnJhbWUgPSBpbW1lZGlhdGUgJiYgaXNQcm9jZXNzaW5nMjtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGFkZFRvQ3VycmVudEZyYW1lID8gdG9SdW4gOiB0b1J1bk5leHRGcmFtZTtcbiAgICAgIGlmIChrZWVwQWxpdmUpXG4gICAgICAgIHRvS2VlcEFsaXZlLmFkZChjYWxsYmFjayk7XG4gICAgICBpZiAoYnVmZmVyLmluZGV4T2YoY2FsbGJhY2spID09PSAtMSkge1xuICAgICAgICBidWZmZXIucHVzaChjYWxsYmFjayk7XG4gICAgICAgIGlmIChhZGRUb0N1cnJlbnRGcmFtZSAmJiBpc1Byb2Nlc3NpbmcyKVxuICAgICAgICAgIG51bVRvUnVuID0gdG9SdW4ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH0sXG4gICAgY2FuY2VsOiAoY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IGluZGV4MiA9IHRvUnVuTmV4dEZyYW1lLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgaWYgKGluZGV4MiAhPT0gLTEpXG4gICAgICAgIHRvUnVuTmV4dEZyYW1lLnNwbGljZShpbmRleDIsIDEpO1xuICAgICAgdG9LZWVwQWxpdmUuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIHByb2Nlc3M6IChmcmFtZURhdGEpID0+IHtcbiAgICAgIGlmIChpc1Byb2Nlc3NpbmcyKSB7XG4gICAgICAgIGZsdXNoTmV4dEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaXNQcm9jZXNzaW5nMiA9IHRydWU7XG4gICAgICBbdG9SdW4sIHRvUnVuTmV4dEZyYW1lXSA9IFt0b1J1bk5leHRGcmFtZSwgdG9SdW5dO1xuICAgICAgdG9SdW5OZXh0RnJhbWUubGVuZ3RoID0gMDtcbiAgICAgIG51bVRvUnVuID0gdG9SdW4ubGVuZ3RoO1xuICAgICAgaWYgKG51bVRvUnVuKSB7XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1Ub1J1bjsgaTIrKykge1xuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdG9SdW5baTJdO1xuICAgICAgICAgIGNhbGxiYWNrKGZyYW1lRGF0YSk7XG4gICAgICAgICAgaWYgKHRvS2VlcEFsaXZlLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHN0ZXAuc2NoZWR1bGUoY2FsbGJhY2spO1xuICAgICAgICAgICAgcnVuTmV4dEZyYW1lMigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNQcm9jZXNzaW5nMiA9IGZhbHNlO1xuICAgICAgaWYgKGZsdXNoTmV4dEZyYW1lKSB7XG4gICAgICAgIGZsdXNoTmV4dEZyYW1lID0gZmFsc2U7XG4gICAgICAgIHN0ZXAucHJvY2VzcyhmcmFtZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHN0ZXA7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXN5bmMvZGlzdC9lcy9pbmRleC5tanNcbnZhciBtYXhFbGFwc2VkID0gNDA7XG52YXIgdXNlRGVmYXVsdEVsYXBzZWQgPSB0cnVlO1xudmFyIHJ1bk5leHRGcmFtZSA9IGZhbHNlO1xudmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xudmFyIGZyYW1lID0ge1xuICBkZWx0YTogMCxcbiAgdGltZXN0YW1wOiAwXG59O1xudmFyIHN0ZXBzT3JkZXIgPSBbXG4gIFwicmVhZFwiLFxuICBcInVwZGF0ZVwiLFxuICBcInByZVJlbmRlclwiLFxuICBcInJlbmRlclwiLFxuICBcInBvc3RSZW5kZXJcIlxuXTtcbnZhciBzdGVwcyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICBhY2Nba2V5XSA9IGNyZWF0ZVJlbmRlclN0ZXAoKCkgPT4gcnVuTmV4dEZyYW1lID0gdHJ1ZSk7XG4gIHJldHVybiBhY2M7XG59LCB7fSk7XG52YXIgc3luYyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICBjb25zdCBzdGVwID0gc3RlcHNba2V5XTtcbiAgYWNjW2tleV0gPSAocHJvY2VzczIsIGtlZXBBbGl2ZSA9IGZhbHNlLCBpbW1lZGlhdGUgPSBmYWxzZSkgPT4ge1xuICAgIGlmICghcnVuTmV4dEZyYW1lKVxuICAgICAgc3RhcnRMb29wKCk7XG4gICAgcmV0dXJuIHN0ZXAuc2NoZWR1bGUocHJvY2VzczIsIGtlZXBBbGl2ZSwgaW1tZWRpYXRlKTtcbiAgfTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9KTtcbnZhciBjYW5jZWxTeW5jID0gc3RlcHNPcmRlci5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gIGFjY1trZXldID0gc3RlcHNba2V5XS5jYW5jZWw7XG4gIHJldHVybiBhY2M7XG59LCB7fSk7XG52YXIgZmx1c2hTeW5jID0gc3RlcHNPcmRlci5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gIGFjY1trZXldID0gKCkgPT4gc3RlcHNba2V5XS5wcm9jZXNzKGZyYW1lKTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9KTtcbnZhciBwcm9jZXNzU3RlcCA9IChzdGVwSWQpID0+IHN0ZXBzW3N0ZXBJZF0ucHJvY2VzcyhmcmFtZSk7XG52YXIgcHJvY2Vzc0ZyYW1lID0gKHRpbWVzdGFtcCkgPT4ge1xuICBydW5OZXh0RnJhbWUgPSBmYWxzZTtcbiAgZnJhbWUuZGVsdGEgPSB1c2VEZWZhdWx0RWxhcHNlZCA/IGRlZmF1bHRUaW1lc3RlcCA6IE1hdGgubWF4KE1hdGgubWluKHRpbWVzdGFtcCAtIGZyYW1lLnRpbWVzdGFtcCwgbWF4RWxhcHNlZCksIDEpO1xuICBmcmFtZS50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gIGlzUHJvY2Vzc2luZyA9IHRydWU7XG4gIHN0ZXBzT3JkZXIuZm9yRWFjaChwcm9jZXNzU3RlcCk7XG4gIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBpZiAocnVuTmV4dEZyYW1lKSB7XG4gICAgdXNlRGVmYXVsdEVsYXBzZWQgPSBmYWxzZTtcbiAgICBvbk5leHRGcmFtZShwcm9jZXNzRnJhbWUpO1xuICB9XG59O1xudmFyIHN0YXJ0TG9vcCA9ICgpID0+IHtcbiAgcnVuTmV4dEZyYW1lID0gdHJ1ZTtcbiAgdXNlRGVmYXVsdEVsYXBzZWQgPSB0cnVlO1xuICBpZiAoIWlzUHJvY2Vzc2luZylcbiAgICBvbk5leHRGcmFtZShwcm9jZXNzRnJhbWUpO1xufTtcbnZhciBnZXRGcmFtZURhdGEgPSAoKSA9PiBmcmFtZTtcbnZhciBlc19kZWZhdWx0ID0gc3luYztcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvdXRpbHMvZWxhcHNlZC5tanNcbmZ1bmN0aW9uIGxvb3BFbGFwc2VkKGVsYXBzZWQsIGR1cmF0aW9uLCBkZWxheTIgPSAwKSB7XG4gIHJldHVybiBlbGFwc2VkIC0gZHVyYXRpb24gLSBkZWxheTI7XG59XG5mdW5jdGlvbiByZXZlcnNlRWxhcHNlZChlbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkyID0gMCwgaXNGb3J3YXJkUGxheWJhY2sgPSB0cnVlKSB7XG4gIHJldHVybiBpc0ZvcndhcmRQbGF5YmFjayA/IGxvb3BFbGFwc2VkKGR1cmF0aW9uICsgLWVsYXBzZWQsIGR1cmF0aW9uLCBkZWxheTIpIDogZHVyYXRpb24gLSAoZWxhcHNlZCAtIGR1cmF0aW9uKSArIGRlbGF5Mjtcbn1cbmZ1bmN0aW9uIGhhc1JlcGVhdERlbGF5RWxhcHNlZChlbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkyLCBpc0ZvcndhcmRQbGF5YmFjaykge1xuICByZXR1cm4gaXNGb3J3YXJkUGxheWJhY2sgPyBlbGFwc2VkID49IGR1cmF0aW9uICsgZGVsYXkyIDogZWxhcHNlZCA8PSAtZGVsYXkyO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy9pbmRleC5tanNcbnZhciBmcmFtZXN5bmMgPSAodXBkYXRlKSA9PiB7XG4gIGNvbnN0IHBhc3NUaW1lc3RhbXAgPSAoeyBkZWx0YSB9KSA9PiB1cGRhdGUoZGVsdGEpO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiAoKSA9PiBlc19kZWZhdWx0LnVwZGF0ZShwYXNzVGltZXN0YW1wLCB0cnVlKSxcbiAgICBzdG9wOiAoKSA9PiBjYW5jZWxTeW5jLnVwZGF0ZShwYXNzVGltZXN0YW1wKVxuICB9O1xufTtcbmZ1bmN0aW9uIGFuaW1hdGUoX2EpIHtcbiAgdmFyIF9iLCBfYztcbiAgdmFyIHsgZnJvbSwgYXV0b3BsYXkgPSB0cnVlLCBkcml2ZXIgPSBmcmFtZXN5bmMsIGVsYXBzZWQgPSAwLCByZXBlYXQ6IHJlcGVhdE1heCA9IDAsIHJlcGVhdFR5cGUgPSBcImxvb3BcIiwgcmVwZWF0RGVsYXkgPSAwLCBvblBsYXksIG9uU3RvcCwgb25Db21wbGV0ZSwgb25SZXBlYXQsIG9uVXBkYXRlIH0gPSBfYSwgb3B0aW9ucyA9IF9fcmVzdChfYSwgW1wiZnJvbVwiLCBcImF1dG9wbGF5XCIsIFwiZHJpdmVyXCIsIFwiZWxhcHNlZFwiLCBcInJlcGVhdFwiLCBcInJlcGVhdFR5cGVcIiwgXCJyZXBlYXREZWxheVwiLCBcIm9uUGxheVwiLCBcIm9uU3RvcFwiLCBcIm9uQ29tcGxldGVcIiwgXCJvblJlcGVhdFwiLCBcIm9uVXBkYXRlXCJdKTtcbiAgbGV0IHsgdG8gfSA9IG9wdGlvbnM7XG4gIGxldCBkcml2ZXJDb250cm9scztcbiAgbGV0IHJlcGVhdENvdW50ID0gMDtcbiAgbGV0IGNvbXB1dGVkRHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICBsZXQgbGF0ZXN0O1xuICBsZXQgaXNDb21wbGV0ZSA9IGZhbHNlO1xuICBsZXQgaXNGb3J3YXJkUGxheWJhY2sgPSB0cnVlO1xuICBsZXQgaW50ZXJwb2xhdGVGcm9tTnVtYmVyO1xuICBjb25zdCBhbmltYXRvciA9IGRldGVjdEFuaW1hdGlvbkZyb21PcHRpb25zKG9wdGlvbnMpO1xuICBpZiAoKF9jID0gKF9iID0gYW5pbWF0b3IpLm5lZWRzSW50ZXJwb2xhdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIGZyb20sIHRvKSkge1xuICAgIGludGVycG9sYXRlRnJvbU51bWJlciA9IGludGVycG9sYXRlKFswLCAxMDBdLCBbZnJvbSwgdG9dLCB7XG4gICAgICBjbGFtcDogZmFsc2VcbiAgICB9KTtcbiAgICBmcm9tID0gMDtcbiAgICB0byA9IDEwMDtcbiAgfVxuICBjb25zdCBhbmltYXRpb24gPSBhbmltYXRvcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZyb20sIHRvIH0pKTtcbiAgZnVuY3Rpb24gcmVwZWF0KCkge1xuICAgIHJlcGVhdENvdW50Kys7XG4gICAgaWYgKHJlcGVhdFR5cGUgPT09IFwicmV2ZXJzZVwiKSB7XG4gICAgICBpc0ZvcndhcmRQbGF5YmFjayA9IHJlcGVhdENvdW50ICUgMiA9PT0gMDtcbiAgICAgIGVsYXBzZWQgPSByZXZlcnNlRWxhcHNlZChlbGFwc2VkLCBjb21wdXRlZER1cmF0aW9uLCByZXBlYXREZWxheSwgaXNGb3J3YXJkUGxheWJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGFwc2VkID0gbG9vcEVsYXBzZWQoZWxhcHNlZCwgY29tcHV0ZWREdXJhdGlvbiwgcmVwZWF0RGVsYXkpO1xuICAgICAgaWYgKHJlcGVhdFR5cGUgPT09IFwibWlycm9yXCIpXG4gICAgICAgIGFuaW1hdGlvbi5mbGlwVGFyZ2V0KCk7XG4gICAgfVxuICAgIGlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICBvblJlcGVhdCAmJiBvblJlcGVhdCgpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgIGRyaXZlckNvbnRyb2xzLnN0b3AoKTtcbiAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUoKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoZGVsdGEpIHtcbiAgICBpZiAoIWlzRm9yd2FyZFBsYXliYWNrKVxuICAgICAgZGVsdGEgPSAtZGVsdGE7XG4gICAgZWxhcHNlZCArPSBkZWx0YTtcbiAgICBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gYW5pbWF0aW9uLm5leHQoTWF0aC5tYXgoMCwgZWxhcHNlZCkpO1xuICAgICAgbGF0ZXN0ID0gc3RhdGUudmFsdWU7XG4gICAgICBpZiAoaW50ZXJwb2xhdGVGcm9tTnVtYmVyKVxuICAgICAgICBsYXRlc3QgPSBpbnRlcnBvbGF0ZUZyb21OdW1iZXIobGF0ZXN0KTtcbiAgICAgIGlzQ29tcGxldGUgPSBpc0ZvcndhcmRQbGF5YmFjayA/IHN0YXRlLmRvbmUgOiBlbGFwc2VkIDw9IDA7XG4gICAgfVxuICAgIG9uVXBkYXRlID09PSBudWxsIHx8IG9uVXBkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblVwZGF0ZShsYXRlc3QpO1xuICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICBpZiAocmVwZWF0Q291bnQgPT09IDApXG4gICAgICAgIGNvbXB1dGVkRHVyYXRpb24gIT09IG51bGwgJiYgY29tcHV0ZWREdXJhdGlvbiAhPT0gdm9pZCAwID8gY29tcHV0ZWREdXJhdGlvbiA6IGNvbXB1dGVkRHVyYXRpb24gPSBlbGFwc2VkO1xuICAgICAgaWYgKHJlcGVhdENvdW50IDwgcmVwZWF0TWF4KSB7XG4gICAgICAgIGhhc1JlcGVhdERlbGF5RWxhcHNlZChlbGFwc2VkLCBjb21wdXRlZER1cmF0aW9uLCByZXBlYXREZWxheSwgaXNGb3J3YXJkUGxheWJhY2spICYmIHJlcGVhdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGxheSgpIHtcbiAgICBvblBsYXkgPT09IG51bGwgfHwgb25QbGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblBsYXkoKTtcbiAgICBkcml2ZXJDb250cm9scyA9IGRyaXZlcih1cGRhdGUpO1xuICAgIGRyaXZlckNvbnRyb2xzLnN0YXJ0KCk7XG4gIH1cbiAgYXV0b3BsYXkgJiYgcGxheSgpO1xuICByZXR1cm4ge1xuICAgIHN0b3A6ICgpID0+IHtcbiAgICAgIG9uU3RvcCA9PT0gbnVsbCB8fCBvblN0b3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uU3RvcCgpO1xuICAgICAgZHJpdmVyQ29udHJvbHMuc3RvcCgpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL3ZlbG9jaXR5LXBlci1zZWNvbmQubWpzXG5mdW5jdGlvbiB2ZWxvY2l0eVBlclNlY29uZCh2ZWxvY2l0eSwgZnJhbWVEdXJhdGlvbikge1xuICByZXR1cm4gZnJhbWVEdXJhdGlvbiA/IHZlbG9jaXR5ICogKDFlMyAvIGZyYW1lRHVyYXRpb24pIDogMDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvaW5lcnRpYS5tanNcbmZ1bmN0aW9uIGluZXJ0aWEoeyBmcm9tID0gMCwgdmVsb2NpdHkgPSAwLCBtaW4sIG1heCwgcG93ZXIgPSAwLjgsIHRpbWVDb25zdGFudCA9IDc1MCwgYm91bmNlU3RpZmZuZXNzID0gNTAwLCBib3VuY2VEYW1waW5nID0gMTAsIHJlc3REZWx0YSA9IDEsIG1vZGlmeVRhcmdldCwgZHJpdmVyLCBvblVwZGF0ZSwgb25Db21wbGV0ZSwgb25TdG9wIH0pIHtcbiAgbGV0IGN1cnJlbnRBbmltYXRpb247XG4gIGZ1bmN0aW9uIGlzT3V0T2ZCb3VuZHModikge1xuICAgIHJldHVybiBtaW4gIT09IHZvaWQgMCAmJiB2IDwgbWluIHx8IG1heCAhPT0gdm9pZCAwICYmIHYgPiBtYXg7XG4gIH1cbiAgZnVuY3Rpb24gYm91bmRhcnlOZWFyZXN0KHYpIHtcbiAgICBpZiAobWluID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbWF4O1xuICAgIGlmIChtYXggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBtaW47XG4gICAgcmV0dXJuIE1hdGguYWJzKG1pbiAtIHYpIDwgTWF0aC5hYnMobWF4IC0gdikgPyBtaW4gOiBtYXg7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRBbmltYXRpb24yKG9wdGlvbnMpIHtcbiAgICBjdXJyZW50QW5pbWF0aW9uID09PSBudWxsIHx8IGN1cnJlbnRBbmltYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRBbmltYXRpb24uc3RvcCgpO1xuICAgIGN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICAgIGRyaXZlcixcbiAgICAgIG9uVXBkYXRlOiAodikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIG9uVXBkYXRlID09PSBudWxsIHx8IG9uVXBkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblVwZGF0ZSh2KTtcbiAgICAgICAgKF9hID0gb3B0aW9ucy5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgdik7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZSxcbiAgICAgIG9uU3RvcFxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBzdGFydFNwcmluZyhvcHRpb25zKSB7XG4gICAgc3RhcnRBbmltYXRpb24yKE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcInNwcmluZ1wiLCBzdGlmZm5lc3M6IGJvdW5jZVN0aWZmbmVzcywgZGFtcGluZzogYm91bmNlRGFtcGluZywgcmVzdERlbHRhIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBpZiAoaXNPdXRPZkJvdW5kcyhmcm9tKSkge1xuICAgIHN0YXJ0U3ByaW5nKHsgZnJvbSwgdmVsb2NpdHksIHRvOiBib3VuZGFyeU5lYXJlc3QoZnJvbSkgfSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHRhcmdldCA9IHBvd2VyICogdmVsb2NpdHkgKyBmcm9tO1xuICAgIGlmICh0eXBlb2YgbW9kaWZ5VGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgdGFyZ2V0ID0gbW9kaWZ5VGFyZ2V0KHRhcmdldCk7XG4gICAgY29uc3QgYm91bmRhcnkgPSBib3VuZGFyeU5lYXJlc3QodGFyZ2V0KTtcbiAgICBjb25zdCBoZWFkaW5nID0gYm91bmRhcnkgPT09IG1pbiA/IC0xIDogMTtcbiAgICBsZXQgcHJldjtcbiAgICBsZXQgY3VycmVudDtcbiAgICBjb25zdCBjaGVja0JvdW5kYXJ5ID0gKHYpID0+IHtcbiAgICAgIHByZXYgPSBjdXJyZW50O1xuICAgICAgY3VycmVudCA9IHY7XG4gICAgICB2ZWxvY2l0eSA9IHZlbG9jaXR5UGVyU2Vjb25kKHYgLSBwcmV2LCBnZXRGcmFtZURhdGEoKS5kZWx0YSk7XG4gICAgICBpZiAoaGVhZGluZyA9PT0gMSAmJiB2ID4gYm91bmRhcnkgfHwgaGVhZGluZyA9PT0gLTEgJiYgdiA8IGJvdW5kYXJ5KSB7XG4gICAgICAgIHN0YXJ0U3ByaW5nKHsgZnJvbTogdiwgdG86IGJvdW5kYXJ5LCB2ZWxvY2l0eSB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN0YXJ0QW5pbWF0aW9uMih7XG4gICAgICB0eXBlOiBcImRlY2F5XCIsXG4gICAgICBmcm9tLFxuICAgICAgdmVsb2NpdHksXG4gICAgICB0aW1lQ29uc3RhbnQsXG4gICAgICBwb3dlcixcbiAgICAgIHJlc3REZWx0YSxcbiAgICAgIG1vZGlmeVRhcmdldCxcbiAgICAgIG9uVXBkYXRlOiBpc091dE9mQm91bmRzKHRhcmdldCkgPyBjaGVja0JvdW5kYXJ5IDogdm9pZCAwXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdG9wOiAoKSA9PiBjdXJyZW50QW5pbWF0aW9uID09PSBudWxsIHx8IGN1cnJlbnRBbmltYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRBbmltYXRpb24uc3RvcCgpXG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9pcy1wb2ludC5tanNcbnZhciBpc1BvaW50ID0gKHBvaW50MikgPT4gcG9pbnQyLmhhc093blByb3BlcnR5KFwieFwiKSAmJiBwb2ludDIuaGFzT3duUHJvcGVydHkoXCJ5XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtcG9pbnQtM2QubWpzXG52YXIgaXNQb2ludDNEID0gKHBvaW50MikgPT4gaXNQb2ludChwb2ludDIpICYmIHBvaW50Mi5oYXNPd25Qcm9wZXJ0eShcInpcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9kaXN0YW5jZS5tanNcbnZhciBkaXN0YW5jZTFEID0gKGEyLCBiMikgPT4gTWF0aC5hYnMoYTIgLSBiMik7XG5mdW5jdGlvbiBkaXN0YW5jZShhMiwgYjIpIHtcbiAgaWYgKGlzTnVtKGEyKSAmJiBpc051bShiMikpIHtcbiAgICByZXR1cm4gZGlzdGFuY2UxRChhMiwgYjIpO1xuICB9IGVsc2UgaWYgKGlzUG9pbnQoYTIpICYmIGlzUG9pbnQoYjIpKSB7XG4gICAgY29uc3QgeERlbHRhID0gZGlzdGFuY2UxRChhMi54LCBiMi54KTtcbiAgICBjb25zdCB5RGVsdGEgPSBkaXN0YW5jZTFEKGEyLnksIGIyLnkpO1xuICAgIGNvbnN0IHpEZWx0YSA9IGlzUG9pbnQzRChhMikgJiYgaXNQb2ludDNEKGIyKSA/IGRpc3RhbmNlMUQoYTIueiwgYjIueikgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeERlbHRhLCAyKSArIE1hdGgucG93KHlEZWx0YSwgMikgKyBNYXRoLnBvdyh6RGVsdGEsIDIpKTtcbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvZWFzaW5nL2N1YmljLWJlemllci5tanNcbnZhciBhID0gKGExLCBhMikgPT4gMSAtIDMgKiBhMiArIDMgKiBhMTtcbnZhciBiID0gKGExLCBhMikgPT4gMyAqIGEyIC0gNiAqIGExO1xudmFyIGMyID0gKGExKSA9PiAzICogYTE7XG52YXIgY2FsY0JlemllciA9ICh0LCBhMSwgYTIpID0+ICgoYShhMSwgYTIpICogdCArIGIoYTEsIGEyKSkgKiB0ICsgYzIoYTEpKSAqIHQ7XG52YXIgZ2V0U2xvcGUgPSAodCwgYTEsIGEyKSA9PiAzICogYShhMSwgYTIpICogdCAqIHQgKyAyICogYihhMSwgYTIpICogdCArIGMyKGExKTtcbnZhciBzdWJkaXZpc2lvblByZWNpc2lvbiA9IDFlLTc7XG52YXIgc3ViZGl2aXNpb25NYXhJdGVyYXRpb25zID0gMTA7XG5mdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcbiAgbGV0IGN1cnJlbnRYO1xuICBsZXQgY3VycmVudFQ7XG4gIGxldCBpMiA9IDA7XG4gIGRvIHtcbiAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMjtcbiAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgIGlmIChjdXJyZW50WCA+IDApIHtcbiAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgfVxuICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBzdWJkaXZpc2lvblByZWNpc2lvbiAmJiArK2kyIDwgc3ViZGl2aXNpb25NYXhJdGVyYXRpb25zKTtcbiAgcmV0dXJuIGN1cnJlbnRUO1xufVxudmFyIG5ld3Rvbkl0ZXJhdGlvbnMgPSA4O1xudmFyIG5ld3Rvbk1pblNsb3BlID0gMWUtMztcbmZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbmV3dG9uSXRlcmF0aW9uczsgKytpMikge1xuICAgIGNvbnN0IGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcbiAgICBpZiAoY3VycmVudFNsb3BlID09PSAwKSB7XG4gICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gIH1cbiAgcmV0dXJuIGFHdWVzc1Q7XG59XG52YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xudmFyIGtTYW1wbGVTdGVwU2l6ZSA9IDEgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEpO1xuZnVuY3Rpb24gY3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMilcbiAgICByZXR1cm4gbGluZWFyO1xuICBjb25zdCBzYW1wbGVWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpMikge1xuICAgIHNhbXBsZVZhbHVlc1tpMl0gPSBjYWxjQmV6aWVyKGkyICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcbiAgICBsZXQgaW50ZXJ2YWxTdGFydCA9IDA7XG4gICAgbGV0IGN1cnJlbnRTYW1wbGUgPSAxO1xuICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcbiAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgfVxuICAgIC0tY3VycmVudFNhbXBsZTtcbiAgICBjb25zdCBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICBjb25zdCBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICBjb25zdCBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICBpZiAoaW5pdGlhbFNsb3BlID49IG5ld3Rvbk1pblNsb3BlKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwKSB7XG4gICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgfVxuICB9XG4gIHJldHVybiAodCkgPT4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IGNhbGNCZXppZXIoZ2V0VEZvclgodCksIG1ZMSwgbVkyKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy91c2UtdGFwLWdlc3R1cmUubWpzXG5mdW5jdGlvbiB1c2VUYXBHZXN0dXJlKHsgb25UYXAsIG9uVGFwU3RhcnQsIG9uVGFwQ2FuY2VsLCB3aGlsZVRhcCwgdmlzdWFsRWxlbWVudCB9KSB7XG4gIGNvbnN0IGhhc1ByZXNzTGlzdGVuZXJzID0gb25UYXAgfHwgb25UYXBTdGFydCB8fCBvblRhcENhbmNlbCB8fCB3aGlsZVRhcDtcbiAgY29uc3QgaXNQcmVzc2luZyA9IHVzZVJlZjMoZmFsc2UpO1xuICBjb25zdCBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzID0gdXNlUmVmMyhudWxsKTtcbiAgY29uc3QgZXZlbnRPcHRpb25zID0ge1xuICAgIHBhc3NpdmU6ICEob25UYXBTdGFydCB8fCBvblRhcCB8fCBvblRhcENhbmNlbCB8fCBvblBvaW50ZXJEb3duKVxuICB9O1xuICBmdW5jdGlvbiByZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIoKSB7XG4gICAgY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50ICYmIGNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMuY3VycmVudCgpO1xuICAgIGNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMuY3VycmVudCA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tQb2ludGVyRW5kKCkge1xuICAgIHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcigpO1xuICAgIGlzUHJlc3NpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUgJiYgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5UYXAsIGZhbHNlKTtcbiAgICByZXR1cm4gIWlzRHJhZ0FjdGl2ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50LCBpbmZvKSB7XG4gICAgaWYgKCFjaGVja1BvaW50ZXJFbmQoKSlcbiAgICAgIHJldHVybjtcbiAgICAhaXNOb2RlT3JDaGlsZCh2aXN1YWxFbGVtZW50LmN1cnJlbnQsIGV2ZW50LnRhcmdldCkgPyBvblRhcENhbmNlbCAmJiBvblRhcENhbmNlbChldmVudCwgaW5mbykgOiBvblRhcCAmJiBvblRhcChldmVudCwgaW5mbyk7XG4gIH1cbiAgZnVuY3Rpb24gb25Qb2ludGVyQ2FuY2VsKGV2ZW50LCBpbmZvKSB7XG4gICAgaWYgKCFjaGVja1BvaW50ZXJFbmQoKSlcbiAgICAgIHJldHVybjtcbiAgICBvblRhcENhbmNlbCAmJiBvblRhcENhbmNlbChldmVudCwgaW5mbyk7XG4gIH1cbiAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCwgaW5mbykge1xuICAgIHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcigpO1xuICAgIGlmIChpc1ByZXNzaW5nLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgaXNQcmVzc2luZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzLmN1cnJlbnQgPSBwaXBlKGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCBldmVudE9wdGlvbnMpLCBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyQ2FuY2VsLCBldmVudE9wdGlvbnMpKTtcbiAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlICYmIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuVGFwLCB0cnVlKTtcbiAgICBvblRhcFN0YXJ0ICYmIG9uVGFwU3RhcnQoZXZlbnQsIGluZm8pO1xuICB9XG4gIHVzZVBvaW50ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIGhhc1ByZXNzTGlzdGVuZXJzID8gb25Qb2ludGVyRG93biA6IHZvaWQgMCwgZXZlbnRPcHRpb25zKTtcbiAgdXNlVW5tb3VudEVmZmVjdChyZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3Byb2Nlc3MubWpzXG52YXIgZGVmYXVsdEVudmlyb25tZW50ID0gXCJwcm9kdWN0aW9uXCI7XG52YXIgZW52ID0gdHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYgPT09IHZvaWQgMCA/IGRlZmF1bHRFbnZpcm9ubWVudCA6IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8IGRlZmF1bHRFbnZpcm9ubWVudDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvdmlld3BvcnQvdXNlLXZpZXdwb3J0Lm1qc1xuaW1wb3J0IHsgdXNlUmVmIGFzIHVzZVJlZjQsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q1IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvd2Fybi1vbmNlLm1qc1xudmFyIHdhcm5lZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5mdW5jdGlvbiB3YXJuT25jZShjb25kaXRpb24sIG1lc3NhZ2UsIGVsZW1lbnQpIHtcbiAgaWYgKGNvbmRpdGlvbiB8fCB3YXJuZWQuaGFzKG1lc3NhZ2UpKVxuICAgIHJldHVybjtcbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICBpZiAoZWxlbWVudClcbiAgICBjb25zb2xlLndhcm4oZWxlbWVudCk7XG4gIHdhcm5lZC5hZGQobWVzc2FnZSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL3ZpZXdwb3J0L29ic2VydmVycy5tanNcbnZhciBvYnNlcnZlckNhbGxiYWNrcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIG9ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIGZpcmVPYnNlcnZlckNhbGxiYWNrID0gKGVudHJ5KSA9PiB7XG4gIGNvbnN0IGNhbGxiYWNrID0gb2JzZXJ2ZXJDYWxsYmFja3MuZ2V0KGVudHJ5LnRhcmdldCk7XG4gIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVudHJ5KTtcbn07XG52YXIgZmlyZUFsbE9ic2VydmVyQ2FsbGJhY2tzID0gKGVudHJpZXMpID0+IHtcbiAgZW50cmllcy5mb3JFYWNoKGZpcmVPYnNlcnZlckNhbGxiYWNrKTtcbn07XG5mdW5jdGlvbiBpbml0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoX2EpIHtcbiAgdmFyIF9iID0gX2EsIHsgcm9vdCB9ID0gX2IsIG9wdGlvbnMgPSBfX29ialJlc3QoX2IsIFtcInJvb3RcIl0pO1xuICBjb25zdCBsb29rdXBSb290ID0gcm9vdCB8fCBkb2N1bWVudDtcbiAgaWYgKCFvYnNlcnZlcnMuaGFzKGxvb2t1cFJvb3QpKSB7XG4gICAgb2JzZXJ2ZXJzLnNldChsb29rdXBSb290LCB7fSk7XG4gIH1cbiAgY29uc3Qgcm9vdE9ic2VydmVycyA9IG9ic2VydmVycy5nZXQobG9va3VwUm9vdCk7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBpZiAoIXJvb3RPYnNlcnZlcnNba2V5XSkge1xuICAgIHJvb3RPYnNlcnZlcnNba2V5XSA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihmaXJlQWxsT2JzZXJ2ZXJDYWxsYmFja3MsIF9fc3ByZWFkVmFsdWVzKHsgcm9vdCB9LCBvcHRpb25zKSk7XG4gIH1cbiAgcmV0dXJuIHJvb3RPYnNlcnZlcnNba2V5XTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVJbnRlcnNlY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vdEludGVyZXNlY3Rpb25PYnNlcnZlciA9IGluaXRJbnRlcnNlY3Rpb25PYnNlcnZlcihvcHRpb25zKTtcbiAgb2JzZXJ2ZXJDYWxsYmFja3Muc2V0KGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgcm9vdEludGVyZXNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIG9ic2VydmVyQ2FsbGJhY2tzLmRlbGV0ZShlbGVtZW50KTtcbiAgICByb290SW50ZXJlc2VjdGlvbk9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvdmlld3BvcnQvdXNlLXZpZXdwb3J0Lm1qc1xuZnVuY3Rpb24gdXNlVmlld3BvcnQoeyB2aXN1YWxFbGVtZW50LCB3aGlsZUluVmlldywgb25WaWV3cG9ydEVudGVyLCBvblZpZXdwb3J0TGVhdmUsIHZpZXdwb3J0ID0ge30gfSkge1xuICBjb25zdCBzdGF0ZSA9IHVzZVJlZjQoe1xuICAgIGhhc0VudGVyZWRWaWV3OiBmYWxzZSxcbiAgICBpc0luVmlldzogZmFsc2VcbiAgfSk7XG4gIGxldCBzaG91bGRPYnNlcnZlID0gQm9vbGVhbih3aGlsZUluVmlldyB8fCBvblZpZXdwb3J0RW50ZXIgfHwgb25WaWV3cG9ydExlYXZlKTtcbiAgaWYgKHZpZXdwb3J0Lm9uY2UgJiYgc3RhdGUuY3VycmVudC5oYXNFbnRlcmVkVmlldylcbiAgICBzaG91bGRPYnNlcnZlID0gZmFsc2U7XG4gIGNvbnN0IHVzZU9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiID8gdXNlTWlzc2luZ0ludGVyc2VjdGlvbk9ic2VydmVyIDogdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gIHVzZU9ic2VydmVyKHNob3VsZE9ic2VydmUsIHN0YXRlLmN1cnJlbnQsIHZpc3VhbEVsZW1lbnQsIHZpZXdwb3J0KTtcbn1cbnZhciB0aHJlc2hvbGROYW1lcyA9IHtcbiAgc29tZTogMCxcbiAgYWxsOiAxXG59O1xuZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoc2hvdWxkT2JzZXJ2ZSwgc3RhdGUsIHZpc3VhbEVsZW1lbnQsIHsgcm9vdCwgbWFyZ2luOiByb290TWFyZ2luLCBhbW91bnQgPSBcInNvbWVcIiwgb25jZSB9KSB7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIGlmICghc2hvdWxkT2JzZXJ2ZSB8fCAhdmlzdWFsRWxlbWVudC5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByb290OiByb290ID09PSBudWxsIHx8IHJvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvb3QuY3VycmVudCxcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIgPyBhbW91bnQgOiB0aHJlc2hvbGROYW1lc1thbW91bnRdXG4gICAgfTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25DYWxsYmFjayA9IChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgeyBpc0ludGVyc2VjdGluZyB9ID0gZW50cnk7XG4gICAgICBpZiAoc3RhdGUuaXNJblZpZXcgPT09IGlzSW50ZXJzZWN0aW5nKVxuICAgICAgICByZXR1cm47XG4gICAgICBzdGF0ZS5pc0luVmlldyA9IGlzSW50ZXJzZWN0aW5nO1xuICAgICAgaWYgKG9uY2UgJiYgIWlzSW50ZXJzZWN0aW5nICYmIHN0YXRlLmhhc0VudGVyZWRWaWV3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgc3RhdGUuaGFzRW50ZXJlZFZpZXcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5JblZpZXcsIGlzSW50ZXJzZWN0aW5nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BzID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBpc0ludGVyc2VjdGluZyA/IHByb3BzLm9uVmlld3BvcnRFbnRlciA6IHByb3BzLm9uVmlld3BvcnRMZWF2ZTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVudHJ5KTtcbiAgICB9O1xuICAgIHJldHVybiBvYnNlcnZlSW50ZXJzZWN0aW9uKHZpc3VhbEVsZW1lbnQuY3VycmVudCwgb3B0aW9ucywgaW50ZXJzZWN0aW9uQ2FsbGJhY2spO1xuICB9LCBbc2hvdWxkT2JzZXJ2ZSwgcm9vdCwgcm9vdE1hcmdpbiwgYW1vdW50XSk7XG59XG5mdW5jdGlvbiB1c2VNaXNzaW5nSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoc2hvdWxkT2JzZXJ2ZSwgc3RhdGUsIHZpc3VhbEVsZW1lbnQsIHsgZmFsbGJhY2sgPSB0cnVlIH0pIHtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgaWYgKCFzaG91bGRPYnNlcnZlIHx8ICFmYWxsYmFjaylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZW52ICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2Fybk9uY2UoZmFsc2UsIFwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgbm90IGF2YWlsYWJsZSBvbiB0aGlzIGRldmljZS4gd2hpbGVJblZpZXcgYW5pbWF0aW9ucyB3aWxsIHRyaWdnZXIgb24gbW91bnQuXCIpO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgc3RhdGUuaGFzRW50ZXJlZFZpZXcgPSB0cnVlO1xuICAgICAgY29uc3QgeyBvblZpZXdwb3J0RW50ZXIgfSA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgIG9uVmlld3BvcnRFbnRlciAmJiBvblZpZXdwb3J0RW50ZXIobnVsbCk7XG4gICAgICBpZiAodmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkge1xuICAgICAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkluVmlldywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtzaG91bGRPYnNlcnZlXSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL21ha2UtcmVuZGVybGVzcy1jb21wb25lbnQubWpzXG52YXIgbWFrZVJlbmRlcmxlc3NDb21wb25lbnQgPSAoaG9vaykgPT4gKHByb3BzKSA9PiB7XG4gIGhvb2socHJvcHMpO1xuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2dlc3R1cmVzLm1qc1xudmFyIGdlc3R1cmVBbmltYXRpb25zID0ge1xuICBpblZpZXc6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZVZpZXdwb3J0KSxcbiAgdGFwOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VUYXBHZXN0dXJlKSxcbiAgZm9jdXM6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZUZvY3VzR2VzdHVyZSksXG4gIGhvdmVyOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VIb3Zlckdlc3R1cmUpXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9hbmltYXRpb25zLm1qc1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDcsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDcgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0FuaW1hdGVQcmVzZW5jZS91c2UtcHJlc2VuY2UubWpzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ2LCB1c2VJZCwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDYgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVByZXNlbmNlKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDYoUHJlc2VuY2VDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpXG4gICAgcmV0dXJuIFt0cnVlLCBudWxsXTtcbiAgY29uc3QgeyBpc1ByZXNlbnQsIG9uRXhpdENvbXBsZXRlLCByZWdpc3RlciB9ID0gY29udGV4dDtcbiAgY29uc3QgaWQyID0gdXNlSWQoKTtcbiAgdXNlRWZmZWN0NigoKSA9PiByZWdpc3RlcihpZDIpLCBbXSk7XG4gIGNvbnN0IHNhZmVUb1JlbW92ZSA9ICgpID0+IG9uRXhpdENvbXBsZXRlICYmIG9uRXhpdENvbXBsZXRlKGlkMik7XG4gIHJldHVybiAhaXNQcmVzZW50ICYmIG9uRXhpdENvbXBsZXRlID8gW2ZhbHNlLCBzYWZlVG9SZW1vdmVdIDogW3RydWVdO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3NoYWxsb3ctY29tcGFyZS5tanNcbmZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByZXYpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJldkxlbmd0aCA9IHByZXYubGVuZ3RoO1xuICBpZiAocHJldkxlbmd0aCAhPT0gbmV4dC5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgcHJldkxlbmd0aDsgaTIrKykge1xuICAgIGlmIChwcmV2W2kyXSAhPT0gbmV4dFtpMl0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdGltZS1jb252ZXJzaW9uLm1qc1xudmFyIHNlY29uZHNUb01pbGxpc2Vjb25kcyA9IChzZWNvbmRzKSA9PiBzZWNvbmRzICogMWUzO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9lYXNpbmcubWpzXG52YXIgZWFzaW5nTG9va3VwID0ge1xuICBsaW5lYXIsXG4gIGVhc2VJbixcbiAgZWFzZUluT3V0LFxuICBlYXNlT3V0LFxuICBjaXJjSW4sXG4gIGNpcmNJbk91dCxcbiAgY2lyY091dCxcbiAgYmFja0luLFxuICBiYWNrSW5PdXQsXG4gIGJhY2tPdXQsXG4gIGFudGljaXBhdGUsXG4gIGJvdW5jZUluLFxuICBib3VuY2VJbk91dCxcbiAgYm91bmNlT3V0XG59O1xudmFyIGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uID0gKGRlZmluaXRpb24pID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICBpbnZhcmlhbnQoZGVmaW5pdGlvbi5sZW5ndGggPT09IDQsIGBDdWJpYyBiZXppZXIgYXJyYXlzIG11c3QgY29udGFpbiBmb3VyIG51bWVyaWNhbCB2YWx1ZXMuYCk7XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IGRlZmluaXRpb247XG4gICAgcmV0dXJuIGN1YmljQmV6aWVyKHgxLCB5MSwgeDIsIHkyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgIGludmFyaWFudChlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl0gIT09IHZvaWQgMCwgYEludmFsaWQgZWFzaW5nIHR5cGUgJyR7ZGVmaW5pdGlvbn0nYCk7XG4gICAgcmV0dXJuIGVhc2luZ0xvb2t1cFtkZWZpbml0aW9uXTtcbiAgfVxuICByZXR1cm4gZGVmaW5pdGlvbjtcbn07XG52YXIgaXNFYXNpbmdBcnJheSA9IChlYXNlKSA9PiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGVhc2UpICYmIHR5cGVvZiBlYXNlWzBdICE9PSBcIm51bWJlclwiO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvaXMtYW5pbWF0YWJsZS5tanNcbnZhciBpc0FuaW1hdGFibGUgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICBpZiAoa2V5ID09PSBcInpJbmRleFwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBjb21wbGV4LnRlc3QodmFsdWUpICYmICF2YWx1ZS5zdGFydHNXaXRoKFwidXJsKFwiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2RlZmF1bHQtdHJhbnNpdGlvbnMubWpzXG52YXIgdW5kZXJEYW1wZWRTcHJpbmcgPSAoKSA9PiAoe1xuICB0eXBlOiBcInNwcmluZ1wiLFxuICBzdGlmZm5lc3M6IDUwMCxcbiAgZGFtcGluZzogMjUsXG4gIHJlc3RTcGVlZDogMTBcbn0pO1xudmFyIGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcgPSAodG8pID0+ICh7XG4gIHR5cGU6IFwic3ByaW5nXCIsXG4gIHN0aWZmbmVzczogNTUwLFxuICBkYW1waW5nOiB0byA9PT0gMCA/IDIgKiBNYXRoLnNxcnQoNTUwKSA6IDMwLFxuICByZXN0U3BlZWQ6IDEwXG59KTtcbnZhciBsaW5lYXJUd2VlbiA9ICgpID0+ICh7XG4gIHR5cGU6IFwia2V5ZnJhbWVzXCIsXG4gIGVhc2U6IFwibGluZWFyXCIsXG4gIGR1cmF0aW9uOiAwLjNcbn0pO1xudmFyIGtleWZyYW1lczIgPSAodmFsdWVzKSA9PiAoe1xuICB0eXBlOiBcImtleWZyYW1lc1wiLFxuICBkdXJhdGlvbjogMC44LFxuICB2YWx1ZXNcbn0pO1xudmFyIGRlZmF1bHRUcmFuc2l0aW9ucyA9IHtcbiAgeDogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHk6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICB6OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgcm90YXRlOiB1bmRlckRhbXBlZFNwcmluZyxcbiAgcm90YXRlWDogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHJvdGF0ZVk6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICByb3RhdGVaOiB1bmRlckRhbXBlZFNwcmluZyxcbiAgc2NhbGVYOiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nLFxuICBzY2FsZVk6IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsXG4gIHNjYWxlOiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nLFxuICBvcGFjaXR5OiBsaW5lYXJUd2VlbixcbiAgYmFja2dyb3VuZENvbG9yOiBsaW5lYXJUd2VlbixcbiAgY29sb3I6IGxpbmVhclR3ZWVuLFxuICBkZWZhdWx0OiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nXG59O1xudmFyIGdldERlZmF1bHRUcmFuc2l0aW9uID0gKHZhbHVlS2V5LCB0bykgPT4ge1xuICBsZXQgdHJhbnNpdGlvbkZhY3Rvcnk7XG4gIGlmIChpc0tleWZyYW1lc1RhcmdldCh0bykpIHtcbiAgICB0cmFuc2l0aW9uRmFjdG9yeSA9IGtleWZyYW1lczI7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNpdGlvbkZhY3RvcnkgPSBkZWZhdWx0VHJhbnNpdGlvbnNbdmFsdWVLZXldIHx8IGRlZmF1bHRUcmFuc2l0aW9ucy5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7IHRvIH0sIHRyYW5zaXRpb25GYWN0b3J5KHRvKSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZGVmYXVsdHMubWpzXG52YXIgZGVmYXVsdFZhbHVlVHlwZXMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBudW1iZXJWYWx1ZVR5cGVzKSwge1xuICBjb2xvcixcbiAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgb3V0bGluZUNvbG9yOiBjb2xvcixcbiAgZmlsbDogY29sb3IsXG4gIHN0cm9rZTogY29sb3IsXG4gIGJvcmRlckNvbG9yOiBjb2xvcixcbiAgYm9yZGVyVG9wQ29sb3I6IGNvbG9yLFxuICBib3JkZXJSaWdodENvbG9yOiBjb2xvcixcbiAgYm9yZGVyQm90dG9tQ29sb3I6IGNvbG9yLFxuICBib3JkZXJMZWZ0Q29sb3I6IGNvbG9yLFxuICBmaWx0ZXIsXG4gIFdlYmtpdEZpbHRlcjogZmlsdGVyXG59KTtcbnZhciBnZXREZWZhdWx0VmFsdWVUeXBlID0gKGtleSkgPT4gZGVmYXVsdFZhbHVlVHlwZXNba2V5XTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL2FuaW1hdGFibGUtbm9uZS5tanNcbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVOb25lMihrZXksIHZhbHVlKSB7XG4gIHZhciBfYTtcbiAgbGV0IGRlZmF1bHRWYWx1ZVR5cGUgPSBnZXREZWZhdWx0VmFsdWVUeXBlKGtleSk7XG4gIGlmIChkZWZhdWx0VmFsdWVUeXBlICE9PSBmaWx0ZXIpXG4gICAgZGVmYXVsdFZhbHVlVHlwZSA9IGNvbXBsZXg7XG4gIHJldHVybiAoX2EgPSBkZWZhdWx0VmFsdWVUeXBlLmdldEFuaW1hdGFibGVOb25lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChkZWZhdWx0VmFsdWVUeXBlLCB2YWx1ZSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWluc3RhbnQtdHJhbnNpdGlvbi1zdGF0ZS5tanNcbnZhciBpbnN0YW50QW5pbWF0aW9uU3RhdGUgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2RlbGF5Lm1qc1xuZnVuY3Rpb24gZGVsYXkoY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgY29uc3QgY2hlY2tFbGFwc2VkID0gKHsgdGltZXN0YW1wIH0pID0+IHtcbiAgICBjb25zdCBlbGFwc2VkID0gdGltZXN0YW1wIC0gc3RhcnQ7XG4gICAgaWYgKGVsYXBzZWQgPj0gdGltZW91dCkge1xuICAgICAgY2FuY2VsU3luYy5yZWFkKGNoZWNrRWxhcHNlZCk7XG4gICAgICBjYWxsYmFjayhlbGFwc2VkIC0gdGltZW91dCk7XG4gICAgfVxuICB9O1xuICBlc19kZWZhdWx0LnJlYWQoY2hlY2tFbGFwc2VkLCB0cnVlKTtcbiAgcmV0dXJuICgpID0+IGNhbmNlbFN5bmMucmVhZChjaGVja0VsYXBzZWQpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy90cmFuc2l0aW9ucy5tanNcbmZ1bmN0aW9uIGlzVHJhbnNpdGlvbkRlZmluZWQoX2EpIHtcbiAgdmFyIF9iID0gX2EsIHsgd2hlbiwgZGVsYXk6IF9kZWxheSwgZGVsYXlDaGlsZHJlbiwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCByZXBlYXQsIHJlcGVhdFR5cGUsIHJlcGVhdERlbGF5LCBmcm9tIH0gPSBfYiwgdHJhbnNpdGlvbiA9IF9fb2JqUmVzdChfYiwgW1wid2hlblwiLCBcImRlbGF5XCIsIFwiZGVsYXlDaGlsZHJlblwiLCBcInN0YWdnZXJDaGlsZHJlblwiLCBcInN0YWdnZXJEaXJlY3Rpb25cIiwgXCJyZXBlYXRcIiwgXCJyZXBlYXRUeXBlXCIsIFwicmVwZWF0RGVsYXlcIiwgXCJmcm9tXCJdKTtcbiAgcmV0dXJuICEhT2JqZWN0LmtleXModHJhbnNpdGlvbikubGVuZ3RoO1xufVxudmFyIGxlZ2FjeVJlcGVhdFdhcm5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbnZlcnRUcmFuc2l0aW9uVG9BbmltYXRpb25PcHRpb25zKF9hKSB7XG4gIHZhciBfYiA9IF9hLCB7IGVhc2UsIHRpbWVzLCB5b3lvLCBmbGlwLCBsb29wIH0gPSBfYiwgdHJhbnNpdGlvbiA9IF9fb2JqUmVzdChfYiwgW1wiZWFzZVwiLCBcInRpbWVzXCIsIFwieW95b1wiLCBcImZsaXBcIiwgXCJsb29wXCJdKTtcbiAgY29uc3Qgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0cmFuc2l0aW9uKTtcbiAgaWYgKHRpbWVzKVxuICAgIG9wdGlvbnNbXCJvZmZzZXRcIl0gPSB0aW1lcztcbiAgaWYgKHRyYW5zaXRpb24uZHVyYXRpb24pXG4gICAgb3B0aW9uc1tcImR1cmF0aW9uXCJdID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRyYW5zaXRpb24uZHVyYXRpb24pO1xuICBpZiAodHJhbnNpdGlvbi5yZXBlYXREZWxheSlcbiAgICBvcHRpb25zLnJlcGVhdERlbGF5ID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRyYW5zaXRpb24ucmVwZWF0RGVsYXkpO1xuICBpZiAoZWFzZSkge1xuICAgIG9wdGlvbnNbXCJlYXNlXCJdID0gaXNFYXNpbmdBcnJheShlYXNlKSA/IGVhc2UubWFwKGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKSA6IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKGVhc2UpO1xuICB9XG4gIGlmICh0cmFuc2l0aW9uLnR5cGUgPT09IFwidHdlZW5cIilcbiAgICBvcHRpb25zLnR5cGUgPSBcImtleWZyYW1lc1wiO1xuICBpZiAoeW95byB8fCBsb29wIHx8IGZsaXApIHtcbiAgICB3YXJuaW5nKCFsZWdhY3lSZXBlYXRXYXJuaW5nLCBcInlveW8sIGxvb3AgYW5kIGZsaXAgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgQVBJLiBSZXBsYWNlIHdpdGggcmVwZWF0IGFuZCByZXBlYXRUeXBlIG9wdGlvbnMuXCIpO1xuICAgIGxlZ2FjeVJlcGVhdFdhcm5pbmcgPSB0cnVlO1xuICAgIGlmICh5b3lvKSB7XG4gICAgICBvcHRpb25zLnJlcGVhdFR5cGUgPSBcInJldmVyc2VcIjtcbiAgICB9IGVsc2UgaWYgKGxvb3ApIHtcbiAgICAgIG9wdGlvbnMucmVwZWF0VHlwZSA9IFwibG9vcFwiO1xuICAgIH0gZWxzZSBpZiAoZmxpcCkge1xuICAgICAgb3B0aW9ucy5yZXBlYXRUeXBlID0gXCJtaXJyb3JcIjtcbiAgICB9XG4gICAgb3B0aW9ucy5yZXBlYXQgPSBsb29wIHx8IHlveW8gfHwgZmxpcCB8fCB0cmFuc2l0aW9uLnJlcGVhdDtcbiAgfVxuICBpZiAodHJhbnNpdGlvbi50eXBlICE9PSBcInNwcmluZ1wiKVxuICAgIG9wdGlvbnMudHlwZSA9IFwia2V5ZnJhbWVzXCI7XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0RGVsYXlGcm9tVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdmFsdWVUcmFuc2l0aW9uID0gZ2V0VmFsdWVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleSkgfHwge307XG4gIHJldHVybiAoX2IgPSAoX2EgPSB2YWx1ZVRyYW5zaXRpb24uZGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRyYW5zaXRpb24uZGVsYXkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG59XG5mdW5jdGlvbiBoeWRyYXRlS2V5ZnJhbWVzKG9wdGlvbnMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy50bykgJiYgb3B0aW9ucy50b1swXSA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMudG8gPSBbLi4ub3B0aW9ucy50b107XG4gICAgb3B0aW9ucy50b1swXSA9IG9wdGlvbnMuZnJvbTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGdldFBvcG1vdGlvbkFuaW1hdGlvbk9wdGlvbnModHJhbnNpdGlvbiwgb3B0aW9ucywga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudG8pICYmIHRyYW5zaXRpb24uZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgIHRyYW5zaXRpb24uZHVyYXRpb24gPSAwLjg7XG4gIH1cbiAgaHlkcmF0ZUtleWZyYW1lcyhvcHRpb25zKTtcbiAgaWYgKCFpc1RyYW5zaXRpb25EZWZpbmVkKHRyYW5zaXRpb24pKSB7XG4gICAgdHJhbnNpdGlvbiA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0cmFuc2l0aW9uKSwgZ2V0RGVmYXVsdFRyYW5zaXRpb24oa2V5LCBvcHRpb25zLnRvKSk7XG4gIH1cbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgY29udmVydFRyYW5zaXRpb25Ub0FuaW1hdGlvbk9wdGlvbnModHJhbnNpdGlvbikpO1xufVxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbiwgb25Db21wbGV0ZSkge1xuICBjb25zdCB2YWx1ZVRyYW5zaXRpb24gPSBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB8fCB7fTtcbiAgbGV0IG9yaWdpbiA9IHZhbHVlVHJhbnNpdGlvbi5mcm9tICE9PSB2b2lkIDAgPyB2YWx1ZVRyYW5zaXRpb24uZnJvbSA6IHZhbHVlLmdldCgpO1xuICBjb25zdCBpc1RhcmdldEFuaW1hdGFibGUgPSBpc0FuaW1hdGFibGUoa2V5LCB0YXJnZXQpO1xuICBpZiAob3JpZ2luID09PSBcIm5vbmVcIiAmJiBpc1RhcmdldEFuaW1hdGFibGUgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG9yaWdpbiA9IGdldEFuaW1hdGFibGVOb25lMihrZXksIHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoaXNaZXJvKG9yaWdpbikgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG9yaWdpbiA9IGdldFplcm9Vbml0KHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1plcm8odGFyZ2V0KSAmJiB0eXBlb2Ygb3JpZ2luID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGFyZ2V0ID0gZ2V0WmVyb1VuaXQob3JpZ2luKTtcbiAgfVxuICBjb25zdCBpc09yaWdpbkFuaW1hdGFibGUgPSBpc0FuaW1hdGFibGUoa2V5LCBvcmlnaW4pO1xuICB3YXJuaW5nKGlzT3JpZ2luQW5pbWF0YWJsZSA9PT0gaXNUYXJnZXRBbmltYXRhYmxlLCBgWW91IGFyZSB0cnlpbmcgdG8gYW5pbWF0ZSAke2tleX0gZnJvbSBcIiR7b3JpZ2lufVwiIHRvIFwiJHt0YXJnZXR9XCIuICR7b3JpZ2lufSBpcyBub3QgYW4gYW5pbWF0YWJsZSB2YWx1ZSAtIHRvIGVuYWJsZSB0aGlzIGFuaW1hdGlvbiBzZXQgJHtvcmlnaW59IHRvIGEgdmFsdWUgYW5pbWF0YWJsZSB0byAke3RhcmdldH0gdmlhIHRoZSBcXGBzdHlsZVxcYCBwcm9wZXJ0eS5gKTtcbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGZyb206IG9yaWdpbixcbiAgICAgIHRvOiB0YXJnZXQsXG4gICAgICB2ZWxvY2l0eTogdmFsdWUuZ2V0VmVsb2NpdHkoKSxcbiAgICAgIG9uQ29tcGxldGUsXG4gICAgICBvblVwZGF0ZTogKHYpID0+IHZhbHVlLnNldCh2KVxuICAgIH07XG4gICAgcmV0dXJuIHZhbHVlVHJhbnNpdGlvbi50eXBlID09PSBcImluZXJ0aWFcIiB8fCB2YWx1ZVRyYW5zaXRpb24udHlwZSA9PT0gXCJkZWNheVwiID8gaW5lcnRpYShfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHZhbHVlVHJhbnNpdGlvbikpIDogYW5pbWF0ZShfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBnZXRQb3Btb3Rpb25BbmltYXRpb25PcHRpb25zKHZhbHVlVHJhbnNpdGlvbiwgb3B0aW9ucywga2V5KSksIHtcbiAgICAgIG9uVXBkYXRlOiAodikgPT4ge1xuICAgICAgICBvcHRpb25zLm9uVXBkYXRlKHYpO1xuICAgICAgICB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUgJiYgdmFsdWVUcmFuc2l0aW9uLm9uVXBkYXRlKHYpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICAgIHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlICYmIHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIHNldCgpIHtcbiAgICBjb25zdCBmaW5hbFRhcmdldCA9IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXModGFyZ2V0KTtcbiAgICB2YWx1ZS5zZXQoZmluYWxUYXJnZXQpO1xuICAgIG9uQ29tcGxldGUoKTtcbiAgICB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUgJiYgdmFsdWVUcmFuc2l0aW9uLm9uVXBkYXRlKGZpbmFsVGFyZ2V0KTtcbiAgICB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSAmJiB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSgpO1xuICAgIHJldHVybiB7IHN0b3A6ICgpID0+IHtcbiAgICB9IH07XG4gIH1cbiAgcmV0dXJuICFpc09yaWdpbkFuaW1hdGFibGUgfHwgIWlzVGFyZ2V0QW5pbWF0YWJsZSB8fCB2YWx1ZVRyYW5zaXRpb24udHlwZSA9PT0gZmFsc2UgPyBzZXQgOiBzdGFydDtcbn1cbmZ1bmN0aW9uIGlzWmVybyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IDAgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHBhcnNlRmxvYXQodmFsdWUpID09PSAwICYmIHZhbHVlLmluZGV4T2YoXCIgXCIpID09PSAtMTtcbn1cbmZ1bmN0aW9uIGdldFplcm9Vbml0KHBvdGVudGlhbFVuaXRUeXBlKSB7XG4gIHJldHVybiB0eXBlb2YgcG90ZW50aWFsVW5pdFR5cGUgPT09IFwibnVtYmVyXCIgPyAwIDogZ2V0QW5pbWF0YWJsZU5vbmUyKFwiXCIsIHBvdGVudGlhbFVuaXRUeXBlKTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHtcbiAgcmV0dXJuIHRyYW5zaXRpb25ba2V5XSB8fCB0cmFuc2l0aW9uW1wiZGVmYXVsdFwiXSB8fCB0cmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uID0ge30pIHtcbiAgaWYgKGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50KSB7XG4gICAgdHJhbnNpdGlvbiA9IHsgdHlwZTogZmFsc2UgfTtcbiAgfVxuICByZXR1cm4gdmFsdWUuc3RhcnQoKG9uQ29tcGxldGUpID0+IHtcbiAgICBsZXQgY29udHJvbHM7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gZ2V0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbiwgb25Db21wbGV0ZSk7XG4gICAgY29uc3QgZGVsYXlCeSA9IGdldERlbGF5RnJvbVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KTtcbiAgICBjb25zdCBzdGFydCA9ICgpID0+IGNvbnRyb2xzID0gYW5pbWF0aW9uKCk7XG4gICAgbGV0IGNhbmNlbERlbGF5O1xuICAgIGlmIChkZWxheUJ5KSB7XG4gICAgICBjYW5jZWxEZWxheSA9IGRlbGF5KHN0YXJ0LCBzZWNvbmRzVG9NaWxsaXNlY29uZHMoZGVsYXlCeSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCgpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsRGVsYXkgJiYgY2FuY2VsRGVsYXkoKTtcbiAgICAgIGNvbnRyb2xzICYmIGNvbnRyb2xzLnN0b3AoKTtcbiAgICB9O1xuICB9KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pcy1udW1lcmljYWwtc3RyaW5nLm1qc1xudmFyIGlzTnVtZXJpY2FsU3RyaW5nID0gKHYpID0+IC9eXFwtP1xcZCpcXC4/XFxkKyQvLnRlc3Qodik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtemVyby12YWx1ZS1zdHJpbmcubWpzXG52YXIgaXNaZXJvVmFsdWVTdHJpbmcgPSAodikgPT4gL14wW14uXFxzXSskLy50ZXN0KHYpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2FycmF5Lm1qc1xuZnVuY3Rpb24gYWRkVW5pcXVlSXRlbShhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5pbmRleE9mKGl0ZW0pID09PSAtMSlcbiAgICBhcnIucHVzaChpdGVtKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0oYXJyLCBpdGVtKSB7XG4gIGNvbnN0IGluZGV4MiA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaW5kZXgyID4gLTEpXG4gICAgYXJyLnNwbGljZShpbmRleDIsIDEpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3N1YnNjcmlwdGlvbi1tYW5hZ2VyLm1qc1xudmFyIFN1YnNjcmlwdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICB9XG4gIGFkZChoYW5kbGVyKSB7XG4gICAgYWRkVW5pcXVlSXRlbSh0aGlzLnN1YnNjcmlwdGlvbnMsIGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiByZW1vdmVJdGVtKHRoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7XG4gIH1cbiAgbm90aWZ5KGEyLCBiMiwgYzMpIHtcbiAgICBjb25zdCBudW1TdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICBpZiAoIW51bVN1YnNjcmlwdGlvbnMpXG4gICAgICByZXR1cm47XG4gICAgaWYgKG51bVN1YnNjcmlwdGlvbnMgPT09IDEpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1swXShhMiwgYjIsIGMzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bVN1YnNjcmlwdGlvbnM7IGkyKyspIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuc3Vic2NyaXB0aW9uc1tpMl07XG4gICAgICAgIGhhbmRsZXIgJiYgaGFuZGxlcihhMiwgYjIsIGMzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoID0gMDtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS9pbmRleC5tanNcbnZhciBpc0Zsb2F0ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufTtcbnZhciBNb3Rpb25WYWx1ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdCkge1xuICAgIHRoaXMudmVyc2lvbiA9IFwiNy42LjdcIjtcbiAgICB0aGlzLnRpbWVEZWx0YSA9IDA7XG4gICAgdGhpcy5sYXN0VXBkYXRlZCA9IDA7XG4gICAgdGhpcy51cGRhdGVTdWJzY3JpYmVycyA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgdGhpcy52ZWxvY2l0eVVwZGF0ZVN1YnNjcmliZXJzID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLnJlbmRlclN1YnNjcmliZXJzID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSA9ICh2LCByZW5kZXIgPSB0cnVlKSA9PiB7XG4gICAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB2O1xuICAgICAgY29uc3QgeyBkZWx0YSwgdGltZXN0YW1wIH0gPSBnZXRGcmFtZURhdGEoKTtcbiAgICAgIGlmICh0aGlzLmxhc3RVcGRhdGVkICE9PSB0aW1lc3RhbXApIHtcbiAgICAgICAgdGhpcy50aW1lRGVsdGEgPSBkZWx0YTtcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgZXNfZGVmYXVsdC5wb3N0UmVuZGVyKHRoaXMuc2NoZWR1bGVWZWxvY2l0eUNoZWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByZXYgIT09IHRoaXMuY3VycmVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzLm5vdGlmeSh0aGlzLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5nZXRTaXplKCkpIHtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVVwZGF0ZVN1YnNjcmliZXJzLm5vdGlmeSh0aGlzLmdldFZlbG9jaXR5KCkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICB0aGlzLnJlbmRlclN1YnNjcmliZXJzLm5vdGlmeSh0aGlzLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zY2hlZHVsZVZlbG9jaXR5Q2hlY2sgPSAoKSA9PiBlc19kZWZhdWx0LnBvc3RSZW5kZXIodGhpcy52ZWxvY2l0eUNoZWNrKTtcbiAgICB0aGlzLnZlbG9jaXR5Q2hlY2sgPSAoeyB0aW1lc3RhbXAgfSkgPT4ge1xuICAgICAgaWYgKHRpbWVzdGFtcCAhPT0gdGhpcy5sYXN0VXBkYXRlZCkge1xuICAgICAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIHRoaXMudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5ub3RpZnkodGhpcy5nZXRWZWxvY2l0eSgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnQgPSBpbml0O1xuICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IGlzRmxvYXQodGhpcy5jdXJyZW50KTtcbiAgfVxuICBvbkNoYW5nZShzdWJzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVTdWJzY3JpYmVycy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgfVxuICBjbGVhckxpc3RlbmVycygpIHtcbiAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzLmNsZWFyKCk7XG4gIH1cbiAgb25SZW5kZXJSZXF1ZXN0KHN1YnNjcmlwdGlvbikge1xuICAgIHN1YnNjcmlwdGlvbih0aGlzLmdldCgpKTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgfVxuICBhdHRhY2gocGFzc2l2ZUVmZmVjdCkge1xuICAgIHRoaXMucGFzc2l2ZUVmZmVjdCA9IHBhc3NpdmVFZmZlY3Q7XG4gIH1cbiAgc2V0KHYsIHJlbmRlciA9IHRydWUpIHtcbiAgICBpZiAoIXJlbmRlciB8fCAhdGhpcy5wYXNzaXZlRWZmZWN0KSB7XG4gICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSh2LCByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhc3NpdmVFZmZlY3QodiwgdGhpcy51cGRhdGVBbmROb3RpZnkpO1xuICAgIH1cbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgfVxuICBnZXRQcmV2aW91cygpIHtcbiAgICByZXR1cm4gdGhpcy5wcmV2O1xuICB9XG4gIGdldFZlbG9jaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPyB2ZWxvY2l0eVBlclNlY29uZChwYXJzZUZsb2F0KHRoaXMuY3VycmVudCkgLSBwYXJzZUZsb2F0KHRoaXMucHJldiksIHRoaXMudGltZURlbHRhKSA6IDA7XG4gIH1cbiAgc3RhcnQoYW5pbWF0aW9uKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmhhc0FuaW1hdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbiA9IGFuaW1hdGlvbihyZXNvbHZlKTtcbiAgICB9KS50aGVuKCgpID0+IHRoaXMuY2xlYXJBbmltYXRpb24oKSk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5zdG9wQW5pbWF0aW9uKVxuICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5jbGVhckFuaW1hdGlvbigpO1xuICB9XG4gIGlzQW5pbWF0aW5nKCkge1xuICAgIHJldHVybiAhIXRoaXMuc3RvcEFuaW1hdGlvbjtcbiAgfVxuICBjbGVhckFuaW1hdGlvbigpIHtcbiAgICB0aGlzLnN0b3BBbmltYXRpb24gPSBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51cGRhdGVTdWJzY3JpYmVycy5jbGVhcigpO1xuICAgIHRoaXMucmVuZGVyU3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICB0aGlzLnN0b3AoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1vdGlvblZhbHVlKGluaXQpIHtcbiAgcmV0dXJuIG5ldyBNb3Rpb25WYWx1ZShpbml0KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3Rlc3QubWpzXG52YXIgdGVzdFZhbHVlVHlwZSA9ICh2KSA9PiAodHlwZSkgPT4gdHlwZS50ZXN0KHYpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvdHlwZS1hdXRvLm1qc1xudmFyIGF1dG8gPSB7XG4gIHRlc3Q6ICh2KSA9PiB2ID09PSBcImF1dG9cIixcbiAgcGFyc2U6ICh2KSA9PiB2XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZGltZW5zaW9ucy5tanNcbnZhciBkaW1lbnNpb25WYWx1ZVR5cGVzID0gW251bWJlciwgcHgsIHBlcmNlbnQsIGRlZ3JlZXMsIHZ3LCB2aCwgYXV0b107XG52YXIgZmluZERpbWVuc2lvblZhbHVlVHlwZSA9ICh2KSA9PiBkaW1lbnNpb25WYWx1ZVR5cGVzLmZpbmQodGVzdFZhbHVlVHlwZSh2KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9maW5kLm1qc1xudmFyIHZhbHVlVHlwZXMgPSBbLi4uZGltZW5zaW9uVmFsdWVUeXBlcywgY29sb3IsIGNvbXBsZXhdO1xudmFyIGZpbmRWYWx1ZVR5cGUgPSAodikgPT4gdmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9yZXNvbHZlLWR5bmFtaWMtdmFyaWFudHMubWpzXG5mdW5jdGlvbiBnZXRDdXJyZW50KHZpc3VhbEVsZW1lbnQpIHtcbiAgY29uc3QgY3VycmVudCA9IHt9O1xuICB2aXN1YWxFbGVtZW50LnZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBjdXJyZW50W2tleV0gPSB2YWx1ZS5nZXQoKSk7XG4gIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gZ2V0VmVsb2NpdHkodmlzdWFsRWxlbWVudCkge1xuICBjb25zdCB2ZWxvY2l0eSA9IHt9O1xuICB2aXN1YWxFbGVtZW50LnZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB2ZWxvY2l0eVtrZXldID0gdmFsdWUuZ2V0VmVsb2NpdHkoKSk7XG4gIHJldHVybiB2ZWxvY2l0eTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIGN1c3RvbSkge1xuICBjb25zdCBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgcmV0dXJuIHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uLCBjdXN0b20gIT09IHZvaWQgMCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgZ2V0Q3VycmVudCh2aXN1YWxFbGVtZW50KSwgZ2V0VmVsb2NpdHkodmlzdWFsRWxlbWVudCkpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9zZXR0ZXJzLm1qc1xuZnVuY3Rpb24gc2V0TW90aW9uVmFsdWUodmlzdWFsRWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICBpZiAodmlzdWFsRWxlbWVudC5oYXNWYWx1ZShrZXkpKSB7XG4gICAgdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpLnNldCh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmlzdWFsRWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKHZhbHVlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRhcmdldCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKSB7XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gIGxldCBfYSA9IHJlc29sdmVkID8gdmlzdWFsRWxlbWVudC5tYWtlVGFyZ2V0QW5pbWF0YWJsZShyZXNvbHZlZCwgZmFsc2UpIDoge30sIHsgdHJhbnNpdGlvbkVuZCA9IHt9LCB0cmFuc2l0aW9uID0ge30gfSA9IF9hLCB0YXJnZXQgPSBfX29ialJlc3QoX2EsIFtcInRyYW5zaXRpb25FbmRcIiwgXCJ0cmFuc2l0aW9uXCJdKTtcbiAgdGFyZ2V0ID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRhcmdldCksIHRyYW5zaXRpb25FbmQpO1xuICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXModGFyZ2V0W2tleV0pO1xuICAgIHNldE1vdGlvblZhbHVlKHZpc3VhbEVsZW1lbnQsIGtleSwgdmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1RhcmdldEZvck5ld1ZhbHVlcyh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbikge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBuZXdWYWx1ZUtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpLmZpbHRlcigoa2V5KSA9PiAhdmlzdWFsRWxlbWVudC5oYXNWYWx1ZShrZXkpKTtcbiAgY29uc3QgbnVtTmV3VmFsdWVzID0gbmV3VmFsdWVLZXlzLmxlbmd0aDtcbiAgaWYgKCFudW1OZXdWYWx1ZXMpXG4gICAgcmV0dXJuO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtTmV3VmFsdWVzOyBpMisrKSB7XG4gICAgY29uc3Qga2V5ID0gbmV3VmFsdWVLZXlzW2kyXTtcbiAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0VmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHRhcmdldFZhbHVlWzBdO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gKF9iID0gKF9hID0gb3JpZ2luW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZpc3VhbEVsZW1lbnQucmVhZFZhbHVlKGtleSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRhcmdldFtrZXldO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgKGlzTnVtZXJpY2FsU3RyaW5nKHZhbHVlKSB8fCBpc1plcm9WYWx1ZVN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoIWZpbmRWYWx1ZVR5cGUodmFsdWUpICYmIGNvbXBsZXgudGVzdCh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gZ2V0QW5pbWF0YWJsZU5vbmUyKGtleSwgdGFyZ2V0VmFsdWUpO1xuICAgIH1cbiAgICB2aXN1YWxFbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUodmFsdWUpKTtcbiAgICBpZiAob3JpZ2luW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgb3JpZ2luW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKVxuICAgICAgdmlzdWFsRWxlbWVudC5zZXRCYXNlVGFyZ2V0KGtleSwgdmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcmlnaW5Gcm9tVHJhbnNpdGlvbihrZXksIHRyYW5zaXRpb24pIHtcbiAgaWYgKCF0cmFuc2l0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgdmFsdWVUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldIHx8IHRyYW5zaXRpb25bXCJkZWZhdWx0XCJdIHx8IHRyYW5zaXRpb247XG4gIHJldHVybiB2YWx1ZVRyYW5zaXRpb24uZnJvbTtcbn1cbmZ1bmN0aW9uIGdldE9yaWdpbih0YXJnZXQsIHRyYW5zaXRpb24sIHZpc3VhbEVsZW1lbnQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBvcmlnaW4gPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgY29uc3QgdHJhbnNpdGlvbk9yaWdpbiA9IGdldE9yaWdpbkZyb21UcmFuc2l0aW9uKGtleSwgdHJhbnNpdGlvbik7XG4gICAgb3JpZ2luW2tleV0gPSB0cmFuc2l0aW9uT3JpZ2luICE9PSB2b2lkIDAgPyB0cmFuc2l0aW9uT3JpZ2luIDogKF9hID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91c2Utd2lsbC1jaGFuZ2UvaXMubWpzXG5mdW5jdGlvbiBpc1dpbGxDaGFuZ2VNb3Rpb25WYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbihpc01vdGlvblZhbHVlKHZhbHVlKSAmJiB2YWx1ZS5hZGQpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9hbmltYXRpb24ubWpzXG5mdW5jdGlvbiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJBbmltYXRpb25TdGFydFwiLCBkZWZpbml0aW9uKTtcbiAgbGV0IGFuaW1hdGlvbjtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICBjb25zdCBhbmltYXRpb25zMiA9IGRlZmluaXRpb24ubWFwKCh2YXJpYW50KSA9PiBhbmltYXRlVmFyaWFudCh2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBvcHRpb25zKSk7XG4gICAgYW5pbWF0aW9uID0gUHJvbWlzZS5hbGwoYW5pbWF0aW9uczIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgYW5pbWF0aW9uID0gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVzb2x2ZWREZWZpbml0aW9uID0gdHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMuY3VzdG9tKSA6IGRlZmluaXRpb247XG4gICAgYW5pbWF0aW9uID0gYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCByZXNvbHZlZERlZmluaXRpb24sIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBhbmltYXRpb24udGhlbigoKSA9PiB2aXN1YWxFbGVtZW50Lm5vdGlmeShcIkFuaW1hdGlvbkNvbXBsZXRlXCIsIGRlZmluaXRpb24pKTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucy5jdXN0b20pO1xuICBsZXQgeyB0cmFuc2l0aW9uID0gdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpIHx8IHt9IH0gPSByZXNvbHZlZCB8fCB7fTtcbiAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbk92ZXJyaWRlKSB7XG4gICAgdHJhbnNpdGlvbiA9IG9wdGlvbnMudHJhbnNpdGlvbk92ZXJyaWRlO1xuICB9XG4gIGNvbnN0IGdldEFuaW1hdGlvbjIgPSByZXNvbHZlZCA/ICgpID0+IGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudCwgcmVzb2x2ZWQsIG9wdGlvbnMpIDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIGNvbnN0IGdldENoaWxkQW5pbWF0aW9ucyA9ICgoX2EgPSB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpemUpID8gKGZvcndhcmREZWxheSA9IDApID0+IHtcbiAgICBjb25zdCB7IGRlbGF5Q2hpbGRyZW4gPSAwLCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24gfSA9IHRyYW5zaXRpb247XG4gICAgcmV0dXJuIGFuaW1hdGVDaGlsZHJlbih2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBkZWxheUNoaWxkcmVuICsgZm9yd2FyZERlbGF5LCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24sIG9wdGlvbnMpO1xuICB9IDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIGNvbnN0IHsgd2hlbiB9ID0gdHJhbnNpdGlvbjtcbiAgaWYgKHdoZW4pIHtcbiAgICBjb25zdCBbZmlyc3QsIGxhc3RdID0gd2hlbiA9PT0gXCJiZWZvcmVDaGlsZHJlblwiID8gW2dldEFuaW1hdGlvbjIsIGdldENoaWxkQW5pbWF0aW9uc10gOiBbZ2V0Q2hpbGRBbmltYXRpb25zLCBnZXRBbmltYXRpb24yXTtcbiAgICByZXR1cm4gZmlyc3QoKS50aGVuKGxhc3QpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbZ2V0QW5pbWF0aW9uMigpLCBnZXRDaGlsZEFuaW1hdGlvbnMob3B0aW9ucy5kZWxheSldKTtcbiAgfVxufVxuZnVuY3Rpb24gYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCB7IGRlbGF5OiBkZWxheTIgPSAwLCB0cmFuc2l0aW9uT3ZlcnJpZGUsIHR5cGUgfSA9IHt9KSB7XG4gIHZhciBfYTtcbiAgbGV0IF9hMiA9IHZpc3VhbEVsZW1lbnQubWFrZVRhcmdldEFuaW1hdGFibGUoZGVmaW5pdGlvbiksIHsgdHJhbnNpdGlvbiA9IHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSwgdHJhbnNpdGlvbkVuZCB9ID0gX2EyLCB0YXJnZXQgPSBfX29ialJlc3QoX2EyLCBbXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbkVuZFwiXSk7XG4gIGNvbnN0IHdpbGxDaGFuZ2UgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKFwid2lsbENoYW5nZVwiKTtcbiAgaWYgKHRyYW5zaXRpb25PdmVycmlkZSlcbiAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbk92ZXJyaWRlO1xuICBjb25zdCBhbmltYXRpb25zMiA9IFtdO1xuICBjb25zdCBhbmltYXRpb25UeXBlU3RhdGUgPSB0eXBlICYmICgoX2EgPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdGUoKVt0eXBlXSk7XG4gIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgIGNvbnN0IHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgIGNvbnN0IHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZVRhcmdldCA9PT0gdm9pZCAwIHx8IGFuaW1hdGlvblR5cGVTdGF0ZSAmJiBzaG91bGRCbG9ja0FuaW1hdGlvbihhbmltYXRpb25UeXBlU3RhdGUsIGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgdmFsdWVUcmFuc2l0aW9uID0gX19zcHJlYWRWYWx1ZXMoeyBkZWxheTogZGVsYXkyIH0sIHRyYW5zaXRpb24pO1xuICAgIGlmICh2aXN1YWxFbGVtZW50LnNob3VsZFJlZHVjZU1vdGlvbiAmJiB0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSkge1xuICAgICAgdmFsdWVUcmFuc2l0aW9uID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgdmFsdWVUcmFuc2l0aW9uKSwge1xuICAgICAgICB0eXBlOiBmYWxzZSxcbiAgICAgICAgZGVsYXk6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgYW5pbWF0aW9uID0gc3RhcnRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdmFsdWVUYXJnZXQsIHZhbHVlVHJhbnNpdGlvbik7XG4gICAgaWYgKGlzV2lsbENoYW5nZU1vdGlvblZhbHVlKHdpbGxDaGFuZ2UpKSB7XG4gICAgICB3aWxsQ2hhbmdlLmFkZChrZXkpO1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnRoZW4oKCkgPT4gd2lsbENoYW5nZS5yZW1vdmUoa2V5KSk7XG4gICAgfVxuICAgIGFuaW1hdGlvbnMyLnB1c2goYW5pbWF0aW9uKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9uczIpLnRoZW4oKCkgPT4ge1xuICAgIHRyYW5zaXRpb25FbmQgJiYgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHRyYW5zaXRpb25FbmQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGVDaGlsZHJlbih2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBkZWxheUNoaWxkcmVuID0gMCwgc3RhZ2dlckNoaWxkcmVuID0gMCwgc3RhZ2dlckRpcmVjdGlvbiA9IDEsIG9wdGlvbnMpIHtcbiAgY29uc3QgYW5pbWF0aW9uczIgPSBbXTtcbiAgY29uc3QgbWF4U3RhZ2dlckR1cmF0aW9uID0gKHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuLnNpemUgLSAxKSAqIHN0YWdnZXJDaGlsZHJlbjtcbiAgY29uc3QgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24gPSBzdGFnZ2VyRGlyZWN0aW9uID09PSAxID8gKGkyID0gMCkgPT4gaTIgKiBzdGFnZ2VyQ2hpbGRyZW4gOiAoaTIgPSAwKSA9PiBtYXhTdGFnZ2VyRHVyYXRpb24gLSBpMiAqIHN0YWdnZXJDaGlsZHJlbjtcbiAgQXJyYXkuZnJvbSh2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikuc29ydChzb3J0QnlUcmVlT3JkZXIpLmZvckVhY2goKGNoaWxkLCBpMikgPT4ge1xuICAgIGFuaW1hdGlvbnMyLnB1c2goYW5pbWF0ZVZhcmlhbnQoY2hpbGQsIHZhcmlhbnQsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICBkZWxheTogZGVsYXlDaGlsZHJlbiArIGdlbmVyYXRlU3RhZ2dlckR1cmF0aW9uKGkyKVxuICAgIH0pKS50aGVuKCgpID0+IGNoaWxkLm5vdGlmeShcIkFuaW1hdGlvbkNvbXBsZXRlXCIsIHZhcmlhbnQpKSk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9uczIpO1xufVxuZnVuY3Rpb24gc29ydEJ5VHJlZU9yZGVyKGEyLCBiMikge1xuICByZXR1cm4gYTIuc29ydE5vZGVQb3NpdGlvbihiMik7XG59XG5mdW5jdGlvbiBzaG91bGRCbG9ja0FuaW1hdGlvbih7IHByb3RlY3RlZEtleXMsIG5lZWRzQW5pbWF0aW5nIH0sIGtleSkge1xuICBjb25zdCBzaG91bGRCbG9jayA9IHByb3RlY3RlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBuZWVkc0FuaW1hdGluZ1trZXldICE9PSB0cnVlO1xuICBuZWVkc0FuaW1hdGluZ1trZXldID0gZmFsc2U7XG4gIHJldHVybiBzaG91bGRCbG9jaztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvYW5pbWF0aW9uLXN0YXRlLm1qc1xudmFyIHZhcmlhbnRQcmlvcml0eU9yZGVyID0gW1xuICBBbmltYXRpb25UeXBlLkFuaW1hdGUsXG4gIEFuaW1hdGlvblR5cGUuSW5WaWV3LFxuICBBbmltYXRpb25UeXBlLkZvY3VzLFxuICBBbmltYXRpb25UeXBlLkhvdmVyLFxuICBBbmltYXRpb25UeXBlLlRhcCxcbiAgQW5pbWF0aW9uVHlwZS5EcmFnLFxuICBBbmltYXRpb25UeXBlLkV4aXRcbl07XG52YXIgcmV2ZXJzZVByaW9yaXR5T3JkZXIgPSBbLi4udmFyaWFudFByaW9yaXR5T3JkZXJdLnJldmVyc2UoKTtcbnZhciBudW1BbmltYXRpb25UeXBlcyA9IHZhcmlhbnRQcmlvcml0eU9yZGVyLmxlbmd0aDtcbmZ1bmN0aW9uIGFuaW1hdGVMaXN0KHZpc3VhbEVsZW1lbnQpIHtcbiAgcmV0dXJuIChhbmltYXRpb25zMikgPT4gUHJvbWlzZS5hbGwoYW5pbWF0aW9uczIubWFwKCh7IGFuaW1hdGlvbiwgb3B0aW9ucyB9KSA9PiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBhbmltYXRpb24sIG9wdGlvbnMpKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBbmltYXRpb25TdGF0ZSh2aXN1YWxFbGVtZW50KSB7XG4gIGxldCBhbmltYXRlMyA9IGFuaW1hdGVMaXN0KHZpc3VhbEVsZW1lbnQpO1xuICBjb25zdCBzdGF0ZSA9IGNyZWF0ZVN0YXRlKCk7XG4gIGxldCBpc0luaXRpYWxSZW5kZXIgPSB0cnVlO1xuICBjb25zdCBidWlsZFJlc29sdmVkVHlwZVZhbHVlcyA9IChhY2MsIGRlZmluaXRpb24pID0+IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgY29uc3QgX2EgPSByZXNvbHZlZCwgeyB0cmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kIH0gPSBfYSwgdGFyZ2V0ID0gX19vYmpSZXN0KF9hLCBbXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbkVuZFwiXSk7XG4gICAgICBhY2MgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgYWNjKSwgdGFyZ2V0KSwgdHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH07XG4gIGZ1bmN0aW9uIHNldEFuaW1hdGVGdW5jdGlvbihtYWtlQW5pbWF0b3IpIHtcbiAgICBhbmltYXRlMyA9IG1ha2VBbmltYXRvcih2aXN1YWxFbGVtZW50KTtcbiAgfVxuICBmdW5jdGlvbiBhbmltYXRlQ2hhbmdlcyhvcHRpb25zLCBjaGFuZ2VkQWN0aXZlVHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdmlzdWFsRWxlbWVudC5nZXRWYXJpYW50Q29udGV4dCh0cnVlKSB8fCB7fTtcbiAgICBjb25zdCBhbmltYXRpb25zMiA9IFtdO1xuICAgIGNvbnN0IHJlbW92ZWRLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgZW5jb3VudGVyZWRLZXlzID0ge307XG4gICAgbGV0IHJlbW92ZWRWYXJpYW50SW5kZXggPSBJbmZpbml0eTtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtQW5pbWF0aW9uVHlwZXM7IGkyKyspIHtcbiAgICAgIGNvbnN0IHR5cGUgPSByZXZlcnNlUHJpb3JpdHlPcmRlcltpMl07XG4gICAgICBjb25zdCB0eXBlU3RhdGUgPSBzdGF0ZVt0eXBlXTtcbiAgICAgIGNvbnN0IHByb3AgPSAoX2EgPSBwcm9wc1t0eXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGV4dFt0eXBlXTtcbiAgICAgIGNvbnN0IHByb3BJc1ZhcmlhbnQgPSBpc1ZhcmlhbnRMYWJlbChwcm9wKTtcbiAgICAgIGNvbnN0IGFjdGl2ZURlbHRhID0gdHlwZSA9PT0gY2hhbmdlZEFjdGl2ZVR5cGUgPyB0eXBlU3RhdGUuaXNBY3RpdmUgOiBudWxsO1xuICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgcmVtb3ZlZFZhcmlhbnRJbmRleCA9IGkyO1xuICAgICAgbGV0IGlzSW5oZXJpdGVkID0gcHJvcCA9PT0gY29udGV4dFt0eXBlXSAmJiBwcm9wICE9PSBwcm9wc1t0eXBlXSAmJiBwcm9wSXNWYXJpYW50O1xuICAgICAgaWYgKGlzSW5oZXJpdGVkICYmIGlzSW5pdGlhbFJlbmRlciAmJiB2aXN1YWxFbGVtZW50Lm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQpIHtcbiAgICAgICAgaXNJbmhlcml0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHR5cGVTdGF0ZS5wcm90ZWN0ZWRLZXlzID0gX19zcHJlYWRWYWx1ZXMoe30sIGVuY291bnRlcmVkS2V5cyk7XG4gICAgICBpZiAoIXR5cGVTdGF0ZS5pc0FjdGl2ZSAmJiBhY3RpdmVEZWx0YSA9PT0gbnVsbCB8fCAhcHJvcCAmJiAhdHlwZVN0YXRlLnByZXZQcm9wIHx8IGlzQW5pbWF0aW9uQ29udHJvbHMocHJvcCkgfHwgdHlwZW9mIHByb3AgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFyaWFudERpZENoYW5nZSA9IGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UodHlwZVN0YXRlLnByZXZQcm9wLCBwcm9wKTtcbiAgICAgIGxldCBzaG91bGRBbmltYXRlVHlwZSA9IHZhcmlhbnREaWRDaGFuZ2UgfHwgdHlwZSA9PT0gY2hhbmdlZEFjdGl2ZVR5cGUgJiYgdHlwZVN0YXRlLmlzQWN0aXZlICYmICFpc0luaGVyaXRlZCAmJiBwcm9wSXNWYXJpYW50IHx8IGkyID4gcmVtb3ZlZFZhcmlhbnRJbmRleCAmJiBwcm9wSXNWYXJpYW50O1xuICAgICAgY29uc3QgZGVmaW5pdGlvbkxpc3QgPSBBcnJheS5pc0FycmF5KHByb3ApID8gcHJvcCA6IFtwcm9wXTtcbiAgICAgIGxldCByZXNvbHZlZFZhbHVlcyA9IGRlZmluaXRpb25MaXN0LnJlZHVjZShidWlsZFJlc29sdmVkVHlwZVZhbHVlcywge30pO1xuICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgcmVzb2x2ZWRWYWx1ZXMgPSB7fTtcbiAgICAgIGNvbnN0IHsgcHJldlJlc29sdmVkVmFsdWVzID0ge30gfSA9IHR5cGVTdGF0ZTtcbiAgICAgIGNvbnN0IGFsbEtleXMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJldlJlc29sdmVkVmFsdWVzKSwgcmVzb2x2ZWRWYWx1ZXMpO1xuICAgICAgY29uc3QgbWFya1RvQW5pbWF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgc2hvdWxkQW5pbWF0ZVR5cGUgPSB0cnVlO1xuICAgICAgICByZW1vdmVkS2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAgdHlwZVN0YXRlLm5lZWRzQW5pbWF0aW5nW2tleV0gPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHJlc29sdmVkVmFsdWVzW2tleV07XG4gICAgICAgIGNvbnN0IHByZXYgPSBwcmV2UmVzb2x2ZWRWYWx1ZXNba2V5XTtcbiAgICAgICAgaWYgKGVuY291bnRlcmVkS2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobmV4dCAhPT0gcHJldikge1xuICAgICAgICAgIGlmIChpc0tleWZyYW1lc1RhcmdldChuZXh0KSAmJiBpc0tleWZyYW1lc1RhcmdldChwcmV2KSkge1xuICAgICAgICAgICAgaWYgKCFzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KSB8fCB2YXJpYW50RGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHR5cGVTdGF0ZS5wcm90ZWN0ZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZWRLZXlzLmFkZChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZXh0ICE9PSB2b2lkIDAgJiYgcmVtb3ZlZEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHR5cGVTdGF0ZS5wcmV2UHJvcCA9IHByb3A7XG4gICAgICB0eXBlU3RhdGUucHJldlJlc29sdmVkVmFsdWVzID0gcmVzb2x2ZWRWYWx1ZXM7XG4gICAgICBpZiAodHlwZVN0YXRlLmlzQWN0aXZlKSB7XG4gICAgICAgIGVuY291bnRlcmVkS2V5cyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBlbmNvdW50ZXJlZEtleXMpLCByZXNvbHZlZFZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNJbml0aWFsUmVuZGVyICYmIHZpc3VhbEVsZW1lbnQuYmxvY2tJbml0aWFsQW5pbWF0aW9uKSB7XG4gICAgICAgIHNob3VsZEFuaW1hdGVUeXBlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkQW5pbWF0ZVR5cGUgJiYgIWlzSW5oZXJpdGVkKSB7XG4gICAgICAgIGFuaW1hdGlvbnMyLnB1c2goLi4uZGVmaW5pdGlvbkxpc3QubWFwKChhbmltYXRpb24pID0+ICh7XG4gICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgIG9wdGlvbnM6IF9fc3ByZWFkVmFsdWVzKHsgdHlwZSB9LCBvcHRpb25zKVxuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVtb3ZlZEtleXMuc2l6ZSkge1xuICAgICAgY29uc3QgZmFsbGJhY2tBbmltYXRpb24gPSB7fTtcbiAgICAgIHJlbW92ZWRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBmYWxsYmFja1RhcmdldCA9IHZpc3VhbEVsZW1lbnQuZ2V0QmFzZVRhcmdldChrZXkpO1xuICAgICAgICBpZiAoZmFsbGJhY2tUYXJnZXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGZhbGxiYWNrQW5pbWF0aW9uW2tleV0gPSBmYWxsYmFja1RhcmdldDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhbmltYXRpb25zMi5wdXNoKHsgYW5pbWF0aW9uOiBmYWxsYmFja0FuaW1hdGlvbiB9KTtcbiAgICB9XG4gICAgbGV0IHNob3VsZEFuaW1hdGUgPSBCb29sZWFuKGFuaW1hdGlvbnMyLmxlbmd0aCk7XG4gICAgaWYgKGlzSW5pdGlhbFJlbmRlciAmJiBwcm9wcy5pbml0aWFsID09PSBmYWxzZSAmJiAhdmlzdWFsRWxlbWVudC5tYW51YWxseUFuaW1hdGVPbk1vdW50KSB7XG4gICAgICBzaG91bGRBbmltYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGlzSW5pdGlhbFJlbmRlciA9IGZhbHNlO1xuICAgIHJldHVybiBzaG91bGRBbmltYXRlID8gYW5pbWF0ZTMoYW5pbWF0aW9uczIpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWN0aXZlKHR5cGUsIGlzQWN0aXZlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChzdGF0ZVt0eXBlXS5pc0FjdGl2ZSA9PT0gaXNBY3RpdmUpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgKF9hID0gdmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiAoX2EyID0gY2hpbGQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLnNldEFjdGl2ZSh0eXBlLCBpc0FjdGl2ZSk7XG4gICAgfSk7XG4gICAgc3RhdGVbdHlwZV0uaXNBY3RpdmUgPSBpc0FjdGl2ZTtcbiAgICBjb25zdCBhbmltYXRpb25zMiA9IGFuaW1hdGVDaGFuZ2VzKG9wdGlvbnMsIHR5cGUpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHN0YXRlKSB7XG4gICAgICBzdGF0ZVtrZXldLnByb3RlY3RlZEtleXMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnMyO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5pbWF0ZUNoYW5nZXMsXG4gICAgc2V0QWN0aXZlLFxuICAgIHNldEFuaW1hdGVGdW5jdGlvbixcbiAgICBnZXRTdGF0ZTogKCkgPT4gc3RhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UocHJldiwgbmV4dCkge1xuICBpZiAodHlwZW9mIG5leHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbmV4dCAhPT0gcHJldjtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgcmV0dXJuICFzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlU3RhdGUoaXNBY3RpdmUgPSBmYWxzZSkge1xuICByZXR1cm4ge1xuICAgIGlzQWN0aXZlLFxuICAgIHByb3RlY3RlZEtleXM6IHt9LFxuICAgIG5lZWRzQW5pbWF0aW5nOiB7fSxcbiAgICBwcmV2UmVzb2x2ZWRWYWx1ZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBbQW5pbWF0aW9uVHlwZS5BbmltYXRlXTogY3JlYXRlVHlwZVN0YXRlKHRydWUpLFxuICAgIFtBbmltYXRpb25UeXBlLkluVmlld106IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgIFtBbmltYXRpb25UeXBlLkhvdmVyXTogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgW0FuaW1hdGlvblR5cGUuVGFwXTogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgW0FuaW1hdGlvblR5cGUuRHJhZ106IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgIFtBbmltYXRpb25UeXBlLkZvY3VzXTogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgW0FuaW1hdGlvblR5cGUuRXhpdF06IGNyZWF0ZVR5cGVTdGF0ZSgpXG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2FuaW1hdGlvbnMubWpzXG52YXIgYW5pbWF0aW9ucyA9IHtcbiAgYW5pbWF0aW9uOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCgoeyB2aXN1YWxFbGVtZW50LCBhbmltYXRlOiBhbmltYXRlMyB9KSA9PiB7XG4gICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSB8fCAodmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSA9IGNyZWF0ZUFuaW1hdGlvblN0YXRlKHZpc3VhbEVsZW1lbnQpKTtcbiAgICBpZiAoaXNBbmltYXRpb25Db250cm9scyhhbmltYXRlMykpIHtcbiAgICAgIHVzZUVmZmVjdDcoKCkgPT4gYW5pbWF0ZTMuc3Vic2NyaWJlKHZpc3VhbEVsZW1lbnQpLCBbYW5pbWF0ZTNdKTtcbiAgICB9XG4gIH0pLFxuICBleGl0OiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCgocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGN1c3RvbSwgdmlzdWFsRWxlbWVudCB9ID0gcHJvcHM7XG4gICAgY29uc3QgW2lzUHJlc2VudCwgc2FmZVRvUmVtb3ZlXSA9IHVzZVByZXNlbmNlKCk7XG4gICAgY29uc3QgcHJlc2VuY2VDb250ZXh0ID0gdXNlQ29udGV4dDcoUHJlc2VuY2VDb250ZXh0KTtcbiAgICB1c2VFZmZlY3Q3KCgpID0+IHtcbiAgICAgIHZpc3VhbEVsZW1lbnQuaXNQcmVzZW50ID0gaXNQcmVzZW50O1xuICAgICAgY29uc3QgYW5pbWF0aW9uID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSAmJiB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkV4aXQsICFpc1ByZXNlbnQsIHtcbiAgICAgICAgY3VzdG9tOiBwcmVzZW5jZUNvbnRleHQgJiYgcHJlc2VuY2VDb250ZXh0LmN1c3RvbSB8fCBjdXN0b21cbiAgICAgIH0pO1xuICAgICAgaWYgKGFuaW1hdGlvbiAmJiAhaXNQcmVzZW50KSB7XG4gICAgICAgIGFuaW1hdGlvbi50aGVuKHNhZmVUb1JlbW92ZSk7XG4gICAgICB9XG4gICAgfSwgW2lzUHJlc2VudF0pO1xuICB9KVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3VzZS1kcmFnLm1qc1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDggfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9QYW5TZXNzaW9uLm1qc1xudmFyIFBhblNlc3Npb24gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGV2ZW50LCBoYW5kbGVycywgeyB0cmFuc2Zvcm1QYWdlUG9pbnQgfSA9IHt9KSB7XG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RNb3ZlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMubGFzdE1vdmVFdmVudEluZm8gPSBudWxsO1xuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnVwZGF0ZVBvaW50ID0gKCkgPT4ge1xuICAgICAgaWYgKCEodGhpcy5sYXN0TW92ZUV2ZW50ICYmIHRoaXMubGFzdE1vdmVFdmVudEluZm8pKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpbmZvMiA9IGdldFBhbkluZm8odGhpcy5sYXN0TW92ZUV2ZW50SW5mbywgdGhpcy5oaXN0b3J5KTtcbiAgICAgIGNvbnN0IGlzUGFuU3RhcnRlZCA9IHRoaXMuc3RhcnRFdmVudCAhPT0gbnVsbDtcbiAgICAgIGNvbnN0IGlzRGlzdGFuY2VQYXN0VGhyZXNob2xkID0gZGlzdGFuY2UoaW5mbzIub2Zmc2V0LCB7IHg6IDAsIHk6IDAgfSkgPj0gMztcbiAgICAgIGlmICghaXNQYW5TdGFydGVkICYmICFpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgeyBwb2ludDogcG9pbnQzIH0gPSBpbmZvMjtcbiAgICAgIGNvbnN0IHsgdGltZXN0YW1wOiB0aW1lc3RhbXAyIH0gPSBnZXRGcmFtZURhdGEoKTtcbiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHBvaW50MyksIHsgdGltZXN0YW1wOiB0aW1lc3RhbXAyIH0pKTtcbiAgICAgIGNvbnN0IHsgb25TdGFydCwgb25Nb3ZlIH0gPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgaWYgKCFpc1BhblN0YXJ0ZWQpIHtcbiAgICAgICAgb25TdGFydCAmJiBvblN0YXJ0KHRoaXMubGFzdE1vdmVFdmVudCwgaW5mbzIpO1xuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSB0aGlzLmxhc3RNb3ZlRXZlbnQ7XG4gICAgICB9XG4gICAgICBvbk1vdmUgJiYgb25Nb3ZlKHRoaXMubGFzdE1vdmVFdmVudCwgaW5mbzIpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZSA9IChldmVudDIsIGluZm8yKSA9PiB7XG4gICAgICB0aGlzLmxhc3RNb3ZlRXZlbnQgPSBldmVudDI7XG4gICAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbzIsIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQyKSAmJiBldmVudDIuYnV0dG9ucyA9PT0gMCkge1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcChldmVudDIsIGluZm8yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXNfZGVmYXVsdC51cGRhdGUodGhpcy51cGRhdGVQb2ludCwgdHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IChldmVudDIsIGluZm8yKSA9PiB7XG4gICAgICB0aGlzLmVuZCgpO1xuICAgICAgY29uc3QgeyBvbkVuZCwgb25TZXNzaW9uRW5kIH0gPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgY29uc3QgcGFuSW5mbyA9IGdldFBhbkluZm8odHJhbnNmb3JtUG9pbnQoaW5mbzIsIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KSwgdGhpcy5oaXN0b3J5KTtcbiAgICAgIGlmICh0aGlzLnN0YXJ0RXZlbnQgJiYgb25FbmQpIHtcbiAgICAgICAgb25FbmQoZXZlbnQyLCBwYW5JbmZvKTtcbiAgICAgIH1cbiAgICAgIG9uU2Vzc2lvbkVuZCAmJiBvblNlc3Npb25FbmQoZXZlbnQyLCBwYW5JbmZvKTtcbiAgICB9O1xuICAgIGlmIChpc1RvdWNoRXZlbnQoZXZlbnQpICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQgPSB0cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gICAgY29uc3QgaW5mbyA9IGV4dHJhY3RFdmVudEluZm8oZXZlbnQpO1xuICAgIGNvbnN0IGluaXRpYWxJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbywgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgIGNvbnN0IHsgcG9pbnQ6IHBvaW50MiB9ID0gaW5pdGlhbEluZm87XG4gICAgY29uc3QgeyB0aW1lc3RhbXAgfSA9IGdldEZyYW1lRGF0YSgpO1xuICAgIHRoaXMuaGlzdG9yeSA9IFtfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwb2ludDIpLCB7IHRpbWVzdGFtcCB9KV07XG4gICAgY29uc3QgeyBvblNlc3Npb25TdGFydCB9ID0gaGFuZGxlcnM7XG4gICAgb25TZXNzaW9uU3RhcnQgJiYgb25TZXNzaW9uU3RhcnQoZXZlbnQsIGdldFBhbkluZm8oaW5pdGlhbEluZm8sIHRoaXMuaGlzdG9yeSkpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzID0gcGlwZShhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJtb3ZlXCIsIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUpLCBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJ1cFwiLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCksIGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcmNhbmNlbFwiLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCkpO1xuICB9XG4gIHVwZGF0ZUhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICB9XG4gIGVuZCgpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyAmJiB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgIGNhbmNlbFN5bmMudXBkYXRlKHRoaXMudXBkYXRlUG9pbnQpO1xuICB9XG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQoaW5mbywgdHJhbnNmb3JtUGFnZVBvaW50KSB7XG4gIHJldHVybiB0cmFuc2Zvcm1QYWdlUG9pbnQgPyB7IHBvaW50OiB0cmFuc2Zvcm1QYWdlUG9pbnQoaW5mby5wb2ludCkgfSA6IGluZm87XG59XG5mdW5jdGlvbiBzdWJ0cmFjdFBvaW50KGEyLCBiMikge1xuICByZXR1cm4geyB4OiBhMi54IC0gYjIueCwgeTogYTIueSAtIGIyLnkgfTtcbn1cbmZ1bmN0aW9uIGdldFBhbkluZm8oeyBwb2ludDogcG9pbnQyIH0sIGhpc3RvcnkpIHtcbiAgcmV0dXJuIHtcbiAgICBwb2ludDogcG9pbnQyLFxuICAgIGRlbHRhOiBzdWJ0cmFjdFBvaW50KHBvaW50MiwgbGFzdERldmljZVBvaW50KGhpc3RvcnkpKSxcbiAgICBvZmZzZXQ6IHN1YnRyYWN0UG9pbnQocG9pbnQyLCBzdGFydERldmljZVBvaW50KGhpc3RvcnkpKSxcbiAgICB2ZWxvY2l0eTogZ2V0VmVsb2NpdHkyKGhpc3RvcnksIDAuMSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHN0YXJ0RGV2aWNlUG9pbnQoaGlzdG9yeSkge1xuICByZXR1cm4gaGlzdG9yeVswXTtcbn1cbmZ1bmN0aW9uIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSB7XG4gIHJldHVybiBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBnZXRWZWxvY2l0eTIoaGlzdG9yeSwgdGltZURlbHRhKSB7XG4gIGlmIChoaXN0b3J5Lmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgbGV0IGkyID0gaGlzdG9yeS5sZW5ndGggLSAxO1xuICBsZXQgdGltZXN0YW1wZWRQb2ludCA9IG51bGw7XG4gIGNvbnN0IGxhc3RQb2ludCA9IGxhc3REZXZpY2VQb2ludChoaXN0b3J5KTtcbiAgd2hpbGUgKGkyID49IDApIHtcbiAgICB0aW1lc3RhbXBlZFBvaW50ID0gaGlzdG9yeVtpMl07XG4gICAgaWYgKGxhc3RQb2ludC50aW1lc3RhbXAgLSB0aW1lc3RhbXBlZFBvaW50LnRpbWVzdGFtcCA+IHNlY29uZHNUb01pbGxpc2Vjb25kcyh0aW1lRGVsdGEpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaTItLTtcbiAgfVxuICBpZiAoIXRpbWVzdGFtcGVkUG9pbnQpIHtcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgY29uc3QgdGltZSA9IChsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXApIC8gMWUzO1xuICBpZiAodGltZSA9PT0gMCkge1xuICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgfVxuICBjb25zdCBjdXJyZW50VmVsb2NpdHkgPSB7XG4gICAgeDogKGxhc3RQb2ludC54IC0gdGltZXN0YW1wZWRQb2ludC54KSAvIHRpbWUsXG4gICAgeTogKGxhc3RQb2ludC55IC0gdGltZXN0YW1wZWRQb2ludC55KSAvIHRpbWVcbiAgfTtcbiAgaWYgKGN1cnJlbnRWZWxvY2l0eS54ID09PSBJbmZpbml0eSkge1xuICAgIGN1cnJlbnRWZWxvY2l0eS54ID0gMDtcbiAgfVxuICBpZiAoY3VycmVudFZlbG9jaXR5LnkgPT09IEluZmluaXR5KSB7XG4gICAgY3VycmVudFZlbG9jaXR5LnkgPSAwO1xuICB9XG4gIHJldHVybiBjdXJyZW50VmVsb2NpdHk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9kZWx0YS1jYWxjLm1qc1xuZnVuY3Rpb24gY2FsY0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzLm1heCAtIGF4aXMubWluO1xufVxuZnVuY3Rpb24gaXNOZWFyKHZhbHVlLCB0YXJnZXQgPSAwLCBtYXhEaXN0YW5jZSA9IDAuMDEpIHtcbiAgcmV0dXJuIGRpc3RhbmNlKHZhbHVlLCB0YXJnZXQpIDwgbWF4RGlzdGFuY2U7XG59XG5mdW5jdGlvbiBjYWxjQXhpc0RlbHRhKGRlbHRhLCBzb3VyY2UsIHRhcmdldCwgb3JpZ2luID0gMC41KSB7XG4gIGRlbHRhLm9yaWdpbiA9IG9yaWdpbjtcbiAgZGVsdGEub3JpZ2luUG9pbnQgPSBtaXgoc291cmNlLm1pbiwgc291cmNlLm1heCwgZGVsdGEub3JpZ2luKTtcbiAgZGVsdGEuc2NhbGUgPSBjYWxjTGVuZ3RoKHRhcmdldCkgLyBjYWxjTGVuZ3RoKHNvdXJjZSk7XG4gIGlmIChpc05lYXIoZGVsdGEuc2NhbGUsIDEsIDFlLTQpIHx8IGlzTmFOKGRlbHRhLnNjYWxlKSlcbiAgICBkZWx0YS5zY2FsZSA9IDE7XG4gIGRlbHRhLnRyYW5zbGF0ZSA9IG1peCh0YXJnZXQubWluLCB0YXJnZXQubWF4LCBkZWx0YS5vcmlnaW4pIC0gZGVsdGEub3JpZ2luUG9pbnQ7XG4gIGlmIChpc05lYXIoZGVsdGEudHJhbnNsYXRlKSB8fCBpc05hTihkZWx0YS50cmFuc2xhdGUpKVxuICAgIGRlbHRhLnRyYW5zbGF0ZSA9IDA7XG59XG5mdW5jdGlvbiBjYWxjQm94RGVsdGEoZGVsdGEsIHNvdXJjZSwgdGFyZ2V0LCBvcmlnaW4pIHtcbiAgY2FsY0F4aXNEZWx0YShkZWx0YS54LCBzb3VyY2UueCwgdGFyZ2V0LngsIG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbi5vcmlnaW5YKTtcbiAgY2FsY0F4aXNEZWx0YShkZWx0YS55LCBzb3VyY2UueSwgdGFyZ2V0LnksIG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbi5vcmlnaW5ZKTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXModGFyZ2V0LCByZWxhdGl2ZSwgcGFyZW50KSB7XG4gIHRhcmdldC5taW4gPSBwYXJlbnQubWluICsgcmVsYXRpdmUubWluO1xuICB0YXJnZXQubWF4ID0gdGFyZ2V0Lm1pbiArIGNhbGNMZW5ndGgocmVsYXRpdmUpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQm94KHRhcmdldCwgcmVsYXRpdmUsIHBhcmVudCkge1xuICBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldC54LCByZWxhdGl2ZS54LCBwYXJlbnQueCk7XG4gIGNhbGNSZWxhdGl2ZUF4aXModGFyZ2V0LnksIHJlbGF0aXZlLnksIHBhcmVudC55KTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQsIGxheW91dCwgcGFyZW50KSB7XG4gIHRhcmdldC5taW4gPSBsYXlvdXQubWluIC0gcGFyZW50Lm1pbjtcbiAgdGFyZ2V0Lm1heCA9IHRhcmdldC5taW4gKyBjYWxjTGVuZ3RoKGxheW91dCk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVQb3NpdGlvbih0YXJnZXQsIGxheW91dCwgcGFyZW50KSB7XG4gIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQueCwgbGF5b3V0LngsIHBhcmVudC54KTtcbiAgY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uKHRhcmdldC55LCBsYXlvdXQueSwgcGFyZW50LnkpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2RyYWcvdXRpbHMvY29uc3RyYWludHMubWpzXG5mdW5jdGlvbiBhcHBseUNvbnN0cmFpbnRzKHBvaW50MiwgeyBtaW4sIG1heCB9LCBlbGFzdGljKSB7XG4gIGlmIChtaW4gIT09IHZvaWQgMCAmJiBwb2ludDIgPCBtaW4pIHtcbiAgICBwb2ludDIgPSBlbGFzdGljID8gbWl4KG1pbiwgcG9pbnQyLCBlbGFzdGljLm1pbikgOiBNYXRoLm1heChwb2ludDIsIG1pbik7XG4gIH0gZWxzZSBpZiAobWF4ICE9PSB2b2lkIDAgJiYgcG9pbnQyID4gbWF4KSB7XG4gICAgcG9pbnQyID0gZWxhc3RpYyA/IG1peChtYXgsIHBvaW50MiwgZWxhc3RpYy5tYXgpIDogTWF0aC5taW4ocG9pbnQyLCBtYXgpO1xuICB9XG4gIHJldHVybiBwb2ludDI7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMoYXhpcywgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbiAhPT0gdm9pZCAwID8gYXhpcy5taW4gKyBtaW4gOiB2b2lkIDAsXG4gICAgbWF4OiBtYXggIT09IHZvaWQgMCA/IGF4aXMubWF4ICsgbWF4IC0gKGF4aXMubWF4IC0gYXhpcy5taW4pIDogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVDb25zdHJhaW50cyhsYXlvdXRCb3gsIHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMobGF5b3V0Qm94LngsIGxlZnQsIHJpZ2h0KSxcbiAgICB5OiBjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMobGF5b3V0Qm94LnksIHRvcCwgYm90dG9tKVxuICB9O1xufVxuZnVuY3Rpb24gY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzKGxheW91dEF4aXMsIGNvbnN0cmFpbnRzQXhpcykge1xuICBsZXQgbWluID0gY29uc3RyYWludHNBeGlzLm1pbiAtIGxheW91dEF4aXMubWluO1xuICBsZXQgbWF4ID0gY29uc3RyYWludHNBeGlzLm1heCAtIGxheW91dEF4aXMubWF4O1xuICBpZiAoY29uc3RyYWludHNBeGlzLm1heCAtIGNvbnN0cmFpbnRzQXhpcy5taW4gPCBsYXlvdXRBeGlzLm1heCAtIGxheW91dEF4aXMubWluKSB7XG4gICAgW21pbiwgbWF4XSA9IFttYXgsIG1pbl07XG4gIH1cbiAgcmV0dXJuIHsgbWluLCBtYXggfTtcbn1cbmZ1bmN0aW9uIGNhbGNWaWV3cG9ydENvbnN0cmFpbnRzKGxheW91dEJveCwgY29uc3RyYWludHNCb3gpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBjYWxjVmlld3BvcnRBeGlzQ29uc3RyYWludHMobGF5b3V0Qm94LngsIGNvbnN0cmFpbnRzQm94LngpLFxuICAgIHk6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueSwgY29uc3RyYWludHNCb3gueSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGNPcmlnaW4yKHNvdXJjZSwgdGFyZ2V0KSB7XG4gIGxldCBvcmlnaW4gPSAwLjU7XG4gIGNvbnN0IHNvdXJjZUxlbmd0aCA9IGNhbGNMZW5ndGgoc291cmNlKTtcbiAgY29uc3QgdGFyZ2V0TGVuZ3RoID0gY2FsY0xlbmd0aCh0YXJnZXQpO1xuICBpZiAodGFyZ2V0TGVuZ3RoID4gc291cmNlTGVuZ3RoKSB7XG4gICAgb3JpZ2luID0gcHJvZ3Jlc3ModGFyZ2V0Lm1pbiwgdGFyZ2V0Lm1heCAtIHNvdXJjZUxlbmd0aCwgc291cmNlLm1pbik7XG4gIH0gZWxzZSBpZiAoc291cmNlTGVuZ3RoID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgb3JpZ2luID0gcHJvZ3Jlc3Moc291cmNlLm1pbiwgc291cmNlLm1heCAtIHRhcmdldExlbmd0aCwgdGFyZ2V0Lm1pbik7XG4gIH1cbiAgcmV0dXJuIGNsYW1wMigwLCAxLCBvcmlnaW4pO1xufVxuZnVuY3Rpb24gcmViYXNlQXhpc0NvbnN0cmFpbnRzKGxheW91dCwgY29uc3RyYWludHMpIHtcbiAgY29uc3QgcmVsYXRpdmVDb25zdHJhaW50cyA9IHt9O1xuICBpZiAoY29uc3RyYWludHMubWluICE9PSB2b2lkIDApIHtcbiAgICByZWxhdGl2ZUNvbnN0cmFpbnRzLm1pbiA9IGNvbnN0cmFpbnRzLm1pbiAtIGxheW91dC5taW47XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnRzLm1heCAhPT0gdm9pZCAwKSB7XG4gICAgcmVsYXRpdmVDb25zdHJhaW50cy5tYXggPSBjb25zdHJhaW50cy5tYXggLSBsYXlvdXQubWluO1xuICB9XG4gIHJldHVybiByZWxhdGl2ZUNvbnN0cmFpbnRzO1xufVxudmFyIGRlZmF1bHRFbGFzdGljID0gMC4zNTtcbmZ1bmN0aW9uIHJlc29sdmVEcmFnRWxhc3RpYyhkcmFnRWxhc3RpYyA9IGRlZmF1bHRFbGFzdGljKSB7XG4gIGlmIChkcmFnRWxhc3RpYyA9PT0gZmFsc2UpIHtcbiAgICBkcmFnRWxhc3RpYyA9IDA7XG4gIH0gZWxzZSBpZiAoZHJhZ0VsYXN0aWMgPT09IHRydWUpIHtcbiAgICBkcmFnRWxhc3RpYyA9IGRlZmF1bHRFbGFzdGljO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBcImxlZnRcIiwgXCJyaWdodFwiKSxcbiAgICB5OiByZXNvbHZlQXhpc0VsYXN0aWMoZHJhZ0VsYXN0aWMsIFwidG9wXCIsIFwiYm90dG9tXCIpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlQXhpc0VsYXN0aWMoZHJhZ0VsYXN0aWMsIG1pbkxhYmVsLCBtYXhMYWJlbCkge1xuICByZXR1cm4ge1xuICAgIG1pbjogcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbWluTGFiZWwpLFxuICAgIG1heDogcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbWF4TGFiZWwpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBsYWJlbCkge1xuICB2YXIgX2E7XG4gIHJldHVybiB0eXBlb2YgZHJhZ0VsYXN0aWMgPT09IFwibnVtYmVyXCIgPyBkcmFnRWxhc3RpYyA6IChfYSA9IGRyYWdFbGFzdGljW2xhYmVsXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L21vZGVscy5tanNcbnZhciBjcmVhdGVBeGlzRGVsdGEgPSAoKSA9PiAoe1xuICB0cmFuc2xhdGU6IDAsXG4gIHNjYWxlOiAxLFxuICBvcmlnaW46IDAsXG4gIG9yaWdpblBvaW50OiAwXG59KTtcbnZhciBjcmVhdGVEZWx0YSA9ICgpID0+ICh7XG4gIHg6IGNyZWF0ZUF4aXNEZWx0YSgpLFxuICB5OiBjcmVhdGVBeGlzRGVsdGEoKVxufSk7XG52YXIgY3JlYXRlQXhpcyA9ICgpID0+ICh7IG1pbjogMCwgbWF4OiAwIH0pO1xudmFyIGNyZWF0ZUJveCA9ICgpID0+ICh7XG4gIHg6IGNyZWF0ZUF4aXMoKSxcbiAgeTogY3JlYXRlQXhpcygpXG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3V0aWxzL2VhY2gtYXhpcy5tanNcbmZ1bmN0aW9uIGVhY2hBeGlzKGNhbGxiYWNrKSB7XG4gIHJldHVybiBbY2FsbGJhY2soXCJ4XCIpLCBjYWxsYmFjayhcInlcIildO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvY29udmVyc2lvbi5tanNcbmZ1bmN0aW9uIGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tIH0pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB7IG1pbjogbGVmdCwgbWF4OiByaWdodCB9LFxuICAgIHk6IHsgbWluOiB0b3AsIG1heDogYm90dG9tIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94KHsgeCwgeSB9KSB7XG4gIHJldHVybiB7IHRvcDogeS5taW4sIHJpZ2h0OiB4Lm1heCwgYm90dG9tOiB5Lm1heCwgbGVmdDogeC5taW4gfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUJveFBvaW50cyhwb2ludDIsIHRyYW5zZm9ybVBvaW50Mikge1xuICBpZiAoIXRyYW5zZm9ybVBvaW50MilcbiAgICByZXR1cm4gcG9pbnQyO1xuICBjb25zdCB0b3BMZWZ0ID0gdHJhbnNmb3JtUG9pbnQyKHsgeDogcG9pbnQyLmxlZnQsIHk6IHBvaW50Mi50b3AgfSk7XG4gIGNvbnN0IGJvdHRvbVJpZ2h0ID0gdHJhbnNmb3JtUG9pbnQyKHsgeDogcG9pbnQyLnJpZ2h0LCB5OiBwb2ludDIuYm90dG9tIH0pO1xuICByZXR1cm4ge1xuICAgIHRvcDogdG9wTGVmdC55LFxuICAgIGxlZnQ6IHRvcExlZnQueCxcbiAgICBib3R0b206IGJvdHRvbVJpZ2h0LnksXG4gICAgcmlnaHQ6IGJvdHRvbVJpZ2h0LnhcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3V0aWxzL2hhcy10cmFuc2Zvcm0ubWpzXG5mdW5jdGlvbiBpc0lkZW50aXR5U2NhbGUoc2NhbGUyKSB7XG4gIHJldHVybiBzY2FsZTIgPT09IHZvaWQgMCB8fCBzY2FsZTIgPT09IDE7XG59XG5mdW5jdGlvbiBoYXNTY2FsZSh7IHNjYWxlOiBzY2FsZTIsIHNjYWxlWCwgc2NhbGVZIH0pIHtcbiAgcmV0dXJuICFpc0lkZW50aXR5U2NhbGUoc2NhbGUyKSB8fCAhaXNJZGVudGl0eVNjYWxlKHNjYWxlWCkgfHwgIWlzSWRlbnRpdHlTY2FsZShzY2FsZVkpO1xufVxuZnVuY3Rpb24gaGFzVHJhbnNmb3JtKHZhbHVlcykge1xuICByZXR1cm4gaGFzU2NhbGUodmFsdWVzKSB8fCBoYXMyRFRyYW5zbGF0ZSh2YWx1ZXMpIHx8IHZhbHVlcy56IHx8IHZhbHVlcy5yb3RhdGUgfHwgdmFsdWVzLnJvdGF0ZVggfHwgdmFsdWVzLnJvdGF0ZVk7XG59XG5mdW5jdGlvbiBoYXMyRFRyYW5zbGF0ZSh2YWx1ZXMpIHtcbiAgcmV0dXJuIGlzMkRUcmFuc2xhdGUodmFsdWVzLngpIHx8IGlzMkRUcmFuc2xhdGUodmFsdWVzLnkpO1xufVxuZnVuY3Rpb24gaXMyRFRyYW5zbGF0ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUgIT09IFwiMCVcIjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWFwcGx5Lm1qc1xuZnVuY3Rpb24gc2NhbGVQb2ludChwb2ludDIsIHNjYWxlMiwgb3JpZ2luUG9pbnQpIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tT3JpZ2luID0gcG9pbnQyIC0gb3JpZ2luUG9pbnQ7XG4gIGNvbnN0IHNjYWxlZCA9IHNjYWxlMiAqIGRpc3RhbmNlRnJvbU9yaWdpbjtcbiAgcmV0dXJuIG9yaWdpblBvaW50ICsgc2NhbGVkO1xufVxuZnVuY3Rpb24gYXBwbHlQb2ludERlbHRhKHBvaW50MiwgdHJhbnNsYXRlLCBzY2FsZTIsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICBpZiAoYm94U2NhbGUgIT09IHZvaWQgMCkge1xuICAgIHBvaW50MiA9IHNjYWxlUG9pbnQocG9pbnQyLCBib3hTY2FsZSwgb3JpZ2luUG9pbnQpO1xuICB9XG4gIHJldHVybiBzY2FsZVBvaW50KHBvaW50Miwgc2NhbGUyLCBvcmlnaW5Qb2ludCkgKyB0cmFuc2xhdGU7XG59XG5mdW5jdGlvbiBhcHBseUF4aXNEZWx0YShheGlzLCB0cmFuc2xhdGUgPSAwLCBzY2FsZTIgPSAxLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgYXhpcy5taW4gPSBhcHBseVBvaW50RGVsdGEoYXhpcy5taW4sIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xuICBheGlzLm1heCA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1heCwgdHJhbnNsYXRlLCBzY2FsZTIsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG59XG5mdW5jdGlvbiBhcHBseUJveERlbHRhKGJveCwgeyB4LCB5IH0pIHtcbiAgYXBwbHlBeGlzRGVsdGEoYm94LngsIHgudHJhbnNsYXRlLCB4LnNjYWxlLCB4Lm9yaWdpblBvaW50KTtcbiAgYXBwbHlBeGlzRGVsdGEoYm94LnksIHkudHJhbnNsYXRlLCB5LnNjYWxlLCB5Lm9yaWdpblBvaW50KTtcbn1cbmZ1bmN0aW9uIGFwcGx5VHJlZURlbHRhcyhib3gsIHRyZWVTY2FsZSwgdHJlZVBhdGgsIGlzU2hhcmVkVHJhbnNpdGlvbiA9IGZhbHNlKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHRyZWVMZW5ndGggPSB0cmVlUGF0aC5sZW5ndGg7XG4gIGlmICghdHJlZUxlbmd0aClcbiAgICByZXR1cm47XG4gIHRyZWVTY2FsZS54ID0gdHJlZVNjYWxlLnkgPSAxO1xuICBsZXQgbm9kZTtcbiAgbGV0IGRlbHRhO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgdHJlZUxlbmd0aDsgaTIrKykge1xuICAgIG5vZGUgPSB0cmVlUGF0aFtpMl07XG4gICAgZGVsdGEgPSBub2RlLnByb2plY3Rpb25EZWx0YTtcbiAgICBpZiAoKChfYiA9IChfYSA9IG5vZGUuaW5zdGFuY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdHlsZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc3BsYXkpID09PSBcImNvbnRlbnRzXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoaXNTaGFyZWRUcmFuc2l0aW9uICYmIG5vZGUub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiYgbm9kZS5zY3JvbGwgJiYgbm9kZSAhPT0gbm9kZS5yb290KSB7XG4gICAgICB0cmFuc2Zvcm1Cb3goYm94LCB7IHg6IC1ub2RlLnNjcm9sbC54LCB5OiAtbm9kZS5zY3JvbGwueSB9KTtcbiAgICB9XG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICB0cmVlU2NhbGUueCAqPSBkZWx0YS54LnNjYWxlO1xuICAgICAgdHJlZVNjYWxlLnkgKj0gZGVsdGEueS5zY2FsZTtcbiAgICAgIGFwcGx5Qm94RGVsdGEoYm94LCBkZWx0YSk7XG4gICAgfVxuICAgIGlmIChpc1NoYXJlZFRyYW5zaXRpb24gJiYgaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgdHJhbnNmb3JtQm94KGJveCwgbm9kZS5sYXRlc3RWYWx1ZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJhbnNsYXRlQXhpcyhheGlzLCBkaXN0YW5jZTIpIHtcbiAgYXhpcy5taW4gPSBheGlzLm1pbiArIGRpc3RhbmNlMjtcbiAgYXhpcy5tYXggPSBheGlzLm1heCArIGRpc3RhbmNlMjtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUF4aXMoYXhpcywgdHJhbnNmb3JtcywgW2tleSwgc2NhbGVLZXksIG9yaWdpbktleV0pIHtcbiAgY29uc3QgYXhpc09yaWdpbiA9IHRyYW5zZm9ybXNbb3JpZ2luS2V5XSAhPT0gdm9pZCAwID8gdHJhbnNmb3Jtc1tvcmlnaW5LZXldIDogMC41O1xuICBjb25zdCBvcmlnaW5Qb2ludCA9IG1peChheGlzLm1pbiwgYXhpcy5tYXgsIGF4aXNPcmlnaW4pO1xuICBhcHBseUF4aXNEZWx0YShheGlzLCB0cmFuc2Zvcm1zW2tleV0sIHRyYW5zZm9ybXNbc2NhbGVLZXldLCBvcmlnaW5Qb2ludCwgdHJhbnNmb3Jtcy5zY2FsZSk7XG59XG52YXIgeEtleXMgPSBbXCJ4XCIsIFwic2NhbGVYXCIsIFwib3JpZ2luWFwiXTtcbnZhciB5S2V5cyA9IFtcInlcIiwgXCJzY2FsZVlcIiwgXCJvcmlnaW5ZXCJdO1xuZnVuY3Rpb24gdHJhbnNmb3JtQm94KGJveCwgdHJhbnNmb3JtKSB7XG4gIHRyYW5zZm9ybUF4aXMoYm94LngsIHRyYW5zZm9ybSwgeEtleXMpO1xuICB0cmFuc2Zvcm1BeGlzKGJveC55LCB0cmFuc2Zvcm0sIHlLZXlzKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3V0aWxzL21lYXN1cmUubWpzXG5mdW5jdGlvbiBtZWFzdXJlVmlld3BvcnRCb3goaW5zdGFuY2UsIHRyYW5zZm9ybVBvaW50Mikge1xuICByZXR1cm4gY29udmVydEJvdW5kaW5nQm94VG9Cb3godHJhbnNmb3JtQm94UG9pbnRzKGluc3RhbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0cmFuc2Zvcm1Qb2ludDIpKTtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVQYWdlQm94KGVsZW1lbnQsIHJvb3RQcm9qZWN0aW9uTm9kZTIsIHRyYW5zZm9ybVBhZ2VQb2ludCkge1xuICBjb25zdCB2aWV3cG9ydEJveCA9IG1lYXN1cmVWaWV3cG9ydEJveChlbGVtZW50LCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICBjb25zdCB7IHNjcm9sbDogc2Nyb2xsMiB9ID0gcm9vdFByb2plY3Rpb25Ob2RlMjtcbiAgaWYgKHNjcm9sbDIpIHtcbiAgICB0cmFuc2xhdGVBeGlzKHZpZXdwb3J0Qm94LngsIHNjcm9sbDIueCk7XG4gICAgdHJhbnNsYXRlQXhpcyh2aWV3cG9ydEJveC55LCBzY3JvbGwyLnkpO1xuICB9XG4gIHJldHVybiB2aWV3cG9ydEJveDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL1Zpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMubWpzXG52YXIgZWxlbWVudERyYWdDb250cm9scyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZpc3VhbEVsZW1lbnQpIHtcbiAgICB0aGlzLm9wZW5HbG9iYWxMb2NrID0gbnVsbDtcbiAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMub3JpZ2luUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHMgPSBmYWxzZTtcbiAgICB0aGlzLmVsYXN0aWMgPSBjcmVhdGVCb3goKTtcbiAgICB0aGlzLnZpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50O1xuICB9XG4gIHN0YXJ0KG9yaWdpbkV2ZW50LCB7IHNuYXBUb0N1cnNvciA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLnZpc3VhbEVsZW1lbnQuaXNQcmVzZW50ID09PSBmYWxzZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvblNlc3Npb25TdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICBpZiAoc25hcFRvQ3Vyc29yKSB7XG4gICAgICAgIHRoaXMuc25hcFRvQ3Vyc29yKGV4dHJhY3RFdmVudEluZm8oZXZlbnQsIFwicGFnZVwiKS5wb2ludCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvblN0YXJ0ID0gKGV2ZW50LCBpbmZvKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB7IGRyYWc6IGRyYWcyLCBkcmFnUHJvcGFnYXRpb24sIG9uRHJhZ1N0YXJ0IH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICBpZiAoZHJhZzIgJiYgIWRyYWdQcm9wYWdhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5vcGVuR2xvYmFsTG9jaylcbiAgICAgICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrKCk7XG4gICAgICAgIHRoaXMub3Blbkdsb2JhbExvY2sgPSBnZXRHbG9iYWxMb2NrKGRyYWcyKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoKTtcbiAgICAgIGlmICh0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikge1xuICAgICAgICB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi5pc0FuaW1hdGlvbkJsb2NrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi50YXJnZXQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5nZXQoKSB8fCAwO1xuICAgICAgICBpZiAocGVyY2VudC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZWRBeGlzID0gKF9iID0gKF9hMiA9IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uKSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMi5sYXlvdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sYXlvdXRCb3hbYXhpc107XG4gICAgICAgICAgaWYgKG1lYXN1cmVkQXhpcykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gY2FsY0xlbmd0aChtZWFzdXJlZEF4aXMpO1xuICAgICAgICAgICAgY3VycmVudCA9IGxlbmd0aCAqIChwYXJzZUZsb2F0KGN1cnJlbnQpIC8gMTAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmlnaW5Qb2ludFtheGlzXSA9IGN1cnJlbnQ7XG4gICAgICB9KTtcbiAgICAgIG9uRHJhZ1N0YXJ0ID09PSBudWxsIHx8IG9uRHJhZ1N0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRyYWdTdGFydChldmVudCwgaW5mbyk7XG4gICAgICAoX2EgPSB0aGlzLnZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5EcmFnLCB0cnVlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW92ZSA9IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgY29uc3QgeyBkcmFnUHJvcGFnYXRpb24sIGRyYWdEaXJlY3Rpb25Mb2NrLCBvbkRpcmVjdGlvbkxvY2ssIG9uRHJhZyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgaWYgKCFkcmFnUHJvcGFnYXRpb24gJiYgIXRoaXMub3Blbkdsb2JhbExvY2spXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgb2Zmc2V0IH0gPSBpbmZvO1xuICAgICAgaWYgKGRyYWdEaXJlY3Rpb25Mb2NrICYmIHRoaXMuY3VycmVudERpcmVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBnZXRDdXJyZW50RGlyZWN0aW9uKG9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREaXJlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICBvbkRpcmVjdGlvbkxvY2sgPT09IG51bGwgfHwgb25EaXJlY3Rpb25Mb2NrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRpcmVjdGlvbkxvY2sodGhpcy5jdXJyZW50RGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUF4aXMoXCJ4XCIsIGluZm8ucG9pbnQsIG9mZnNldCk7XG4gICAgICB0aGlzLnVwZGF0ZUF4aXMoXCJ5XCIsIGluZm8ucG9pbnQsIG9mZnNldCk7XG4gICAgICB0aGlzLnZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBvbkRyYWcgPT09IG51bGwgfHwgb25EcmFnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRyYWcoZXZlbnQsIGluZm8pO1xuICAgIH07XG4gICAgY29uc3Qgb25TZXNzaW9uRW5kID0gKGV2ZW50LCBpbmZvKSA9PiB0aGlzLnN0b3AoZXZlbnQsIGluZm8pO1xuICAgIHRoaXMucGFuU2Vzc2lvbiA9IG5ldyBQYW5TZXNzaW9uKG9yaWdpbkV2ZW50LCB7XG4gICAgICBvblNlc3Npb25TdGFydCxcbiAgICAgIG9uU3RhcnQsXG4gICAgICBvbk1vdmUsXG4gICAgICBvblNlc3Npb25FbmRcbiAgICB9LCB7IHRyYW5zZm9ybVBhZ2VQb2ludDogdGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpIH0pO1xuICB9XG4gIHN0b3AoZXZlbnQsIGluZm8pIHtcbiAgICBjb25zdCBpc0RyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nO1xuICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgaWYgKCFpc0RyYWdnaW5nKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgdmVsb2NpdHkgfSA9IGluZm87XG4gICAgdGhpcy5zdGFydEFuaW1hdGlvbih2ZWxvY2l0eSk7XG4gICAgY29uc3QgeyBvbkRyYWdFbmQgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICBvbkRyYWdFbmQgPT09IG51bGwgfHwgb25EcmFnRW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRyYWdFbmQoZXZlbnQsIGluZm8pO1xuICB9XG4gIGNhbmNlbCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikge1xuICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24uaXNBbmltYXRpb25CbG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICAgIChfYSA9IHRoaXMucGFuU2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZCgpO1xuICAgIHRoaXMucGFuU2Vzc2lvbiA9IHZvaWQgMDtcbiAgICBjb25zdCB7IGRyYWdQcm9wYWdhdGlvbiB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgIGlmICghZHJhZ1Byb3BhZ2F0aW9uICYmIHRoaXMub3Blbkdsb2JhbExvY2spIHtcbiAgICAgIHRoaXMub3Blbkdsb2JhbExvY2soKTtcbiAgICAgIHRoaXMub3Blbkdsb2JhbExvY2sgPSBudWxsO1xuICAgIH1cbiAgICAoX2IgPSB0aGlzLnZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5EcmFnLCBmYWxzZSk7XG4gIH1cbiAgdXBkYXRlQXhpcyhheGlzLCBfcG9pbnQsIG9mZnNldCkge1xuICAgIGNvbnN0IHsgZHJhZzogZHJhZzIgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICBpZiAoIW9mZnNldCB8fCAhc2hvdWxkRHJhZyhheGlzLCBkcmFnMiwgdGhpcy5jdXJyZW50RGlyZWN0aW9uKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICBsZXQgbmV4dCA9IHRoaXMub3JpZ2luUG9pbnRbYXhpc10gKyBvZmZzZXRbYXhpc107XG4gICAgaWYgKHRoaXMuY29uc3RyYWludHMgJiYgdGhpcy5jb25zdHJhaW50c1theGlzXSkge1xuICAgICAgbmV4dCA9IGFwcGx5Q29uc3RyYWludHMobmV4dCwgdGhpcy5jb25zdHJhaW50c1theGlzXSwgdGhpcy5lbGFzdGljW2F4aXNdKTtcbiAgICB9XG4gICAgYXhpc1ZhbHVlLnNldChuZXh0KTtcbiAgfVxuICByZXNvbHZlQ29uc3RyYWludHMoKSB7XG4gICAgY29uc3QgeyBkcmFnQ29uc3RyYWludHMsIGRyYWdFbGFzdGljIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgY29uc3QgeyBsYXlvdXQgfSA9IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uIHx8IHt9O1xuICAgIGNvbnN0IHByZXZDb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgaWYgKGRyYWdDb25zdHJhaW50cyAmJiBpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpKSB7XG4gICAgICBpZiAoIXRoaXMuY29uc3RyYWludHMpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IHRoaXMucmVzb2x2ZVJlZkNvbnN0cmFpbnRzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkcmFnQ29uc3RyYWludHMgJiYgbGF5b3V0KSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBjYWxjUmVsYXRpdmVDb25zdHJhaW50cyhsYXlvdXQubGF5b3V0Qm94LCBkcmFnQ29uc3RyYWludHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVsYXN0aWMgPSByZXNvbHZlRHJhZ0VsYXN0aWMoZHJhZ0VsYXN0aWMpO1xuICAgIGlmIChwcmV2Q29uc3RyYWludHMgIT09IHRoaXMuY29uc3RyYWludHMgJiYgbGF5b3V0ICYmIHRoaXMuY29uc3RyYWludHMgJiYgIXRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzKSB7XG4gICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICBpZiAodGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykpIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdID0gcmViYXNlQXhpc0NvbnN0cmFpbnRzKGxheW91dC5sYXlvdXRCb3hbYXhpc10sIHRoaXMuY29uc3RyYWludHNbYXhpc10pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZVJlZkNvbnN0cmFpbnRzKCkge1xuICAgIGNvbnN0IHsgZHJhZ0NvbnN0cmFpbnRzOiBjb25zdHJhaW50cywgb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgaWYgKCFjb25zdHJhaW50cyB8fCAhaXNSZWZPYmplY3QoY29uc3RyYWludHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzRWxlbWVudCA9IGNvbnN0cmFpbnRzLmN1cnJlbnQ7XG4gICAgaW52YXJpYW50KGNvbnN0cmFpbnRzRWxlbWVudCAhPT0gbnVsbCwgXCJJZiBgZHJhZ0NvbnN0cmFpbnRzYCBpcyBzZXQgYXMgYSBSZWFjdCByZWYsIHRoYXQgcmVmIG11c3QgYmUgcGFzc2VkIHRvIGFub3RoZXIgY29tcG9uZW50J3MgYHJlZmAgcHJvcC5cIik7XG4gICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgaWYgKCFwcm9qZWN0aW9uIHx8ICFwcm9qZWN0aW9uLmxheW91dClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBjb25zdHJhaW50c0JveCA9IG1lYXN1cmVQYWdlQm94KGNvbnN0cmFpbnRzRWxlbWVudCwgcHJvamVjdGlvbi5yb290LCB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCkpO1xuICAgIGxldCBtZWFzdXJlZENvbnN0cmFpbnRzID0gY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMocHJvamVjdGlvbi5sYXlvdXQubGF5b3V0Qm94LCBjb25zdHJhaW50c0JveCk7XG4gICAgaWYgKG9uTWVhc3VyZURyYWdDb25zdHJhaW50cykge1xuICAgICAgY29uc3QgdXNlckNvbnN0cmFpbnRzID0gb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94KG1lYXN1cmVkQ29uc3RyYWludHMpKTtcbiAgICAgIHRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzID0gISF1c2VyQ29uc3RyYWludHM7XG4gICAgICBpZiAodXNlckNvbnN0cmFpbnRzKSB7XG4gICAgICAgIG1lYXN1cmVkQ29uc3RyYWludHMgPSBjb252ZXJ0Qm91bmRpbmdCb3hUb0JveCh1c2VyQ29uc3RyYWludHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVhc3VyZWRDb25zdHJhaW50cztcbiAgfVxuICBzdGFydEFuaW1hdGlvbih2ZWxvY2l0eSkge1xuICAgIGNvbnN0IHsgZHJhZzogZHJhZzIsIGRyYWdNb21lbnR1bSwgZHJhZ0VsYXN0aWMsIGRyYWdUcmFuc2l0aW9uLCBkcmFnU25hcFRvT3JpZ2luLCBvbkRyYWdUcmFuc2l0aW9uRW5kIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzIHx8IHt9O1xuICAgIGNvbnN0IG1vbWVudHVtQW5pbWF0aW9ucyA9IGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZzIsIHRoaXMuY3VycmVudERpcmVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRyYW5zaXRpb24gPSAoX2EgPSBjb25zdHJhaW50cyA9PT0gbnVsbCB8fCBjb25zdHJhaW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uc3RyYWludHNbYXhpc10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgaWYgKGRyYWdTbmFwVG9PcmlnaW4pXG4gICAgICAgIHRyYW5zaXRpb24gPSB7IG1pbjogMCwgbWF4OiAwIH07XG4gICAgICBjb25zdCBib3VuY2VTdGlmZm5lc3MgPSBkcmFnRWxhc3RpYyA/IDIwMCA6IDFlNjtcbiAgICAgIGNvbnN0IGJvdW5jZURhbXBpbmcgPSBkcmFnRWxhc3RpYyA/IDQwIDogMWU3O1xuICAgICAgY29uc3QgaW5lcnRpYTIgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgIHR5cGU6IFwiaW5lcnRpYVwiLFxuICAgICAgICB2ZWxvY2l0eTogZHJhZ01vbWVudHVtID8gdmVsb2NpdHlbYXhpc10gOiAwLFxuICAgICAgICBib3VuY2VTdGlmZm5lc3MsXG4gICAgICAgIGJvdW5jZURhbXBpbmcsXG4gICAgICAgIHRpbWVDb25zdGFudDogNzUwLFxuICAgICAgICByZXN0RGVsdGE6IDEsXG4gICAgICAgIHJlc3RTcGVlZDogMTBcbiAgICAgIH0sIGRyYWdUcmFuc2l0aW9uKSwgdHJhbnNpdGlvbik7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydEF4aXNWYWx1ZUFuaW1hdGlvbihheGlzLCBpbmVydGlhMik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKG1vbWVudHVtQW5pbWF0aW9ucykudGhlbihvbkRyYWdUcmFuc2l0aW9uRW5kKTtcbiAgfVxuICBzdGFydEF4aXNWYWx1ZUFuaW1hdGlvbihheGlzLCB0cmFuc2l0aW9uKSB7XG4gICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgcmV0dXJuIHN0YXJ0QW5pbWF0aW9uKGF4aXMsIGF4aXNWYWx1ZSwgMCwgdHJhbnNpdGlvbik7XG4gIH1cbiAgc3RvcEFuaW1hdGlvbigpIHtcbiAgICBlYWNoQXhpcygoYXhpcykgPT4gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuc3RvcCgpKTtcbiAgfVxuICBnZXRBeGlzTW90aW9uVmFsdWUoYXhpcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZHJhZ0tleSA9IFwiX2RyYWdcIiArIGF4aXMudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBleHRlcm5hbE1vdGlvblZhbHVlID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKClbZHJhZ0tleV07XG4gICAgcmV0dXJuIGV4dGVybmFsTW90aW9uVmFsdWUgPyBleHRlcm5hbE1vdGlvblZhbHVlIDogdGhpcy52aXN1YWxFbGVtZW50LmdldFZhbHVlKGF4aXMsIChfYiA9IChfYSA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpLmluaXRpYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtheGlzXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCk7XG4gIH1cbiAgc25hcFRvQ3Vyc29yKHBvaW50Mikge1xuICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICBjb25zdCB7IGRyYWc6IGRyYWcyIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZzIsIHRoaXMuY3VycmVudERpcmVjdGlvbikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICBpZiAocHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLmxheW91dCkge1xuICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSBwcm9qZWN0aW9uLmxheW91dC5sYXlvdXRCb3hbYXhpc107XG4gICAgICAgIGF4aXNWYWx1ZS5zZXQocG9pbnQyW2F4aXNdIC0gbWl4KG1pbiwgbWF4LCAwLjUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzY2FsZVBvc2l0aW9uV2l0aGluQ29uc3RyYWludHMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy52aXN1YWxFbGVtZW50LmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBkcmFnOiBkcmFnMiwgZHJhZ0NvbnN0cmFpbnRzIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgaWYgKCFpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpIHx8ICFwcm9qZWN0aW9uIHx8ICF0aGlzLmNvbnN0cmFpbnRzKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgIGNvbnN0IGJveFByb2dyZXNzID0geyB4OiAwLCB5OiAwIH07XG4gICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgaWYgKGF4aXNWYWx1ZSkge1xuICAgICAgICBjb25zdCBsYXRlc3QgPSBheGlzVmFsdWUuZ2V0KCk7XG4gICAgICAgIGJveFByb2dyZXNzW2F4aXNdID0gY2FsY09yaWdpbjIoeyBtaW46IGxhdGVzdCwgbWF4OiBsYXRlc3QgfSwgdGhpcy5jb25zdHJhaW50c1theGlzXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgeyB0cmFuc2Zvcm1UZW1wbGF0ZSB9ID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgdGhpcy52aXN1YWxFbGVtZW50LmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGUgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh7fSwgXCJcIikgOiBcIm5vbmVcIjtcbiAgICAoX2EgPSBwcm9qZWN0aW9uLnJvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGVTY3JvbGwoKTtcbiAgICBwcm9qZWN0aW9uLnVwZGF0ZUxheW91dCgpO1xuICAgIHRoaXMucmVzb2x2ZUNvbnN0cmFpbnRzKCk7XG4gICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnMiwgbnVsbCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcy5jb25zdHJhaW50c1theGlzXTtcbiAgICAgIGF4aXNWYWx1ZS5zZXQobWl4KG1pbiwgbWF4LCBib3hQcm9ncmVzc1theGlzXSkpO1xuICAgIH0pO1xuICB9XG4gIGFkZExpc3RlbmVycygpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBlbGVtZW50RHJhZ0NvbnRyb2xzLnNldCh0aGlzLnZpc3VhbEVsZW1lbnQsIHRoaXMpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudDtcbiAgICBjb25zdCBzdG9wUG9pbnRlckxpc3RlbmVyID0gYWRkUG9pbnRlckV2ZW50KGVsZW1lbnQsIFwicG9pbnRlcmRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB7IGRyYWc6IGRyYWcyLCBkcmFnTGlzdGVuZXIgPSB0cnVlIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICBkcmFnMiAmJiBkcmFnTGlzdGVuZXIgJiYgdGhpcy5zdGFydChldmVudCk7XG4gICAgfSk7XG4gICAgY29uc3QgbWVhc3VyZURyYWdDb25zdHJhaW50cyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZHJhZ0NvbnN0cmFpbnRzIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICBpZiAoaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gdGhpcy5yZXNvbHZlUmVmQ29uc3RyYWludHMoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgIGNvbnN0IHN0b3BNZWFzdXJlTGF5b3V0TGlzdGVuZXIgPSBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtZWFzdXJlXCIsIG1lYXN1cmVEcmFnQ29uc3RyYWludHMpO1xuICAgIGlmIChwcm9qZWN0aW9uICYmICFwcm9qZWN0aW9uLmxheW91dCkge1xuICAgICAgKF9hID0gcHJvamVjdGlvbi5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlU2Nyb2xsKCk7XG4gICAgICBwcm9qZWN0aW9uLnVwZGF0ZUxheW91dCgpO1xuICAgIH1cbiAgICBtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKCk7XG4gICAgY29uc3Qgc3RvcFJlc2l6ZUxpc3RlbmVyID0gYWRkRG9tRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCAoKSA9PiB0aGlzLnNjYWxlUG9zaXRpb25XaXRoaW5Db25zdHJhaW50cygpKTtcbiAgICBjb25zdCBzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIgPSBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwgKHsgZGVsdGEsIGhhc0xheW91dENoYW5nZWQgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZyAmJiBoYXNMYXlvdXRDaGFuZ2VkKSB7XG4gICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgY29uc3QgbW90aW9uVmFsdWUyID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgICAgaWYgKCFtb3Rpb25WYWx1ZTIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgdGhpcy5vcmlnaW5Qb2ludFtheGlzXSArPSBkZWx0YVtheGlzXS50cmFuc2xhdGU7XG4gICAgICAgICAgbW90aW9uVmFsdWUyLnNldChtb3Rpb25WYWx1ZTIuZ2V0KCkgKyBkZWx0YVtheGlzXS50cmFuc2xhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdG9wUmVzaXplTGlzdGVuZXIoKTtcbiAgICAgIHN0b3BQb2ludGVyTGlzdGVuZXIoKTtcbiAgICAgIHN0b3BNZWFzdXJlTGF5b3V0TGlzdGVuZXIoKTtcbiAgICAgIHN0b3BMYXlvdXRVcGRhdGVMaXN0ZW5lciA9PT0gbnVsbCB8fCBzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0b3BMYXlvdXRVcGRhdGVMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cbiAgZ2V0UHJvcHMoKSB7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICBjb25zdCB7IGRyYWc6IGRyYWcyID0gZmFsc2UsIGRyYWdEaXJlY3Rpb25Mb2NrID0gZmFsc2UsIGRyYWdQcm9wYWdhdGlvbiA9IGZhbHNlLCBkcmFnQ29uc3RyYWludHMgPSBmYWxzZSwgZHJhZ0VsYXN0aWMgPSBkZWZhdWx0RWxhc3RpYywgZHJhZ01vbWVudHVtID0gdHJ1ZSB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByb3BzKSwge1xuICAgICAgZHJhZzogZHJhZzIsXG4gICAgICBkcmFnRGlyZWN0aW9uTG9jayxcbiAgICAgIGRyYWdQcm9wYWdhdGlvbixcbiAgICAgIGRyYWdDb25zdHJhaW50cyxcbiAgICAgIGRyYWdFbGFzdGljLFxuICAgICAgZHJhZ01vbWVudHVtXG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzaG91bGREcmFnKGRpcmVjdGlvbiwgZHJhZzIsIGN1cnJlbnREaXJlY3Rpb24pIHtcbiAgcmV0dXJuIChkcmFnMiA9PT0gdHJ1ZSB8fCBkcmFnMiA9PT0gZGlyZWN0aW9uKSAmJiAoY3VycmVudERpcmVjdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50RGlyZWN0aW9uID09PSBkaXJlY3Rpb24pO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudERpcmVjdGlvbihvZmZzZXQsIGxvY2tUaHJlc2hvbGQgPSAxMCkge1xuICBsZXQgZGlyZWN0aW9uID0gbnVsbDtcbiAgaWYgKE1hdGguYWJzKG9mZnNldC55KSA+IGxvY2tUaHJlc2hvbGQpIHtcbiAgICBkaXJlY3Rpb24gPSBcInlcIjtcbiAgfSBlbHNlIGlmIChNYXRoLmFicyhvZmZzZXQueCkgPiBsb2NrVGhyZXNob2xkKSB7XG4gICAgZGlyZWN0aW9uID0gXCJ4XCI7XG4gIH1cbiAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3VzZS1kcmFnLm1qc1xuZnVuY3Rpb24gdXNlRHJhZyhwcm9wcykge1xuICBjb25zdCB7IGRyYWdDb250cm9sczogZ3JvdXBEcmFnQ29udHJvbHMsIHZpc3VhbEVsZW1lbnQgfSA9IHByb3BzO1xuICBjb25zdCBkcmFnQ29udHJvbHMgPSB1c2VDb25zdGFudCgoKSA9PiBuZXcgVmlzdWFsRWxlbWVudERyYWdDb250cm9scyh2aXN1YWxFbGVtZW50KSk7XG4gIHVzZUVmZmVjdDgoKCkgPT4gZ3JvdXBEcmFnQ29udHJvbHMgJiYgZ3JvdXBEcmFnQ29udHJvbHMuc3Vic2NyaWJlKGRyYWdDb250cm9scyksIFtkcmFnQ29udHJvbHMsIGdyb3VwRHJhZ0NvbnRyb2xzXSk7XG4gIHVzZUVmZmVjdDgoKCkgPT4gZHJhZ0NvbnRyb2xzLmFkZExpc3RlbmVycygpLCBbZHJhZ0NvbnRyb2xzXSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLXBhbi1nZXN0dXJlLm1qc1xuaW1wb3J0IHsgdXNlUmVmIGFzIHVzZVJlZjUsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDgsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q5IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VQYW5HZXN0dXJlKHsgb25QYW4sIG9uUGFuU3RhcnQsIG9uUGFuRW5kLCBvblBhblNlc3Npb25TdGFydCwgdmlzdWFsRWxlbWVudCB9KSB7XG4gIGNvbnN0IGhhc1BhbkV2ZW50cyA9IG9uUGFuIHx8IG9uUGFuU3RhcnQgfHwgb25QYW5FbmQgfHwgb25QYW5TZXNzaW9uU3RhcnQ7XG4gIGNvbnN0IHBhblNlc3Npb24gPSB1c2VSZWY1KG51bGwpO1xuICBjb25zdCB7IHRyYW5zZm9ybVBhZ2VQb2ludCB9ID0gdXNlQ29udGV4dDgoTW90aW9uQ29uZmlnQ29udGV4dCk7XG4gIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgIG9uU2Vzc2lvblN0YXJ0OiBvblBhblNlc3Npb25TdGFydCxcbiAgICBvblN0YXJ0OiBvblBhblN0YXJ0LFxuICAgIG9uTW92ZTogb25QYW4sXG4gICAgb25FbmQ6IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgcGFuU2Vzc2lvbi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIG9uUGFuRW5kICYmIG9uUGFuRW5kKGV2ZW50LCBpbmZvKTtcbiAgICB9XG4gIH07XG4gIHVzZUVmZmVjdDkoKCkgPT4ge1xuICAgIGlmIChwYW5TZXNzaW9uLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHBhblNlc3Npb24uY3VycmVudC51cGRhdGVIYW5kbGVycyhoYW5kbGVycyk7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCkge1xuICAgIHBhblNlc3Npb24uY3VycmVudCA9IG5ldyBQYW5TZXNzaW9uKGV2ZW50LCBoYW5kbGVycywge1xuICAgICAgdHJhbnNmb3JtUGFnZVBvaW50XG4gICAgfSk7XG4gIH1cbiAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmRvd25cIiwgaGFzUGFuRXZlbnRzICYmIG9uUG9pbnRlckRvd24pO1xuICB1c2VVbm1vdW50RWZmZWN0KCgpID0+IHBhblNlc3Npb24uY3VycmVudCAmJiBwYW5TZXNzaW9uLmN1cnJlbnQuZW5kKCkpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9kcmFnLm1qc1xudmFyIGRyYWcgPSB7XG4gIHBhbjogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlUGFuR2VzdHVyZSksXG4gIGRyYWc6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZURyYWcpXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvY3NzLXZhcmlhYmxlcy1jb252ZXJzaW9uLm1qc1xuZnVuY3Rpb24gaXNDU1NWYXJpYWJsZTIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKFwidmFyKC0tXCIpO1xufVxudmFyIGNzc1ZhcmlhYmxlUmVnZXggPSAvdmFyXFwoKC0tW2EtekEtWjAtOS1fXSspLD8gPyhbYS16QS1aMC05ICgpJSMuLC1dKyk/XFwpLztcbmZ1bmN0aW9uIHBhcnNlQ1NTVmFyaWFibGUoY3VycmVudCkge1xuICBjb25zdCBtYXRjaCA9IGNzc1ZhcmlhYmxlUmVnZXguZXhlYyhjdXJyZW50KTtcbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm4gWyxdO1xuICBjb25zdCBbLCB0b2tlbiwgZmFsbGJhY2tdID0gbWF0Y2g7XG4gIHJldHVybiBbdG9rZW4sIGZhbGxiYWNrXTtcbn1cbnZhciBtYXhEZXB0aCA9IDQ7XG5mdW5jdGlvbiBnZXRWYXJpYWJsZVZhbHVlKGN1cnJlbnQsIGVsZW1lbnQsIGRlcHRoID0gMSkge1xuICBpbnZhcmlhbnQoZGVwdGggPD0gbWF4RGVwdGgsIGBNYXggQ1NTIHZhcmlhYmxlIGZhbGxiYWNrIGRlcHRoIGRldGVjdGVkIGluIHByb3BlcnR5IFwiJHtjdXJyZW50fVwiLiBUaGlzIG1heSBpbmRpY2F0ZSBhIGNpcmN1bGFyIGZhbGxiYWNrIGRlcGVuZGVuY3kuYCk7XG4gIGNvbnN0IFt0b2tlbiwgZmFsbGJhY2tdID0gcGFyc2VDU1NWYXJpYWJsZShjdXJyZW50KTtcbiAgaWYgKCF0b2tlbilcbiAgICByZXR1cm47XG4gIGNvbnN0IHJlc29sdmVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSh0b2tlbik7XG4gIGlmIChyZXNvbHZlZCkge1xuICAgIHJldHVybiByZXNvbHZlZC50cmltKCk7XG4gIH0gZWxzZSBpZiAoaXNDU1NWYXJpYWJsZTIoZmFsbGJhY2spKSB7XG4gICAgcmV0dXJuIGdldFZhcmlhYmxlVmFsdWUoZmFsbGJhY2ssIGVsZW1lbnQsIGRlcHRoICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlQ1NTVmFyaWFibGVzKHZpc3VhbEVsZW1lbnQsIF9hLCB0cmFuc2l0aW9uRW5kKSB7XG4gIHZhciB0YXJnZXQgPSBfX29ialJlc3QoX2EsIFtdKTtcbiAgY29uc3QgZWxlbWVudCA9IHZpc3VhbEVsZW1lbnQuY3VycmVudDtcbiAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKVxuICAgIHJldHVybiB7IHRhcmdldCwgdHJhbnNpdGlvbkVuZCB9O1xuICBpZiAodHJhbnNpdGlvbkVuZCkge1xuICAgIHRyYW5zaXRpb25FbmQgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdHJhbnNpdGlvbkVuZCk7XG4gIH1cbiAgdmlzdWFsRWxlbWVudC52YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICBjb25zdCBjdXJyZW50ID0gdmFsdWUuZ2V0KCk7XG4gICAgaWYgKCFpc0NTU1ZhcmlhYmxlMihjdXJyZW50KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZXNvbHZlZCA9IGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCk7XG4gICAgaWYgKHJlc29sdmVkKVxuICAgICAgdmFsdWUuc2V0KHJlc29sdmVkKTtcbiAgfSk7XG4gIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0YXJnZXRba2V5XTtcbiAgICBpZiAoIWlzQ1NTVmFyaWFibGUyKGN1cnJlbnQpKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBnZXRWYXJpYWJsZVZhbHVlKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHJlc29sdmVkO1xuICAgIGlmICh0cmFuc2l0aW9uRW5kICYmIHRyYW5zaXRpb25FbmRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICB0cmFuc2l0aW9uRW5kW2tleV0gPSBjdXJyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB0YXJnZXQsIHRyYW5zaXRpb25FbmQgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL3VuaXQtY29udmVyc2lvbi5tanNcbnZhciBwb3NpdGlvbmFsS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJ3aWR0aFwiLFxuICBcImhlaWdodFwiLFxuICBcInRvcFwiLFxuICBcImxlZnRcIixcbiAgXCJyaWdodFwiLFxuICBcImJvdHRvbVwiLFxuICBcInhcIixcbiAgXCJ5XCJcbl0pO1xudmFyIGlzUG9zaXRpb25hbEtleSA9IChrZXkpID0+IHBvc2l0aW9uYWxLZXlzLmhhcyhrZXkpO1xudmFyIGhhc1Bvc2l0aW9uYWxLZXkgPSAodGFyZ2V0KSA9PiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLnNvbWUoaXNQb3NpdGlvbmFsS2V5KTtcbn07XG52YXIgc2V0QW5kUmVzZXRWZWxvY2l0eSA9ICh2YWx1ZSwgdG8pID0+IHtcbiAgdmFsdWUuc2V0KHRvLCBmYWxzZSk7XG4gIHZhbHVlLnNldCh0byk7XG59O1xudmFyIGlzTnVtT3JQeFR5cGUgPSAodikgPT4gdiA9PT0gbnVtYmVyIHx8IHYgPT09IHB4O1xudmFyIEJvdW5kaW5nQm94RGltZW5zaW9uO1xuKGZ1bmN0aW9uKEJvdW5kaW5nQm94RGltZW5zaW9uMikge1xuICBCb3VuZGluZ0JveERpbWVuc2lvbjJbXCJ3aWR0aFwiXSA9IFwid2lkdGhcIjtcbiAgQm91bmRpbmdCb3hEaW1lbnNpb24yW1wiaGVpZ2h0XCJdID0gXCJoZWlnaHRcIjtcbiAgQm91bmRpbmdCb3hEaW1lbnNpb24yW1wibGVmdFwiXSA9IFwibGVmdFwiO1xuICBCb3VuZGluZ0JveERpbWVuc2lvbjJbXCJyaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgQm91bmRpbmdCb3hEaW1lbnNpb24yW1widG9wXCJdID0gXCJ0b3BcIjtcbiAgQm91bmRpbmdCb3hEaW1lbnNpb24yW1wiYm90dG9tXCJdID0gXCJib3R0b21cIjtcbn0pKEJvdW5kaW5nQm94RGltZW5zaW9uIHx8IChCb3VuZGluZ0JveERpbWVuc2lvbiA9IHt9KSk7XG52YXIgZ2V0UG9zRnJvbU1hdHJpeCA9IChtYXRyaXgsIHBvcykgPT4gcGFyc2VGbG9hdChtYXRyaXguc3BsaXQoXCIsIFwiKVtwb3NdKTtcbnZhciBnZXRUcmFuc2xhdGVGcm9tTWF0cml4ID0gKHBvczIsIHBvczMpID0+IChfYmJveCwgeyB0cmFuc2Zvcm0gfSkgPT4ge1xuICBpZiAodHJhbnNmb3JtID09PSBcIm5vbmVcIiB8fCAhdHJhbnNmb3JtKVxuICAgIHJldHVybiAwO1xuICBjb25zdCBtYXRyaXgzZCA9IHRyYW5zZm9ybS5tYXRjaCgvXm1hdHJpeDNkXFwoKC4rKVxcKSQvKTtcbiAgaWYgKG1hdHJpeDNkKSB7XG4gICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4M2RbMV0sIHBvczMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1hdHJpeCA9IHRyYW5zZm9ybS5tYXRjaCgvXm1hdHJpeFxcKCguKylcXCkkLyk7XG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4WzFdLCBwb3MyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG59O1xudmFyIHRyYW5zZm9ybUtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJ4XCIsIFwieVwiLCBcInpcIl0pO1xudmFyIG5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm1LZXlzID0gdHJhbnNmb3JtUHJvcE9yZGVyLmZpbHRlcigoa2V5KSA9PiAhdHJhbnNmb3JtS2V5cy5oYXMoa2V5KSk7XG5mdW5jdGlvbiByZW1vdmVOb25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtKHZpc3VhbEVsZW1lbnQpIHtcbiAgY29uc3QgcmVtb3ZlZFRyYW5zZm9ybXMgPSBbXTtcbiAgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJlbW92ZWRUcmFuc2Zvcm1zLnB1c2goW2tleSwgdmFsdWUuZ2V0KCldKTtcbiAgICAgIHZhbHVlLnNldChrZXkuc3RhcnRzV2l0aChcInNjYWxlXCIpID8gMSA6IDApO1xuICAgIH1cbiAgfSk7XG4gIGlmIChyZW1vdmVkVHJhbnNmb3Jtcy5sZW5ndGgpXG4gICAgdmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgcmV0dXJuIHJlbW92ZWRUcmFuc2Zvcm1zO1xufVxudmFyIHBvc2l0aW9uYWxWYWx1ZXMgPSB7XG4gIHdpZHRoOiAoeyB4IH0sIHsgcGFkZGluZ0xlZnQgPSBcIjBcIiwgcGFkZGluZ1JpZ2h0ID0gXCIwXCIgfSkgPT4geC5tYXggLSB4Lm1pbiAtIHBhcnNlRmxvYXQocGFkZGluZ0xlZnQpIC0gcGFyc2VGbG9hdChwYWRkaW5nUmlnaHQpLFxuICBoZWlnaHQ6ICh7IHkgfSwgeyBwYWRkaW5nVG9wID0gXCIwXCIsIHBhZGRpbmdCb3R0b20gPSBcIjBcIiB9KSA9PiB5Lm1heCAtIHkubWluIC0gcGFyc2VGbG9hdChwYWRkaW5nVG9wKSAtIHBhcnNlRmxvYXQocGFkZGluZ0JvdHRvbSksXG4gIHRvcDogKF9iYm94LCB7IHRvcCB9KSA9PiBwYXJzZUZsb2F0KHRvcCksXG4gIGxlZnQ6IChfYmJveCwgeyBsZWZ0IH0pID0+IHBhcnNlRmxvYXQobGVmdCksXG4gIGJvdHRvbTogKHsgeSB9LCB7IHRvcCB9KSA9PiBwYXJzZUZsb2F0KHRvcCkgKyAoeS5tYXggLSB5Lm1pbiksXG4gIHJpZ2h0OiAoeyB4IH0sIHsgbGVmdCB9KSA9PiBwYXJzZUZsb2F0KGxlZnQpICsgKHgubWF4IC0geC5taW4pLFxuICB4OiBnZXRUcmFuc2xhdGVGcm9tTWF0cml4KDQsIDEzKSxcbiAgeTogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg1LCAxNClcbn07XG52YXIgY29udmVydENoYW5nZWRWYWx1ZVR5cGVzID0gKHRhcmdldCwgdmlzdWFsRWxlbWVudCwgY2hhbmdlZEtleXMpID0+IHtcbiAgY29uc3Qgb3JpZ2luQmJveCA9IHZpc3VhbEVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCk7XG4gIGNvbnN0IGVsZW1lbnQgPSB2aXN1YWxFbGVtZW50LmN1cnJlbnQ7XG4gIGNvbnN0IGVsZW1lbnRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgY29uc3QgeyBkaXNwbGF5IH0gPSBlbGVtZW50Q29tcHV0ZWRTdHlsZTtcbiAgY29uc3Qgb3JpZ2luID0ge307XG4gIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgIHZpc3VhbEVsZW1lbnQuc2V0U3RhdGljVmFsdWUoXCJkaXNwbGF5XCIsIHRhcmdldC5kaXNwbGF5IHx8IFwiYmxvY2tcIik7XG4gIH1cbiAgY2hhbmdlZEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgb3JpZ2luW2tleV0gPSBwb3NpdGlvbmFsVmFsdWVzW2tleV0ob3JpZ2luQmJveCwgZWxlbWVudENvbXB1dGVkU3R5bGUpO1xuICB9KTtcbiAgdmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgY29uc3QgdGFyZ2V0QmJveCA9IHZpc3VhbEVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCk7XG4gIGNoYW5nZWRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgIHNldEFuZFJlc2V0VmVsb2NpdHkodmFsdWUsIG9yaWdpbltrZXldKTtcbiAgICB0YXJnZXRba2V5XSA9IHBvc2l0aW9uYWxWYWx1ZXNba2V5XSh0YXJnZXRCYm94LCBlbGVtZW50Q29tcHV0ZWRTdHlsZSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyA9ICh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiA9IHt9LCB0cmFuc2l0aW9uRW5kID0ge30pID0+IHtcbiAgdGFyZ2V0ID0gX19zcHJlYWRWYWx1ZXMoe30sIHRhcmdldCk7XG4gIHRyYW5zaXRpb25FbmQgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdHJhbnNpdGlvbkVuZCk7XG4gIGNvbnN0IHRhcmdldFBvc2l0aW9uYWxLZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KS5maWx0ZXIoaXNQb3NpdGlvbmFsS2V5KTtcbiAgbGV0IHJlbW92ZWRUcmFuc2Zvcm1WYWx1ZXMgPSBbXTtcbiAgbGV0IGhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzID0gZmFsc2U7XG4gIGNvbnN0IGNoYW5nZWRWYWx1ZVR5cGVLZXlzID0gW107XG4gIHRhcmdldFBvc2l0aW9uYWxLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgIGlmICghdmlzdWFsRWxlbWVudC5oYXNWYWx1ZShrZXkpKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBmcm9tID0gb3JpZ2luW2tleV07XG4gICAgbGV0IGZyb21UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZShmcm9tKTtcbiAgICBjb25zdCB0byA9IHRhcmdldFtrZXldO1xuICAgIGxldCB0b1R5cGU7XG4gICAgaWYgKGlzS2V5ZnJhbWVzVGFyZ2V0KHRvKSkge1xuICAgICAgY29uc3QgbnVtS2V5ZnJhbWVzID0gdG8ubGVuZ3RoO1xuICAgICAgY29uc3QgZnJvbUluZGV4ID0gdG9bMF0gPT09IG51bGwgPyAxIDogMDtcbiAgICAgIGZyb20gPSB0b1tmcm9tSW5kZXhdO1xuICAgICAgZnJvbVR5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKGZyb20pO1xuICAgICAgZm9yIChsZXQgaTIgPSBmcm9tSW5kZXg7IGkyIDwgbnVtS2V5ZnJhbWVzOyBpMisrKSB7XG4gICAgICAgIGlmICghdG9UeXBlKSB7XG4gICAgICAgICAgdG9UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZSh0b1tpMl0pO1xuICAgICAgICAgIGludmFyaWFudCh0b1R5cGUgPT09IGZyb21UeXBlIHx8IGlzTnVtT3JQeFR5cGUoZnJvbVR5cGUpICYmIGlzTnVtT3JQeFR5cGUodG9UeXBlKSwgXCJLZXlmcmFtZXMgbXVzdCBiZSBvZiB0aGUgc2FtZSBkaW1lbnNpb24gYXMgdGhlIGN1cnJlbnQgdmFsdWVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW52YXJpYW50KGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodG9baTJdKSA9PT0gdG9UeXBlLCBcIkFsbCBrZXlmcmFtZXMgbXVzdCBiZSBvZiB0aGUgc2FtZSB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodG8pO1xuICAgIH1cbiAgICBpZiAoZnJvbVR5cGUgIT09IHRvVHlwZSkge1xuICAgICAgaWYgKGlzTnVtT3JQeFR5cGUoZnJvbVR5cGUpICYmIGlzTnVtT3JQeFR5cGUodG9UeXBlKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhbHVlLnNldChwYXJzZUZsb2F0KGN1cnJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBwYXJzZUZsb2F0KHRvKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRvKSAmJiB0b1R5cGUgPT09IHB4KSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB0by5tYXAocGFyc2VGbG9hdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKGZyb21UeXBlID09PSBudWxsIHx8IGZyb21UeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmcm9tVHlwZS50cmFuc2Zvcm0pICYmICh0b1R5cGUgPT09IG51bGwgfHwgdG9UeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b1R5cGUudHJhbnNmb3JtKSAmJiAoZnJvbSA9PT0gMCB8fCB0byA9PT0gMCkpIHtcbiAgICAgICAgaWYgKGZyb20gPT09IDApIHtcbiAgICAgICAgICB2YWx1ZS5zZXQodG9UeXBlLnRyYW5zZm9ybShmcm9tKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBmcm9tVHlwZS50cmFuc2Zvcm0odG8pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzKSB7XG4gICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcyA9IHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0odmlzdWFsRWxlbWVudCk7XG4gICAgICAgICAgaGFzQXR0ZW1wdGVkVG9SZW1vdmVUcmFuc2Zvcm1WYWx1ZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZWRWYWx1ZVR5cGVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgdHJhbnNpdGlvbkVuZFtrZXldID0gdHJhbnNpdGlvbkVuZFtrZXldICE9PSB2b2lkIDAgPyB0cmFuc2l0aW9uRW5kW2tleV0gOiB0YXJnZXRba2V5XTtcbiAgICAgICAgc2V0QW5kUmVzZXRWZWxvY2l0eSh2YWx1ZSwgdG8pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChjaGFuZ2VkVmFsdWVUeXBlS2V5cy5sZW5ndGgpIHtcbiAgICBjb25zdCBzY3JvbGxZID0gY2hhbmdlZFZhbHVlVHlwZUtleXMuaW5kZXhPZihcImhlaWdodFwiKSA+PSAwID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogbnVsbDtcbiAgICBjb25zdCBjb252ZXJ0ZWRUYXJnZXQgPSBjb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXModGFyZ2V0LCB2aXN1YWxFbGVtZW50LCBjaGFuZ2VkVmFsdWVUeXBlS2V5cyk7XG4gICAgaWYgKHJlbW92ZWRUcmFuc2Zvcm1WYWx1ZXMubGVuZ3RoKSB7XG4gICAgICByZW1vdmVkVHJhbnNmb3JtVmFsdWVzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSkuc2V0KHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2aXN1YWxFbGVtZW50LnJlbmRlcigpO1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgc2Nyb2xsWSAhPT0gbnVsbCkge1xuICAgICAgd2luZG93LnNjcm9sbFRvKHsgdG9wOiBzY3JvbGxZIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyB0YXJnZXQ6IGNvbnZlcnRlZFRhcmdldCwgdHJhbnNpdGlvbkVuZCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHRhcmdldCwgdHJhbnNpdGlvbkVuZCB9O1xuICB9XG59O1xuZnVuY3Rpb24gdW5pdENvbnZlcnNpb24odmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpIHtcbiAgcmV0dXJuIGhhc1Bvc2l0aW9uYWxLZXkodGFyZ2V0KSA/IGNoZWNrQW5kQ29udmVydENoYW5nZWRWYWx1ZVR5cGVzKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKSA6IHsgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9wYXJzZS1kb20tdmFyaWFudC5tanNcbnZhciBwYXJzZURvbVZhcmlhbnQgPSAodmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpID0+IHtcbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlQ1NTVmFyaWFibGVzKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgdHJhbnNpdGlvbkVuZCk7XG4gIHRhcmdldCA9IHJlc29sdmVkLnRhcmdldDtcbiAgdHJhbnNpdGlvbkVuZCA9IHJlc29sdmVkLnRyYW5zaXRpb25FbmQ7XG4gIHJldHVybiB1bml0Q29udmVyc2lvbih2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9WaXN1YWxFbGVtZW50Lm1qc1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3JlZHVjZWQtbW90aW9uL3N0YXRlLm1qc1xudmFyIHByZWZlcnNSZWR1Y2VkTW90aW9uID0geyBjdXJyZW50OiBudWxsIH07XG52YXIgaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyID0geyBjdXJyZW50OiBmYWxzZSB9O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3JlZHVjZWQtbW90aW9uL2luZGV4Lm1qc1xuZnVuY3Rpb24gaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uKCkge1xuICBoYXNSZWR1Y2VkTW90aW9uTGlzdGVuZXIuY3VycmVudCA9IHRydWU7XG4gIGlmICghaXNCcm93c2VyKVxuICAgIHJldHVybjtcbiAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgY29uc3QgbW90aW9uTWVkaWFRdWVyeSA9IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb24pXCIpO1xuICAgIGNvbnN0IHNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcyA9ICgpID0+IHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQgPSBtb3Rpb25NZWRpYVF1ZXJ5Lm1hdGNoZXM7XG4gICAgbW90aW9uTWVkaWFRdWVyeS5hZGRMaXN0ZW5lcihzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMpO1xuICAgIHNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcygpO1xuICB9IGVsc2Uge1xuICAgIHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQgPSBmYWxzZTtcbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9tb3Rpb24tdmFsdWVzLm1qc1xuZnVuY3Rpb24gdXBkYXRlTW90aW9uVmFsdWVzRnJvbVByb3BzKGVsZW1lbnQsIG5leHQsIHByZXYpIHtcbiAgY29uc3QgeyB3aWxsQ2hhbmdlIH0gPSBuZXh0O1xuICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgY29uc3QgbmV4dFZhbHVlID0gbmV4dFtrZXldO1xuICAgIGNvbnN0IHByZXZWYWx1ZSA9IHByZXZba2V5XTtcbiAgICBpZiAoaXNNb3Rpb25WYWx1ZShuZXh0VmFsdWUpKSB7XG4gICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbmV4dFZhbHVlKTtcbiAgICAgIGlmIChpc1dpbGxDaGFuZ2VNb3Rpb25WYWx1ZSh3aWxsQ2hhbmdlKSkge1xuICAgICAgICB3aWxsQ2hhbmdlLmFkZChrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgd2Fybk9uY2UobmV4dFZhbHVlLnZlcnNpb24gPT09IFwiNy42LjdcIiwgYEF0dGVtcHRpbmcgdG8gbWl4IEZyYW1lciBNb3Rpb24gdmVyc2lvbnMgJHtuZXh0VmFsdWUudmVyc2lvbn0gd2l0aCA3LjYuNyBtYXkgbm90IHdvcmsgYXMgZXhwZWN0ZWQuYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc01vdGlvblZhbHVlKHByZXZWYWx1ZSkpIHtcbiAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZShuZXh0VmFsdWUpKTtcbiAgICAgIGlmIChpc1dpbGxDaGFuZ2VNb3Rpb25WYWx1ZSh3aWxsQ2hhbmdlKSkge1xuICAgICAgICB3aWxsQ2hhbmdlLnJlbW92ZShrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldlZhbHVlICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgIGlmIChlbGVtZW50Lmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IGVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgIWV4aXN0aW5nVmFsdWUuaGFzQW5pbWF0ZWQgJiYgZXhpc3RpbmdWYWx1ZS5zZXQobmV4dFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdFZhbHVlID0gZWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXkpO1xuICAgICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUobGF0ZXN0VmFsdWUgIT09IHZvaWQgMCA/IGxhdGVzdFZhbHVlIDogbmV4dFZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcbiAgICBpZiAobmV4dFtrZXldID09PSB2b2lkIDApXG4gICAgICBlbGVtZW50LnJlbW92ZVZhbHVlKGtleSk7XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL1Zpc3VhbEVsZW1lbnQubWpzXG52YXIgZmVhdHVyZU5hbWVzID0gT2JqZWN0LmtleXMoZmVhdHVyZURlZmluaXRpb25zKTtcbnZhciBudW1GZWF0dXJlcyA9IGZlYXR1cmVOYW1lcy5sZW5ndGg7XG52YXIgcHJvcEV2ZW50SGFuZGxlcnMgPSBbXG4gIFwiQW5pbWF0aW9uU3RhcnRcIixcbiAgXCJBbmltYXRpb25Db21wbGV0ZVwiLFxuICBcIlVwZGF0ZVwiLFxuICBcIlVubW91bnRcIixcbiAgXCJCZWZvcmVMYXlvdXRNZWFzdXJlXCIsXG4gIFwiTGF5b3V0TWVhc3VyZVwiLFxuICBcIkxheW91dEFuaW1hdGlvblN0YXJ0XCIsXG4gIFwiTGF5b3V0QW5pbWF0aW9uQ29tcGxldGVcIlxuXTtcbnZhciBWaXN1YWxFbGVtZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IHBhcmVudCwgcHJvcHMsIHJlZHVjZWRNb3Rpb25Db25maWcsIHZpc3VhbFN0YXRlIH0sIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5jaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5pc1ZhcmlhbnROb2RlID0gZmFsc2U7XG4gICAgdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHMgPSBmYWxzZTtcbiAgICB0aGlzLnNob3VsZFJlZHVjZU1vdGlvbiA9IG51bGw7XG4gICAgdGhpcy52YWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuaXNQcmVzZW50ID0gdHJ1ZTtcbiAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmV2TW90aW9uVmFsdWVzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICB0aGlzLm5vdGlmeVVwZGF0ZSA9ICgpID0+IHRoaXMubm90aWZ5KFwiVXBkYXRlXCIsIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICB0aGlzLnJlbmRlciA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5jdXJyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnRyaWdnZXJCdWlsZCgpO1xuICAgICAgdGhpcy5yZW5kZXJJbnN0YW5jZSh0aGlzLmN1cnJlbnQsIHRoaXMucmVuZGVyU3RhdGUsIHRoaXMucHJvcHMuc3R5bGUsIHRoaXMucHJvamVjdGlvbik7XG4gICAgfTtcbiAgICB0aGlzLnNjaGVkdWxlUmVuZGVyID0gKCkgPT4gZXNfZGVmYXVsdC5yZW5kZXIodGhpcy5yZW5kZXIsIGZhbHNlLCB0cnVlKTtcbiAgICBjb25zdCB7IGxhdGVzdFZhbHVlcywgcmVuZGVyU3RhdGUgfSA9IHZpc3VhbFN0YXRlO1xuICAgIHRoaXMubGF0ZXN0VmFsdWVzID0gbGF0ZXN0VmFsdWVzO1xuICAgIHRoaXMuYmFzZVRhcmdldCA9IF9fc3ByZWFkVmFsdWVzKHt9LCBsYXRlc3RWYWx1ZXMpO1xuICAgIHRoaXMuaW5pdGlhbFZhbHVlcyA9IHByb3BzLmluaXRpYWwgPyBfX3NwcmVhZFZhbHVlcyh7fSwgbGF0ZXN0VmFsdWVzKSA6IHt9O1xuICAgIHRoaXMucmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5kZXB0aCA9IHBhcmVudCA/IHBhcmVudC5kZXB0aCArIDEgOiAwO1xuICAgIHRoaXMucmVkdWNlZE1vdGlvbkNvbmZpZyA9IHJlZHVjZWRNb3Rpb25Db25maWc7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmlzQ29udHJvbGxpbmdWYXJpYW50cyA9IGlzQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcyk7XG4gICAgdGhpcy5pc1ZhcmlhbnROb2RlID0gaXNWYXJpYW50Tm9kZShwcm9wcyk7XG4gICAgaWYgKHRoaXMuaXNWYXJpYW50Tm9kZSkge1xuICAgICAgdGhpcy52YXJpYW50Q2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIH1cbiAgICB0aGlzLm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQgPSBCb29sZWFuKHBhcmVudCAmJiBwYXJlbnQuY3VycmVudCk7XG4gICAgY29uc3QgX2EgPSB0aGlzLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcyksIHsgd2lsbENoYW5nZSB9ID0gX2EsIGluaXRpYWxNb3Rpb25WYWx1ZXMgPSBfX29ialJlc3QoX2EsIFtcIndpbGxDaGFuZ2VcIl0pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluaXRpYWxNb3Rpb25WYWx1ZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5pdGlhbE1vdGlvblZhbHVlc1trZXldO1xuICAgICAgaWYgKGxhdGVzdFZhbHVlc1trZXldICE9PSB2b2lkIDAgJiYgaXNNb3Rpb25WYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuc2V0KGxhdGVzdFZhbHVlc1trZXldLCBmYWxzZSk7XG4gICAgICAgIGlmIChpc1dpbGxDaGFuZ2VNb3Rpb25WYWx1ZSh3aWxsQ2hhbmdlKSkge1xuICAgICAgICAgIHdpbGxDaGFuZ2UuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKF9wcm9wcykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBtb3VudChpbnN0YW5jZSkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICBpZiAodGhpcy5wcm9qZWN0aW9uKSB7XG4gICAgICB0aGlzLnByb2plY3Rpb24ubW91bnQoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5pc1ZhcmlhbnROb2RlICYmICF0aGlzLmlzQ29udHJvbGxpbmdWYXJpYW50cykge1xuICAgICAgdGhpcy5yZW1vdmVGcm9tVmFyaWFudFRyZWUgPSAoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZFZhcmlhbnRDaGlsZCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy52YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGhpcy5iaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKSk7XG4gICAgaWYgKCFoYXNSZWR1Y2VkTW90aW9uTGlzdGVuZXIuY3VycmVudCkge1xuICAgICAgaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuc2hvdWxkUmVkdWNlTW90aW9uID0gdGhpcy5yZWR1Y2VkTW90aW9uQ29uZmlnID09PSBcIm5ldmVyXCIgPyBmYWxzZSA6IHRoaXMucmVkdWNlZE1vdGlvbkNvbmZpZyA9PT0gXCJhbHdheXNcIiA/IHRydWUgOiBwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50O1xuICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLmFkZCh0aGlzKTtcbiAgICB0aGlzLnNldFByb3BzKHRoaXMucHJvcHMpO1xuICB9XG4gIHVubW91bnQoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgKF9hID0gdGhpcy5wcm9qZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5tb3VudCgpO1xuICAgIGNhbmNlbFN5bmMudXBkYXRlKHRoaXMubm90aWZ5VXBkYXRlKTtcbiAgICBjYW5jZWxTeW5jLnJlbmRlcih0aGlzLnJlbmRlcik7XG4gICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuZm9yRWFjaCgocmVtb3ZlKSA9PiByZW1vdmUoKSk7XG4gICAgKF9iID0gdGhpcy5yZW1vdmVGcm9tVmFyaWFudFRyZWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMpO1xuICAgIChfYyA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2hpbGRyZW4uZGVsZXRlKHRoaXMpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZXZlbnRzKSB7XG4gICAgICB0aGlzLmV2ZW50c1trZXldLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gIH1cbiAgYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHJlbW92ZU9uQ2hhbmdlID0gdmFsdWUub25DaGFuZ2UoKGxhdGVzdFZhbHVlKSA9PiB7XG4gICAgICB0aGlzLmxhdGVzdFZhbHVlc1trZXldID0gbGF0ZXN0VmFsdWU7XG4gICAgICB0aGlzLnByb3BzLm9uVXBkYXRlICYmIGVzX2RlZmF1bHQudXBkYXRlKHRoaXMubm90aWZ5VXBkYXRlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVtb3ZlT25SZW5kZXJSZXF1ZXN0ID0gdmFsdWUub25SZW5kZXJSZXF1ZXN0KHRoaXMuc2NoZWR1bGVSZW5kZXIpO1xuICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLnNldChrZXksICgpID0+IHtcbiAgICAgIHJlbW92ZU9uQ2hhbmdlKCk7XG4gICAgICByZW1vdmVPblJlbmRlclJlcXVlc3QoKTtcbiAgICB9KTtcbiAgfVxuICBzb3J0Tm9kZVBvc2l0aW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQgfHwgIXRoaXMuc29ydEluc3RhbmNlTm9kZVBvc2l0aW9uIHx8IHRoaXMudHlwZSAhPT0gb3RoZXIudHlwZSlcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiB0aGlzLnNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbih0aGlzLmN1cnJlbnQsIG90aGVyLmN1cnJlbnQpO1xuICB9XG4gIGxvYWRGZWF0dXJlcyhyZW5kZXJlZFByb3BzLCBpc1N0cmljdCwgcHJlbG9hZGVkRmVhdHVyZXMsIHByb2plY3Rpb25JZCwgUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciwgaW5pdGlhbExheW91dEdyb3VwQ29uZmlnKSB7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBbXTtcbiAgICBpZiAoZW52ICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcmVsb2FkZWRGZWF0dXJlcyAmJiBpc1N0cmljdCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCBcIllvdSBoYXZlIHJlbmRlcmVkIGEgYG1vdGlvbmAgY29tcG9uZW50IHdpdGhpbiBhIGBMYXp5TW90aW9uYCBjb21wb25lbnQuIFRoaXMgd2lsbCBicmVhayB0cmVlIHNoYWtpbmcuIEltcG9ydCBhbmQgcmVuZGVyIGEgYG1gIGNvbXBvbmVudCBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bUZlYXR1cmVzOyBpMisrKSB7XG4gICAgICBjb25zdCBuYW1lID0gZmVhdHVyZU5hbWVzW2kyXTtcbiAgICAgIGNvbnN0IHsgaXNFbmFibGVkLCBDb21wb25lbnQgfSA9IGZlYXR1cmVEZWZpbml0aW9uc1tuYW1lXTtcbiAgICAgIGlmIChpc0VuYWJsZWQocmVuZGVyZWRQcm9wcykgJiYgQ29tcG9uZW50KSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlRWxlbWVudDMoQ29tcG9uZW50LCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICBrZXk6IG5hbWVcbiAgICAgICAgfSwgcmVuZGVyZWRQcm9wcyksIHtcbiAgICAgICAgICB2aXN1YWxFbGVtZW50OiB0aGlzXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5wcm9qZWN0aW9uICYmIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMucHJvamVjdGlvbiA9IG5ldyBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKHByb2plY3Rpb25JZCwgdGhpcy5sYXRlc3RWYWx1ZXMsIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnByb2plY3Rpb24pO1xuICAgICAgY29uc3QgeyBsYXlvdXRJZCwgbGF5b3V0LCBkcmFnOiBkcmFnMiwgZHJhZ0NvbnN0cmFpbnRzLCBsYXlvdXRTY3JvbGwgfSA9IHJlbmRlcmVkUHJvcHM7XG4gICAgICB0aGlzLnByb2plY3Rpb24uc2V0T3B0aW9ucyh7XG4gICAgICAgIGxheW91dElkLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGFsd2F5c01lYXN1cmVMYXlvdXQ6IEJvb2xlYW4oZHJhZzIpIHx8IGRyYWdDb25zdHJhaW50cyAmJiBpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpLFxuICAgICAgICB2aXN1YWxFbGVtZW50OiB0aGlzLFxuICAgICAgICBzY2hlZHVsZVJlbmRlcjogKCkgPT4gdGhpcy5zY2hlZHVsZVJlbmRlcigpLFxuICAgICAgICBhbmltYXRpb25UeXBlOiB0eXBlb2YgbGF5b3V0ID09PSBcInN0cmluZ1wiID8gbGF5b3V0IDogXCJib3RoXCIsXG4gICAgICAgIGluaXRpYWxQcm9tb3Rpb25Db25maWc6IGluaXRpYWxMYXlvdXRHcm91cENvbmZpZyxcbiAgICAgICAgbGF5b3V0U2Nyb2xsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG4gIHRyaWdnZXJCdWlsZCgpIHtcbiAgICB0aGlzLmJ1aWxkKHRoaXMucmVuZGVyU3RhdGUsIHRoaXMubGF0ZXN0VmFsdWVzLCB0aGlzLm9wdGlvbnMsIHRoaXMucHJvcHMpO1xuICB9XG4gIG1lYXN1cmVWaWV3cG9ydEJveCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID8gdGhpcy5tZWFzdXJlSW5zdGFuY2VWaWV3cG9ydEJveCh0aGlzLmN1cnJlbnQsIHRoaXMucHJvcHMpIDogY3JlYXRlQm94KCk7XG4gIH1cbiAgZ2V0U3RhdGljVmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZXN0VmFsdWVzW2tleV07XG4gIH1cbiAgc2V0U3RhdGljVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICBtYWtlVGFyZ2V0QW5pbWF0YWJsZSh0YXJnZXQsIGNhbk11dGF0ZSA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVGFyZ2V0QW5pbWF0YWJsZUZyb21JbnN0YW5jZSh0YXJnZXQsIHRoaXMucHJvcHMsIGNhbk11dGF0ZSk7XG4gIH1cbiAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICBpZiAocHJvcHMudHJhbnNmb3JtVGVtcGxhdGUgfHwgdGhpcy5wcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgIH1cbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHByb3BFdmVudEhhbmRsZXJzLmxlbmd0aDsgaTIrKykge1xuICAgICAgY29uc3Qga2V5ID0gcHJvcEV2ZW50SGFuZGxlcnNbaTJdO1xuICAgICAgaWYgKHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldKSB7XG4gICAgICAgIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gcHJvcHNbXCJvblwiICsga2V5XTtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XSA9IHRoaXMub24oa2V5LCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJldk1vdGlvblZhbHVlcyA9IHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyh0aGlzLCB0aGlzLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcyksIHRoaXMucHJldk1vdGlvblZhbHVlcyk7XG4gIH1cbiAgZ2V0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHM7XG4gIH1cbiAgZ2V0VmFyaWFudChuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnByb3BzLnZhcmlhbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbbmFtZV07XG4gIH1cbiAgZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMudHJhbnNpdGlvbjtcbiAgfVxuICBnZXRUcmFuc2Zvcm1QYWdlUG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMudHJhbnNmb3JtUGFnZVBvaW50O1xuICB9XG4gIGdldENsb3Nlc3RWYXJpYW50Tm9kZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHRoaXMuaXNWYXJpYW50Tm9kZSA/IHRoaXMgOiAoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldENsb3Nlc3RWYXJpYW50Tm9kZSgpO1xuICB9XG4gIGdldFZhcmlhbnRDb250ZXh0KHN0YXJ0QXRQYXJlbnQgPSBmYWxzZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHN0YXJ0QXRQYXJlbnQpXG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRWYXJpYW50Q29udGV4dCgpO1xuICAgIGlmICghdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHMpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQyID0gKChfYiA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0VmFyaWFudENvbnRleHQoKSkgfHwge307XG4gICAgICBpZiAodGhpcy5wcm9wcy5pbml0aWFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dDIuaW5pdGlhbCA9IHRoaXMucHJvcHMuaW5pdGlhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZXh0MjtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IHt9O1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1WYXJpYW50UHJvcHM7IGkyKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB2YXJpYW50UHJvcHMyW2kyXTtcbiAgICAgIGNvbnN0IHByb3AgPSB0aGlzLnByb3BzW25hbWVdO1xuICAgICAgaWYgKGlzVmFyaWFudExhYmVsKHByb3ApIHx8IHByb3AgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRleHRbbmFtZV0gPSBwcm9wO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBhZGRWYXJpYW50Q2hpbGQoY2hpbGQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY2xvc2VzdFZhcmlhbnROb2RlID0gdGhpcy5nZXRDbG9zZXN0VmFyaWFudE5vZGUoKTtcbiAgICBpZiAoY2xvc2VzdFZhcmlhbnROb2RlKSB7XG4gICAgICAoX2EgPSBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkKGNoaWxkKTtcbiAgICAgIHJldHVybiAoKSA9PiBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuLmRlbGV0ZShjaGlsZCk7XG4gICAgfVxuICB9XG4gIGFkZFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXNWYWx1ZShrZXkpKVxuICAgICAgdGhpcy5yZW1vdmVWYWx1ZShrZXkpO1xuICAgIHRoaXMudmFsdWVzLnNldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLmxhdGVzdFZhbHVlc1trZXldID0gdmFsdWUuZ2V0KCk7XG4gICAgdGhpcy5iaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKTtcbiAgfVxuICByZW1vdmVWYWx1ZShrZXkpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy52YWx1ZXMuZGVsZXRlKGtleSk7XG4gICAgKF9hID0gdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYSgpO1xuICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmRlbGV0ZShrZXkpO1xuICAgIGRlbGV0ZSB0aGlzLmxhdGVzdFZhbHVlc1trZXldO1xuICAgIHRoaXMucmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUoa2V5LCB0aGlzLnJlbmRlclN0YXRlKTtcbiAgfVxuICBoYXNWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMuaGFzKGtleSk7XG4gIH1cbiAgZ2V0VmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy52YWx1ZXMgJiYgdGhpcy5wcm9wcy52YWx1ZXNba2V5XSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMudmFsdWVzW2tleV07XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWVzLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwICYmIGRlZmF1bHRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IG1vdGlvblZhbHVlKGRlZmF1bHRWYWx1ZSk7XG4gICAgICB0aGlzLmFkZFZhbHVlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZFZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLmxhdGVzdFZhbHVlc1trZXldICE9PSB2b2lkIDAgfHwgIXRoaXMuY3VycmVudCA/IHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gOiB0aGlzLnJlYWRWYWx1ZUZyb21JbnN0YW5jZSh0aGlzLmN1cnJlbnQsIGtleSwgdGhpcy5vcHRpb25zKTtcbiAgfVxuICBzZXRCYXNlVGFyZ2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmJhc2VUYXJnZXRba2V5XSA9IHZhbHVlO1xuICB9XG4gIGdldEJhc2VUYXJnZXQoa2V5KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgaW5pdGlhbCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB2YWx1ZUZyb21Jbml0aWFsID0gdHlwZW9mIGluaXRpYWwgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGluaXRpYWwgPT09IFwib2JqZWN0XCIgPyAoX2EgPSByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyh0aGlzLnByb3BzLCBpbml0aWFsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2tleV0gOiB2b2lkIDA7XG4gICAgaWYgKGluaXRpYWwgJiYgdmFsdWVGcm9tSW5pdGlhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdmFsdWVGcm9tSW5pdGlhbDtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRCYXNlVGFyZ2V0RnJvbVByb3BzKHRoaXMucHJvcHMsIGtleSk7XG4gICAgaWYgKHRhcmdldCAhPT0gdm9pZCAwICYmICFpc01vdGlvblZhbHVlKHRhcmdldCkpXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZXNba2V5XSAhPT0gdm9pZCAwICYmIHZhbHVlRnJvbUluaXRpYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMuYmFzZVRhcmdldFtrZXldO1xuICB9XG4gIG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5hZGQoY2FsbGJhY2spO1xuICB9XG4gIG5vdGlmeShldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vdGlmeSguLi5hcmdzKTtcbiAgfVxufTtcbnZhciB2YXJpYW50UHJvcHMyID0gW1wiaW5pdGlhbFwiLCAuLi52YXJpYW50UHJpb3JpdHlPcmRlcl07XG52YXIgbnVtVmFyaWFudFByb3BzID0gdmFyaWFudFByb3BzMi5sZW5ndGg7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS9ET01WaXN1YWxFbGVtZW50Lm1qc1xudmFyIERPTVZpc3VhbEVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIFZpc3VhbEVsZW1lbnQge1xuICBzb3J0SW5zdGFuY2VOb2RlUG9zaXRpb24oYTIsIGIyKSB7XG4gICAgcmV0dXJuIGEyLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIyKSAmIDIgPyAxIDogLTE7XG4gIH1cbiAgZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyhwcm9wcywga2V5KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBwcm9wcy5zdHlsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2tleV07XG4gIH1cbiAgcmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUoa2V5LCB7IHZhcnMsIHN0eWxlIH0pIHtcbiAgICBkZWxldGUgdmFyc1trZXldO1xuICAgIGRlbGV0ZSBzdHlsZVtrZXldO1xuICB9XG4gIG1ha2VUYXJnZXRBbmltYXRhYmxlRnJvbUluc3RhbmNlKF9hLCB7IHRyYW5zZm9ybVZhbHVlcyB9LCBpc01vdW50ZWQpIHtcbiAgICB2YXIgX2IgPSBfYSwgeyB0cmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kIH0gPSBfYiwgdGFyZ2V0ID0gX19vYmpSZXN0KF9iLCBbXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbkVuZFwiXSk7XG4gICAgbGV0IG9yaWdpbiA9IGdldE9yaWdpbih0YXJnZXQsIHRyYW5zaXRpb24gfHwge30sIHRoaXMpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWx1ZXMpIHtcbiAgICAgIGlmICh0cmFuc2l0aW9uRW5kKVxuICAgICAgICB0cmFuc2l0aW9uRW5kID0gdHJhbnNmb3JtVmFsdWVzKHRyYW5zaXRpb25FbmQpO1xuICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtVmFsdWVzKHRhcmdldCk7XG4gICAgICBpZiAob3JpZ2luKVxuICAgICAgICBvcmlnaW4gPSB0cmFuc2Zvcm1WYWx1ZXMob3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXModGhpcywgdGFyZ2V0LCBvcmlnaW4pO1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VEb21WYXJpYW50KHRoaXMsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKTtcbiAgICAgIHRyYW5zaXRpb25FbmQgPSBwYXJzZWQudHJhbnNpdGlvbkVuZDtcbiAgICAgIHRhcmdldCA9IHBhcnNlZC50YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgdHJhbnNpdGlvbkVuZFxuICAgIH0sIHRhcmdldCk7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvSFRNTFZpc3VhbEVsZW1lbnQubWpzXG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlMihlbGVtZW50KSB7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbnZhciBIVE1MVmlzdWFsRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgRE9NVmlzdWFsRWxlbWVudCB7XG4gIHJlYWRWYWx1ZUZyb21JbnN0YW5jZShpbnN0YW5jZSwga2V5KSB7XG4gICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICBjb25zdCBkZWZhdWx0VHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgICAgIHJldHVybiBkZWZhdWx0VHlwZSA/IGRlZmF1bHRUeXBlLmRlZmF1bHQgfHwgMCA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlMihpbnN0YW5jZSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IChpc0NTU1ZhcmlhYmxlKGtleSkgPyBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoa2V5KSA6IGNvbXB1dGVkU3R5bGVba2V5XSkgfHwgMDtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS50cmltKCkgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgbWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3goaW5zdGFuY2UsIHsgdHJhbnNmb3JtUGFnZVBvaW50IH0pIHtcbiAgICByZXR1cm4gbWVhc3VyZVZpZXdwb3J0Qm94KGluc3RhbmNlLCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICB9XG4gIGJ1aWxkKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzKSB7XG4gICAgYnVpbGRIVE1MU3R5bGVzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgfVxuICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKTtcbiAgfVxuICByZW5kZXJJbnN0YW5jZShpbnN0YW5jZSwgcmVuZGVyU3RhdGUsIHN0eWxlUHJvcCwgcHJvamVjdGlvbikge1xuICAgIHJlbmRlckhUTUwoaW5zdGFuY2UsIHJlbmRlclN0YXRlLCBzdHlsZVByb3AsIHByb2plY3Rpb24pO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvU1ZHVmlzdWFsRWxlbWVudC5tanNcbnZhciBTVkdWaXN1YWxFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBET01WaXN1YWxFbGVtZW50IHtcbiAgZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyhwcm9wcywga2V5KSB7XG4gICAgcmV0dXJuIHByb3BzW2tleV07XG4gIH1cbiAgcmVhZFZhbHVlRnJvbUluc3RhbmNlKGluc3RhbmNlLCBrZXkpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gKChfYSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlZmF1bHQpIHx8IDA7XG4gICAgfVxuICAgIGtleSA9ICFjYW1lbENhc2VBdHRyaWJ1dGVzLmhhcyhrZXkpID8gY2FtZWxUb0Rhc2goa2V5KSA6IGtleTtcbiAgICByZXR1cm4gaW5zdGFuY2UuZ2V0QXR0cmlidXRlKGtleSk7XG4gIH1cbiAgbWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3goKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJveCgpO1xuICB9XG4gIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMyKHByb3BzKTtcbiAgfVxuICBidWlsZChyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBvcHRpb25zLCBwcm9wcykge1xuICAgIGJ1aWxkU1ZHQXR0cnMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICB9XG4gIHJlbmRlckluc3RhbmNlKGluc3RhbmNlLCByZW5kZXJTdGF0ZSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gICAgcmVuZGVyU1ZHKGluc3RhbmNlLCByZW5kZXJTdGF0ZSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL2NyZWF0ZS12aXN1YWwtZWxlbWVudC5tanNcbnZhciBjcmVhdGVEb21WaXN1YWxFbGVtZW50ID0gKENvbXBvbmVudCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KSA/IG5ldyBTVkdWaXN1YWxFbGVtZW50KG9wdGlvbnMsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IGZhbHNlIH0pIDogbmV3IEhUTUxWaXN1YWxFbGVtZW50KG9wdGlvbnMsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IHRydWUgfSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9sYXlvdXQvTWVhc3VyZUxheW91dC5tanNcbmltcG9ydCBSZWFjdF9fZGVmYXVsdDIsIHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0OSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWJvcmRlci1yYWRpdXMubWpzXG5mdW5jdGlvbiBwaXhlbHNUb1BlcmNlbnQocGl4ZWxzLCBheGlzKSB7XG4gIGlmIChheGlzLm1heCA9PT0gYXhpcy5taW4pXG4gICAgcmV0dXJuIDA7XG4gIHJldHVybiBwaXhlbHMgLyAoYXhpcy5tYXggLSBheGlzLm1pbikgKiAxMDA7XG59XG52YXIgY29ycmVjdEJvcmRlclJhZGl1cyA9IHtcbiAgY29ycmVjdDogKGxhdGVzdCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS50YXJnZXQpXG4gICAgICByZXR1cm4gbGF0ZXN0O1xuICAgIGlmICh0eXBlb2YgbGF0ZXN0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAocHgudGVzdChsYXRlc3QpKSB7XG4gICAgICAgIGxhdGVzdCA9IHBhcnNlRmxvYXQobGF0ZXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsYXRlc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHggPSBwaXhlbHNUb1BlcmNlbnQobGF0ZXN0LCBub2RlLnRhcmdldC54KTtcbiAgICBjb25zdCB5ID0gcGl4ZWxzVG9QZXJjZW50KGxhdGVzdCwgbm9kZS50YXJnZXQueSk7XG4gICAgcmV0dXJuIGAke3h9JSAke3l9JWA7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9zdHlsZXMvc2NhbGUtYm94LXNoYWRvdy5tanNcbnZhciB2YXJUb2tlbiA9IFwiXyRjc3NcIjtcbnZhciBjb3JyZWN0Qm94U2hhZG93ID0ge1xuICBjb3JyZWN0OiAobGF0ZXN0LCB7IHRyZWVTY2FsZSwgcHJvamVjdGlvbkRlbHRhIH0pID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbCA9IGxhdGVzdDtcbiAgICBjb25zdCBjb250YWluc0NTU1ZhcmlhYmxlcyA9IGxhdGVzdC5pbmNsdWRlcyhcInZhcihcIik7XG4gICAgY29uc3QgY3NzVmFyaWFibGVzID0gW107XG4gICAgaWYgKGNvbnRhaW5zQ1NTVmFyaWFibGVzKSB7XG4gICAgICBsYXRlc3QgPSBsYXRlc3QucmVwbGFjZShjc3NWYXJpYWJsZVJlZ2V4LCAobWF0Y2gpID0+IHtcbiAgICAgICAgY3NzVmFyaWFibGVzLnB1c2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gdmFyVG9rZW47XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2hhZG93ID0gY29tcGxleC5wYXJzZShsYXRlc3QpO1xuICAgIGlmIChzaGFkb3cubGVuZ3RoID4gNSlcbiAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIobGF0ZXN0KTtcbiAgICBjb25zdCBvZmZzZXQgPSB0eXBlb2Ygc2hhZG93WzBdICE9PSBcIm51bWJlclwiID8gMSA6IDA7XG4gICAgY29uc3QgeFNjYWxlID0gcHJvamVjdGlvbkRlbHRhLnguc2NhbGUgKiB0cmVlU2NhbGUueDtcbiAgICBjb25zdCB5U2NhbGUgPSBwcm9qZWN0aW9uRGVsdGEueS5zY2FsZSAqIHRyZWVTY2FsZS55O1xuICAgIHNoYWRvd1swICsgb2Zmc2V0XSAvPSB4U2NhbGU7XG4gICAgc2hhZG93WzEgKyBvZmZzZXRdIC89IHlTY2FsZTtcbiAgICBjb25zdCBhdmVyYWdlU2NhbGUgPSBtaXgoeFNjYWxlLCB5U2NhbGUsIDAuNSk7XG4gICAgaWYgKHR5cGVvZiBzaGFkb3dbMiArIG9mZnNldF0gPT09IFwibnVtYmVyXCIpXG4gICAgICBzaGFkb3dbMiArIG9mZnNldF0gLz0gYXZlcmFnZVNjYWxlO1xuICAgIGlmICh0eXBlb2Ygc2hhZG93WzMgKyBvZmZzZXRdID09PSBcIm51bWJlclwiKVxuICAgICAgc2hhZG93WzMgKyBvZmZzZXRdIC89IGF2ZXJhZ2VTY2FsZTtcbiAgICBsZXQgb3V0cHV0ID0gdGVtcGxhdGUoc2hhZG93KTtcbiAgICBpZiAoY29udGFpbnNDU1NWYXJpYWJsZXMpIHtcbiAgICAgIGxldCBpMiA9IDA7XG4gICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSh2YXJUb2tlbiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBjc3NWYXJpYWJsZSA9IGNzc1ZhcmlhYmxlc1tpMl07XG4gICAgICAgIGkyKys7XG4gICAgICAgIHJldHVybiBjc3NWYXJpYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9sYXlvdXQvTWVhc3VyZUxheW91dC5tanNcbnZhciBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQgPSBjbGFzcyBleHRlbmRzIFJlYWN0X19kZWZhdWx0Mi5Db21wb25lbnQge1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQsIGxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cCwgbGF5b3V0SWQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB2aXN1YWxFbGVtZW50O1xuICAgIGFkZFNjYWxlQ29ycmVjdG9yKGRlZmF1bHRTY2FsZUNvcnJlY3RvcnMpO1xuICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICBpZiAobGF5b3V0R3JvdXAuZ3JvdXApXG4gICAgICAgIGxheW91dEdyb3VwLmdyb3VwLmFkZChwcm9qZWN0aW9uKTtcbiAgICAgIGlmIChzd2l0Y2hMYXlvdXRHcm91cCAmJiBzd2l0Y2hMYXlvdXRHcm91cC5yZWdpc3RlciAmJiBsYXlvdXRJZCkge1xuICAgICAgICBzd2l0Y2hMYXlvdXRHcm91cC5yZWdpc3Rlcihwcm9qZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHByb2plY3Rpb24ucm9vdC5kaWRVcGRhdGUoKTtcbiAgICAgIHByb2plY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbkNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgICAgcHJvamVjdGlvbi5zZXRPcHRpb25zKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByb2plY3Rpb24ub3B0aW9ucyksIHtcbiAgICAgICAgb25FeGl0Q29tcGxldGU6ICgpID0+IHRoaXMuc2FmZVRvUmVtb3ZlKClcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0V2ZXJVcGRhdGVkID0gdHJ1ZTtcbiAgfVxuICBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBjb25zdCB7IGxheW91dERlcGVuZGVuY3ksIHZpc3VhbEVsZW1lbnQsIGRyYWc6IGRyYWcyLCBpc1ByZXNlbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICBpZiAoIXByb2plY3Rpb24pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBwcm9qZWN0aW9uLmlzUHJlc2VudCA9IGlzUHJlc2VudDtcbiAgICBpZiAoZHJhZzIgfHwgcHJldlByb3BzLmxheW91dERlcGVuZGVuY3kgIT09IGxheW91dERlcGVuZGVuY3kgfHwgbGF5b3V0RGVwZW5kZW5jeSA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm9qZWN0aW9uLndpbGxVcGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKHByZXZQcm9wcy5pc1ByZXNlbnQgIT09IGlzUHJlc2VudCkge1xuICAgICAgaWYgKGlzUHJlc2VudCkge1xuICAgICAgICBwcm9qZWN0aW9uLnByb21vdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb2plY3Rpb24ucmVsZWdhdGUoKSkge1xuICAgICAgICBlc19kZWZhdWx0LnBvc3RSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBpZiAoISgoX2EgPSBwcm9qZWN0aW9uLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZW1iZXJzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy5wcm9wcy52aXN1YWxFbGVtZW50O1xuICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICBwcm9qZWN0aW9uLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICBpZiAoIXByb2plY3Rpb24uY3VycmVudEFuaW1hdGlvbiAmJiBwcm9qZWN0aW9uLmlzTGVhZCgpKSB7XG4gICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCwgbGF5b3V0R3JvdXAsIHN3aXRjaExheW91dEdyb3VwOiBwcm9tb3RlQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHZpc3VhbEVsZW1lbnQ7XG4gICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgIHByb2plY3Rpb24uc2NoZWR1bGVDaGVja0FmdGVyVW5tb3VudCgpO1xuICAgICAgaWYgKGxheW91dEdyb3VwID09PSBudWxsIHx8IGxheW91dEdyb3VwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXlvdXRHcm91cC5ncm91cClcbiAgICAgICAgbGF5b3V0R3JvdXAuZ3JvdXAucmVtb3ZlKHByb2plY3Rpb24pO1xuICAgICAgaWYgKHByb21vdGVDb250ZXh0ID09PSBudWxsIHx8IHByb21vdGVDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9tb3RlQ29udGV4dC5kZXJlZ2lzdGVyKVxuICAgICAgICBwcm9tb3RlQ29udGV4dC5kZXJlZ2lzdGVyKHByb2plY3Rpb24pO1xuICAgIH1cbiAgfVxuICBzYWZlVG9SZW1vdmUoKSB7XG4gICAgY29uc3QgeyBzYWZlVG9SZW1vdmUgfSA9IHRoaXMucHJvcHM7XG4gICAgc2FmZVRvUmVtb3ZlID09PSBudWxsIHx8IHNhZmVUb1JlbW92ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2FmZVRvUmVtb3ZlKCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuZnVuY3Rpb24gTWVhc3VyZUxheW91dChwcm9wcykge1xuICBjb25zdCBbaXNQcmVzZW50LCBzYWZlVG9SZW1vdmVdID0gdXNlUHJlc2VuY2UoKTtcbiAgY29uc3QgbGF5b3V0R3JvdXAgPSB1c2VDb250ZXh0OShMYXlvdXRHcm91cENvbnRleHQpO1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQyLmNyZWF0ZUVsZW1lbnQoTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcyksIHsgbGF5b3V0R3JvdXAsIHN3aXRjaExheW91dEdyb3VwOiB1c2VDb250ZXh0OShTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQpLCBpc1ByZXNlbnQsIHNhZmVUb1JlbW92ZSB9KSk7XG59XG52YXIgZGVmYXVsdFNjYWxlQ29ycmVjdG9ycyA9IHtcbiAgYm9yZGVyUmFkaXVzOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBjb3JyZWN0Qm9yZGVyUmFkaXVzKSwge1xuICAgIGFwcGx5VG86IFtcbiAgICAgIFwiYm9yZGVyVG9wTGVmdFJhZGl1c1wiLFxuICAgICAgXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFxuICAgICAgXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzXCIsXG4gICAgICBcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCJcbiAgICBdXG4gIH0pLFxuICBib3JkZXJUb3BMZWZ0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICBib3JkZXJUb3BSaWdodFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gIGJveFNoYWRvdzogY29ycmVjdEJveFNoYWRvd1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvbGF5b3V0L2luZGV4Lm1qc1xudmFyIGxheW91dEZlYXR1cmVzID0ge1xuICBtZWFzdXJlTGF5b3V0OiBNZWFzdXJlTGF5b3V0XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRlLm1qc1xuZnVuY3Rpb24gYW5pbWF0ZTIoZnJvbSwgdG8sIHRyYW5zaXRpb24gPSB7fSkge1xuICBjb25zdCB2YWx1ZSA9IGlzTW90aW9uVmFsdWUoZnJvbSkgPyBmcm9tIDogbW90aW9uVmFsdWUoZnJvbSk7XG4gIHN0YXJ0QW5pbWF0aW9uKFwiXCIsIHZhbHVlLCB0bywgdHJhbnNpdGlvbik7XG4gIHJldHVybiB7XG4gICAgc3RvcDogKCkgPT4gdmFsdWUuc3RvcCgpLFxuICAgIGlzQW5pbWF0aW5nOiAoKSA9PiB2YWx1ZS5pc0FuaW1hdGluZygpXG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9hbmltYXRpb24vbWl4LXZhbHVlcy5tanNcbnZhciBib3JkZXJzID0gW1wiVG9wTGVmdFwiLCBcIlRvcFJpZ2h0XCIsIFwiQm90dG9tTGVmdFwiLCBcIkJvdHRvbVJpZ2h0XCJdO1xudmFyIG51bUJvcmRlcnMgPSBib3JkZXJzLmxlbmd0aDtcbnZhciBhc051bWJlciA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTtcbnZhciBpc1B4ID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgcHgudGVzdCh2YWx1ZSk7XG5mdW5jdGlvbiBtaXhWYWx1ZXModGFyZ2V0LCBmb2xsb3csIGxlYWQsIHByb2dyZXNzMywgc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSwgaXNPbmx5TWVtYmVyKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgaWYgKHNob3VsZENyb3NzZmFkZU9wYWNpdHkpIHtcbiAgICB0YXJnZXQub3BhY2l0eSA9IG1peChcbiAgICAgIDAsXG4gICAgICAoX2EgPSBsZWFkLm9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEsXG4gICAgICBlYXNlQ3Jvc3NmYWRlSW4ocHJvZ3Jlc3MzKVxuICAgICk7XG4gICAgdGFyZ2V0Lm9wYWNpdHlFeGl0ID0gbWl4KChfYiA9IGZvbGxvdy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxLCAwLCBlYXNlQ3Jvc3NmYWRlT3V0KHByb2dyZXNzMykpO1xuICB9IGVsc2UgaWYgKGlzT25seU1lbWJlcikge1xuICAgIHRhcmdldC5vcGFjaXR5ID0gbWl4KChfYyA9IGZvbGxvdy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAxLCAoX2QgPSBsZWFkLm9wYWNpdHkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDEsIHByb2dyZXNzMyk7XG4gIH1cbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bUJvcmRlcnM7IGkyKyspIHtcbiAgICBjb25zdCBib3JkZXJMYWJlbCA9IGBib3JkZXIke2JvcmRlcnNbaTJdfVJhZGl1c2A7XG4gICAgbGV0IGZvbGxvd1JhZGl1cyA9IGdldFJhZGl1cyhmb2xsb3csIGJvcmRlckxhYmVsKTtcbiAgICBsZXQgbGVhZFJhZGl1cyA9IGdldFJhZGl1cyhsZWFkLCBib3JkZXJMYWJlbCk7XG4gICAgaWYgKGZvbGxvd1JhZGl1cyA9PT0gdm9pZCAwICYmIGxlYWRSYWRpdXMgPT09IHZvaWQgMClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGZvbGxvd1JhZGl1cyB8fCAoZm9sbG93UmFkaXVzID0gMCk7XG4gICAgbGVhZFJhZGl1cyB8fCAobGVhZFJhZGl1cyA9IDApO1xuICAgIGNvbnN0IGNhbk1peCA9IGZvbGxvd1JhZGl1cyA9PT0gMCB8fCBsZWFkUmFkaXVzID09PSAwIHx8IGlzUHgoZm9sbG93UmFkaXVzKSA9PT0gaXNQeChsZWFkUmFkaXVzKTtcbiAgICBpZiAoY2FuTWl4KSB7XG4gICAgICB0YXJnZXRbYm9yZGVyTGFiZWxdID0gTWF0aC5tYXgobWl4KGFzTnVtYmVyKGZvbGxvd1JhZGl1cyksIGFzTnVtYmVyKGxlYWRSYWRpdXMpLCBwcm9ncmVzczMpLCAwKTtcbiAgICAgIGlmIChwZXJjZW50LnRlc3QobGVhZFJhZGl1cykgfHwgcGVyY2VudC50ZXN0KGZvbGxvd1JhZGl1cykpIHtcbiAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSArPSBcIiVcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IGxlYWRSYWRpdXM7XG4gICAgfVxuICB9XG4gIGlmIChmb2xsb3cucm90YXRlIHx8IGxlYWQucm90YXRlKSB7XG4gICAgdGFyZ2V0LnJvdGF0ZSA9IG1peChmb2xsb3cucm90YXRlIHx8IDAsIGxlYWQucm90YXRlIHx8IDAsIHByb2dyZXNzMyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJhZGl1cyh2YWx1ZXMsIHJhZGl1c05hbWUpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gdmFsdWVzW3JhZGl1c05hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZXMuYm9yZGVyUmFkaXVzO1xufVxudmFyIGVhc2VDcm9zc2ZhZGVJbiA9IGNvbXByZXNzKDAsIDAuNSwgY2lyY091dCk7XG52YXIgZWFzZUNyb3NzZmFkZU91dCA9IGNvbXByZXNzKDAuNSwgMC45NSwgbGluZWFyKTtcbmZ1bmN0aW9uIGNvbXByZXNzKG1pbiwgbWF4LCBlYXNpbmcpIHtcbiAgcmV0dXJuIChwMikgPT4ge1xuICAgIGlmIChwMiA8IG1pbilcbiAgICAgIHJldHVybiAwO1xuICAgIGlmIChwMiA+IG1heClcbiAgICAgIHJldHVybiAxO1xuICAgIHJldHVybiBlYXNpbmcocHJvZ3Jlc3MobWluLCBtYXgsIHAyKSk7XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9jb3B5Lm1qc1xuZnVuY3Rpb24gY29weUF4aXNJbnRvKGF4aXMsIG9yaWdpbkF4aXMpIHtcbiAgYXhpcy5taW4gPSBvcmlnaW5BeGlzLm1pbjtcbiAgYXhpcy5tYXggPSBvcmlnaW5BeGlzLm1heDtcbn1cbmZ1bmN0aW9uIGNvcHlCb3hJbnRvKGJveCwgb3JpZ2luQm94KSB7XG4gIGNvcHlBeGlzSW50byhib3gueCwgb3JpZ2luQm94LngpO1xuICBjb3B5QXhpc0ludG8oYm94LnksIG9yaWdpbkJveC55KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLXJlbW92ZS5tanNcbmZ1bmN0aW9uIHJlbW92ZVBvaW50RGVsdGEocG9pbnQyLCB0cmFuc2xhdGUsIHNjYWxlMiwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKSB7XG4gIHBvaW50MiAtPSB0cmFuc2xhdGU7XG4gIHBvaW50MiA9IHNjYWxlUG9pbnQocG9pbnQyLCAxIC8gc2NhbGUyLCBvcmlnaW5Qb2ludCk7XG4gIGlmIChib3hTY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgcG9pbnQyID0gc2NhbGVQb2ludChwb2ludDIsIDEgLyBib3hTY2FsZSwgb3JpZ2luUG9pbnQpO1xuICB9XG4gIHJldHVybiBwb2ludDI7XG59XG5mdW5jdGlvbiByZW1vdmVBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlID0gMCwgc2NhbGUyID0gMSwgb3JpZ2luID0gMC41LCBib3hTY2FsZSwgb3JpZ2luQXhpcyA9IGF4aXMsIHNvdXJjZUF4aXMgPSBheGlzKSB7XG4gIGlmIChwZXJjZW50LnRlc3QodHJhbnNsYXRlKSkge1xuICAgIHRyYW5zbGF0ZSA9IHBhcnNlRmxvYXQodHJhbnNsYXRlKTtcbiAgICBjb25zdCByZWxhdGl2ZVByb2dyZXNzID0gbWl4KHNvdXJjZUF4aXMubWluLCBzb3VyY2VBeGlzLm1heCwgdHJhbnNsYXRlIC8gMTAwKTtcbiAgICB0cmFuc2xhdGUgPSByZWxhdGl2ZVByb2dyZXNzIC0gc291cmNlQXhpcy5taW47XG4gIH1cbiAgaWYgKHR5cGVvZiB0cmFuc2xhdGUgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuO1xuICBsZXQgb3JpZ2luUG9pbnQgPSBtaXgob3JpZ2luQXhpcy5taW4sIG9yaWdpbkF4aXMubWF4LCBvcmlnaW4pO1xuICBpZiAoYXhpcyA9PT0gb3JpZ2luQXhpcylcbiAgICBvcmlnaW5Qb2ludCAtPSB0cmFuc2xhdGU7XG4gIGF4aXMubWluID0gcmVtb3ZlUG9pbnREZWx0YShheGlzLm1pbiwgdHJhbnNsYXRlLCBzY2FsZTIsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG4gIGF4aXMubWF4ID0gcmVtb3ZlUG9pbnREZWx0YShheGlzLm1heCwgdHJhbnNsYXRlLCBzY2FsZTIsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG59XG5mdW5jdGlvbiByZW1vdmVBeGlzVHJhbnNmb3JtcyhheGlzLCB0cmFuc2Zvcm1zLCBba2V5LCBzY2FsZUtleSwgb3JpZ2luS2V5XSwgb3JpZ2luLCBzb3VyY2VBeGlzKSB7XG4gIHJlbW92ZUF4aXNEZWx0YShheGlzLCB0cmFuc2Zvcm1zW2tleV0sIHRyYW5zZm9ybXNbc2NhbGVLZXldLCB0cmFuc2Zvcm1zW29yaWdpbktleV0sIHRyYW5zZm9ybXMuc2NhbGUsIG9yaWdpbiwgc291cmNlQXhpcyk7XG59XG52YXIgeEtleXMyID0gW1wieFwiLCBcInNjYWxlWFwiLCBcIm9yaWdpblhcIl07XG52YXIgeUtleXMyID0gW1wieVwiLCBcInNjYWxlWVwiLCBcIm9yaWdpbllcIl07XG5mdW5jdGlvbiByZW1vdmVCb3hUcmFuc2Zvcm1zKGJveCwgdHJhbnNmb3Jtcywgb3JpZ2luQm94LCBzb3VyY2VCb3gpIHtcbiAgcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYm94LngsIHRyYW5zZm9ybXMsIHhLZXlzMiwgb3JpZ2luQm94ID09PSBudWxsIHx8IG9yaWdpbkJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luQm94LngsIHNvdXJjZUJveCA9PT0gbnVsbCB8fCBzb3VyY2VCb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZUJveC54KTtcbiAgcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYm94LnksIHRyYW5zZm9ybXMsIHlLZXlzMiwgb3JpZ2luQm94ID09PSBudWxsIHx8IG9yaWdpbkJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luQm94LnksIHNvdXJjZUJveCA9PT0gbnVsbCB8fCBzb3VyY2VCb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZUJveC55KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L3V0aWxzLm1qc1xuZnVuY3Rpb24gaXNBeGlzRGVsdGFaZXJvKGRlbHRhKSB7XG4gIHJldHVybiBkZWx0YS50cmFuc2xhdGUgPT09IDAgJiYgZGVsdGEuc2NhbGUgPT09IDE7XG59XG5mdW5jdGlvbiBpc0RlbHRhWmVybyhkZWx0YSkge1xuICByZXR1cm4gaXNBeGlzRGVsdGFaZXJvKGRlbHRhLngpICYmIGlzQXhpc0RlbHRhWmVybyhkZWx0YS55KTtcbn1cbmZ1bmN0aW9uIGJveEVxdWFscyhhMiwgYjIpIHtcbiAgcmV0dXJuIGEyLngubWluID09PSBiMi54Lm1pbiAmJiBhMi54Lm1heCA9PT0gYjIueC5tYXggJiYgYTIueS5taW4gPT09IGIyLnkubWluICYmIGEyLnkubWF4ID09PSBiMi55Lm1heDtcbn1cbmZ1bmN0aW9uIGFzcGVjdFJhdGlvKGJveCkge1xuICByZXR1cm4gY2FsY0xlbmd0aChib3gueCkgLyBjYWxjTGVuZ3RoKGJveC55KTtcbn1cbmZ1bmN0aW9uIGlzQ2xvc2VUbyhhMiwgYjIsIG1heCA9IDAuMSkge1xuICByZXR1cm4gZGlzdGFuY2UoYTIsIGIyKSA8PSBtYXg7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9zaGFyZWQvc3RhY2subWpzXG52YXIgTm9kZVN0YWNrID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1lbWJlcnMgPSBbXTtcbiAgfVxuICBhZGQobm9kZSkge1xuICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5tZW1iZXJzLCBub2RlKTtcbiAgICBub2RlLnNjaGVkdWxlUmVuZGVyKCk7XG4gIH1cbiAgcmVtb3ZlKG5vZGUpIHtcbiAgICByZW1vdmVJdGVtKHRoaXMubWVtYmVycywgbm9kZSk7XG4gICAgaWYgKG5vZGUgPT09IHRoaXMucHJldkxlYWQpIHtcbiAgICAgIHRoaXMucHJldkxlYWQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChub2RlID09PSB0aGlzLmxlYWQpIHtcbiAgICAgIGNvbnN0IHByZXZMZWFkID0gdGhpcy5tZW1iZXJzW3RoaXMubWVtYmVycy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgICB0aGlzLnByb21vdGUocHJldkxlYWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWxlZ2F0ZShub2RlKSB7XG4gICAgY29uc3QgaW5kZXhPZk5vZGUgPSB0aGlzLm1lbWJlcnMuZmluZEluZGV4KChtZW1iZXIpID0+IG5vZGUgPT09IG1lbWJlcik7XG4gICAgaWYgKGluZGV4T2ZOb2RlID09PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBwcmV2TGVhZDtcbiAgICBmb3IgKGxldCBpMiA9IGluZGV4T2ZOb2RlOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgICBjb25zdCBtZW1iZXIgPSB0aGlzLm1lbWJlcnNbaTJdO1xuICAgICAgaWYgKG1lbWJlci5pc1ByZXNlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgIHByZXZMZWFkID0gbWVtYmVyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICB0aGlzLnByb21vdGUocHJldkxlYWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcHJvbW90ZShub2RlLCBwcmVzZXJ2ZUZvbGxvd09wYWNpdHkpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcHJldkxlYWQgPSB0aGlzLmxlYWQ7XG4gICAgaWYgKG5vZGUgPT09IHByZXZMZWFkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucHJldkxlYWQgPSBwcmV2TGVhZDtcbiAgICB0aGlzLmxlYWQgPSBub2RlO1xuICAgIG5vZGUuc2hvdygpO1xuICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgcHJldkxlYWQuaW5zdGFuY2UgJiYgcHJldkxlYWQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgIG5vZGUuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgIG5vZGUucmVzdW1lRnJvbSA9IHByZXZMZWFkO1xuICAgICAgaWYgKHByZXNlcnZlRm9sbG93T3BhY2l0eSkge1xuICAgICAgICBub2RlLnJlc3VtZUZyb20ucHJlc2VydmVPcGFjaXR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2TGVhZC5zbmFwc2hvdCkge1xuICAgICAgICBub2RlLnNuYXBzaG90ID0gcHJldkxlYWQuc25hcHNob3Q7XG4gICAgICAgIG5vZGUuc25hcHNob3QubGF0ZXN0VmFsdWVzID0gcHJldkxlYWQuYW5pbWF0aW9uVmFsdWVzIHx8IHByZXZMZWFkLmxhdGVzdFZhbHVlcztcbiAgICAgICAgbm9kZS5zbmFwc2hvdC5pc1NoYXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoKF9hID0gbm9kZS5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNVcGRhdGluZykge1xuICAgICAgICBub2RlLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjcm9zc2ZhZGUgfSA9IG5vZGUub3B0aW9ucztcbiAgICAgIGlmIChjcm9zc2ZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHByZXZMZWFkLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXhpdEFuaW1hdGlvbkNvbXBsZXRlKCkge1xuICAgIHRoaXMubWVtYmVycy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgKF9iID0gKF9hID0gbm9kZS5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgKF9lID0gKF9jID0gbm9kZS5yZXN1bWluZ0Zyb20pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2QgPSBfYy5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QpO1xuICAgIH0pO1xuICB9XG4gIHNjaGVkdWxlUmVuZGVyKCkge1xuICAgIHRoaXMubWVtYmVycy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBub2RlLmluc3RhbmNlICYmIG5vZGUuc2NoZWR1bGVSZW5kZXIoZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIHJlbW92ZUxlYWRTbmFwc2hvdCgpIHtcbiAgICBpZiAodGhpcy5sZWFkICYmIHRoaXMubGVhZC5zbmFwc2hvdCkge1xuICAgICAgdGhpcy5sZWFkLnNuYXBzaG90ID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy90cmFuc2Zvcm0ubWpzXG52YXIgaWRlbnRpdHlQcm9qZWN0aW9uID0gXCJ0cmFuc2xhdGUzZCgwcHgsIDBweCwgMCkgc2NhbGUoMSwgMSkgc2NhbGUoMSwgMSlcIjtcbmZ1bmN0aW9uIGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybShkZWx0YSwgdHJlZVNjYWxlLCBsYXRlc3RUcmFuc2Zvcm0pIHtcbiAgY29uc3QgeFRyYW5zbGF0ZSA9IGRlbHRhLngudHJhbnNsYXRlIC8gdHJlZVNjYWxlLng7XG4gIGNvbnN0IHlUcmFuc2xhdGUgPSBkZWx0YS55LnRyYW5zbGF0ZSAvIHRyZWVTY2FsZS55O1xuICBsZXQgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eFRyYW5zbGF0ZX1weCwgJHt5VHJhbnNsYXRlfXB4LCAwKSBgO1xuICB0cmFuc2Zvcm0gKz0gYHNjYWxlKCR7MSAvIHRyZWVTY2FsZS54fSwgJHsxIC8gdHJlZVNjYWxlLnl9KSBgO1xuICBpZiAobGF0ZXN0VHJhbnNmb3JtKSB7XG4gICAgY29uc3QgeyByb3RhdGUsIHJvdGF0ZVgsIHJvdGF0ZVkgfSA9IGxhdGVzdFRyYW5zZm9ybTtcbiAgICBpZiAocm90YXRlKVxuICAgICAgdHJhbnNmb3JtICs9IGByb3RhdGUoJHtyb3RhdGV9ZGVnKSBgO1xuICAgIGlmIChyb3RhdGVYKVxuICAgICAgdHJhbnNmb3JtICs9IGByb3RhdGVYKCR7cm90YXRlWH1kZWcpIGA7XG4gICAgaWYgKHJvdGF0ZVkpXG4gICAgICB0cmFuc2Zvcm0gKz0gYHJvdGF0ZVkoJHtyb3RhdGVZfWRlZykgYDtcbiAgfVxuICBjb25zdCBlbGVtZW50U2NhbGVYID0gZGVsdGEueC5zY2FsZSAqIHRyZWVTY2FsZS54O1xuICBjb25zdCBlbGVtZW50U2NhbGVZID0gZGVsdGEueS5zY2FsZSAqIHRyZWVTY2FsZS55O1xuICB0cmFuc2Zvcm0gKz0gYHNjYWxlKCR7ZWxlbWVudFNjYWxlWH0sICR7ZWxlbWVudFNjYWxlWX0pYDtcbiAgcmV0dXJuIHRyYW5zZm9ybSA9PT0gaWRlbnRpdHlQcm9qZWN0aW9uID8gXCJub25lXCIgOiB0cmFuc2Zvcm07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2NvbXBhcmUtYnktZGVwdGgubWpzXG52YXIgY29tcGFyZUJ5RGVwdGggPSAoYTIsIGIyKSA9PiBhMi5kZXB0aCAtIGIyLmRlcHRoO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9mbGF0LXRyZWUubWpzXG52YXIgRmxhdFRyZWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgfVxuICBhZGQoY2hpbGQpIHtcbiAgICBhZGRVbmlxdWVJdGVtKHRoaXMuY2hpbGRyZW4sIGNoaWxkKTtcbiAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICB9XG4gIHJlbW92ZShjaGlsZCkge1xuICAgIHJlbW92ZUl0ZW0odGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xuICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gIH1cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIHRoaXMuaXNEaXJ0eSAmJiB0aGlzLmNoaWxkcmVuLnNvcnQoY29tcGFyZUJ5RGVwdGgpO1xuICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL2NyZWF0ZS1wcm9qZWN0aW9uLW5vZGUubWpzXG52YXIgdHJhbnNmb3JtQXhlcyA9IFtcIlwiLCBcIlhcIiwgXCJZXCIsIFwiWlwiXTtcbnZhciBhbmltYXRpb25UYXJnZXQgPSAxZTM7XG5mdW5jdGlvbiBjcmVhdGVQcm9qZWN0aW9uTm9kZSh7IGF0dGFjaFJlc2l6ZUxpc3RlbmVyLCBkZWZhdWx0UGFyZW50LCBtZWFzdXJlU2Nyb2xsLCBjaGVja0lzU2Nyb2xsUm9vdCwgcmVzZXRUcmFuc2Zvcm0gfSkge1xuICByZXR1cm4gY2xhc3MgUHJvamVjdGlvbk5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRJZCwgbGF0ZXN0VmFsdWVzID0ge30sIHBhcmVudCA9IGRlZmF1bHRQYXJlbnQgPT09IG51bGwgfHwgZGVmYXVsdFBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdFBhcmVudCgpKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5pc1RyZWVBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNBbmltYXRpb25CbG9ja2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmlzU1ZHID0gZmFsc2U7XG4gICAgICB0aGlzLm5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgIHRoaXMudHJlZVNjYWxlID0geyB4OiAxLCB5OiAxIH07XG4gICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5wb3RlbnRpYWxOb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB0aGlzLmNoZWNrVXBkYXRlRmFpbGVkID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc1VwZGF0aW5nKSB7XG4gICAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gocmVzb2x2ZVRhcmdldERlbHRhKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNhbGNQcm9qZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgICB0aGlzLnNoYXJlZE5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuZWxlbWVudElkID0gZWxlbWVudElkO1xuICAgICAgdGhpcy5sYXRlc3RWYWx1ZXMgPSBsYXRlc3RWYWx1ZXM7XG4gICAgICB0aGlzLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCB8fCBwYXJlbnQgOiB0aGlzO1xuICAgICAgdGhpcy5wYXRoID0gcGFyZW50ID8gWy4uLnBhcmVudC5wYXRoLCBwYXJlbnRdIDogW107XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMuZGVwdGggPSBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcbiAgICAgIGVsZW1lbnRJZCAmJiB0aGlzLnJvb3QucmVnaXN0ZXJQb3RlbnRpYWxOb2RlKGVsZW1lbnRJZCwgdGhpcyk7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgdGhpcy5wYXRoLmxlbmd0aDsgaTIrKykge1xuICAgICAgICB0aGlzLnBhdGhbaTJdLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJvb3QgPT09IHRoaXMpXG4gICAgICAgIHRoaXMubm9kZXMgPSBuZXcgRmxhdFRyZWUoKTtcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZXZlbnRIYW5kbGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzLnNldChuYW1lLCBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmV2ZW50SGFuZGxlcnMuZ2V0KG5hbWUpLmFkZChoYW5kbGVyKTtcbiAgICB9XG4gICAgbm90aWZ5TGlzdGVuZXJzKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbk1hbmFnZXIgPSB0aGlzLmV2ZW50SGFuZGxlcnMuZ2V0KG5hbWUpO1xuICAgICAgc3Vic2NyaXB0aW9uTWFuYWdlciA9PT0gbnVsbCB8fCBzdWJzY3JpcHRpb25NYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdWJzY3JpcHRpb25NYW5hZ2VyLm5vdGlmeSguLi5hcmdzKTtcbiAgICB9XG4gICAgaGFzTGlzdGVuZXJzKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50SGFuZGxlcnMuaGFzKG5hbWUpO1xuICAgIH1cbiAgICByZWdpc3RlclBvdGVudGlhbE5vZGUoaWQyLCBub2RlKSB7XG4gICAgICB0aGlzLnBvdGVudGlhbE5vZGVzLnNldChpZDIsIG5vZGUpO1xuICAgIH1cbiAgICBtb3VudChpbnN0YW5jZSwgaXNMYXlvdXREaXJ0eSA9IGZhbHNlKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5pc1NWRyA9IGluc3RhbmNlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBpbnN0YW5jZS50YWdOYW1lICE9PSBcInN2Z1wiO1xuICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgY29uc3QgeyBsYXlvdXRJZCwgbGF5b3V0LCB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAodmlzdWFsRWxlbWVudCAmJiAhdmlzdWFsRWxlbWVudC5jdXJyZW50KSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQubW91bnQoaW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5yb290Lm5vZGVzLmFkZCh0aGlzKTtcbiAgICAgIChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGRyZW4uYWRkKHRoaXMpO1xuICAgICAgdGhpcy5lbGVtZW50SWQgJiYgdGhpcy5yb290LnBvdGVudGlhbE5vZGVzLmRlbGV0ZSh0aGlzLmVsZW1lbnRJZCk7XG4gICAgICBpZiAoaXNMYXlvdXREaXJ0eSAmJiAobGF5b3V0IHx8IGxheW91dElkKSkge1xuICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGF0dGFjaFJlc2l6ZUxpc3RlbmVyKSB7XG4gICAgICAgIGxldCBjYW5jZWxEZWxheTtcbiAgICAgICAgY29uc3QgcmVzaXplVW5ibG9ja1VwZGF0ZSA9ICgpID0+IHRoaXMucm9vdC51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSBmYWxzZTtcbiAgICAgICAgYXR0YWNoUmVzaXplTGlzdGVuZXIoaW5zdGFuY2UsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJvb3QudXBkYXRlQmxvY2tlZEJ5UmVzaXplID0gdHJ1ZTtcbiAgICAgICAgICBjYW5jZWxEZWxheSAmJiBjYW5jZWxEZWxheSgpO1xuICAgICAgICAgIGNhbmNlbERlbGF5ID0gZGVsYXkocmVzaXplVW5ibG9ja1VwZGF0ZSwgMjUwKTtcbiAgICAgICAgICBpZiAoZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0FuaW1hdGVkU2luY2VSZXNpemUpIHtcbiAgICAgICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goZmluaXNoQW5pbWF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGxheW91dElkKSB7XG4gICAgICAgIHRoaXMucm9vdC5yZWdpc3RlclNoYXJlZE5vZGUobGF5b3V0SWQsIHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSAmJiB2aXN1YWxFbGVtZW50ICYmIChsYXlvdXRJZCB8fCBsYXlvdXQpKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImRpZFVwZGF0ZVwiLCAoeyBkZWx0YSwgaGFzTGF5b3V0Q2hhbmdlZCwgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkLCBsYXlvdXQ6IG5ld0xheW91dCB9KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMiwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgaWYgKHRoaXMuaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGxheW91dFRyYW5zaXRpb24gPSAoX2IgPSAoX2EyID0gdGhpcy5vcHRpb25zLnRyYW5zaXRpb24pICE9PSBudWxsICYmIF9hMiAhPT0gdm9pZCAwID8gX2EyIDogdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbjtcbiAgICAgICAgICBjb25zdCB7IG9uTGF5b3V0QW5pbWF0aW9uU3RhcnQsIG9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGUgfSA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgICBjb25zdCB0YXJnZXRDaGFuZ2VkID0gIXRoaXMudGFyZ2V0TGF5b3V0IHx8ICFib3hFcXVhbHModGhpcy50YXJnZXRMYXlvdXQsIG5ld0xheW91dCkgfHwgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkO1xuICAgICAgICAgIGNvbnN0IGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSAhaGFzTGF5b3V0Q2hhbmdlZCAmJiBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgaWYgKCgoX2MgPSB0aGlzLnJlc3VtZUZyb20pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pbnN0YW5jZSkgfHwgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCB8fCBoYXNMYXlvdXRDaGFuZ2VkICYmICh0YXJnZXRDaGFuZ2VkIHx8ICF0aGlzLmN1cnJlbnRBbmltYXRpb24pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWVGcm9tKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tID0gdGhpcy5yZXN1bWVGcm9tO1xuICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5yZXN1bWluZ0Zyb20gPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEFuaW1hdGlvbk9yaWdpbihkZWx0YSwgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCk7XG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgZ2V0VmFsdWVUcmFuc2l0aW9uKGxheW91dFRyYW5zaXRpb24sIFwibGF5b3V0XCIpKSwge1xuICAgICAgICAgICAgICBvblBsYXk6IG9uTGF5b3V0QW5pbWF0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIG9uQ29tcGxldGU6IG9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQuc2hvdWxkUmVkdWNlTW90aW9uKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMuZGVsYXkgPSAwO1xuICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLnR5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24oYW5pbWF0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzTGF5b3V0Q2hhbmdlZCAmJiB0aGlzLmFuaW1hdGlvblByb2dyZXNzID09PSAwKSB7XG4gICAgICAgICAgICAgIGZpbmlzaEFuaW1hdGlvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNMZWFkKCkgJiYgKChfZSA9IChfZCA9IHRoaXMub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudGFyZ2V0TGF5b3V0ID0gbmV3TGF5b3V0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudCgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICB0aGlzLm9wdGlvbnMubGF5b3V0SWQgJiYgdGhpcy53aWxsVXBkYXRlKCk7XG4gICAgICB0aGlzLnJvb3Qubm9kZXMucmVtb3ZlKHRoaXMpO1xuICAgICAgKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKHRoaXMpO1xuICAgICAgKF9iID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jaGlsZHJlbi5kZWxldGUodGhpcyk7XG4gICAgICB0aGlzLmluc3RhbmNlID0gdm9pZCAwO1xuICAgICAgY2FuY2VsU3luYy5wcmVSZW5kZXIodGhpcy51cGRhdGVQcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgYmxvY2tVcGRhdGUoKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIHVuYmxvY2tVcGRhdGUoKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpc1VwZGF0ZUJsb2NrZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgfHwgdGhpcy51cGRhdGVCbG9ja2VkQnlSZXNpemU7XG4gICAgfVxuICAgIGlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gdGhpcy5pc0FuaW1hdGlvbkJsb2NrZWQgfHwgKChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCgpKSB8fCBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRVcGRhdGUoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGhpcy5pc1VwZGF0ZUJsb2NrZWQoKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5pc1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgIChfYSA9IHRoaXMubm9kZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKHJlc2V0Um90YXRpb24pO1xuICAgIH1cbiAgICB3aWxsVXBkYXRlKHNob3VsZE5vdGlmeUxpc3RlbmVycyA9IHRydWUpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgaWYgKHRoaXMucm9vdC5pc1VwZGF0ZUJsb2NrZWQoKSkge1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMpLm9uRXhpdENvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgICF0aGlzLnJvb3QuaXNVcGRhdGluZyAmJiB0aGlzLnJvb3Quc3RhcnRVcGRhdGUoKTtcbiAgICAgIGlmICh0aGlzLmlzTGF5b3V0RGlydHkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgdGhpcy5wYXRoLmxlbmd0aDsgaTIrKykge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2kyXTtcbiAgICAgICAgbm9kZS5zaG91bGRSZXNldFRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgIG5vZGUudXBkYXRlU2Nyb2xsKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGxheW91dElkLCBsYXlvdXQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChsYXlvdXRJZCA9PT0gdm9pZCAwICYmICFsYXlvdXQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlID0gKF9jID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRQcm9wcygpLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHRyYW5zZm9ybVRlbXBsYXRlID09PSBudWxsIHx8IHRyYW5zZm9ybVRlbXBsYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLmxhdGVzdFZhbHVlcywgXCJcIik7XG4gICAgICB0aGlzLnVwZGF0ZVNuYXBzaG90KCk7XG4gICAgICBzaG91bGROb3RpZnlMaXN0ZW5lcnMgJiYgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJ3aWxsVXBkYXRlXCIpO1xuICAgIH1cbiAgICBkaWRVcGRhdGUoKSB7XG4gICAgICBjb25zdCB1cGRhdGVXYXNCbG9ja2VkID0gdGhpcy5pc1VwZGF0ZUJsb2NrZWQoKTtcbiAgICAgIGlmICh1cGRhdGVXYXNCbG9ja2VkKSB7XG4gICAgICAgIHRoaXMudW5ibG9ja1VwZGF0ZSgpO1xuICAgICAgICB0aGlzLmNsZWFyQWxsU25hcHNob3RzKCk7XG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChjbGVhck1lYXN1cmVtZW50cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pc1VwZGF0aW5nKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnBvdGVudGlhbE5vZGVzLnNpemUpIHtcbiAgICAgICAgdGhpcy5wb3RlbnRpYWxOb2Rlcy5mb3JFYWNoKG1vdW50Tm9kZUVhcmx5KTtcbiAgICAgICAgdGhpcy5wb3RlbnRpYWxOb2Rlcy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHJlc2V0VHJhbnNmb3JtU3R5bGUpO1xuICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHVwZGF0ZUxheW91dCk7XG4gICAgICB0aGlzLm5vZGVzLmZvckVhY2gobm90aWZ5TGF5b3V0VXBkYXRlKTtcbiAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgIGZsdXNoU3luYy51cGRhdGUoKTtcbiAgICAgIGZsdXNoU3luYy5wcmVSZW5kZXIoKTtcbiAgICAgIGZsdXNoU3luYy5yZW5kZXIoKTtcbiAgICB9XG4gICAgY2xlYXJBbGxTbmFwc2hvdHMoKSB7XG4gICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJTbmFwc2hvdCk7XG4gICAgICB0aGlzLnNoYXJlZE5vZGVzLmZvckVhY2gocmVtb3ZlTGVhZFNuYXBzaG90cyk7XG4gICAgfVxuICAgIHNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpIHtcbiAgICAgIGVzX2RlZmF1bHQucHJlUmVuZGVyKHRoaXMudXBkYXRlUHJvamVjdGlvbiwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBzY2hlZHVsZUNoZWNrQWZ0ZXJVbm1vdW50KCkge1xuICAgICAgZXNfZGVmYXVsdC5wb3N0UmVuZGVyKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNMYXlvdXREaXJ0eSkge1xuICAgICAgICAgIHRoaXMucm9vdC5kaWRVcGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJvb3QuY2hlY2tVcGRhdGVGYWlsZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVNuYXBzaG90KCkge1xuICAgICAgaWYgKHRoaXMuc25hcHNob3QgfHwgIXRoaXMuaW5zdGFuY2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuc25hcHNob3QgPSB0aGlzLm1lYXN1cmUoKTtcbiAgICB9XG4gICAgdXBkYXRlTGF5b3V0KCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgaWYgKCEodGhpcy5vcHRpb25zLmFsd2F5c01lYXN1cmVMYXlvdXQgJiYgdGhpcy5pc0xlYWQoKSkgJiYgIXRoaXMuaXNMYXlvdXREaXJ0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZXN1bWVGcm9tICYmICF0aGlzLnJlc3VtZUZyb20uaW5zdGFuY2UpIHtcbiAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGF0aC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2kyXTtcbiAgICAgICAgICBub2RlLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2TGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgICB0aGlzLmxheW91dCA9IHRoaXMubWVhc3VyZShmYWxzZSk7XG4gICAgICB0aGlzLmxheW91dENvcnJlY3RlZCA9IGNyZWF0ZUJveCgpO1xuICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gZmFsc2U7XG4gICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IHZvaWQgMDtcbiAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwibWVhc3VyZVwiLCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgKF9hID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub3RpZnkoXCJMYXlvdXRNZWFzdXJlXCIsIHRoaXMubGF5b3V0LmxheW91dEJveCwgcHJldkxheW91dCA9PT0gbnVsbCB8fCBwcmV2TGF5b3V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2TGF5b3V0LmxheW91dEJveCk7XG4gICAgfVxuICAgIHVwZGF0ZVNjcm9sbCgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmIHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5pc1Njcm9sbFJvb3QgPSBjaGVja0lzU2Nyb2xsUm9vdCh0aGlzLmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5zY3JvbGwgPSBtZWFzdXJlU2Nyb2xsKHRoaXMuaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXNldFRyYW5zZm9ybSgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghcmVzZXRUcmFuc2Zvcm0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGlzUmVzZXRSZXF1ZXN0ZWQgPSB0aGlzLmlzTGF5b3V0RGlydHkgfHwgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybTtcbiAgICAgIGNvbnN0IGhhc1Byb2plY3Rpb24gPSB0aGlzLnByb2plY3Rpb25EZWx0YSAmJiAhaXNEZWx0YVplcm8odGhpcy5wcm9qZWN0aW9uRGVsdGEpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGUgPSAoX2EgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZVZhbHVlID0gdHJhbnNmb3JtVGVtcGxhdGUgPT09IG51bGwgfHwgdHJhbnNmb3JtVGVtcGxhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlSGFzQ2hhbmdlZCA9IHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgIT09IHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWU7XG4gICAgICBpZiAoaXNSZXNldFJlcXVlc3RlZCAmJiAoaGFzUHJvamVjdGlvbiB8fCBoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpIHx8IHRyYW5zZm9ybVRlbXBsYXRlSGFzQ2hhbmdlZCkpIHtcbiAgICAgICAgcmVzZXRUcmFuc2Zvcm0odGhpcy5pbnN0YW5jZSwgdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSk7XG4gICAgICAgIHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlKHJlbW92ZVRyYW5zZm9ybSA9IHRydWUpIHtcbiAgICAgIGNvbnN0IHBhZ2VCb3ggPSB0aGlzLm1lYXN1cmVQYWdlQm94KCk7XG4gICAgICBsZXQgbGF5b3V0Qm94ID0gdGhpcy5yZW1vdmVFbGVtZW50U2Nyb2xsKHBhZ2VCb3gpO1xuICAgICAgaWYgKHJlbW92ZVRyYW5zZm9ybSkge1xuICAgICAgICBsYXlvdXRCb3ggPSB0aGlzLnJlbW92ZVRyYW5zZm9ybShsYXlvdXRCb3gpO1xuICAgICAgfVxuICAgICAgcm91bmRCb3gobGF5b3V0Qm94KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lYXN1cmVkQm94OiBwYWdlQm94LFxuICAgICAgICBsYXlvdXRCb3gsXG4gICAgICAgIGxhdGVzdFZhbHVlczoge31cbiAgICAgIH07XG4gICAgfVxuICAgIG1lYXN1cmVQYWdlQm94KCkge1xuICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgIHJldHVybiBjcmVhdGVCb3goKTtcbiAgICAgIGNvbnN0IGJveCA9IHZpc3VhbEVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCk7XG4gICAgICBjb25zdCB7IHNjcm9sbDogc2Nyb2xsMiB9ID0gdGhpcy5yb290O1xuICAgICAgaWYgKHNjcm9sbDIpIHtcbiAgICAgICAgdHJhbnNsYXRlQXhpcyhib3gueCwgc2Nyb2xsMi54KTtcbiAgICAgICAgdHJhbnNsYXRlQXhpcyhib3gueSwgc2Nyb2xsMi55KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib3g7XG4gICAgfVxuICAgIHJlbW92ZUVsZW1lbnRTY3JvbGwoYm94KSB7XG4gICAgICBjb25zdCBib3hXaXRob3V0U2Nyb2xsID0gY3JlYXRlQm94KCk7XG4gICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0U2Nyb2xsLCBib3gpO1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGF0aC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpMl07XG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsOiBzY3JvbGwyLCBvcHRpb25zLCBpc1Njcm9sbFJvb3QgfSA9IG5vZGU7XG4gICAgICAgIGlmIChub2RlICE9PSB0aGlzLnJvb3QgJiYgc2Nyb2xsMiAmJiBvcHRpb25zLmxheW91dFNjcm9sbCkge1xuICAgICAgICAgIGlmIChpc1Njcm9sbFJvb3QpIHtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKGJveFdpdGhvdXRTY3JvbGwsIGJveCk7XG4gICAgICAgICAgICBjb25zdCB7IHNjcm9sbDogcm9vdFNjcm9sbCB9ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgaWYgKHJvb3RTY3JvbGwpIHtcbiAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLngsIC1yb290U2Nyb2xsLngpO1xuICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueSwgLXJvb3RTY3JvbGwueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC54LCBzY3JvbGwyLngpO1xuICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC55LCBzY3JvbGwyLnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYm94V2l0aG91dFNjcm9sbDtcbiAgICB9XG4gICAgYXBwbHlUcmFuc2Zvcm0oYm94LCB0cmFuc2Zvcm1Pbmx5ID0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHdpdGhUcmFuc2Zvcm1zID0gY3JlYXRlQm94KCk7XG4gICAgICBjb3B5Qm94SW50byh3aXRoVHJhbnNmb3JtcywgYm94KTtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0aGlzLnBhdGgubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaTJdO1xuICAgICAgICBpZiAoIXRyYW5zZm9ybU9ubHkgJiYgbm9kZS5vcHRpb25zLmxheW91dFNjcm9sbCAmJiBub2RlLnNjcm9sbCAmJiBub2RlICE9PSBub2RlLnJvb3QpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1Cb3god2l0aFRyYW5zZm9ybXMsIHtcbiAgICAgICAgICAgIHg6IC1ub2RlLnNjcm9sbC54LFxuICAgICAgICAgICAgeTogLW5vZGUuc2Nyb2xsLnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3Jtcywgbm9kZS5sYXRlc3RWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2l0aFRyYW5zZm9ybXM7XG4gICAgfVxuICAgIHJlbW92ZVRyYW5zZm9ybShib3gpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGJveFdpdGhvdXRUcmFuc2Zvcm0gPSBjcmVhdGVCb3goKTtcbiAgICAgIGNvcHlCb3hJbnRvKGJveFdpdGhvdXRUcmFuc2Zvcm0sIGJveCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgdGhpcy5wYXRoLmxlbmd0aDsgaTIrKykge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2kyXTtcbiAgICAgICAgaWYgKCFub2RlLmluc3RhbmNlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGhhc1NjYWxlKG5vZGUubGF0ZXN0VmFsdWVzKSAmJiBub2RlLnVwZGF0ZVNuYXBzaG90KCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUJveCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICBjb25zdCBub2RlQm94ID0gbm9kZS5tZWFzdXJlUGFnZUJveCgpO1xuICAgICAgICBjb3B5Qm94SW50byhzb3VyY2VCb3gsIG5vZGVCb3gpO1xuICAgICAgICByZW1vdmVCb3hUcmFuc2Zvcm1zKGJveFdpdGhvdXRUcmFuc2Zvcm0sIG5vZGUubGF0ZXN0VmFsdWVzLCAoX2EgPSBub2RlLnNuYXBzaG90KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGF5b3V0Qm94LCBzb3VyY2VCb3gpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3hXaXRob3V0VHJhbnNmb3JtLCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm94V2l0aG91dFRyYW5zZm9ybTtcbiAgICB9XG4gICAgc2V0VGFyZ2V0RGVsdGEoZGVsdGEpIHtcbiAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSBkZWx0YTtcbiAgICAgIHRoaXMucm9vdC5zY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24oKTtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKSwge1xuICAgICAgICBjcm9zc2ZhZGU6IG9wdGlvbnMuY3Jvc3NmYWRlICE9PSB2b2lkIDAgPyBvcHRpb25zLmNyb3NzZmFkZSA6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhck1lYXN1cmVtZW50cygpIHtcbiAgICAgIHRoaXMuc2Nyb2xsID0gdm9pZCAwO1xuICAgICAgdGhpcy5sYXlvdXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnNuYXBzaG90ID0gdm9pZCAwO1xuICAgICAgdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSB2b2lkIDA7XG4gICAgICB0aGlzLnRhcmdldCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXNvbHZlVGFyZ2V0RGVsdGEoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB7IGxheW91dCwgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIShsYXlvdXQgfHwgbGF5b3V0SWQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoIXRoaXMudGFyZ2V0RGVsdGEgJiYgIXRoaXMucmVsYXRpdmVUYXJnZXQpIHtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXJlbnQgPSB0aGlzLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhcmVudCAmJiByZWxhdGl2ZVBhcmVudC5sYXlvdXQpIHtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gcmVsYXRpdmVQYXJlbnQ7XG4gICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbih0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCB0aGlzLmxheW91dC5sYXlvdXRCb3gsIHJlbGF0aXZlUGFyZW50LmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVsYXRpdmVUYXJnZXQgJiYgIXRoaXMudGFyZ2V0RGVsdGEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghdGhpcy50YXJnZXQpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgdGhpcy50YXJnZXRXaXRoVHJhbnNmb3JtcyA9IGNyZWF0ZUJveCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVsYXRpdmVUYXJnZXQgJiYgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiAmJiAoKF9hID0gdGhpcy5yZWxhdGl2ZVBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhcmdldCkpIHtcbiAgICAgICAgY2FsY1JlbGF0aXZlQm94KHRoaXMudGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlUGFyZW50LnRhcmdldCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0RGVsdGEpIHtcbiAgICAgICAgaWYgKEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pKSB7XG4gICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29weUJveEludG8odGhpcy50YXJnZXQsIHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlCb3hEZWx0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXREZWx0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5Qm94SW50byh0aGlzLnRhcmdldCwgdGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCkge1xuICAgICAgICB0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZWxhdGl2ZVBhcmVudCA9IHRoaXMuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlUGFyZW50ICYmIEJvb2xlYW4ocmVsYXRpdmVQYXJlbnQucmVzdW1pbmdGcm9tKSA9PT0gQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkgJiYgIXJlbGF0aXZlUGFyZW50Lm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmIHJlbGF0aXZlUGFyZW50LnRhcmdldCkge1xuICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSByZWxhdGl2ZVBhcmVudDtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sIHRoaXMudGFyZ2V0LCByZWxhdGl2ZVBhcmVudC50YXJnZXQpO1xuICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCkge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCB8fCBoYXNTY2FsZSh0aGlzLnBhcmVudC5sYXRlc3RWYWx1ZXMpIHx8IGhhczJEVHJhbnNsYXRlKHRoaXMucGFyZW50LmxhdGVzdFZhbHVlcykpXG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICBpZiAoKHRoaXMucGFyZW50LnJlbGF0aXZlVGFyZ2V0IHx8IHRoaXMucGFyZW50LnRhcmdldERlbHRhKSAmJiB0aGlzLnBhcmVudC5sYXlvdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhbGNQcm9qZWN0aW9uKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBsYXlvdXQsIGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICB0aGlzLmlzVHJlZUFuaW1hdGluZyA9IEJvb2xlYW4oKChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNUcmVlQW5pbWF0aW5nKSB8fCB0aGlzLmN1cnJlbnRBbmltYXRpb24gfHwgdGhpcy5wZW5kaW5nQW5pbWF0aW9uKTtcbiAgICAgIGlmICghdGhpcy5pc1RyZWVBbmltYXRpbmcpIHtcbiAgICAgICAgdGhpcy50YXJnZXREZWx0YSA9IHRoaXMucmVsYXRpdmVUYXJnZXQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICEobGF5b3V0IHx8IGxheW91dElkKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbGVhZCA9IHRoaXMuZ2V0TGVhZCgpO1xuICAgICAgY29weUJveEludG8odGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICBhcHBseVRyZWVEZWx0YXModGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRoaXMudHJlZVNjYWxlLCB0aGlzLnBhdGgsIEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pIHx8IHRoaXMgIT09IGxlYWQpO1xuICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IGxlYWQ7XG4gICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLnByb2plY3Rpb25EZWx0YSkge1xuICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2VHJlZVNjYWxlWCA9IHRoaXMudHJlZVNjYWxlLng7XG4gICAgICBjb25zdCBwcmV2VHJlZVNjYWxlWSA9IHRoaXMudHJlZVNjYWxlLnk7XG4gICAgICBjb25zdCBwcmV2UHJvamVjdGlvblRyYW5zZm9ybSA9IHRoaXMucHJvamVjdGlvblRyYW5zZm9ybTtcbiAgICAgIGNhbGNCb3hEZWx0YSh0aGlzLnByb2plY3Rpb25EZWx0YSwgdGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRhcmdldCwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtID0gYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtKHRoaXMucHJvamVjdGlvbkRlbHRhLCB0aGlzLnRyZWVTY2FsZSk7XG4gICAgICBpZiAodGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtICE9PSBwcmV2UHJvamVjdGlvblRyYW5zZm9ybSB8fCB0aGlzLnRyZWVTY2FsZS54ICE9PSBwcmV2VHJlZVNjYWxlWCB8fCB0aGlzLnRyZWVTY2FsZS55ICE9PSBwcmV2VHJlZVNjYWxlWSkge1xuICAgICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJwcm9qZWN0aW9uVXBkYXRlXCIsIHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlbmRlcihub3RpZnlBbGwyID0gdHJ1ZSkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMpLnNjaGVkdWxlUmVuZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICBub3RpZnlBbGwyICYmICgoX2MgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zY2hlZHVsZVJlbmRlcigpKTtcbiAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSAmJiAhdGhpcy5yZXN1bWluZ0Zyb20uaW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20gPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHNldEFuaW1hdGlvbk9yaWdpbihkZWx0YSwgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IGZhbHNlKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuc25hcHNob3Q7XG4gICAgICBjb25zdCBzbmFwc2hvdExhdGVzdFZhbHVlcyA9IChzbmFwc2hvdCA9PT0gbnVsbCB8fCBzbmFwc2hvdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc25hcHNob3QubGF0ZXN0VmFsdWVzKSB8fCB7fTtcbiAgICAgIGNvbnN0IG1peGVkVmFsdWVzID0gX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgIGNvbnN0IHRhcmdldERlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luID0gdm9pZCAwO1xuICAgICAgdGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQgPSAhaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZDtcbiAgICAgIGNvbnN0IHJlbGF0aXZlTGF5b3V0ID0gY3JlYXRlQm94KCk7XG4gICAgICBjb25zdCBpc1NoYXJlZExheW91dEFuaW1hdGlvbiA9IHNuYXBzaG90ID09PSBudWxsIHx8IHNuYXBzaG90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbmFwc2hvdC5pc1NoYXJlZDtcbiAgICAgIGNvbnN0IGlzT25seU1lbWJlciA9ICgoKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVtYmVycy5sZW5ndGgpIHx8IDApIDw9IDE7XG4gICAgICBjb25zdCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5ID0gQm9vbGVhbihpc1NoYXJlZExheW91dEFuaW1hdGlvbiAmJiAhaXNPbmx5TWVtYmVyICYmIHRoaXMub3B0aW9ucy5jcm9zc2ZhZGUgPT09IHRydWUgJiYgIXRoaXMucGF0aC5zb21lKGhhc09wYWNpdHlDcm9zc2ZhZGUpKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSAwO1xuICAgICAgdGhpcy5taXhUYXJnZXREZWx0YSA9IChsYXRlc3QpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MzID0gbGF0ZXN0IC8gMWUzO1xuICAgICAgICBtaXhBeGlzRGVsdGEodGFyZ2V0RGVsdGEueCwgZGVsdGEueCwgcHJvZ3Jlc3MzKTtcbiAgICAgICAgbWl4QXhpc0RlbHRhKHRhcmdldERlbHRhLnksIGRlbHRhLnksIHByb2dyZXNzMyk7XG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0RGVsdGEodGFyZ2V0RGVsdGEpO1xuICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZVRhcmdldCAmJiB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luICYmIHRoaXMubGF5b3V0ICYmICgoX2EyID0gdGhpcy5yZWxhdGl2ZVBhcmVudCkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIubGF5b3V0KSkge1xuICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHJlbGF0aXZlTGF5b3V0LCB0aGlzLmxheW91dC5sYXlvdXRCb3gsIHRoaXMucmVsYXRpdmVQYXJlbnQubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgbWl4Qm94KHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sIHJlbGF0aXZlTGF5b3V0LCBwcm9ncmVzczMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NoYXJlZExheW91dEFuaW1hdGlvbikge1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVmFsdWVzID0gbWl4ZWRWYWx1ZXM7XG4gICAgICAgICAgbWl4VmFsdWVzKG1peGVkVmFsdWVzLCBzbmFwc2hvdExhdGVzdFZhbHVlcywgdGhpcy5sYXRlc3RWYWx1ZXMsIHByb2dyZXNzMywgc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSwgaXNPbmx5TWVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvb3Quc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IHByb2dyZXNzMztcbiAgICAgIH07XG4gICAgICB0aGlzLm1peFRhcmdldERlbHRhKDApO1xuICAgIH1cbiAgICBzdGFydEFuaW1hdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJhbmltYXRpb25TdGFydFwiKTtcbiAgICAgIChfYSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTtcbiAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSkge1xuICAgICAgICAoX2IgPSB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGVuZGluZ0FuaW1hdGlvbikge1xuICAgICAgICBjYW5jZWxTeW5jLnVwZGF0ZSh0aGlzLnBlbmRpbmdBbmltYXRpb24pO1xuICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBlc19kZWZhdWx0LnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0ZTIoMCwgYW5pbWF0aW9uVGFyZ2V0LCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgICAgIG9uVXBkYXRlOiAobGF0ZXN0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgdGhpcy5taXhUYXJnZXREZWx0YShsYXRlc3QpO1xuICAgICAgICAgICAgKF9hMiA9IG9wdGlvbnMub25VcGRhdGUpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLmNhbGwob3B0aW9ucywgbGF0ZXN0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICAoX2EyID0gb3B0aW9ucy5vbkNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMi5jYWxsKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbiA9IHZvaWQgMDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wbGV0ZUFuaW1hdGlvbigpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSkge1xuICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5wcmVzZXJ2ZU9wYWNpdHkgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICAoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leGl0QW5pbWF0aW9uQ29tcGxldGUoKTtcbiAgICAgIHRoaXMucmVzdW1pbmdGcm9tID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25WYWx1ZXMgPSB2b2lkIDA7XG4gICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcImFuaW1hdGlvbkNvbXBsZXRlXCIpO1xuICAgIH1cbiAgICBmaW5pc2hBbmltYXRpb24oKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgIChfYSA9IHRoaXMubWl4VGFyZ2V0RGVsdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGFuaW1hdGlvblRhcmdldCk7XG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbXBsZXRlQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIGFwcGx5VHJhbnNmb3Jtc1RvVGFyZ2V0KCkge1xuICAgICAgY29uc3QgbGVhZCA9IHRoaXMuZ2V0TGVhZCgpO1xuICAgICAgbGV0IHsgdGFyZ2V0V2l0aFRyYW5zZm9ybXMsIHRhcmdldCwgbGF5b3V0LCBsYXRlc3RWYWx1ZXMgfSA9IGxlYWQ7XG4gICAgICBpZiAoIXRhcmdldFdpdGhUcmFuc2Zvcm1zIHx8ICF0YXJnZXQgfHwgIWxheW91dClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMgIT09IGxlYWQgJiYgdGhpcy5sYXlvdXQgJiYgbGF5b3V0ICYmIHNob3VsZEFuaW1hdGVQb3NpdGlvbk9ubHkodGhpcy5vcHRpb25zLmFuaW1hdGlvblR5cGUsIHRoaXMubGF5b3V0LmxheW91dEJveCwgbGF5b3V0LmxheW91dEJveCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQgfHwgY3JlYXRlQm94KCk7XG4gICAgICAgIGNvbnN0IHhMZW5ndGggPSBjYWxjTGVuZ3RoKHRoaXMubGF5b3V0LmxheW91dEJveC54KTtcbiAgICAgICAgdGFyZ2V0LngubWluID0gbGVhZC50YXJnZXQueC5taW47XG4gICAgICAgIHRhcmdldC54Lm1heCA9IHRhcmdldC54Lm1pbiArIHhMZW5ndGg7XG4gICAgICAgIGNvbnN0IHlMZW5ndGggPSBjYWxjTGVuZ3RoKHRoaXMubGF5b3V0LmxheW91dEJveC55KTtcbiAgICAgICAgdGFyZ2V0LnkubWluID0gbGVhZC50YXJnZXQueS5taW47XG4gICAgICAgIHRhcmdldC55Lm1heCA9IHRhcmdldC55Lm1pbiArIHlMZW5ndGg7XG4gICAgICB9XG4gICAgICBjb3B5Qm94SW50byh0YXJnZXRXaXRoVHJhbnNmb3JtcywgdGFyZ2V0KTtcbiAgICAgIHRyYW5zZm9ybUJveCh0YXJnZXRXaXRoVHJhbnNmb3JtcywgbGF0ZXN0VmFsdWVzKTtcbiAgICAgIGNhbGNCb3hEZWx0YSh0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0sIHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0YXJnZXRXaXRoVHJhbnNmb3JtcywgbGF0ZXN0VmFsdWVzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJTaGFyZWROb2RlKGxheW91dElkLCBub2RlKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGlmICghdGhpcy5zaGFyZWROb2Rlcy5oYXMobGF5b3V0SWQpKSB7XG4gICAgICAgIHRoaXMuc2hhcmVkTm9kZXMuc2V0KGxheW91dElkLCBuZXcgTm9kZVN0YWNrKCkpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLnNoYXJlZE5vZGVzLmdldChsYXlvdXRJZCk7XG4gICAgICBzdGFjay5hZGQobm9kZSk7XG4gICAgICBub2RlLnByb21vdGUoe1xuICAgICAgICB0cmFuc2l0aW9uOiAoX2EgPSBub2RlLm9wdGlvbnMuaW5pdGlhbFByb21vdGlvbkNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYW5zaXRpb24sXG4gICAgICAgIHByZXNlcnZlRm9sbG93T3BhY2l0eTogKF9jID0gKF9iID0gbm9kZS5vcHRpb25zLmluaXRpYWxQcm9tb3Rpb25Db25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaG91bGRQcmVzZXJ2ZUZvbGxvd09wYWNpdHkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCBub2RlKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlzTGVhZCgpIHtcbiAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgcmV0dXJuIHN0YWNrID8gc3RhY2subGVhZCA9PT0gdGhpcyA6IHRydWU7XG4gICAgfVxuICAgIGdldExlYWQoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB7IGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICByZXR1cm4gbGF5b3V0SWQgPyAoKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVhZCkgfHwgdGhpcyA6IHRoaXM7XG4gICAgfVxuICAgIGdldFByZXZMZWFkKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBsYXlvdXRJZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgcmV0dXJuIGxheW91dElkID8gKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJldkxlYWQgOiB2b2lkIDA7XG4gICAgfVxuICAgIGdldFN0YWNrKCkge1xuICAgICAgY29uc3QgeyBsYXlvdXRJZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKGxheW91dElkKVxuICAgICAgICByZXR1cm4gdGhpcy5yb290LnNoYXJlZE5vZGVzLmdldChsYXlvdXRJZCk7XG4gICAgfVxuICAgIHByb21vdGUoeyBuZWVkc1Jlc2V0LCB0cmFuc2l0aW9uLCBwcmVzZXJ2ZUZvbGxvd09wYWNpdHkgfSA9IHt9KSB7XG4gICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgIGlmIChzdGFjaylcbiAgICAgICAgc3RhY2sucHJvbW90ZSh0aGlzLCBwcmVzZXJ2ZUZvbGxvd09wYWNpdHkpO1xuICAgICAgaWYgKG5lZWRzUmVzZXQpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubmVlZHNSZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNpdGlvbilcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKHsgdHJhbnNpdGlvbiB9KTtcbiAgICB9XG4gICAgcmVsZWdhdGUoKSB7XG4gICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgIGlmIChzdGFjaykge1xuICAgICAgICByZXR1cm4gc3RhY2sucmVsZWdhdGUodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2V0Um90YXRpb24oKSB7XG4gICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IGhhc1JvdGF0ZSA9IGZhbHNlO1xuICAgICAgY29uc3QgcmVzZXRWYWx1ZXMgPSB7fTtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0cmFuc2Zvcm1BeGVzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICBjb25zdCBheGlzID0gdHJhbnNmb3JtQXhlc1tpMl07XG4gICAgICAgIGNvbnN0IGtleSA9IFwicm90YXRlXCIgKyBheGlzO1xuICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQuZ2V0U3RhdGljVmFsdWUoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGhhc1JvdGF0ZSA9IHRydWU7XG4gICAgICAgIHJlc2V0VmFsdWVzW2tleV0gPSB2aXN1YWxFbGVtZW50LmdldFN0YXRpY1ZhbHVlKGtleSk7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0U3RhdGljVmFsdWUoa2V5LCAwKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzUm90YXRlKVxuICAgICAgICByZXR1cm47XG4gICAgICB2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXNldFZhbHVlcykge1xuICAgICAgICB2aXN1YWxFbGVtZW50LnNldFN0YXRpY1ZhbHVlKGtleSwgcmVzZXRWYWx1ZXNba2V5XSk7XG4gICAgICB9XG4gICAgICB2aXN1YWxFbGVtZW50LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgfVxuICAgIGdldFByb2plY3Rpb25TdHlsZXMoc3R5bGVQcm9wID0ge30pIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgY29uc3Qgc3R5bGVzID0ge307XG4gICAgICBpZiAoIXRoaXMuaW5zdGFuY2UgfHwgdGhpcy5pc1NWRylcbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVzLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGUgPSAoX2EgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICBpZiAodGhpcy5uZWVkc1Jlc2V0KSB7XG4gICAgICAgIHRoaXMubmVlZHNSZXNldCA9IGZhbHNlO1xuICAgICAgICBzdHlsZXMub3BhY2l0eSA9IFwiXCI7XG4gICAgICAgIHN0eWxlcy5wb2ludGVyRXZlbnRzID0gcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiO1xuICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGUgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLmxhdGVzdFZhbHVlcywgXCJcIikgOiBcIm5vbmVcIjtcbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgIGlmICghdGhpcy5wcm9qZWN0aW9uRGVsdGEgfHwgIXRoaXMubGF5b3V0IHx8ICFsZWFkLnRhcmdldCkge1xuICAgICAgICBjb25zdCBlbXB0eVN0eWxlcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxheW91dElkKSB7XG4gICAgICAgICAgZW1wdHlTdHlsZXMub3BhY2l0eSA9IHRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHkgIT09IHZvaWQgMCA/IHRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHkgOiAxO1xuICAgICAgICAgIGVtcHR5U3R5bGVzLnBvaW50ZXJFdmVudHMgPSByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzUHJvamVjdGVkICYmICFoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgICAgZW1wdHlTdHlsZXMudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGUgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh7fSwgXCJcIikgOiBcIm5vbmVcIjtcbiAgICAgICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eVN0eWxlcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlc1RvUmVuZGVyID0gbGVhZC5hbmltYXRpb25WYWx1ZXMgfHwgbGVhZC5sYXRlc3RWYWx1ZXM7XG4gICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtc1RvVGFyZ2V0KCk7XG4gICAgICBzdHlsZXMudHJhbnNmb3JtID0gYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtKHRoaXMucHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSwgdGhpcy50cmVlU2NhbGUsIHZhbHVlc1RvUmVuZGVyKTtcbiAgICAgIGlmICh0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGUodmFsdWVzVG9SZW5kZXIsIHN0eWxlcy50cmFuc2Zvcm0pO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnByb2plY3Rpb25EZWx0YTtcbiAgICAgIHN0eWxlcy50cmFuc2Zvcm1PcmlnaW4gPSBgJHt4Lm9yaWdpbiAqIDEwMH0lICR7eS5vcmlnaW4gKiAxMDB9JSAwYDtcbiAgICAgIGlmIChsZWFkLmFuaW1hdGlvblZhbHVlcykge1xuICAgICAgICBzdHlsZXMub3BhY2l0eSA9IGxlYWQgPT09IHRoaXMgPyAoX2MgPSAoX2IgPSB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAxIDogdGhpcy5wcmVzZXJ2ZU9wYWNpdHkgPyB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5IDogdmFsdWVzVG9SZW5kZXIub3BhY2l0eUV4aXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZXMub3BhY2l0eSA9IGxlYWQgPT09IHRoaXMgPyB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5ICE9PSB2b2lkIDAgPyB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5IDogXCJcIiA6IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHlFeGl0ICE9PSB2b2lkIDAgPyB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdCA6IDA7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2FsZUNvcnJlY3RvcnMpIHtcbiAgICAgICAgaWYgKHZhbHVlc1RvUmVuZGVyW2tleV0gPT09IHZvaWQgMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgeyBjb3JyZWN0LCBhcHBseVRvIH0gPSBzY2FsZUNvcnJlY3RvcnNba2V5XTtcbiAgICAgICAgY29uc3QgY29ycmVjdGVkID0gY29ycmVjdCh2YWx1ZXNUb1JlbmRlcltrZXldLCBsZWFkKTtcbiAgICAgICAgaWYgKGFwcGx5VG8pIHtcbiAgICAgICAgICBjb25zdCBudW0gPSBhcHBseVRvLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtOyBpMisrKSB7XG4gICAgICAgICAgICBzdHlsZXNbYXBwbHlUb1tpMl1dID0gY29ycmVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZXNba2V5XSA9IGNvcnJlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRJZCkge1xuICAgICAgICBzdHlsZXMucG9pbnRlckV2ZW50cyA9IGxlYWQgPT09IHRoaXMgPyByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCIgOiBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfVxuICAgIGNsZWFyU25hcHNob3QoKSB7XG4gICAgICB0aGlzLnJlc3VtZUZyb20gPSB0aGlzLnNuYXBzaG90ID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXNldFRyZWUoKSB7XG4gICAgICB0aGlzLnJvb3Qubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSBub2RlLmN1cnJlbnRBbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucm9vdC5ub2Rlcy5mb3JFYWNoKGNsZWFyTWVhc3VyZW1lbnRzKTtcbiAgICAgIHRoaXMucm9vdC5zaGFyZWROb2Rlcy5jbGVhcigpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxheW91dChub2RlKSB7XG4gIG5vZGUudXBkYXRlTGF5b3V0KCk7XG59XG5mdW5jdGlvbiBub3RpZnlMYXlvdXRVcGRhdGUobm9kZSkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3Qgc25hcHNob3QgPSAoKF9hID0gbm9kZS5yZXN1bWVGcm9tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc25hcHNob3QpIHx8IG5vZGUuc25hcHNob3Q7XG4gIGlmIChub2RlLmlzTGVhZCgpICYmIG5vZGUubGF5b3V0ICYmIHNuYXBzaG90ICYmIG5vZGUuaGFzTGlzdGVuZXJzKFwiZGlkVXBkYXRlXCIpKSB7XG4gICAgY29uc3QgeyBsYXlvdXRCb3g6IGxheW91dCwgbWVhc3VyZWRCb3g6IG1lYXN1cmVkTGF5b3V0IH0gPSBub2RlLmxheW91dDtcbiAgICBjb25zdCB7IGFuaW1hdGlvblR5cGUgfSA9IG5vZGUub3B0aW9ucztcbiAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gXCJzaXplXCIpIHtcbiAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgIGNvbnN0IGF4aXNTbmFwc2hvdCA9IHNuYXBzaG90LmlzU2hhcmVkID8gc25hcHNob3QubWVhc3VyZWRCb3hbYXhpc10gOiBzbmFwc2hvdC5sYXlvdXRCb3hbYXhpc107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNhbGNMZW5ndGgoYXhpc1NuYXBzaG90KTtcbiAgICAgICAgYXhpc1NuYXBzaG90Lm1pbiA9IGxheW91dFtheGlzXS5taW47XG4gICAgICAgIGF4aXNTbmFwc2hvdC5tYXggPSBheGlzU25hcHNob3QubWluICsgbGVuZ3RoO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzaG91bGRBbmltYXRlUG9zaXRpb25Pbmx5KGFuaW1hdGlvblR5cGUsIHNuYXBzaG90LmxheW91dEJveCwgbGF5b3V0KSkge1xuICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgY29uc3QgYXhpc1NuYXBzaG90ID0gc25hcHNob3QuaXNTaGFyZWQgPyBzbmFwc2hvdC5tZWFzdXJlZEJveFtheGlzXSA6IHNuYXBzaG90LmxheW91dEJveFtheGlzXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY2FsY0xlbmd0aChsYXlvdXRbYXhpc10pO1xuICAgICAgICBheGlzU25hcHNob3QubWF4ID0gYXhpc1NuYXBzaG90Lm1pbiArIGxlbmd0aDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBsYXlvdXREZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgY2FsY0JveERlbHRhKGxheW91dERlbHRhLCBsYXlvdXQsIHNuYXBzaG90LmxheW91dEJveCk7XG4gICAgY29uc3QgdmlzdWFsRGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgIGlmIChzbmFwc2hvdC5pc1NoYXJlZCkge1xuICAgICAgY2FsY0JveERlbHRhKHZpc3VhbERlbHRhLCBub2RlLmFwcGx5VHJhbnNmb3JtKG1lYXN1cmVkTGF5b3V0LCB0cnVlKSwgc25hcHNob3QubWVhc3VyZWRCb3gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxjQm94RGVsdGEodmlzdWFsRGVsdGEsIGxheW91dCwgc25hcHNob3QubGF5b3V0Qm94KTtcbiAgICB9XG4gICAgY29uc3QgaGFzTGF5b3V0Q2hhbmdlZCA9ICFpc0RlbHRhWmVybyhsYXlvdXREZWx0YSk7XG4gICAgbGV0IGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIGlmICghbm9kZS5yZXN1bWVGcm9tKSB7XG4gICAgICBjb25zdCByZWxhdGl2ZVBhcmVudCA9IG5vZGUuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgIGlmIChyZWxhdGl2ZVBhcmVudCAmJiAhcmVsYXRpdmVQYXJlbnQucmVzdW1lRnJvbSkge1xuICAgICAgICBjb25zdCB7IHNuYXBzaG90OiBwYXJlbnRTbmFwc2hvdCwgbGF5b3V0OiBwYXJlbnRMYXlvdXQgfSA9IHJlbGF0aXZlUGFyZW50O1xuICAgICAgICBpZiAocGFyZW50U25hcHNob3QgJiYgcGFyZW50TGF5b3V0KSB7XG4gICAgICAgICAgY29uc3QgcmVsYXRpdmVTbmFwc2hvdCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHJlbGF0aXZlU25hcHNob3QsIHNuYXBzaG90LmxheW91dEJveCwgcGFyZW50U25hcHNob3QubGF5b3V0Qm94KTtcbiAgICAgICAgICBjb25zdCByZWxhdGl2ZUxheW91dCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHJlbGF0aXZlTGF5b3V0LCBsYXlvdXQsIHBhcmVudExheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgIGlmICghYm94RXF1YWxzKHJlbGF0aXZlU25hcHNob3QsIHJlbGF0aXZlTGF5b3V0KSkge1xuICAgICAgICAgICAgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5ub3RpZnlMaXN0ZW5lcnMoXCJkaWRVcGRhdGVcIiwge1xuICAgICAgbGF5b3V0LFxuICAgICAgc25hcHNob3QsXG4gICAgICBkZWx0YTogdmlzdWFsRGVsdGEsXG4gICAgICBsYXlvdXREZWx0YSxcbiAgICAgIGhhc0xheW91dENoYW5nZWQsXG4gICAgICBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWRcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChub2RlLmlzTGVhZCgpKSB7XG4gICAgKF9jID0gKF9iID0gbm9kZS5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xuICB9XG4gIG5vZGUub3B0aW9ucy50cmFuc2l0aW9uID0gdm9pZCAwO1xufVxuZnVuY3Rpb24gY2xlYXJTbmFwc2hvdChub2RlKSB7XG4gIG5vZGUuY2xlYXJTbmFwc2hvdCgpO1xufVxuZnVuY3Rpb24gY2xlYXJNZWFzdXJlbWVudHMobm9kZSkge1xuICBub2RlLmNsZWFyTWVhc3VyZW1lbnRzKCk7XG59XG5mdW5jdGlvbiByZXNldFRyYW5zZm9ybVN0eWxlKG5vZGUpIHtcbiAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSBub2RlLm9wdGlvbnM7XG4gIGlmICh2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKS5vbkJlZm9yZUxheW91dE1lYXN1cmUpIHtcbiAgICB2aXN1YWxFbGVtZW50Lm5vdGlmeShcIkJlZm9yZUxheW91dE1lYXN1cmVcIik7XG4gIH1cbiAgbm9kZS5yZXNldFRyYW5zZm9ybSgpO1xufVxuZnVuY3Rpb24gZmluaXNoQW5pbWF0aW9uKG5vZGUpIHtcbiAgbm9kZS5maW5pc2hBbmltYXRpb24oKTtcbiAgbm9kZS50YXJnZXREZWx0YSA9IG5vZGUucmVsYXRpdmVUYXJnZXQgPSBub2RlLnRhcmdldCA9IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXREZWx0YShub2RlKSB7XG4gIG5vZGUucmVzb2x2ZVRhcmdldERlbHRhKCk7XG59XG5mdW5jdGlvbiBjYWxjUHJvamVjdGlvbihub2RlKSB7XG4gIG5vZGUuY2FsY1Byb2plY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIHJlc2V0Um90YXRpb24obm9kZSkge1xuICBub2RlLnJlc2V0Um90YXRpb24oKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxlYWRTbmFwc2hvdHMoc3RhY2spIHtcbiAgc3RhY2sucmVtb3ZlTGVhZFNuYXBzaG90KCk7XG59XG5mdW5jdGlvbiBtaXhBeGlzRGVsdGEob3V0cHV0LCBkZWx0YSwgcDIpIHtcbiAgb3V0cHV0LnRyYW5zbGF0ZSA9IG1peChkZWx0YS50cmFuc2xhdGUsIDAsIHAyKTtcbiAgb3V0cHV0LnNjYWxlID0gbWl4KGRlbHRhLnNjYWxlLCAxLCBwMik7XG4gIG91dHB1dC5vcmlnaW4gPSBkZWx0YS5vcmlnaW47XG4gIG91dHB1dC5vcmlnaW5Qb2ludCA9IGRlbHRhLm9yaWdpblBvaW50O1xufVxuZnVuY3Rpb24gbWl4QXhpcyhvdXRwdXQsIGZyb20sIHRvLCBwMikge1xuICBvdXRwdXQubWluID0gbWl4KGZyb20ubWluLCB0by5taW4sIHAyKTtcbiAgb3V0cHV0Lm1heCA9IG1peChmcm9tLm1heCwgdG8ubWF4LCBwMik7XG59XG5mdW5jdGlvbiBtaXhCb3gob3V0cHV0LCBmcm9tLCB0bywgcDIpIHtcbiAgbWl4QXhpcyhvdXRwdXQueCwgZnJvbS54LCB0by54LCBwMik7XG4gIG1peEF4aXMob3V0cHV0LnksIGZyb20ueSwgdG8ueSwgcDIpO1xufVxuZnVuY3Rpb24gaGFzT3BhY2l0eUNyb3NzZmFkZShub2RlKSB7XG4gIHJldHVybiBub2RlLmFuaW1hdGlvblZhbHVlcyAmJiBub2RlLmFuaW1hdGlvblZhbHVlcy5vcGFjaXR5RXhpdCAhPT0gdm9pZCAwO1xufVxudmFyIGRlZmF1bHRMYXlvdXRUcmFuc2l0aW9uID0ge1xuICBkdXJhdGlvbjogMC40NSxcbiAgZWFzZTogWzAuNCwgMCwgMC4xLCAxXVxufTtcbmZ1bmN0aW9uIG1vdW50Tm9kZUVhcmx5KG5vZGUsIGlkMikge1xuICBsZXQgc2VhcmNoTm9kZSA9IG5vZGUucm9vdDtcbiAgZm9yIChsZXQgaTIgPSBub2RlLnBhdGgubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgIGlmIChCb29sZWFuKG5vZGUucGF0aFtpMl0uaW5zdGFuY2UpKSB7XG4gICAgICBzZWFyY2hOb2RlID0gbm9kZS5wYXRoW2kyXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWFyY2hFbGVtZW50ID0gc2VhcmNoTm9kZSAmJiBzZWFyY2hOb2RlICE9PSBub2RlLnJvb3QgPyBzZWFyY2hOb2RlLmluc3RhbmNlIDogZG9jdW1lbnQ7XG4gIGNvbnN0IGVsZW1lbnQgPSBzZWFyY2hFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXByb2plY3Rpb24taWQ9XCIke2lkMn1cIl1gKTtcbiAgaWYgKGVsZW1lbnQpXG4gICAgbm9kZS5tb3VudChlbGVtZW50LCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHJvdW5kQXhpcyhheGlzKSB7XG4gIGF4aXMubWluID0gTWF0aC5yb3VuZChheGlzLm1pbik7XG4gIGF4aXMubWF4ID0gTWF0aC5yb3VuZChheGlzLm1heCk7XG59XG5mdW5jdGlvbiByb3VuZEJveChib3gpIHtcbiAgcm91bmRBeGlzKGJveC54KTtcbiAgcm91bmRBeGlzKGJveC55KTtcbn1cbmZ1bmN0aW9uIHNob3VsZEFuaW1hdGVQb3NpdGlvbk9ubHkoYW5pbWF0aW9uVHlwZSwgc25hcHNob3QsIGxheW91dCkge1xuICByZXR1cm4gYW5pbWF0aW9uVHlwZSA9PT0gXCJwb3NpdGlvblwiIHx8IGFuaW1hdGlvblR5cGUgPT09IFwicHJlc2VydmUtYXNwZWN0XCIgJiYgIWlzQ2xvc2VUbyhhc3BlY3RSYXRpbyhzbmFwc2hvdCksIGFzcGVjdFJhdGlvKGxheW91dCksIDAuMik7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL0RvY3VtZW50UHJvamVjdGlvbk5vZGUubWpzXG52YXIgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSA9IGNyZWF0ZVByb2plY3Rpb25Ob2RlKHtcbiAgYXR0YWNoUmVzaXplTGlzdGVuZXI6IChyZWYsIG5vdGlmeSkgPT4gYWRkRG9tRXZlbnQocmVmLCBcInJlc2l6ZVwiLCBub3RpZnkpLFxuICBtZWFzdXJlU2Nyb2xsOiAoKSA9PiAoe1xuICAgIHg6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcbiAgICB5OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wXG4gIH0pLFxuICBjaGVja0lzU2Nyb2xsUm9vdDogKCkgPT4gdHJ1ZVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL0hUTUxQcm9qZWN0aW9uTm9kZS5tanNcbnZhciByb290UHJvamVjdGlvbk5vZGUgPSB7XG4gIGN1cnJlbnQ6IHZvaWQgMFxufTtcbnZhciBIVE1MUHJvamVjdGlvbk5vZGUgPSBjcmVhdGVQcm9qZWN0aW9uTm9kZSh7XG4gIG1lYXN1cmVTY3JvbGw6IChpbnN0YW5jZSkgPT4gKHtcbiAgICB4OiBpbnN0YW5jZS5zY3JvbGxMZWZ0LFxuICAgIHk6IGluc3RhbmNlLnNjcm9sbFRvcFxuICB9KSxcbiAgZGVmYXVsdFBhcmVudDogKCkgPT4ge1xuICAgIGlmICghcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IGRvY3VtZW50Tm9kZSA9IG5ldyBEb2N1bWVudFByb2plY3Rpb25Ob2RlKDAsIHt9KTtcbiAgICAgIGRvY3VtZW50Tm9kZS5tb3VudCh3aW5kb3cpO1xuICAgICAgZG9jdW1lbnROb2RlLnNldE9wdGlvbnMoeyBsYXlvdXRTY3JvbGw6IHRydWUgfSk7XG4gICAgICByb290UHJvamVjdGlvbk5vZGUuY3VycmVudCA9IGRvY3VtZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50O1xuICB9LFxuICByZXNldFRyYW5zZm9ybTogKGluc3RhbmNlLCB2YWx1ZSkgPT4ge1xuICAgIGluc3RhbmNlLnN0eWxlLnRyYW5zZm9ybSA9IHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IFwibm9uZVwiO1xuICB9LFxuICBjaGVja0lzU2Nyb2xsUm9vdDogKGluc3RhbmNlKSA9PiBCb29sZWFuKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGluc3RhbmNlKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS9tb3Rpb24ubWpzXG52YXIgZmVhdHVyZUJ1bmRsZSA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBhbmltYXRpb25zKSwgZ2VzdHVyZUFuaW1hdGlvbnMpLCBkcmFnKSwgbGF5b3V0RmVhdHVyZXMpO1xudmFyIG1vdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVNb3Rpb25Qcm94eSgoQ29tcG9uZW50LCBjb25maWcpID0+IGNyZWF0ZURvbU1vdGlvbkNvbmZpZyhDb21wb25lbnQsIGNvbmZpZywgZmVhdHVyZUJ1bmRsZSwgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCwgSFRNTFByb2plY3Rpb25Ob2RlKSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvY2xhbXAuZXMuanNcbnZhciBjbGFtcDMgPSAobWluLCBtYXgsIHYpID0+IE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvaXMtbnVtYmVyLmVzLmpzXG52YXIgaXNOdW1iZXIgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9pcy1lYXNpbmctbGlzdC5lcy5qc1xudmFyIGlzRWFzaW5nTGlzdCA9IChlYXNpbmcpID0+IEFycmF5LmlzQXJyYXkoZWFzaW5nKSAmJiAhaXNOdW1iZXIoZWFzaW5nWzBdKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC93cmFwLmVzLmpzXG52YXIgd3JhcCA9IChtaW4sIG1heCwgdikgPT4ge1xuICBjb25zdCByYW5nZVNpemUgPSBtYXggLSBtaW47XG4gIHJldHVybiAoKHYgLSBtaW4pICUgcmFuZ2VTaXplICsgcmFuZ2VTaXplKSAlIHJhbmdlU2l6ZSArIG1pbjtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvZWFzaW5nLmVzLmpzXG5mdW5jdGlvbiBnZXRFYXNpbmdGb3JTZWdtZW50KGVhc2luZywgaTIpIHtcbiAgcmV0dXJuIGlzRWFzaW5nTGlzdChlYXNpbmcpID8gZWFzaW5nW3dyYXAoMCwgZWFzaW5nLmxlbmd0aCwgaTIpXSA6IGVhc2luZztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9taXguZXMuanNcbnZhciBtaXgyID0gKG1pbiwgbWF4LCBwcm9ncmVzczMpID0+IC1wcm9ncmVzczMgKiBtaW4gKyBwcm9ncmVzczMgKiBtYXggKyBtaW47XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3Qvbm9vcC5lcy5qc1xudmFyIG5vb3BSZXR1cm4gPSAodikgPT4gdjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9wcm9ncmVzcy5lcy5qc1xudmFyIHByb2dyZXNzMiA9IChtaW4sIG1heCwgdmFsdWUpID0+IG1heCAtIG1pbiA9PT0gMCA/IDEgOiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3Qvb2Zmc2V0LmVzLmpzXG5mdW5jdGlvbiBmaWxsT2Zmc2V0KG9mZnNldCwgcmVtYWluaW5nKSB7XG4gIGNvbnN0IG1pbiA9IG9mZnNldFtvZmZzZXQubGVuZ3RoIC0gMV07XG4gIGZvciAobGV0IGkyID0gMTsgaTIgPD0gcmVtYWluaW5nOyBpMisrKSB7XG4gICAgY29uc3Qgb2Zmc2V0UHJvZ3Jlc3MgPSBwcm9ncmVzczIoMCwgcmVtYWluaW5nLCBpMik7XG4gICAgb2Zmc2V0LnB1c2gobWl4MihtaW4sIDEsIG9mZnNldFByb2dyZXNzKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmF1bHRPZmZzZXQyKGxlbmd0aCkge1xuICBjb25zdCBvZmZzZXQgPSBbMF07XG4gIGZpbGxPZmZzZXQob2Zmc2V0LCBsZW5ndGggLSAxKTtcbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9pbnRlcnBvbGF0ZS5lcy5qc1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUyKG91dHB1dCwgaW5wdXQgPSBkZWZhdWx0T2Zmc2V0MihvdXRwdXQubGVuZ3RoKSwgZWFzaW5nID0gbm9vcFJldHVybikge1xuICBjb25zdCBsZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuICBjb25zdCByZW1haW5kZXIgPSBsZW5ndGggLSBpbnB1dC5sZW5ndGg7XG4gIHJlbWFpbmRlciA+IDAgJiYgZmlsbE9mZnNldChpbnB1dCwgcmVtYWluZGVyKTtcbiAgcmV0dXJuICh0KSA9PiB7XG4gICAgbGV0IGkyID0gMDtcbiAgICBmb3IgKDsgaTIgPCBsZW5ndGggLSAyOyBpMisrKSB7XG4gICAgICBpZiAodCA8IGlucHV0W2kyICsgMV0pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgcHJvZ3Jlc3NJblJhbmdlID0gY2xhbXAzKDAsIDEsIHByb2dyZXNzMihpbnB1dFtpMl0sIGlucHV0W2kyICsgMV0sIHQpKTtcbiAgICBjb25zdCBzZWdtZW50RWFzaW5nID0gZ2V0RWFzaW5nRm9yU2VnbWVudChlYXNpbmcsIGkyKTtcbiAgICBwcm9ncmVzc0luUmFuZ2UgPSBzZWdtZW50RWFzaW5nKHByb2dyZXNzSW5SYW5nZSk7XG4gICAgcmV0dXJuIG1peDIob3V0cHV0W2kyXSwgb3V0cHV0W2kyICsgMV0sIHByb2dyZXNzSW5SYW5nZSk7XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvaXMtZnVuY3Rpb24uZXMuanNcbnZhciBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9pcy1zdHJpbmcuZXMuanNcbnZhciBpc1N0cmluZzIgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC92ZWxvY2l0eS5lcy5qc1xuZnVuY3Rpb24gdmVsb2NpdHlQZXJTZWNvbmQyKHZlbG9jaXR5LCBmcmFtZUR1cmF0aW9uKSB7XG4gIHJldHVybiBmcmFtZUR1cmF0aW9uID8gdmVsb2NpdHkgKiAoMWUzIC8gZnJhbWVEdXJhdGlvbikgOiAwO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC91dGlscy9yZXNvbHZlLWVsZW1lbnRzLmVzLmpzXG5mdW5jdGlvbiByZXNvbHZlRWxlbWVudHMoZWxlbWVudHMsIHNlbGVjdG9yQ2FjaGUpIHtcbiAgdmFyIF9hO1xuICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHNlbGVjdG9yQ2FjaGUpIHtcbiAgICAgIChfYSA9IHNlbGVjdG9yQ2FjaGVbZWxlbWVudHNdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzZWxlY3RvckNhY2hlW2VsZW1lbnRzXSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudHMpO1xuICAgICAgZWxlbWVudHMgPSBzZWxlY3RvckNhY2hlW2VsZW1lbnRzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWxlbWVudHMgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnRzIHx8IFtdKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL21vZHVsZXMvaW5kZXguanNcbnZhciBpbXBvcnRfdHNsaWI0ID0gX190b0VTTShyZXF1aXJlX3RzbGliMigpLCAxKTtcbnZhciB7XG4gIF9fZXh0ZW5kczogX19leHRlbmRzMixcbiAgX19hc3NpZ246IF9fYXNzaWduMixcbiAgX19yZXN0OiBfX3Jlc3QyLFxuICBfX2RlY29yYXRlOiBfX2RlY29yYXRlMixcbiAgX19wYXJhbTogX19wYXJhbTIsXG4gIF9fbWV0YWRhdGE6IF9fbWV0YWRhdGEyLFxuICBfX2F3YWl0ZXI6IF9fYXdhaXRlcjIsXG4gIF9fZ2VuZXJhdG9yOiBfX2dlbmVyYXRvcjIsXG4gIF9fZXhwb3J0U3RhcjogX19leHBvcnRTdGFyMixcbiAgX19jcmVhdGVCaW5kaW5nOiBfX2NyZWF0ZUJpbmRpbmcyLFxuICBfX3ZhbHVlczogX192YWx1ZXMyLFxuICBfX3JlYWQ6IF9fcmVhZDIsXG4gIF9fc3ByZWFkOiBfX3NwcmVhZDIsXG4gIF9fc3ByZWFkQXJyYXlzOiBfX3NwcmVhZEFycmF5czIsXG4gIF9fc3ByZWFkQXJyYXk6IF9fc3ByZWFkQXJyYXkyLFxuICBfX2F3YWl0OiBfX2F3YWl0MixcbiAgX19hc3luY0dlbmVyYXRvcjogX19hc3luY0dlbmVyYXRvcjIsXG4gIF9fYXN5bmNEZWxlZ2F0b3I6IF9fYXN5bmNEZWxlZ2F0b3IyLFxuICBfX2FzeW5jVmFsdWVzOiBfX2FzeW5jVmFsdWVzMixcbiAgX19tYWtlVGVtcGxhdGVPYmplY3Q6IF9fbWFrZVRlbXBsYXRlT2JqZWN0MixcbiAgX19pbXBvcnRTdGFyOiBfX2ltcG9ydFN0YXIyLFxuICBfX2ltcG9ydERlZmF1bHQ6IF9faW1wb3J0RGVmYXVsdDIsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQyLFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0OiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MixcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEluOiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4yXG59ID0gaW1wb3J0X3RzbGliNC5kZWZhdWx0O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9yZXNpemUvaGFuZGxlLWVsZW1lbnQuZXMuanNcbnZhciByZXNpemVIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIG9ic2VydmVyO1xuZnVuY3Rpb24gZ2V0RWxlbWVudFNpemUodGFyZ2V0LCBib3JkZXJCb3hTaXplKSB7XG4gIGlmIChib3JkZXJCb3hTaXplKSB7XG4gICAgY29uc3QgeyBpbmxpbmVTaXplLCBibG9ja1NpemUgfSA9IGJvcmRlckJveFNpemVbMF07XG4gICAgcmV0dXJuIHsgd2lkdGg6IGlubGluZVNpemUsIGhlaWdodDogYmxvY2tTaXplIH07XG4gIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBcImdldEJCb3hcIiBpbiB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0LmdldEJCb3goKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRhcmdldC5vZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogdGFyZ2V0Lm9mZnNldEhlaWdodFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIG5vdGlmeVRhcmdldCh7IHRhcmdldCwgY29udGVudFJlY3QsIGJvcmRlckJveFNpemUgfSkge1xuICB2YXIgX2E7XG4gIChfYSA9IHJlc2l6ZUhhbmRsZXJzLmdldCh0YXJnZXQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgIGhhbmRsZXIoe1xuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGVudFNpemU6IGNvbnRlbnRSZWN0LFxuICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBnZXRFbGVtZW50U2l6ZSh0YXJnZXQsIGJvcmRlckJveFNpemUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vdGlmeUFsbChlbnRyaWVzKSB7XG4gIGVudHJpZXMuZm9yRWFjaChub3RpZnlUYXJnZXQpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVzaXplT2JzZXJ2ZXIoKSB7XG4gIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuO1xuICBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihub3RpZnlBbGwpO1xufVxuZnVuY3Rpb24gcmVzaXplRWxlbWVudCh0YXJnZXQsIGhhbmRsZXIpIHtcbiAgaWYgKCFvYnNlcnZlcilcbiAgICBjcmVhdGVSZXNpemVPYnNlcnZlcigpO1xuICBjb25zdCBlbGVtZW50cyA9IHJlc29sdmVFbGVtZW50cyh0YXJnZXQpO1xuICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgbGV0IGVsZW1lbnRIYW5kbGVycyA9IHJlc2l6ZUhhbmRsZXJzLmdldChlbGVtZW50KTtcbiAgICBpZiAoIWVsZW1lbnRIYW5kbGVycykge1xuICAgICAgZWxlbWVudEhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHJlc2l6ZUhhbmRsZXJzLnNldChlbGVtZW50LCBlbGVtZW50SGFuZGxlcnMpO1xuICAgIH1cbiAgICBlbGVtZW50SGFuZGxlcnMuYWRkKGhhbmRsZXIpO1xuICAgIG9ic2VydmVyID09PSBudWxsIHx8IG9ic2VydmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50SGFuZGxlcnMgPSByZXNpemVIYW5kbGVycy5nZXQoZWxlbWVudCk7XG4gICAgICBlbGVtZW50SGFuZGxlcnMgPT09IG51bGwgfHwgZWxlbWVudEhhbmRsZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50SGFuZGxlcnMuZGVsZXRlKGhhbmRsZXIpO1xuICAgICAgaWYgKCEoZWxlbWVudEhhbmRsZXJzID09PSBudWxsIHx8IGVsZW1lbnRIYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudEhhbmRsZXJzLnNpemUpKSB7XG4gICAgICAgIG9ic2VydmVyID09PSBudWxsIHx8IG9ic2VydmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Jlc2l6ZS9oYW5kbGUtd2luZG93LmVzLmpzXG52YXIgd2luZG93Q2FsbGJhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciB3aW5kb3dSZXNpemVIYW5kbGVyO1xuZnVuY3Rpb24gY3JlYXRlV2luZG93UmVzaXplSGFuZGxlcigpIHtcbiAgd2luZG93UmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICBjb25zdCBzaXplID0ge1xuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICB0YXJnZXQ6IHdpbmRvdyxcbiAgICAgIHNpemUsXG4gICAgICBjb250ZW50U2l6ZTogc2l6ZVxuICAgIH07XG4gICAgd2luZG93Q2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhpbmZvKSk7XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHdpbmRvd1Jlc2l6ZUhhbmRsZXIpO1xufVxuZnVuY3Rpb24gcmVzaXplV2luZG93KGNhbGxiYWNrKSB7XG4gIHdpbmRvd0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICBpZiAoIXdpbmRvd1Jlc2l6ZUhhbmRsZXIpXG4gICAgY3JlYXRlV2luZG93UmVzaXplSGFuZGxlcigpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHdpbmRvd0NhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgIGlmICghd2luZG93Q2FsbGJhY2tzLnNpemUgJiYgd2luZG93UmVzaXplSGFuZGxlcikge1xuICAgICAgd2luZG93UmVzaXplSGFuZGxlciA9IHZvaWQgMDtcbiAgICB9XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Jlc2l6ZS9pbmRleC5lcy5qc1xuZnVuY3Rpb24gcmVzaXplKGEyLCBiMikge1xuICByZXR1cm4gaXNGdW5jdGlvbihhMikgPyByZXNpemVXaW5kb3coYTIpIDogcmVzaXplRWxlbWVudChhMiwgYjIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvaW5mby5lcy5qc1xudmFyIG1heEVsYXBzZWQyID0gNTA7XG52YXIgY3JlYXRlQXhpc0luZm8gPSAoKSA9PiAoe1xuICBjdXJyZW50OiAwLFxuICBvZmZzZXQ6IFtdLFxuICBwcm9ncmVzczogMCxcbiAgc2Nyb2xsTGVuZ3RoOiAwLFxuICB0YXJnZXRPZmZzZXQ6IDAsXG4gIHRhcmdldExlbmd0aDogMCxcbiAgY29udGFpbmVyTGVuZ3RoOiAwLFxuICB2ZWxvY2l0eTogMFxufSk7XG52YXIgY3JlYXRlU2Nyb2xsSW5mbyA9ICgpID0+ICh7XG4gIHRpbWU6IDAsXG4gIHg6IGNyZWF0ZUF4aXNJbmZvKCksXG4gIHk6IGNyZWF0ZUF4aXNJbmZvKClcbn0pO1xudmFyIGtleXMgPSB7XG4gIHg6IHtcbiAgICBsZW5ndGg6IFwiV2lkdGhcIixcbiAgICBwb3NpdGlvbjogXCJMZWZ0XCJcbiAgfSxcbiAgeToge1xuICAgIGxlbmd0aDogXCJIZWlnaHRcIixcbiAgICBwb3NpdGlvbjogXCJUb3BcIlxuICB9XG59O1xuZnVuY3Rpb24gdXBkYXRlQXhpc0luZm8oZWxlbWVudCwgYXhpc05hbWUsIGluZm8sIHRpbWUpIHtcbiAgY29uc3QgYXhpcyA9IGluZm9bYXhpc05hbWVdO1xuICBjb25zdCB7IGxlbmd0aCwgcG9zaXRpb24gfSA9IGtleXNbYXhpc05hbWVdO1xuICBjb25zdCBwcmV2ID0gYXhpcy5jdXJyZW50O1xuICBjb25zdCBwcmV2VGltZSA9IGluZm8udGltZTtcbiAgYXhpcy5jdXJyZW50ID0gZWxlbWVudFtcInNjcm9sbFwiICsgcG9zaXRpb25dO1xuICBheGlzLnNjcm9sbExlbmd0aCA9IGVsZW1lbnRbXCJzY3JvbGxcIiArIGxlbmd0aF0gLSBlbGVtZW50W1wiY2xpZW50XCIgKyBsZW5ndGhdO1xuICBheGlzLm9mZnNldC5sZW5ndGggPSAwO1xuICBheGlzLm9mZnNldFswXSA9IDA7XG4gIGF4aXMub2Zmc2V0WzFdID0gYXhpcy5zY3JvbGxMZW5ndGg7XG4gIGF4aXMucHJvZ3Jlc3MgPSBwcm9ncmVzczIoMCwgYXhpcy5zY3JvbGxMZW5ndGgsIGF4aXMuY3VycmVudCk7XG4gIGNvbnN0IGVsYXBzZWQgPSB0aW1lIC0gcHJldlRpbWU7XG4gIGF4aXMudmVsb2NpdHkgPSBlbGFwc2VkID4gbWF4RWxhcHNlZDIgPyAwIDogdmVsb2NpdHlQZXJTZWNvbmQyKGF4aXMuY3VycmVudCAtIHByZXYsIGVsYXBzZWQpO1xufVxuZnVuY3Rpb24gdXBkYXRlU2Nyb2xsSW5mbyhlbGVtZW50LCBpbmZvLCB0aW1lKSB7XG4gIHVwZGF0ZUF4aXNJbmZvKGVsZW1lbnQsIFwieFwiLCBpbmZvLCB0aW1lKTtcbiAgdXBkYXRlQXhpc0luZm8oZWxlbWVudCwgXCJ5XCIsIGluZm8sIHRpbWUpO1xuICBpbmZvLnRpbWUgPSB0aW1lO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvb2Zmc2V0cy9pbnNldC5lcy5qc1xuZnVuY3Rpb24gY2FsY0luc2V0KGVsZW1lbnQsIGNvbnRhaW5lcikge1xuICBsZXQgaW5zZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgbGV0IGN1cnJlbnQgPSBlbGVtZW50O1xuICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBjb250YWluZXIpIHtcbiAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICBpbnNldC54ICs9IGN1cnJlbnQub2Zmc2V0TGVmdDtcbiAgICAgIGluc2V0LnkgKz0gY3VycmVudC5vZmZzZXRUb3A7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5vZmZzZXRQYXJlbnQ7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50IGluc3RhbmNlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICYmIFwiZ2V0QkJveFwiIGluIGN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHsgdG9wLCBsZWZ0IH0gPSBjdXJyZW50LmdldEJCb3goKTtcbiAgICAgIGluc2V0LnggKz0gbGVmdDtcbiAgICAgIGluc2V0LnkgKz0gdG9wO1xuICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC50YWdOYW1lICE9PSBcInN2Z1wiKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnNldDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL29mZnNldHMvcHJlc2V0cy5lcy5qc1xudmFyIFNjcm9sbE9mZnNldCA9IHtcbiAgRW50ZXI6IFtcbiAgICBbMCwgMV0sXG4gICAgWzEsIDFdXG4gIF0sXG4gIEV4aXQ6IFtcbiAgICBbMCwgMF0sXG4gICAgWzEsIDBdXG4gIF0sXG4gIEFueTogW1xuICAgIFsxLCAwXSxcbiAgICBbMCwgMV1cbiAgXSxcbiAgQWxsOiBbXG4gICAgWzAsIDBdLFxuICAgIFsxLCAxXVxuICBdXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvb2Zmc2V0cy9lZGdlLmVzLmpzXG52YXIgbmFtZWRFZGdlcyA9IHtcbiAgc3RhcnQ6IDAsXG4gIGNlbnRlcjogMC41LFxuICBlbmQ6IDFcbn07XG5mdW5jdGlvbiByZXNvbHZlRWRnZShlZGdlLCBsZW5ndGgsIGluc2V0ID0gMCkge1xuICBsZXQgZGVsdGEgPSAwO1xuICBpZiAobmFtZWRFZGdlc1tlZGdlXSAhPT0gdm9pZCAwKSB7XG4gICAgZWRnZSA9IG5hbWVkRWRnZXNbZWRnZV07XG4gIH1cbiAgaWYgKGlzU3RyaW5nMihlZGdlKSkge1xuICAgIGNvbnN0IGFzTnVtYmVyMiA9IHBhcnNlRmxvYXQoZWRnZSk7XG4gICAgaWYgKGVkZ2UuZW5kc1dpdGgoXCJweFwiKSkge1xuICAgICAgZGVsdGEgPSBhc051bWJlcjI7XG4gICAgfSBlbHNlIGlmIChlZGdlLmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgZWRnZSA9IGFzTnVtYmVyMiAvIDEwMDtcbiAgICB9IGVsc2UgaWYgKGVkZ2UuZW5kc1dpdGgoXCJ2d1wiKSkge1xuICAgICAgZGVsdGEgPSBhc051bWJlcjIgLyAxMDAgKiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgfSBlbHNlIGlmIChlZGdlLmVuZHNXaXRoKFwidmhcIikpIHtcbiAgICAgIGRlbHRhID0gYXNOdW1iZXIyIC8gMTAwICogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRnZSA9IGFzTnVtYmVyMjtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTnVtYmVyKGVkZ2UpKSB7XG4gICAgZGVsdGEgPSBsZW5ndGggKiBlZGdlO1xuICB9XG4gIHJldHVybiBpbnNldCArIGRlbHRhO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvb2Zmc2V0cy9vZmZzZXQuZXMuanNcbnZhciBkZWZhdWx0T2Zmc2V0MyA9IFswLCAwXTtcbmZ1bmN0aW9uIHJlc29sdmVPZmZzZXQob2Zmc2V0LCBjb250YWluZXJMZW5ndGgsIHRhcmdldExlbmd0aCwgdGFyZ2V0SW5zZXQpIHtcbiAgbGV0IG9mZnNldERlZmluaXRpb24gPSBBcnJheS5pc0FycmF5KG9mZnNldCkgPyBvZmZzZXQgOiBkZWZhdWx0T2Zmc2V0MztcbiAgbGV0IHRhcmdldFBvaW50ID0gMDtcbiAgbGV0IGNvbnRhaW5lclBvaW50ID0gMDtcbiAgaWYgKGlzTnVtYmVyKG9mZnNldCkpIHtcbiAgICBvZmZzZXREZWZpbml0aW9uID0gW29mZnNldCwgb2Zmc2V0XTtcbiAgfSBlbHNlIGlmIChpc1N0cmluZzIob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldC50cmltKCk7XG4gICAgaWYgKG9mZnNldC5pbmNsdWRlcyhcIiBcIikpIHtcbiAgICAgIG9mZnNldERlZmluaXRpb24gPSBvZmZzZXQuc3BsaXQoXCIgXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXREZWZpbml0aW9uID0gW29mZnNldCwgbmFtZWRFZGdlc1tvZmZzZXRdID8gb2Zmc2V0IDogYDBgXTtcbiAgICB9XG4gIH1cbiAgdGFyZ2V0UG9pbnQgPSByZXNvbHZlRWRnZShvZmZzZXREZWZpbml0aW9uWzBdLCB0YXJnZXRMZW5ndGgsIHRhcmdldEluc2V0KTtcbiAgY29udGFpbmVyUG9pbnQgPSByZXNvbHZlRWRnZShvZmZzZXREZWZpbml0aW9uWzFdLCBjb250YWluZXJMZW5ndGgpO1xuICByZXR1cm4gdGFyZ2V0UG9pbnQgLSBjb250YWluZXJQb2ludDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL29mZnNldHMvaW5kZXguZXMuanNcbnZhciBwb2ludCA9IHsgeDogMCwgeTogMCB9O1xuZnVuY3Rpb24gcmVzb2x2ZU9mZnNldHMoY29udGFpbmVyLCBpbmZvLCBvcHRpb25zKSB7XG4gIGxldCB7IG9mZnNldDogb2Zmc2V0RGVmaW5pdGlvbiA9IFNjcm9sbE9mZnNldC5BbGwgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHsgdGFyZ2V0ID0gY29udGFpbmVyLCBheGlzID0gXCJ5XCIgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGxlbmd0aExhYmVsID0gYXhpcyA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICBjb25zdCBpbnNldCA9IHRhcmdldCAhPT0gY29udGFpbmVyID8gY2FsY0luc2V0KHRhcmdldCwgY29udGFpbmVyKSA6IHBvaW50O1xuICBjb25zdCB0YXJnZXRTaXplID0gdGFyZ2V0ID09PSBjb250YWluZXIgPyB7IHdpZHRoOiBjb250YWluZXIuc2Nyb2xsV2lkdGgsIGhlaWdodDogY29udGFpbmVyLnNjcm9sbEhlaWdodCB9IDogeyB3aWR0aDogdGFyZ2V0LmNsaWVudFdpZHRoLCBoZWlnaHQ6IHRhcmdldC5jbGllbnRIZWlnaHQgfTtcbiAgY29uc3QgY29udGFpbmVyU2l6ZSA9IHtcbiAgICB3aWR0aDogY29udGFpbmVyLmNsaWVudFdpZHRoLFxuICAgIGhlaWdodDogY29udGFpbmVyLmNsaWVudEhlaWdodFxuICB9O1xuICBpbmZvW2F4aXNdLm9mZnNldC5sZW5ndGggPSAwO1xuICBsZXQgaGFzQ2hhbmdlZCA9ICFpbmZvW2F4aXNdLmludGVycG9sYXRlO1xuICBjb25zdCBudW1PZmZzZXRzID0gb2Zmc2V0RGVmaW5pdGlvbi5sZW5ndGg7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1PZmZzZXRzOyBpMisrKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gcmVzb2x2ZU9mZnNldChvZmZzZXREZWZpbml0aW9uW2kyXSwgY29udGFpbmVyU2l6ZVtsZW5ndGhMYWJlbF0sIHRhcmdldFNpemVbbGVuZ3RoTGFiZWxdLCBpbnNldFtheGlzXSk7XG4gICAgaWYgKCFoYXNDaGFuZ2VkICYmIG9mZnNldCAhPT0gaW5mb1theGlzXS5pbnRlcnBvbGF0b3JPZmZzZXRzW2kyXSkge1xuICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIGluZm9bYXhpc10ub2Zmc2V0W2kyXSA9IG9mZnNldDtcbiAgfVxuICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgIGluZm9bYXhpc10uaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTIoZGVmYXVsdE9mZnNldDIobnVtT2Zmc2V0cyksIGluZm9bYXhpc10ub2Zmc2V0KTtcbiAgICBpbmZvW2F4aXNdLmludGVycG9sYXRvck9mZnNldHMgPSBbLi4uaW5mb1theGlzXS5vZmZzZXRdO1xuICB9XG4gIGluZm9bYXhpc10ucHJvZ3Jlc3MgPSBpbmZvW2F4aXNdLmludGVycG9sYXRlKGluZm9bYXhpc10uY3VycmVudCk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9vbi1zY3JvbGwtaGFuZGxlci5lcy5qc1xuZnVuY3Rpb24gbWVhc3VyZShjb250YWluZXIsIHRhcmdldCA9IGNvbnRhaW5lciwgaW5mbykge1xuICBpbmZvLngudGFyZ2V0T2Zmc2V0ID0gMDtcbiAgaW5mby55LnRhcmdldE9mZnNldCA9IDA7XG4gIGlmICh0YXJnZXQgIT09IGNvbnRhaW5lcikge1xuICAgIGxldCBub2RlID0gdGFyZ2V0O1xuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT0gY29udGFpbmVyKSB7XG4gICAgICBpbmZvLngudGFyZ2V0T2Zmc2V0ICs9IG5vZGUub2Zmc2V0TGVmdDtcbiAgICAgIGluZm8ueS50YXJnZXRPZmZzZXQgKz0gbm9kZS5vZmZzZXRUb3A7XG4gICAgICBub2RlID0gbm9kZS5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICB9XG4gIGluZm8ueC50YXJnZXRMZW5ndGggPSB0YXJnZXQgPT09IGNvbnRhaW5lciA/IHRhcmdldC5zY3JvbGxXaWR0aCA6IHRhcmdldC5jbGllbnRXaWR0aDtcbiAgaW5mby55LnRhcmdldExlbmd0aCA9IHRhcmdldCA9PT0gY29udGFpbmVyID8gdGFyZ2V0LnNjcm9sbEhlaWdodCA6IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gIGluZm8ueC5jb250YWluZXJMZW5ndGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gIGluZm8ueS5jb250YWluZXJMZW5ndGggPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xufVxuZnVuY3Rpb24gY3JlYXRlT25TY3JvbGxIYW5kbGVyKGVsZW1lbnQsIG9uU2Nyb2xsLCBpbmZvLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCBcInlcIjtcbiAgcmV0dXJuIHtcbiAgICBtZWFzdXJlOiAoKSA9PiBtZWFzdXJlKGVsZW1lbnQsIG9wdGlvbnMudGFyZ2V0LCBpbmZvKSxcbiAgICB1cGRhdGU6ICh0aW1lKSA9PiB7XG4gICAgICB1cGRhdGVTY3JvbGxJbmZvKGVsZW1lbnQsIGluZm8sIHRpbWUpO1xuICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0IHx8IG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgIHJlc29sdmVPZmZzZXRzKGVsZW1lbnQsIGluZm8sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbm90aWZ5OiBpc0Z1bmN0aW9uKG9uU2Nyb2xsKSA/ICgpID0+IG9uU2Nyb2xsKGluZm8pIDogc2NydWJBbmltYXRpb24ob25TY3JvbGwsIGluZm9bYXhpc10pXG4gIH07XG59XG5mdW5jdGlvbiBzY3J1YkFuaW1hdGlvbihjb250cm9scywgYXhpc0luZm8pIHtcbiAgY29udHJvbHMucGF1c2UoKTtcbiAgY29udHJvbHMuZm9yRWFjaE5hdGl2ZSgoYW5pbWF0aW9uLCB7IGVhc2luZyB9KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoYW5pbWF0aW9uLnVwZGF0ZUR1cmF0aW9uKSB7XG4gICAgICBpZiAoIWVhc2luZylcbiAgICAgICAgYW5pbWF0aW9uLmVhc2luZyA9IG5vb3BSZXR1cm47XG4gICAgICBhbmltYXRpb24udXBkYXRlRHVyYXRpb24oMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRpbWluZ09wdGlvbnMgPSB7IGR1cmF0aW9uOiAxZTMgfTtcbiAgICAgIGlmICghZWFzaW5nKVxuICAgICAgICB0aW1pbmdPcHRpb25zLmVhc2luZyA9IFwibGluZWFyXCI7XG4gICAgICAoX2IgPSAoX2EgPSBhbmltYXRpb24uZWZmZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlVGltaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGltaW5nT3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb250cm9scy5jdXJyZW50VGltZSA9IGF4aXNJbmZvLnByb2dyZXNzO1xuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvaW5kZXguZXMuanNcbnZhciBzY3JvbGxMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciByZXNpemVMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBvblNjcm9sbEhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgZ2V0RXZlbnRUYXJnZXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gd2luZG93IDogZWxlbWVudDtcbmZ1bmN0aW9uIHNjcm9sbChvblNjcm9sbCwgX2EgPSB7fSkge1xuICB2YXIgeyBjb250YWluZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfSA9IF9hLCBvcHRpb25zID0gX19yZXN0MihfYSwgW1wiY29udGFpbmVyXCJdKTtcbiAgbGV0IGNvbnRhaW5lckhhbmRsZXJzID0gb25TY3JvbGxIYW5kbGVycy5nZXQoY29udGFpbmVyKTtcbiAgaWYgKCFjb250YWluZXJIYW5kbGVycykge1xuICAgIGNvbnRhaW5lckhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBvblNjcm9sbEhhbmRsZXJzLnNldChjb250YWluZXIsIGNvbnRhaW5lckhhbmRsZXJzKTtcbiAgfVxuICBjb25zdCBpbmZvID0gY3JlYXRlU2Nyb2xsSW5mbygpO1xuICBjb25zdCBjb250YWluZXJIYW5kbGVyID0gY3JlYXRlT25TY3JvbGxIYW5kbGVyKGNvbnRhaW5lciwgb25TY3JvbGwsIGluZm8sIG9wdGlvbnMpO1xuICBjb250YWluZXJIYW5kbGVycy5hZGQoY29udGFpbmVySGFuZGxlcik7XG4gIGlmICghc2Nyb2xsTGlzdGVuZXJzLmhhcyhjb250YWluZXIpKSB7XG4gICAgY29uc3QgbGlzdGVuZXIyID0gKCkgPT4ge1xuICAgICAgY29uc3QgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGNvbnRhaW5lckhhbmRsZXJzKVxuICAgICAgICBoYW5kbGVyLm1lYXN1cmUoKTtcbiAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBjb250YWluZXJIYW5kbGVycylcbiAgICAgICAgaGFuZGxlci51cGRhdGUodGltZSk7XG4gICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgY29udGFpbmVySGFuZGxlcnMpXG4gICAgICAgIGhhbmRsZXIubm90aWZ5KCk7XG4gICAgfTtcbiAgICBzY3JvbGxMaXN0ZW5lcnMuc2V0KGNvbnRhaW5lciwgbGlzdGVuZXIyKTtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChjb250YWluZXIpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGxpc3RlbmVyMiwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIGlmIChjb250YWluZXIgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgcmVzaXplTGlzdGVuZXJzLnNldChjb250YWluZXIsIHJlc2l6ZShjb250YWluZXIsIGxpc3RlbmVyMikpO1xuICAgIH1cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBsaXN0ZW5lcjIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgfVxuICBjb25zdCBsaXN0ZW5lciA9IHNjcm9sbExpc3RlbmVycy5nZXQoY29udGFpbmVyKTtcbiAgY29uc3Qgb25Mb2FkUHJvY2Vzc3MgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobGlzdGVuZXIpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKHR5cGVvZiBvblNjcm9sbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgb25TY3JvbGwuc3RvcCgpO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKG9uTG9hZFByb2Nlc3NzKTtcbiAgICBjb25zdCBjb250YWluZXJIYW5kbGVyczIgPSBvblNjcm9sbEhhbmRsZXJzLmdldChjb250YWluZXIpO1xuICAgIGlmICghY29udGFpbmVySGFuZGxlcnMyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnRhaW5lckhhbmRsZXJzMi5kZWxldGUoY29udGFpbmVySGFuZGxlcik7XG4gICAgaWYgKGNvbnRhaW5lckhhbmRsZXJzMi5zaXplKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxpc3RlbmVyMiA9IHNjcm9sbExpc3RlbmVycy5nZXQoY29udGFpbmVyKTtcbiAgICBzY3JvbGxMaXN0ZW5lcnMuZGVsZXRlKGNvbnRhaW5lcik7XG4gICAgaWYgKGxpc3RlbmVyMikge1xuICAgICAgZ2V0RXZlbnRUYXJnZXQoY29udGFpbmVyKS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGxpc3RlbmVyMik7XG4gICAgICAoX2EyID0gcmVzaXplTGlzdGVuZXJzLmdldChjb250YWluZXIpKSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMigpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbGlzdGVuZXIyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLXNjcm9sbC5tanNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIGNyZWF0ZVNjcm9sbE1vdGlvblZhbHVlcyA9ICgpID0+ICh7XG4gIHNjcm9sbFg6IG1vdGlvblZhbHVlKDApLFxuICBzY3JvbGxZOiBtb3Rpb25WYWx1ZSgwKSxcbiAgc2Nyb2xsWFByb2dyZXNzOiBtb3Rpb25WYWx1ZSgwKSxcbiAgc2Nyb2xsWVByb2dyZXNzOiBtb3Rpb25WYWx1ZSgwKVxufSk7XG5mdW5jdGlvbiB1c2VTY3JvbGwoX2EgPSB7fSkge1xuICB2YXIgX2IgPSBfYSwgeyBjb250YWluZXIsIHRhcmdldCwgbGF5b3V0RWZmZWN0ID0gdHJ1ZSB9ID0gX2IsIG9wdGlvbnMgPSBfX29ialJlc3QoX2IsIFtcImNvbnRhaW5lclwiLCBcInRhcmdldFwiLCBcImxheW91dEVmZmVjdFwiXSk7XG4gIGNvbnN0IHZhbHVlcyA9IHVzZUNvbnN0YW50KGNyZWF0ZVNjcm9sbE1vdGlvblZhbHVlcyk7XG4gIGNvbnN0IHVzZUxpZmVjeWNsZUVmZmVjdCA9IGxheW91dEVmZmVjdCA/IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3QxMDtcbiAgdXNlTGlmZWN5Y2xlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gc2Nyb2xsKCh7IHgsIHkgfSkgPT4ge1xuICAgICAgdmFsdWVzLnNjcm9sbFguc2V0KHguY3VycmVudCk7XG4gICAgICB2YWx1ZXMuc2Nyb2xsWFByb2dyZXNzLnNldCh4LnByb2dyZXNzKTtcbiAgICAgIHZhbHVlcy5zY3JvbGxZLnNldCh5LmN1cnJlbnQpO1xuICAgICAgdmFsdWVzLnNjcm9sbFlQcm9ncmVzcy5zZXQoeS5wcm9ncmVzcyk7XG4gICAgfSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIGNvbnRhaW5lcjogKGNvbnRhaW5lciA9PT0gbnVsbCB8fCBjb250YWluZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRhaW5lci5jdXJyZW50KSB8fCB2b2lkIDAsXG4gICAgICB0YXJnZXQ6ICh0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQuY3VycmVudCkgfHwgdm9pZCAwXG4gICAgfSkpO1xuICB9LCBbXSk7XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbi8vIHNyYy9NZW51LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBNZW51ID0gKCkgPT4ge1xuICBjb25zdCB7IHNjcm9sbFlQcm9ncmVzcyB9ID0gdXNlU2Nyb2xsKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcImhpZGRlbiBzbTpibG9ja1wiLFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4Mihtb3Rpb24uZGl2LCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJwcm9ncmVzcy1iYXJcIixcbiAgICAgICAgc3R5bGU6IHsgc2NhbGVYOiBzY3JvbGxZUHJvZ3Jlc3MgfVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gYmctZ3JhZGllbnQtdG8tciBmcm9tLWJsdWUtNDAwIHRvLWJsdWUtNTAwXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCIvXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlB5bGFyXFx1MjEyMiBBSVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyb3VuZGVkLXhsIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYVwiLCB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiL2Jsb2dcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiRGFpbHkgV29ya1wiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyb3VuZGVkLXhsIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYVwiLCB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiL3doYXQtaXMtcHlsYXJcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQWJvdXRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicm91bmRlZC14bCBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGVcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihcImFcIiwge1xuICAgICAgICAgICAgICBocmVmOiBcIi9weWxhci1saWNlbnNlXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlRoZSBMaWNlbnNlXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCJodHRwczovL3BlbmNpbC5kb21haW5zXCIsXG4gICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgcmVsOiBcIm5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUGVuY2lsIERvbWFpbnNcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiaGlkZGVuIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZSBtZDpibG9ja1wiLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaGlkZGVuIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZSBtZDpibG9ja1wiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihcImFcIiwge1xuICAgICAgICAgICAgICAgICAgaHJlZjogXCJodHRwOi8vdHdpdHRlci5jb20vc3VwZXJkYXRhc1wiLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlR3aXR0ZXJcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcImFcIiwge1xuICAgICAgICAgICAgICAgIGhyZWY6IFwiaHR0cDovL2dpdGh1Yi5jb20vbWlndWVsZ2FyZ2FsbG8vbmV4dDEzLWdhbGxlcnktaW1hZ2UtdHVyYm9cIixcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaGlkZGVuIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZSBtZDpibG9ja1wiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihcInBpY3R1cmVcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiaW1nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjOiBcImh0dHBzOi8vaW1nLnNoaWVsZHMuaW8vZ2l0aHViL3N0YXJzL21pZ3VlbGdhcmdhbGxvL05leHQxMy1nYWxsZXJ5LWltYWdlLXR1cmJvP3N0eWxlPXNvY2lhbFwiLFxuICAgICAgICAgICAgICAgICAgICBhbHQ6IFwiTGFuZHNjYXBlIHBpY3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyMFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFZlcnNpb24sIHt9KVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICAgIH0pXG4gICAgXVxuICB9KTtcbn07XG5cbi8vIHNyYy9NZW51UHlsYXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MywganN4cyBhcyBqc3hzMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE1lbnVQeWxhciA9ICgpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwiZmxleCBoaWRkZW4gZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBiZy1ncmFkaWVudC10by1yIGZyb20tYmx1ZS00MDAgdG8tYmx1ZS01MDAgc206YmxvY2tcIixcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMyKFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJmbGV4IGZsZXgtcm93XCIsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MyhcImJ1dHRvblwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzKFwiYVwiLCB7XG4gICAgICAgICAgICBocmVmOiBcIi9ibG9nXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJPdXIgRGFpbHkgV29ya1wiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicm91bmRlZC14bCBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGVcIixcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMoXCJhXCIsIHtcbiAgICAgICAgICAgIGhyZWY6IFwiL3doYXQtaXMtcHlsYXJcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIldoYXQgaXMgUHlsYXIgQUlcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MyhcImJ1dHRvblwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzKFwiYVwiLCB7XG4gICAgICAgICAgICBocmVmOiBcIi9weWxhci1saWNlbnNlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJMaWNlbnNlXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgXVxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL1RpdGxlUHlsYXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NCwganN4cyBhcyBqc3hzMyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFRpdGxlUHlsYXIgPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4czMoXCJkaXZcIiwge1xuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4czMoXCJoMVwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJweS04IHRleHQtY2VudGVyIHRleHQtNXhsIGZvbnQtYm9sZFwiLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMC41LCBkdXJhdGlvbjogMS41IH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJQXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NChtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDAuNiwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwieVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDQobW90aW9uLnNwYW4sIHtcbiAgICAgICAgICAgIGluaXRpYWw6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgYW5pbWF0ZTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB7IGRlbGF5OiAwLjcsIGR1cmF0aW9uOiAxLjUgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcImxcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMC44LCBkdXJhdGlvbjogMS41IH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJhXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NChtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDAuOSwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiclxcdTIxMjJcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMSwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiXFx4QTBcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMS4xLCBkdXJhdGlvbjogMS41IH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NChtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDEuMiwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiSVwiXG4gICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4czMobW90aW9uLmgyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJweS04IHRleHQtY2VudGVyIHRleHQtNHhsIGZvbnQtYm9sZFwiLFxuICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgYW5pbWF0ZTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDEuNCwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiUHlcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIFwidGhvblwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiTFwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJlYXJuaW5nXCIsXG4gICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDQoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJ0ZXh0LWJsdWUtNTAwXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBcInJ0aWZpY2lhbFwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiUlwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJlc2VhcmNoXFx1MjEyMlwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibGFja1wiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiIFwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDQoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJ0ZXh0LWJsdWUtNTAwXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBcInJ0aWZpY2lhbFwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiSVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJudGVsbGlnZW5jZVwiLFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgIF1cbiAgICAgIH0pXG4gICAgXVxuICB9KTtcbn07XG5cbi8vIHNyYy9MaXN0UHlsYXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NSwganN4cyBhcyBqc3hzNCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIExpc3RQeWxhciA9ICgpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g1KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwibXQtOCBmbGV4IGZsZXgtcm93IGp1c3RpZnktY2VudGVyXCIsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hzNChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwiZmxleCB3LTMvNCBmbGV4LWNvbFwiLFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDUoXCJoMlwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInRleHQtMnhsIGZvbnQtYm9sZFwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBcIldlbGNvbWUgdG8gdGhlIFB5bGFyIEFJIEJsb2dcIlxuICAgICAgICB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHM0KFwicFwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm10LTQgdGV4dC1sZ1wiLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBcIlB5bGFyIEFJIGlzOlwiLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHM0KFwidWxcIiwge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibGlzdC1pbnNpZGUgbGlzdC1kaXNjXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDUoXCJsaVwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJHZW5lcmF0aXZlIGFydCByZXN1bHRzXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NShcImFcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiV2hhdCBpcyBnZW5lcmF0aXZlIGFydD8gR2VuZXJhdGl2ZSBhcnQgaXMgYSBmb3JtIG9mIGFydCB0aGF0IHVzZXMgYSBjb21wdXRlciB0byBjcmVhdGUgYXJ0LiBUaGUgY29tcHV0ZXIgaXMgcHJvZ3JhbW1lZCB0byBjcmVhdGUgYXJ0IGJhc2VkIG9uIGEgc2V0IG9mIHJ1bGVzLlwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDUoXCJwXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlxceEEwXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NShcImxpXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlByb210IEVuZ2luZWVyaW5nIGRlc2lnblwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDUoXCJhXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlByb210IEVuZ2luZWVyaW5nIGlzIGEgZm9ybSBvZiBlbmdpbmVlcmluZyB0aGF0IHVzZXMgYSBjb21wdXRlciB0byBjcmVhdGUgZW5naW5lZXJpbmcuIFRoZSBjb21wdXRlciBpcyBwcm9ncmFtbWVkIHRvIGNyZWF0ZSBlbmdpbmVlcmluZyBiYXNlZCBvbiBhIHNldCBvZiBydWxlcy5cIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g1KFwicFwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJcXHhBMFwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDUoXCJsaVwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJTdGFibGVEaWZmdXNpb24gMi4wIG1vZGlmaWVkXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NShcImFcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiU3RhYmxlRGlmZnVzaW9uIDIuMCBpcyBhIGNvbXB1dGVyIHByb2dyYW0gdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSBhcnQgYmFzZWQgb24gYSBzZXQgb2YgcnVsZXMuXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NShcInBcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiXFx4QTBcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgXVxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL0Zvb3Rlci50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g2LCBqc3hzIGFzIGpzeHM1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRm9vdGVyID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHM1KFwiZm9vdGVyXCIsIHtcbiAgICBjbGFzc05hbWU6IFwiYmctd2hpdGUgcHktOCB0ZXh0LWNlbnRlclwiLFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4NihcImRpdlwiLCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4czUoXCJhXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgXCJNYWRlIHdpdGggXFx1Mjc2NFxcdUZFMEYgYnlcIixcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDYoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCJodHRwczovL3R3aXR0ZXIuY29tL21pZ3VlbGdhcmdhbGxvXCIsXG4gICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImhvdmVyOnRleHQtYmx1ZSB0ZXh0LWluZGlnby02MDBcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiTWlndWVsIEdhcmdhbGxvXCJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCIuXCJcbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g2KFwiZGl2XCIsIHtcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hzNShcImFcIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBcIjIwMjIgXFx4QTlcIixcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDYoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCJodHRwczovL2h1Z2dpbmdmYWNlLmNvL3NwYWNlcy9zdXBlcmRhdGFzL0xJQ0VOU0VcIixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgICByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaG92ZXI6dGV4dC1ibHVlIHRleHQtaW5kaWdvLTYwMFwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJQeWxhclxcdTIxMjIgQUkgY3JlYXRpdmUgTUwgbGljZW5zZVwiXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwiLlwiXG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4NihcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJoaWRkZW4gc206YmxvY2tcIixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g2KFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiZmxleCB3LWZ1bGwgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCIsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g2KFwiYVwiLCB7XG4gICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vc3BhY2VzL3N1cGVyZGF0YXMvTElDRU5TRVwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWRkZW4gcC0yIG1kOmJsb2NrXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDYoXCJwaWN0dXJlXCIsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g2KFwiaW1nXCIsIHtcbiAgICAgICAgICAgICAgICBzcmM6IFwiaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9mcm9udC9hc3NldHMvaHVnZ2luZ2ZhY2VfbG9nby5zdmdcIixcbiAgICAgICAgICAgICAgICBhbHQ6IFwiTGFuZHNjYXBlIHBpY3R1cmVcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogNDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4NihcInBcIiwge1xuICAgICAgICBjaGlsZHJlbjogXCJUaGFua3MgZm9yIHlvdXIgdGltZS5cIlxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xufTtcblxuLy8gc3JjL1Njcm9sbGFibGUudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFNjcm9sbGFibGUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgc2Nyb2xsWVByb2dyZXNzIH0gPSB1c2VTY3JvbGwoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g3KG1vdGlvbi5kaXYsIHtcbiAgICBjbGFzc05hbWU6IFwicHJvZ3Jlc3MtYmFyXCIsXG4gICAgc3R5bGU6IHsgc2NhbGVYOiBzY3JvbGxZUHJvZ3Jlc3MgfVxuICB9KTtcbn07XG5cbi8vIHNyYy9CbG9nUHlsYXIvYmxvZy50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRUxFTUVOVFMyID0gNTtcbnZhciBibG9nID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDgoXCJkaXZcIiwge1xuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4OChcInN2Z1wiLCB7XG4gICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgd2lkdGg6IFwiOTVcIixcbiAgICAgIGhlaWdodDogXCI5NVwiLFxuICAgICAgc3Ryb2tlOiBcIiNGRkZcIixcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IFwiMFwiLFxuICAgICAgdmlld0JveDogXCIwIDAgOTUgOTVcIixcbiAgICAgIGNsYXNzTmFtZTogXCJtLTIgcm91bmRlZC14bCBweS0yIHNoYWRvdy1tZCBob3ZlcjpzaGFkb3cteGxcIixcbiAgICAgIHN0eWxlOiBrKEVMRU1FTlRTMiksXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDgoXCJwYXRoXCIsIHtcbiAgICAgICAgZDogXCJNMzIuODE2LDEyLjk1LDMwLjM0OSw4LjU2OGg0Ljc4YS40MzkuNDM5LDAsMCwxLC4zNDYuMmwuOTMxLDEuNTM0Yy41NTguOTIsMS4yMjUsMi4wMiwxLjYwNywyLjY0OFpNMjMuOTc1LDM5LjQ5NWEuMzM5LjMzOSwwLDAsMS0uMzE1LjIwN0gxOC43NzJsNy41OTUtMTMuNjM1YS43MzEuNzMxLDAsMCwwLS42MzYtMS4wODdoMEwxMi43ODcsMjVsLTIuNTc0LTQuNDU2SDI5LjA3NmMuMDExLDAsLjAyLDAsLjAzMSwwYS42NzcuNjc3LDAsMCwwLC4yMTctLjA0NWwuMDQ3LS4wMmEuNzIyLjcyMiwwLDAsMCwuMzQ2LS4zMTNsMy4xMDgtNS43NDVoNS4xM1ptLTYuNDY4LS41MTgtLjYxMy0xLjAwOWMtLjc4NS0xLjMtMS43OTEtMi45NTUtMS45LTMuMTM3YS4zODUuMzg1LDAsMCwxLC4wMjQtLjM1NWw0LjQ1Ny04LjAyNyw1LjAxOS0uMDA2Wk04Ljk0OCwzMC40NDQsNi40NTMsMjYuMDExLDguOTY4LDIxLjNsMi41MjIsNC4zNjdDMTAuNzA2LDI3LjE0LDkuNDgzLDI5LjQ0Miw4Ljk0OCwzMC40NDRabS0zLjM0OC42OUgyLjg4MWEuNDQzLjQ0MywwLDAsMS0uMzQzLS4yTDEuNzI2LDI5LjZDMS4xNDcsMjguNjQxLjQwOSwyNy40MjUsMCwyNi43NTJINS4ybDIuNDY2LDQuMzgzWk0xNC4wMzcuMjA4QS4zMzguMzM4LDAsMCwxLDE0LjM1MSwwaDQuOTFMMTEuNjQ2LDEzLjYzNmMtLjAwNi4wMTEtLjAxLjAyMy0uMDE2LjAzNXMtLjAyMS4wNDYtLjAzLjA3LS4wMTUuMDQ2LS4wMjEuMDY5LS4wMTEuMDQ0LS4wMTQuMDY2YS42NDguNjQ4LDAsMCwwLS4wMDguMDgxYzAsLjAxMiwwLC4wMjMsMCwuMDM2czAsLjAxOCwwLC4wMjdhLjU5MS41OTEsMCwwLDAsLjAwOC4wNzkuNTM4LjUzOCwwLDAsMCwuMDEyLjA2NmMuMDA2LjAyMy4wMTMuMDQ1LjAyMS4wNjhzLjAxNi4wNDUuMDI1LjA2Ni4wMjEuMDQxLjAzMy4wNjIuMDIzLjA0LjAzNy4wNTlhLjY0NC42NDQsMCwwLDAsLjA0NS4wNTVjLjAxNi4wMTcuMDMxLjAzNS4wNDguMDUxcy4wMzUuMDI5LjA1My4wNDNhLjYzNC42MzQsMCwwLDAsLjA2My4wNDVsLjAyMy4wMTZjLjAwOCwwLC4wMTguMDA2LjAyNy4wMTFhLjcyOS43MjksMCwwLDAsLjExOS4wNDhjLjAxNSwwLC4wMjkuMDEuMDQ0LjAxM2EuNy43LDAsMCwwLC4xNjQuMDIxaC4zM2wxMi42MTktLjAxN2MuMzM0LjU4Ljk1NywxLjY3MywxLjQ4OSwyLjZxLjYxMiwxLjA3MiwxLjAxLDEuNzY4SDguOTQ5Yy0uMDA4LDAtLjAxNiwwLS4wMjQsMGEuNzI1LjcyNSwwLDAsMC0uNjMxLjM4Mkw1LjE4NSwyNS4yOUguMDU5Wm02LjQ3OS41MzQuNDU2Ljc1Yy44LDEuMzIxLDEuOTMyLDMuMTg1LDIuMDUyLDMuMzc5QS4zODMuMzgzLDAsMCwxLDIzLDUuMjI3bC00LjQ1Nyw4LjAyNy01LjAxNy4wMDZabTguNTQ2LDguNTExLDIuNSw0LjQzNS0yLjU0NSw0LjdjLS4zLS41MjktLjY4LTEuMTg5LTEuMDM0LTEuODA4LS43LTEuMjI0LTEuMjA4LTIuMTE1LTEuNDk1LTIuNjEzQzI3LjAyOCwxMi45NzcsMjguNDYyLDEwLjM0OSwyOS4wNjIsOS4yNTNaXCIsXG4gICAgICAgIGlkOiBcIkZpbGwtMVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiZmlsbC15ZWxsb3ctNTAwXCJcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyBzcmMvQmxvZ1B5bGFyL3Bvc3QxMjAzMjAyMi50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g5IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRUxFTUVOVFMzID0gNTtcbnZhciBwb3N0MTIwMzIwMjIgPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OShcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g5KFwic3ZnXCIsIHtcbiAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICB3aWR0aDogXCI5NVwiLFxuICAgICAgaGVpZ2h0OiBcIjk1XCIsXG4gICAgICBzdHJva2U6IFwiI0ZGRlwiLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCIwXCIsXG4gICAgICB2aWV3Qm94OiBcIjAgMCA5NSA5NVwiLFxuICAgICAgY2xhc3NOYW1lOiBcIm0tMiByb3VuZGVkLXhsIHB5LTIgc2hhZG93LW1kIGhvdmVyOnNoYWRvdy14bFwiLFxuICAgICAgc3R5bGU6IGsoRUxFTUVOVFMzKSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4OShcInBhdGhcIiwge1xuICAgICAgICBkOiBcIk0zMi44MTYsMTIuOTUsMzAuMzQ5LDguNTY4aDQuNzhhLjQzOS40MzksMCwwLDEsLjM0Ni4ybC45MzEsMS41MzRjLjU1OC45MiwxLjIyNSwyLjAyLDEuNjA3LDIuNjQ4Wk0yMy45NzUsMzkuNDk1YS4zMzkuMzM5LDAsMCwxLS4zMTUuMjA3SDE4Ljc3Mmw3LjU5NS0xMy42MzVhLjczMS43MzEsMCwwLDAtLjYzNi0xLjA4N2gwTDEyLjc4NywyNWwtMi41NzQtNC40NTZIMjkuMDc2Yy4wMTEsMCwuMDIsMCwuMDMxLDBhLjY3Ny42NzcsMCwwLDAsLjIxNy0uMDQ1bC4wNDctLjAyYS43MjIuNzIyLDAsMCwwLC4zNDYtLjMxM2wzLjEwOC01Ljc0NWg1LjEzWm0tNi40NjgtLjUxOC0uNjEzLTEuMDA5Yy0uNzg1LTEuMy0xLjc5MS0yLjk1NS0xLjktMy4xMzdhLjM4NS4zODUsMCwwLDEsLjAyNC0uMzU1bDQuNDU3LTguMDI3LDUuMDE5LS4wMDZaTTguOTQ4LDMwLjQ0NCw2LjQ1MywyNi4wMTEsOC45NjgsMjEuM2wyLjUyMiw0LjM2N0MxMC43MDYsMjcuMTQsOS40ODMsMjkuNDQyLDguOTQ4LDMwLjQ0NFptLTMuMzQ4LjY5SDIuODgxYS40NDMuNDQzLDAsMCwxLS4zNDMtLjJMMS43MjYsMjkuNkMxLjE0NywyOC42NDEuNDA5LDI3LjQyNSwwLDI2Ljc1Mkg1LjJsMi40NjYsNC4zODNaTTE0LjAzNy4yMDhBLjMzOC4zMzgsMCwwLDEsMTQuMzUxLDBoNC45MUwxMS42NDYsMTMuNjM2Yy0uMDA2LjAxMS0uMDEuMDIzLS4wMTYuMDM1cy0uMDIxLjA0Ni0uMDMuMDctLjAxNS4wNDYtLjAyMS4wNjktLjAxMS4wNDQtLjAxNC4wNjZhLjY0OC42NDgsMCwwLDAtLjAwOC4wODFjMCwuMDEyLDAsLjAyMywwLC4wMzZzMCwuMDE4LDAsLjAyN2EuNTkxLjU5MSwwLDAsMCwuMDA4LjA3OS41MzguNTM4LDAsMCwwLC4wMTIuMDY2Yy4wMDYuMDIzLjAxMy4wNDUuMDIxLjA2OHMuMDE2LjA0NS4wMjUuMDY2LjAyMS4wNDEuMDMzLjA2Mi4wMjMuMDQuMDM3LjA1OWEuNjQ0LjY0NCwwLDAsMCwuMDQ1LjA1NWMuMDE2LjAxNy4wMzEuMDM1LjA0OC4wNTFzLjAzNS4wMjkuMDUzLjA0M2EuNjM0LjYzNCwwLDAsMCwuMDYzLjA0NWwuMDIzLjAxNmMuMDA4LDAsLjAxOC4wMDYuMDI3LjAxMWEuNzI5LjcyOSwwLDAsMCwuMTE5LjA0OGMuMDE1LDAsLjAyOS4wMS4wNDQuMDEzYS43LjcsMCwwLDAsLjE2NC4wMjFoLjMzbDEyLjYxOS0uMDE3Yy4zMzQuNTguOTU3LDEuNjczLDEuNDg5LDIuNnEuNjEyLDEuMDcyLDEuMDEsMS43NjhIOC45NDljLS4wMDgsMC0uMDE2LDAtLjAyNCwwYS43MjUuNzI1LDAsMCwwLS42MzEuMzgyTDUuMTg1LDI1LjI5SC4wNTlabTYuNDc5LjUzNC40NTYuNzVjLjgsMS4zMjEsMS45MzIsMy4xODUsMi4wNTIsMy4zNzlBLjM4My4zODMsMCwwLDEsMjMsNS4yMjdsLTQuNDU3LDguMDI3LTUuMDE3LjAwNlptOC41NDYsOC41MTEsMi41LDQuNDM1LTIuNTQ1LDQuN2MtLjMtLjUyOS0uNjgtMS4xODktMS4wMzQtMS44MDgtLjctMS4yMjQtMS4yMDgtMi4xMTUtMS40OTUtMi42MTNDMjcuMDI4LDEyLjk3NywyOC40NjIsMTAuMzQ5LDI5LjA2Miw5LjI1M1pcIixcbiAgICAgICAgaWQ6IFwiRmlsbC0xXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJmaWxsLXllbGxvdy01MDBcIlxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG5leHBvcnQge1xuICBGb290ZXIsXG4gIExpc3RQeWxhcixcbiAgTWVudSxcbiAgTWVudVB5bGFyLFxuICBTY3JvbGxhYmxlLFxuICBUaXRsZVB5bGFyLFxuICBWZXJzaW9uLFxuICBibG9nLFxuICBwb3N0MTIwMzIwMjJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../packages/ui/dist/index.mjs\n"));

/***/ })

});