/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "../../node_modules/next/dist/build/polyfills/process.js":
/*!***************************************************************!*\
  !*** ../../node_modules/next/dist/build/polyfills/process.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar ref, ref1;\nmodule.exports = ((ref = __webpack_require__.g.process) == null ? void 0 : ref.env) && typeof ((ref1 = __webpack_require__.g.process) == null ? void 0 : ref1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"../../node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EseUJBQXlCLHFCQUFNLHlEQUF5RCxxQkFBTSxzREFBc0QscUJBQU0sV0FBVyxtQkFBTyxDQUFDLHdGQUF3Qjs7QUFFck0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/YzU5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciByZWYsIHJlZjE7XG5tb2R1bGUuZXhwb3J0cyA9ICgocmVmID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiByZWYuZW52KSAmJiB0eXBlb2YgKChyZWYxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiByZWYxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlZC9wcm9jZXNzXCIpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Falex%2Fframeworks%2Fstaff%2FNext13-Gallery-Image-Turbo%2Fapps%2Fweb%2Fsrc%2Fpages%2Findex.tsx&page=%2F!":
/*!*************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Falex%2Fframeworks%2Fstaff%2FNext13-Gallery-Image-Turbo%2Fapps%2Fweb%2Fsrc%2Fpages%2Findex.tsx&page=%2F! ***!
  \*************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/index.tsx */ \"./src/pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1jbGllbnQtcGFnZXMtbG9hZGVyLmpzP2Fic29sdXRlUGFnZVBhdGg9JTJGaG9tZSUyRmFsZXglMkZmcmFtZXdvcmtzJTJGc3RhZmYlMkZOZXh0MTMtR2FsbGVyeS1JbWFnZS1UdXJibyUyRmFwcHMlMkZ3ZWIlMkZzcmMlMkZwYWdlcyUyRmluZGV4LnRzeCZwYWdlPSUyRiEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUM7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzYwZjUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9cIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3NyYy9wYWdlcy9pbmRleC50c3hcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Falex%2Fframeworks%2Fstaff%2FNext13-Gallery-Image-Turbo%2Fapps%2Fweb%2Fsrc%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"../../node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ui */ \"../../packages/ui/dist/index.mjs\");\n/* eslint-disable react/jsx-no-comment-textnodes */ \n\n\n\n\nfunction Home() {\n    console.log(\"âœ… Pylar AI\");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-w-screen flex min-h-screen flex-col bg-white\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Pylar AI by Pencil\"\n                    }, void 0, false, {\n                        fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                        lineNumber: 12,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"./favicon.ico\"\n                    }, void 0, false, {\n                        fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                        lineNumber: 13,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                lineNumber: 11,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ui__WEBPACK_IMPORTED_MODULE_2__.Menu, {}, void 0, false, {\n                fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                lineNumber: 15,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ui__WEBPACK_IMPORTED_MODULE_2__.TitlePylar, {}, void 0, false, {\n                    fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                    lineNumber: 17,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ui__WEBPACK_IMPORTED_MODULE_2__.Footer, {}, void 0, false, {\n                fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n                lineNumber: 19,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/alex/frameworks/staff/Next13-Gallery-Image-Turbo/apps/web/src/pages/index.tsx\",\n        lineNumber: 10,\n        columnNumber: 5\n    }, this);\n}\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXgudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLGlEQUFpRCxHQUNqRDtBQUE2QjtBQUNIO0FBQ007QUFDSjtBQUViLFNBQVNJLE9BQU87SUFDN0JDLFFBQVFDLEdBQUcsQ0FBQztJQUNaLHFCQUNFLDhEQUFDQztRQUFJQyxXQUFVOzswQkFDYiw4REFBQ1Isa0RBQUlBOztrQ0FDSCw4REFBQ1M7a0NBQU07Ozs7OztrQ0FDUCw4REFBQ0M7d0JBQUtDLEtBQUk7d0JBQU9DLE1BQUs7Ozs7Ozs7Ozs7OzswQkFFeEIsOERBQUNYLG9DQUFJQTs7Ozs7MEJBQ0wsOERBQUNZOzBCQUNDLDRFQUFDWCwwQ0FBVUE7Ozs7Ozs7Ozs7MEJBRWIsOERBQUNDLHNDQUFNQTs7Ozs7Ozs7Ozs7QUFHYixDQUFDO0tBZnVCQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvaW5kZXgudHN4PzE5YTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcmVhY3QvanN4LW5vLWNvbW1lbnQtdGV4dG5vZGVzICovXG5pbXBvcnQgSGVhZCBmcm9tIFwibmV4dC9oZWFkXCI7XG5pbXBvcnQgeyBNZW51IH0gZnJvbSBcInVpXCI7XG5pbXBvcnQgeyBUaXRsZVB5bGFyIH0gZnJvbSBcInVpXCI7XG5pbXBvcnQgeyBGb290ZXIgfSBmcm9tIFwidWlcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcbiAgY29uc29sZS5sb2coXCLinIUgUHlsYXIgQUlcIik7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtaW4tdy1zY3JlZW4gZmxleCBtaW4taC1zY3JlZW4gZmxleC1jb2wgYmctd2hpdGVcIj5cbiAgICAgIDxIZWFkPlxuICAgICAgICA8dGl0bGU+UHlsYXIgQUkgYnkgUGVuY2lsPC90aXRsZT5cbiAgICAgICAgPGxpbmsgcmVsPVwiaWNvblwiIGhyZWY9XCIuL2Zhdmljb24uaWNvXCIgLz5cbiAgICAgIDwvSGVhZD5cbiAgICAgIDxNZW51IC8+XG4gICAgICA8bWFpbj5cbiAgICAgICAgPFRpdGxlUHlsYXIgLz5cbiAgICAgIDwvbWFpbj5cbiAgICAgIDxGb290ZXIgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJIZWFkIiwiTWVudSIsIlRpdGxlUHlsYXIiLCJGb290ZXIiLCJIb21lIiwiY29uc29sZSIsImxvZyIsImRpdiIsImNsYXNzTmFtZSIsInRpdGxlIiwibGluayIsInJlbCIsImhyZWYiLCJtYWluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n"));

/***/ }),

/***/ "../../node_modules/next/dist/compiled/process/browser.js":
/*!****************************************************************!*\
  !*** ../../node_modules/next/dist/compiled/process/browser.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLFlBQVksT0FBTyxnQkFBZ0IsbUJBQW1CLE1BQU0sTUFBTSw0QkFBNEIsbURBQW1ELCtCQUErQixxREFBcUQsWUFBWSxJQUFJLG1DQUFtQyxhQUFhLEtBQUssb0JBQW9CLFNBQVMsbUJBQW1CLElBQUkscUNBQXFDLGVBQWUsS0FBSyx1QkFBdUIsU0FBUyx1QkFBdUIsSUFBSSx1QkFBdUIsbUJBQW1CLHVCQUF1QiwyQ0FBMkMsYUFBYSx1QkFBdUIsSUFBSSxjQUFjLFNBQVMsSUFBSSx3QkFBd0IsU0FBUywwQkFBMEIsNEJBQTRCLHFCQUFxQix1QkFBdUIsZ0RBQWdELGVBQWUsdUJBQXVCLElBQUksWUFBWSxTQUFTLElBQUksc0JBQXNCLFNBQVMsd0JBQXdCLFNBQVMsWUFBWSxNQUFNLFNBQVMsMkJBQTJCLFdBQVcsT0FBTyxRQUFRLGFBQWEsY0FBYyxLQUFLLEtBQUssYUFBYSxjQUFjLHNCQUFzQixNQUFNLE9BQU8sa0NBQWtDLE9BQU8sZUFBZSxTQUFTLElBQUksS0FBSyxhQUFhLE1BQU0sWUFBWSxLQUFLLFdBQVcsT0FBTyxRQUFRLG1CQUFtQix1QkFBdUIsb0NBQW9DLHVCQUF1QixZQUFZLG1CQUFtQixLQUFLLHFCQUFxQixzQkFBc0IscUJBQXFCLHlCQUF5QixtQkFBbUIsV0FBVyxhQUFhLDhCQUE4QixpQ0FBaUMsa0JBQWtCLGVBQWUsU0FBUyxVQUFVLGFBQWEsY0FBYyxpQkFBaUIsVUFBVSxtQkFBbUIsWUFBWSxXQUFXLHNCQUFzQiwwQkFBMEIsWUFBWSx1QkFBdUIsMkJBQTJCLHdCQUF3QixVQUFVLHNCQUFzQixxREFBcUQsaUJBQWlCLFdBQVcsb0JBQW9CLG1EQUFtRCxtQkFBbUIsWUFBWSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz8yYzJlIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "../../node_modules/next/head.js":
/*!***************************************!*\
  !*** ../../node_modules/next/head.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"../../node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvaGVhZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxSEFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2hlYWQuanM/NmIzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9zaGFyZWQvbGliL2hlYWQnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/next/head.js\n"));

/***/ }),

/***/ "../../node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs =  jsxWithValidationStatic ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxnREFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULGlDQUFpQztBQUNqQztBQUNBLFNBQVM7QUFDVCwyQkFBMkI7QUFDM0I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9FQUFvRTs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGtCQUFr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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1gsWUFBWTtBQUNaLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcz9jMjExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbnZhciBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFO1xuXG57XG4gIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuLy8gZXZlbiB3aXRoIHRoZSBwcm9kIHRyYW5zZm9ybS4gVGhpcyBtZWFucyB0aGF0IGpzeERFViBpcyBwdXJlbHlcbi8vIG9wdC1pbiBiZWhhdmlvciBmb3IgYmV0dGVyIG1lc3NhZ2VzIGJ1dCB0aGF0IHdlIHdvbid0IHN0b3Bcbi8vIGdpdmluZyB5b3Ugd2FybmluZ3MgaWYgeW91IHVzZSBwcm9kdWN0aW9uIGFwaXMuXG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBmYWxzZSk7XG4gIH1cbn1cblxudmFyIGpzeCA9ICBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cbi8vIGZvciBub3cgd2UgY2FuIHNoaXAgaWRlbnRpY2FsIHByb2QgZnVuY3Rpb25zXG5cbnZhciBqc3hzID0gIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIDtcblxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeCA9IGpzeDtcbmV4cG9ydHMuanN4cyA9IGpzeHM7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "../../node_modules/react/jsx-runtime.js":
/*!***********************************************!*\
  !*** ../../node_modules/react/jsx-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"../../node_modules/react/cjs/react-jsx-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxtSkFBa0U7QUFDcEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtcnVudGltZS5qcz84ZTcwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react/jsx-runtime.js\n"));

/***/ }),

/***/ "../../packages/ui/dist/index.mjs":
/*!****************************************!*\
  !*** ../../packages/ui/dist/index.mjs ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Footer\": function() { return /* binding */ Footer; },\n/* harmony export */   \"ListPylar\": function() { return /* binding */ ListPylar; },\n/* harmony export */   \"Menu\": function() { return /* binding */ Menu; },\n/* harmony export */   \"MenuPylar\": function() { return /* binding */ MenuPylar; },\n/* harmony export */   \"Scrollable\": function() { return /* binding */ Scrollable; },\n/* harmony export */   \"TitlePylar\": function() { return /* binding */ TitlePylar; },\n/* harmony export */   \"Version\": function() { return /* binding */ Version; },\n/* harmony export */   \"blog\": function() { return /* binding */ blog; },\n/* harmony export */   \"post12032022\": function() { return /* binding */ post12032022; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"../../node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../node_modules/next/dist/build/polyfills/process.js\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a2, b2) => {\n  for (var prop in b2 || (b2 = {}))\n    if (__hasOwnProp.call(b2, prop))\n      __defNormalProp(a2, prop, b2[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b2)) {\n      if (__propIsEnum.call(b2, prop))\n        __defNormalProp(a2, prop, b2[prop]);\n    }\n  return a2;\n};\nvar __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb2, mod) => function __require() {\n  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// ../../node_modules/@emotion/memoize/dist/memoize.esm.js\nfunction memoize(fn) {\n  var cache = {};\n  return function(arg) {\n    if (cache[arg] === void 0)\n      cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\nvar memoize_esm_default;\nvar init_memoize_esm = __esm({\n  \"../../node_modules/@emotion/memoize/dist/memoize.esm.js\"() {\n    memoize_esm_default = memoize;\n  }\n});\n\n// ../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\nvar is_prop_valid_esm_exports = {};\n__export(is_prop_valid_esm_exports, {\n  default: () => is_prop_valid_esm_default\n});\nvar reactPropsRegex, index, is_prop_valid_esm_default;\nvar init_is_prop_valid_esm = __esm({\n  \"../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\"() {\n    init_memoize_esm();\n    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;\n    index = memoize_esm_default(\n      function(prop) {\n        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;\n      }\n    );\n    is_prop_valid_esm_default = index;\n  }\n});\n\n// ../../node_modules/popmotion/node_modules/tslib/tslib.js\nvar require_tslib = __commonJS({\n  \"../../node_modules/popmotion/node_modules/tslib/tslib.js\"(exports, module) {\n    var __extends3;\n    var __assign3;\n    var __rest3;\n    var __decorate3;\n    var __param3;\n    var __metadata3;\n    var __awaiter3;\n    var __generator3;\n    var __exportStar3;\n    var __values3;\n    var __read3;\n    var __spread3;\n    var __spreadArrays3;\n    var __spreadArray3;\n    var __await3;\n    var __asyncGenerator3;\n    var __asyncDelegator3;\n    var __asyncValues3;\n    var __makeTemplateObject3;\n    var __importStar3;\n    var __importDefault3;\n    var __classPrivateFieldGet3;\n    var __classPrivateFieldSet3;\n    var __classPrivateFieldIn3;\n    var __createBinding3;\n    (function(factory) {\n      var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n      if (typeof define === \"function\" && define.amd) {\n        define(\"tslib\", [\"exports\"], function(exports2) {\n          factory(createExporter(root, createExporter(exports2)));\n        });\n      } else if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        factory(createExporter(root, createExporter(module.exports)));\n      } else {\n        factory(createExporter(root));\n      }\n      function createExporter(exports2, previous) {\n        if (exports2 !== root) {\n          if (typeof Object.create === \"function\") {\n            Object.defineProperty(exports2, \"__esModule\", { value: true });\n          } else {\n            exports2.__esModule = true;\n          }\n        }\n        return function(id2, v) {\n          return exports2[id2] = previous ? previous(id2, v) : v;\n        };\n      }\n    })(function(exporter) {\n      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p2 in b2)\n          if (Object.prototype.hasOwnProperty.call(b2, p2))\n            d2[p2] = b2[p2];\n      };\n      __extends3 = function(d2, b2) {\n        if (typeof b2 !== \"function\" && b2 !== null)\n          throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n        extendStatics(d2, b2);\n        function __() {\n          this.constructor = d2;\n        }\n        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n      };\n      __assign3 = Object.assign || function(t) {\n        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {\n          s = arguments[i2];\n          for (var p2 in s)\n            if (Object.prototype.hasOwnProperty.call(s, p2))\n              t[p2] = s[p2];\n        }\n        return t;\n      };\n      __rest3 = function(s, e) {\n        var t = {};\n        for (var p2 in s)\n          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)\n            t[p2] = s[p2];\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {\n            if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))\n              t[p2[i2]] = s[p2[i2]];\n          }\n        return t;\n      };\n      __decorate3 = function(decorators, target, key, desc) {\n        var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n          r = Reflect.decorate(decorators, target, key, desc);\n        else\n          for (var i2 = decorators.length - 1; i2 >= 0; i2--)\n            if (d2 = decorators[i2])\n              r = (c3 < 3 ? d2(r) : c3 > 3 ? d2(target, key, r) : d2(target, key)) || r;\n        return c3 > 3 && r && Object.defineProperty(target, key, r), r;\n      };\n      __param3 = function(paramIndex, decorator) {\n        return function(target, key) {\n          decorator(target, key, paramIndex);\n        };\n      };\n      __metadata3 = function(metadataKey, metadataValue) {\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n          return Reflect.metadata(metadataKey, metadataValue);\n      };\n      __awaiter3 = function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      __generator3 = function(thisArg, body) {\n        var _ = { label: 0, sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        }, trys: [], ops: [] }, f2, y, t, g2;\n        return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n          return this;\n        }), g2;\n        function verb(n) {\n          return function(v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f2)\n            throw new TypeError(\"Generator is already executing.\");\n          while (_)\n            try {\n              if (f2 = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                return t;\n              if (y = 0, t)\n                op = [op[0] & 2, t.value];\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n                case 4:\n                  _.label++;\n                  return { value: op[1], done: false };\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n                case 7:\n                  op = _.ops.pop();\n                  _.trys.pop();\n                  continue;\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n                    _.ops.push(op);\n                    break;\n                  }\n                  if (t[2])\n                    _.ops.pop();\n                  _.trys.pop();\n                  continue;\n              }\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f2 = t = 0;\n            }\n          if (op[0] & 5)\n            throw op[1];\n          return { value: op[0] ? op[1] : void 0, done: true };\n        }\n      };\n      __exportStar3 = function(m, o) {\n        for (var p2 in m)\n          if (p2 !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p2))\n            __createBinding3(o, m, p2);\n      };\n      __createBinding3 = Object.create ? function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        var desc = Object.getOwnPropertyDescriptor(m, k2);\n        if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n          desc = { enumerable: true, get: function() {\n            return m[k2];\n          } };\n        }\n        Object.defineProperty(o, k22, desc);\n      } : function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        o[k22] = m[k2];\n      };\n      __values3 = function(o) {\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i2 = 0;\n        if (m)\n          return m.call(o);\n        if (o && typeof o.length === \"number\")\n          return {\n            next: function() {\n              if (o && i2 >= o.length)\n                o = void 0;\n              return { value: o && o[i2++], done: !o };\n            }\n          };\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n      };\n      __read3 = function(o, n) {\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n        if (!m)\n          return o;\n        var i2 = m.call(o), r, ar = [], e;\n        try {\n          while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)\n            ar.push(r.value);\n        } catch (error) {\n          e = { error };\n        } finally {\n          try {\n            if (r && !r.done && (m = i2[\"return\"]))\n              m.call(i2);\n          } finally {\n            if (e)\n              throw e.error;\n          }\n        }\n        return ar;\n      };\n      __spread3 = function() {\n        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)\n          ar = ar.concat(__read3(arguments[i2]));\n        return ar;\n      };\n      __spreadArrays3 = function() {\n        for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n          s += arguments[i2].length;\n        for (var r = Array(s), k2 = 0, i2 = 0; i2 < il; i2++)\n          for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k2++)\n            r[k2] = a2[j];\n        return r;\n      };\n      __spreadArray3 = function(to, from, pack) {\n        if (pack || arguments.length === 2)\n          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {\n            if (ar || !(i2 in from)) {\n              if (!ar)\n                ar = Array.prototype.slice.call(from, 0, i2);\n              ar[i2] = from[i2];\n            }\n          }\n        return to.concat(ar || Array.prototype.slice.call(from));\n      };\n      __await3 = function(v) {\n        return this instanceof __await3 ? (this.v = v, this) : new __await3(v);\n      };\n      __asyncGenerator3 = function(thisArg, _arguments, generator) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];\n        return i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2;\n        function verb(n) {\n          if (g2[n])\n            i2[n] = function(v) {\n              return new Promise(function(a2, b2) {\n                q.push([n, v, a2, b2]) > 1 || resume(n, v);\n              });\n            };\n        }\n        function resume(n, v) {\n          try {\n            step(g2[n](v));\n          } catch (e) {\n            settle(q[0][3], e);\n          }\n        }\n        function step(r) {\n          r.value instanceof __await3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n        }\n        function fulfill(value) {\n          resume(\"next\", value);\n        }\n        function reject(value) {\n          resume(\"throw\", value);\n        }\n        function settle(f2, v) {\n          if (f2(v), q.shift(), q.length)\n            resume(q[0][0], q[0][1]);\n        }\n      };\n      __asyncDelegator3 = function(o) {\n        var i2, p2;\n        return i2 = {}, verb(\"next\"), verb(\"throw\", function(e) {\n          throw e;\n        }), verb(\"return\"), i2[Symbol.iterator] = function() {\n          return this;\n        }, i2;\n        function verb(n, f2) {\n          i2[n] = o[n] ? function(v) {\n            return (p2 = !p2) ? { value: __await3(o[n](v)), done: n === \"return\" } : f2 ? f2(v) : v;\n          } : f2;\n        }\n      };\n      __asyncValues3 = function(o) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var m = o[Symbol.asyncIterator], i2;\n        return m ? m.call(o) : (o = typeof __values3 === \"function\" ? __values3(o) : o[Symbol.iterator](), i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2);\n        function verb(n) {\n          i2[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n              v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n          };\n        }\n        function settle(resolve, reject, d2, v) {\n          Promise.resolve(v).then(function(v2) {\n            resolve({ value: v2, done: d2 });\n          }, reject);\n        }\n      };\n      __makeTemplateObject3 = function(cooked, raw) {\n        if (Object.defineProperty) {\n          Object.defineProperty(cooked, \"raw\", { value: raw });\n        } else {\n          cooked.raw = raw;\n        }\n        return cooked;\n      };\n      var __setModuleDefault = Object.create ? function(o, v) {\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n      } : function(o, v) {\n        o[\"default\"] = v;\n      };\n      __importStar3 = function(mod) {\n        if (mod && mod.__esModule)\n          return mod;\n        var result = {};\n        if (mod != null) {\n          for (var k2 in mod)\n            if (k2 !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k2))\n              __createBinding3(result, mod, k2);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n      };\n      __importDefault3 = function(mod) {\n        return mod && mod.__esModule ? mod : { \"default\": mod };\n      };\n      __classPrivateFieldGet3 = function(receiver, state, kind, f2) {\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a getter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n        return kind === \"m\" ? f2 : kind === \"a\" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);\n      };\n      __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {\n        if (kind === \"m\")\n          throw new TypeError(\"Private method is not writable\");\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a setter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n        return kind === \"a\" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;\n      };\n      __classPrivateFieldIn3 = function(state, receiver) {\n        if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\")\n          throw new TypeError(\"Cannot use 'in' operator on non-object\");\n        return typeof state === \"function\" ? receiver === state : state.has(receiver);\n      };\n      exporter(\"__extends\", __extends3);\n      exporter(\"__assign\", __assign3);\n      exporter(\"__rest\", __rest3);\n      exporter(\"__decorate\", __decorate3);\n      exporter(\"__param\", __param3);\n      exporter(\"__metadata\", __metadata3);\n      exporter(\"__awaiter\", __awaiter3);\n      exporter(\"__generator\", __generator3);\n      exporter(\"__exportStar\", __exportStar3);\n      exporter(\"__createBinding\", __createBinding3);\n      exporter(\"__values\", __values3);\n      exporter(\"__read\", __read3);\n      exporter(\"__spread\", __spread3);\n      exporter(\"__spreadArrays\", __spreadArrays3);\n      exporter(\"__spreadArray\", __spreadArray3);\n      exporter(\"__await\", __await3);\n      exporter(\"__asyncGenerator\", __asyncGenerator3);\n      exporter(\"__asyncDelegator\", __asyncDelegator3);\n      exporter(\"__asyncValues\", __asyncValues3);\n      exporter(\"__makeTemplateObject\", __makeTemplateObject3);\n      exporter(\"__importStar\", __importStar3);\n      exporter(\"__importDefault\", __importDefault3);\n      exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet3);\n      exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet3);\n      exporter(\"__classPrivateFieldIn\", __classPrivateFieldIn3);\n    });\n  }\n});\n\n// ../../node_modules/tslib/tslib.js\nvar require_tslib2 = __commonJS({\n  \"../../node_modules/tslib/tslib.js\"(exports, module) {\n    var __extends3;\n    var __assign3;\n    var __rest3;\n    var __decorate3;\n    var __param3;\n    var __metadata3;\n    var __awaiter3;\n    var __generator3;\n    var __exportStar3;\n    var __values3;\n    var __read3;\n    var __spread3;\n    var __spreadArrays3;\n    var __spreadArray3;\n    var __await3;\n    var __asyncGenerator3;\n    var __asyncDelegator3;\n    var __asyncValues3;\n    var __makeTemplateObject3;\n    var __importStar3;\n    var __importDefault3;\n    var __classPrivateFieldGet3;\n    var __classPrivateFieldSet3;\n    var __classPrivateFieldIn3;\n    var __createBinding3;\n    (function(factory) {\n      var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n      if (typeof define === \"function\" && define.amd) {\n        define(\"tslib\", [\"exports\"], function(exports2) {\n          factory(createExporter(root, createExporter(exports2)));\n        });\n      } else if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        factory(createExporter(root, createExporter(module.exports)));\n      } else {\n        factory(createExporter(root));\n      }\n      function createExporter(exports2, previous) {\n        if (exports2 !== root) {\n          if (typeof Object.create === \"function\") {\n            Object.defineProperty(exports2, \"__esModule\", { value: true });\n          } else {\n            exports2.__esModule = true;\n          }\n        }\n        return function(id2, v) {\n          return exports2[id2] = previous ? previous(id2, v) : v;\n        };\n      }\n    })(function(exporter) {\n      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p2 in b2)\n          if (Object.prototype.hasOwnProperty.call(b2, p2))\n            d2[p2] = b2[p2];\n      };\n      __extends3 = function(d2, b2) {\n        if (typeof b2 !== \"function\" && b2 !== null)\n          throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n        extendStatics(d2, b2);\n        function __() {\n          this.constructor = d2;\n        }\n        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n      };\n      __assign3 = Object.assign || function(t) {\n        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {\n          s = arguments[i2];\n          for (var p2 in s)\n            if (Object.prototype.hasOwnProperty.call(s, p2))\n              t[p2] = s[p2];\n        }\n        return t;\n      };\n      __rest3 = function(s, e) {\n        var t = {};\n        for (var p2 in s)\n          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)\n            t[p2] = s[p2];\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {\n            if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))\n              t[p2[i2]] = s[p2[i2]];\n          }\n        return t;\n      };\n      __decorate3 = function(decorators, target, key, desc) {\n        var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n          r = Reflect.decorate(decorators, target, key, desc);\n        else\n          for (var i2 = decorators.length - 1; i2 >= 0; i2--)\n            if (d2 = decorators[i2])\n              r = (c3 < 3 ? d2(r) : c3 > 3 ? d2(target, key, r) : d2(target, key)) || r;\n        return c3 > 3 && r && Object.defineProperty(target, key, r), r;\n      };\n      __param3 = function(paramIndex, decorator) {\n        return function(target, key) {\n          decorator(target, key, paramIndex);\n        };\n      };\n      __metadata3 = function(metadataKey, metadataValue) {\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n          return Reflect.metadata(metadataKey, metadataValue);\n      };\n      __awaiter3 = function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      __generator3 = function(thisArg, body) {\n        var _ = { label: 0, sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        }, trys: [], ops: [] }, f2, y, t, g2;\n        return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n          return this;\n        }), g2;\n        function verb(n) {\n          return function(v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f2)\n            throw new TypeError(\"Generator is already executing.\");\n          while (g2 && (g2 = 0, op[0] && (_ = 0)), _)\n            try {\n              if (f2 = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                return t;\n              if (y = 0, t)\n                op = [op[0] & 2, t.value];\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n                case 4:\n                  _.label++;\n                  return { value: op[1], done: false };\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n                case 7:\n                  op = _.ops.pop();\n                  _.trys.pop();\n                  continue;\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n                    _.ops.push(op);\n                    break;\n                  }\n                  if (t[2])\n                    _.ops.pop();\n                  _.trys.pop();\n                  continue;\n              }\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f2 = t = 0;\n            }\n          if (op[0] & 5)\n            throw op[1];\n          return { value: op[0] ? op[1] : void 0, done: true };\n        }\n      };\n      __exportStar3 = function(m, o) {\n        for (var p2 in m)\n          if (p2 !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p2))\n            __createBinding3(o, m, p2);\n      };\n      __createBinding3 = Object.create ? function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        var desc = Object.getOwnPropertyDescriptor(m, k2);\n        if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n          desc = { enumerable: true, get: function() {\n            return m[k2];\n          } };\n        }\n        Object.defineProperty(o, k22, desc);\n      } : function(o, m, k2, k22) {\n        if (k22 === void 0)\n          k22 = k2;\n        o[k22] = m[k2];\n      };\n      __values3 = function(o) {\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i2 = 0;\n        if (m)\n          return m.call(o);\n        if (o && typeof o.length === \"number\")\n          return {\n            next: function() {\n              if (o && i2 >= o.length)\n                o = void 0;\n              return { value: o && o[i2++], done: !o };\n            }\n          };\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n      };\n      __read3 = function(o, n) {\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n        if (!m)\n          return o;\n        var i2 = m.call(o), r, ar = [], e;\n        try {\n          while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)\n            ar.push(r.value);\n        } catch (error) {\n          e = { error };\n        } finally {\n          try {\n            if (r && !r.done && (m = i2[\"return\"]))\n              m.call(i2);\n          } finally {\n            if (e)\n              throw e.error;\n          }\n        }\n        return ar;\n      };\n      __spread3 = function() {\n        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)\n          ar = ar.concat(__read3(arguments[i2]));\n        return ar;\n      };\n      __spreadArrays3 = function() {\n        for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n          s += arguments[i2].length;\n        for (var r = Array(s), k2 = 0, i2 = 0; i2 < il; i2++)\n          for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k2++)\n            r[k2] = a2[j];\n        return r;\n      };\n      __spreadArray3 = function(to, from, pack) {\n        if (pack || arguments.length === 2)\n          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {\n            if (ar || !(i2 in from)) {\n              if (!ar)\n                ar = Array.prototype.slice.call(from, 0, i2);\n              ar[i2] = from[i2];\n            }\n          }\n        return to.concat(ar || Array.prototype.slice.call(from));\n      };\n      __await3 = function(v) {\n        return this instanceof __await3 ? (this.v = v, this) : new __await3(v);\n      };\n      __asyncGenerator3 = function(thisArg, _arguments, generator) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];\n        return i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2;\n        function verb(n) {\n          if (g2[n])\n            i2[n] = function(v) {\n              return new Promise(function(a2, b2) {\n                q.push([n, v, a2, b2]) > 1 || resume(n, v);\n              });\n            };\n        }\n        function resume(n, v) {\n          try {\n            step(g2[n](v));\n          } catch (e) {\n            settle(q[0][3], e);\n          }\n        }\n        function step(r) {\n          r.value instanceof __await3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n        }\n        function fulfill(value) {\n          resume(\"next\", value);\n        }\n        function reject(value) {\n          resume(\"throw\", value);\n        }\n        function settle(f2, v) {\n          if (f2(v), q.shift(), q.length)\n            resume(q[0][0], q[0][1]);\n        }\n      };\n      __asyncDelegator3 = function(o) {\n        var i2, p2;\n        return i2 = {}, verb(\"next\"), verb(\"throw\", function(e) {\n          throw e;\n        }), verb(\"return\"), i2[Symbol.iterator] = function() {\n          return this;\n        }, i2;\n        function verb(n, f2) {\n          i2[n] = o[n] ? function(v) {\n            return (p2 = !p2) ? { value: __await3(o[n](v)), done: n === \"return\" } : f2 ? f2(v) : v;\n          } : f2;\n        }\n      };\n      __asyncValues3 = function(o) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var m = o[Symbol.asyncIterator], i2;\n        return m ? m.call(o) : (o = typeof __values3 === \"function\" ? __values3(o) : o[Symbol.iterator](), i2 = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i2[Symbol.asyncIterator] = function() {\n          return this;\n        }, i2);\n        function verb(n) {\n          i2[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n              v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n          };\n        }\n        function settle(resolve, reject, d2, v) {\n          Promise.resolve(v).then(function(v2) {\n            resolve({ value: v2, done: d2 });\n          }, reject);\n        }\n      };\n      __makeTemplateObject3 = function(cooked, raw) {\n        if (Object.defineProperty) {\n          Object.defineProperty(cooked, \"raw\", { value: raw });\n        } else {\n          cooked.raw = raw;\n        }\n        return cooked;\n      };\n      var __setModuleDefault = Object.create ? function(o, v) {\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n      } : function(o, v) {\n        o[\"default\"] = v;\n      };\n      __importStar3 = function(mod) {\n        if (mod && mod.__esModule)\n          return mod;\n        var result = {};\n        if (mod != null) {\n          for (var k2 in mod)\n            if (k2 !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k2))\n              __createBinding3(result, mod, k2);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n      };\n      __importDefault3 = function(mod) {\n        return mod && mod.__esModule ? mod : { \"default\": mod };\n      };\n      __classPrivateFieldGet3 = function(receiver, state, kind, f2) {\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a getter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n        return kind === \"m\" ? f2 : kind === \"a\" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);\n      };\n      __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {\n        if (kind === \"m\")\n          throw new TypeError(\"Private method is not writable\");\n        if (kind === \"a\" && !f2)\n          throw new TypeError(\"Private accessor was defined without a setter\");\n        if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver))\n          throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n        return kind === \"a\" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;\n      };\n      __classPrivateFieldIn3 = function(state, receiver) {\n        if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\")\n          throw new TypeError(\"Cannot use 'in' operator on non-object\");\n        return typeof state === \"function\" ? receiver === state : state.has(receiver);\n      };\n      exporter(\"__extends\", __extends3);\n      exporter(\"__assign\", __assign3);\n      exporter(\"__rest\", __rest3);\n      exporter(\"__decorate\", __decorate3);\n      exporter(\"__param\", __param3);\n      exporter(\"__metadata\", __metadata3);\n      exporter(\"__awaiter\", __awaiter3);\n      exporter(\"__generator\", __generator3);\n      exporter(\"__exportStar\", __exportStar3);\n      exporter(\"__createBinding\", __createBinding3);\n      exporter(\"__values\", __values3);\n      exporter(\"__read\", __read3);\n      exporter(\"__spread\", __spread3);\n      exporter(\"__spreadArrays\", __spreadArrays3);\n      exporter(\"__spreadArray\", __spreadArray3);\n      exporter(\"__await\", __await3);\n      exporter(\"__asyncGenerator\", __asyncGenerator3);\n      exporter(\"__asyncDelegator\", __asyncDelegator3);\n      exporter(\"__asyncValues\", __asyncValues3);\n      exporter(\"__makeTemplateObject\", __makeTemplateObject3);\n      exporter(\"__importStar\", __importStar3);\n      exporter(\"__importDefault\", __importDefault3);\n      exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet3);\n      exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet3);\n      exporter(\"__classPrivateFieldIn\", __classPrivateFieldIn3);\n    });\n  }\n});\n\n// ../../node_modules/meshgrad/dist/index.mjs\nvar i = () => Math.round(Math.random() * 360);\nvar c = (n) => Math.round(Math.random() * (n * 100) % 100);\nvar g = (n, t, e) => Math.round(t / e * (n * 100) % 100);\nvar d = (n) => {\n  if (!!n) {\n    n = n.replace(/#/g, \"\"), n.length === 3 && (n = n.split(\"\").map(function(b2) {\n      return b2 + b2;\n    }).join(\"\"));\n    var t = /^([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})[\\da-z]{0,0}$/i.exec(n);\n    if (!!t) {\n      var e = parseInt(t[1], 16), r = parseInt(t[2], 16), a2 = parseInt(t[3], 16);\n      e /= 255, r /= 255, a2 /= 255;\n      var o = Math.max(e, r, a2), s = Math.min(e, r, a2), u = (o + s) / 2;\n      if (o == s)\n        u = 0;\n      else {\n        var m = o - s;\n        switch (o) {\n          case e:\n            u = (r - a2) / m + (r < a2 ? 6 : 0);\n            break;\n          case r:\n            u = (a2 - e) / m + 2;\n            break;\n          case a2:\n            u = (e - r) / m + 4;\n            break;\n        }\n        u /= 6;\n      }\n      return u = Math.round(360 * u), u;\n    }\n  }\n};\nvar p = (n, t) => Array.from({ length: n }, (e, r) => r === 0 ? `hsl(${t}, 100%, 80%)` : r < n / 1.4 ? `hsl(${t - 30 * (1 - 2 * (r % 2)) * (r > 2 ? r / 2 : r)}, 100%, ${76 - r * (1 - 2 * (r % 2)) * 1.75}%)` : `hsl(${t - 150 * (1 - 2 * (r % 2))}, 100%, ${76 - r * (1 - 2 * (r % 2)) * 1.25}%)`);\nvar M = (n, t, e) => Array.from({ length: n }, (r, a2) => `radial-gradient(at ${e ? g(a2, e, n) : c(a2)}% ${e ? g(a2 * 10, e, n) : c(a2 * 10)}%, ${t[a2]} 0px, transparent 50%)\n`);\nvar f = (n, t, e) => {\n  let r = p(n, t || i()), a2 = M(n, r, e || void 0);\n  return [r[0], a2.join(\",\")];\n};\nvar k = (n, t, e) => {\n  let [r, a2] = f(n, d(t) ? d(t) : void 0, e || void 0);\n  return { backgroundColor: r, backgroundImage: a2 };\n};\n\n// src/Version.tsx\n\nvar ELEMENTS = 8;\nvar Version = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n    className: \"m-2 hidden rounded-full py-2 px-4 text-xs font-bold text-black shadow-md hover:shadow-xl md:block\",\n    style: k(ELEMENTS),\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n      href: \"http://github.com/miguelgargallo/next13-gallery-image-turbo\",\n      target: \"_blank\",\n      rel: \"noopener noreferrer\",\n      children: \"v1.0.0\"\n    })\n  });\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/index.mjs\n\n\n\n// ../../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs\n\nvar MotionConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n  transformPagePoint: (p2) => p2,\n  isStatic: false,\n  reducedMotion: \"never\"\n});\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/index.mjs\n\nvar MotionContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\nfunction useVisualElementContext() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionContext).visualElement;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/context/PresenceContext.mjs\n\nvar PresenceContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n\n// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/utils/is-browser.mjs\nvar isBrowser = typeof document !== \"undefined\";\n\n// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\nvar useIsomorphicLayoutEffect = isBrowser ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n\n// ../../node_modules/framer-motion/dist/es/context/LazyContext.mjs\n\nvar LazyContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({ strict: false });\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n  const parent = useVisualElementContext();\n  const lazyContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LazyContext);\n  const presenceContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PresenceContext);\n  const reducedMotionConfig = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionConfigContext).reducedMotion;\n  const visualElementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  createVisualElement = createVisualElement || lazyContext.renderer;\n  if (!visualElementRef.current && createVisualElement) {\n    visualElementRef.current = createVisualElement(Component, {\n      visualState,\n      parent,\n      props,\n      presenceId: presenceContext ? presenceContext.id : void 0,\n      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,\n      reducedMotionConfig\n    });\n  }\n  const visualElement = visualElementRef.current;\n  useIsomorphicLayoutEffect(() => {\n    visualElement && visualElement.render();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (visualElement && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n  });\n  useIsomorphicLayoutEffect(() => () => visualElement && visualElement.notify(\"Unmount\"), []);\n  return visualElement;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/utils/is-ref-object.mjs\nfunction isRefObject(ref) {\n  return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\nfunction useMotionRef(visualState, visualElement, externalRef) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (instance) => {\n      instance && visualState.mount && visualState.mount(instance);\n      if (visualElement) {\n        instance ? visualElement.mount(instance) : visualElement.unmount();\n      }\n      if (externalRef) {\n        if (typeof externalRef === \"function\") {\n          externalRef(instance);\n        } else if (isRefObject(externalRef)) {\n          externalRef.current = instance;\n        }\n      }\n    },\n    [visualElement]\n  );\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs\nfunction isVariantLabel(v) {\n  return typeof v === \"string\" || Array.isArray(v);\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs\nfunction isAnimationControls(v) {\n  return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs\nvar variantProps = [\n  \"initial\",\n  \"animate\",\n  \"exit\",\n  \"whileHover\",\n  \"whileDrag\",\n  \"whileTap\",\n  \"whileFocus\",\n  \"whileInView\"\n];\nfunction isControllingVariants(props) {\n  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));\n}\nfunction isVariantNode(props) {\n  return Boolean(isControllingVariants(props) || props.variants);\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs\nfunction getCurrentTreeVariants(props, context) {\n  if (isControllingVariants(props)) {\n    const { initial, animate: animate3 } = props;\n    return {\n      initial: initial === false || isVariantLabel(initial) ? initial : void 0,\n      animate: isVariantLabel(animate3) ? animate3 : void 0\n    };\n  }\n  return props.inherit !== false ? context : {};\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\nfunction useCreateMotionContext(props) {\n  const { initial, animate: animate3 } = getCurrentTreeVariants(props, (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionContext));\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({ initial, animate: animate3 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate3)]);\n}\nfunction variantLabelsAsDependency(prop) {\n  return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/definitions.mjs\nvar createDefinition = (propNames) => ({\n  isEnabled: (props) => propNames.some((name) => !!props[name])\n});\nvar featureDefinitions = {\n  measureLayout: createDefinition([\"layout\", \"layoutId\", \"drag\"]),\n  animation: createDefinition([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileFocus\",\n    \"whileDrag\",\n    \"whileInView\"\n  ]),\n  exit: createDefinition([\"exit\"]),\n  drag: createDefinition([\"drag\", \"dragControls\"]),\n  focus: createDefinition([\"whileFocus\"]),\n  hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n  tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n  pan: createDefinition([\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanSessionStart\",\n    \"onPanEnd\"\n  ]),\n  inView: createDefinition([\n    \"whileInView\",\n    \"onViewportEnter\",\n    \"onViewportLeave\"\n  ])\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/load-features.mjs\nfunction loadFeatures(features) {\n  for (const key in features) {\n    if (key === \"projectionNodeConstructor\") {\n      featureDefinitions.projectionNodeConstructor = features[key];\n    } else {\n      featureDefinitions[key].Component = features[key];\n    }\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/use-constant.mjs\n\nfunction useConstant(init) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  if (ref.current === null) {\n    ref.current = init();\n  }\n  return ref.current;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/node/state.mjs\nvar globalProjectionState = {\n  hasAnimatedSinceResize: true,\n  hasEverUpdated: false\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/node/id.mjs\nvar id = 1;\nfunction useProjectionId() {\n  return useConstant(() => {\n    if (globalProjectionState.hasEverUpdated) {\n      return id++;\n    }\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs\n\nvar LayoutGroupContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/VisualElementHandler.mjs\n\nvar VisualElementHandler = class extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  getSnapshotBeforeUpdate() {\n    const { visualElement, props } = this.props;\n    if (visualElement)\n      visualElement.setProps(props);\n    return null;\n  }\n  componentDidUpdate() {\n  }\n  render() {\n    return this.props.children;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs\n\nvar SwitchLayoutGroupContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/symbol.mjs\nvar motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n\n// ../../node_modules/framer-motion/dist/es/motion/index.mjs\nfunction createMotionComponent({ preloadedFeatures, createVisualElement, projectionNodeConstructor, useRender, useVisualState, Component }) {\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  function MotionComponent(props, externalRef) {\n    const configAndProps = __spreadProps(__spreadValues(__spreadValues({}, (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionConfigContext)), props), {\n      layoutId: useLayoutId(props)\n    });\n    const { isStatic } = configAndProps;\n    let features = null;\n    const context = useCreateMotionContext(props);\n    const projectionId = isStatic ? void 0 : useProjectionId();\n    const visualState = useVisualState(props, isStatic);\n    if (!isStatic && isBrowser) {\n      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);\n      const lazyStrictMode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LazyContext).strict;\n      const initialLayoutGroupConfig = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SwitchLayoutGroupContext);\n      if (context.visualElement) {\n        features = context.visualElement.loadFeatures(\n          configAndProps,\n          lazyStrictMode,\n          preloadedFeatures,\n          projectionId,\n          projectionNodeConstructor || featureDefinitions.projectionNodeConstructor,\n          initialLayoutGroupConfig\n        );\n      }\n    }\n    return react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      VisualElementHandler,\n      { visualElement: context.visualElement, props: configAndProps },\n      features,\n      react__WEBPACK_IMPORTED_MODULE_1__.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement))\n    );\n  }\n  const ForwardRefComponent = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(MotionComponent);\n  ForwardRefComponent[motionComponentSymbol] = Component;\n  return ForwardRefComponent;\n}\nfunction useLayoutId({ layoutId }) {\n  const layoutGroupId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LayoutGroupContext).id;\n  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs\nfunction createMotionProxy(createConfig) {\n  function custom(Component, customMotionComponentConfig = {}) {\n    return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n  }\n  if (typeof Proxy === \"undefined\") {\n    return custom;\n  }\n  const componentCache = /* @__PURE__ */ new Map();\n  return new Proxy(custom, {\n    get: (_target, key) => {\n      if (!componentCache.has(key)) {\n        componentCache.set(key, custom(key));\n      }\n      return componentCache.get(key);\n    }\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs\nvar lowercaseSVGElements = [\n  \"animate\",\n  \"circle\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"g\",\n  \"image\",\n  \"line\",\n  \"filter\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"rect\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"tspan\",\n  \"use\",\n  \"view\"\n];\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs\nfunction isSVGComponent(Component) {\n  if (typeof Component !== \"string\" || Component.includes(\"-\")) {\n    return false;\n  } else if (lowercaseSVGElements.indexOf(Component) > -1 || /[A-Z]/.test(Component)) {\n    return true;\n  }\n  return false;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/use-render.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/render/html/use-props.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs\nvar scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n  Object.assign(scaleCorrectors, correctors);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/transform.mjs\nvar transformPropOrder = [\n  \"transformPerspective\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"translateX\",\n  \"translateY\",\n  \"translateZ\",\n  \"scale\",\n  \"scaleX\",\n  \"scaleY\",\n  \"rotate\",\n  \"rotateX\",\n  \"rotateY\",\n  \"rotateZ\",\n  \"skew\",\n  \"skewX\",\n  \"skewY\"\n];\nvar transformProps = new Set(transformPropOrder);\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n  return transformProps.has(key) || key.startsWith(\"origin\") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === \"opacity\");\n}\n\n// ../../node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs\nvar isMotionValue = (value) => !!(value === null || value === void 0 ? void 0 : value.getVelocity);\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\nvar sortTransformProps = (a2, b2) => transformPropOrder.indexOf(a2) - transformPropOrder.indexOf(b2);\nfunction buildTransform({ transform, transformKeys: transformKeys2 }, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {\n  let transformString = \"\";\n  transformKeys2.sort(sortTransformProps);\n  for (const key of transformKeys2) {\n    transformString += `${translateAlias[key] || key}(${transform[key]}) `;\n  }\n  if (enableHardwareAcceleration && !transform.z) {\n    transformString += \"translateZ(0)\";\n  }\n  transformString = transformString.trim();\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n  return transformString;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs\nfunction isCSSVariable(key) {\n  return key.startsWith(\"--\");\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs\nvar getValueAsType = (value, type) => {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n\n// ../../node_modules/style-value-types/dist/es/utils.mjs\nvar clamp = (min, max) => (v) => Math.max(Math.min(v, max), min);\nvar sanitize = (v) => v % 1 ? Number(v.toFixed(5)) : v;\nvar floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nvar colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))/gi;\nvar singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))$/i;\nfunction isString(v) {\n  return typeof v === \"string\";\n}\n\n// ../../node_modules/style-value-types/dist/es/numbers/index.mjs\nvar number = {\n  test: (v) => typeof v === \"number\",\n  parse: parseFloat,\n  transform: (v) => v\n};\nvar alpha = Object.assign(Object.assign({}, number), { transform: clamp(0, 1) });\nvar scale = Object.assign(Object.assign({}, number), { default: 1 });\n\n// ../../node_modules/style-value-types/dist/es/numbers/units.mjs\nvar createUnitType = (unit) => ({\n  test: (v) => isString(v) && v.endsWith(unit) && v.split(\" \").length === 1,\n  parse: parseFloat,\n  transform: (v) => `${v}${unit}`\n});\nvar degrees = createUnitType(\"deg\");\nvar percent = createUnitType(\"%\");\nvar px = createUnitType(\"px\");\nvar vh = createUnitType(\"vh\");\nvar vw = createUnitType(\"vw\");\nvar progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v) => percent.parse(v) / 100, transform: (v) => percent.transform(v * 100) });\n\n// ../../node_modules/style-value-types/dist/es/color/utils.mjs\nvar isColorString = (type, testProp) => (v) => {\n  return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));\n};\nvar splitColor = (aName, bName, cName) => (v) => {\n  if (!isString(v))\n    return v;\n  const [a2, b2, c3, alpha2] = v.match(floatRegex);\n  return {\n    [aName]: parseFloat(a2),\n    [bName]: parseFloat(b2),\n    [cName]: parseFloat(c3),\n    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1\n  };\n};\n\n// ../../node_modules/style-value-types/dist/es/color/hsla.mjs\nvar hsla = {\n  test: isColorString(\"hsl\", \"hue\"),\n  parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n    return \"hsla(\" + Math.round(hue) + \", \" + percent.transform(sanitize(saturation)) + \", \" + percent.transform(sanitize(lightness)) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\";\n  }\n};\n\n// ../../node_modules/style-value-types/dist/es/color/rgba.mjs\nvar clampRgbUnit = clamp(0, 255);\nvar rgbUnit = Object.assign(Object.assign({}, number), { transform: (v) => Math.round(clampRgbUnit(v)) });\nvar rgba = {\n  test: isColorString(\"rgb\", \"red\"),\n  parse: splitColor(\"red\", \"green\", \"blue\"),\n  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" + rgbUnit.transform(red) + \", \" + rgbUnit.transform(green) + \", \" + rgbUnit.transform(blue) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\"\n};\n\n// ../../node_modules/style-value-types/dist/es/color/hex.mjs\nfunction parseHex(v) {\n  let r = \"\";\n  let g2 = \"\";\n  let b2 = \"\";\n  let a2 = \"\";\n  if (v.length > 5) {\n    r = v.substr(1, 2);\n    g2 = v.substr(3, 2);\n    b2 = v.substr(5, 2);\n    a2 = v.substr(7, 2);\n  } else {\n    r = v.substr(1, 1);\n    g2 = v.substr(2, 1);\n    b2 = v.substr(3, 1);\n    a2 = v.substr(4, 1);\n    r += r;\n    g2 += g2;\n    b2 += b2;\n    a2 += a2;\n  }\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g2, 16),\n    blue: parseInt(b2, 16),\n    alpha: a2 ? parseInt(a2, 16) / 255 : 1\n  };\n}\nvar hex = {\n  test: isColorString(\"#\"),\n  parse: parseHex,\n  transform: rgba.transform\n};\n\n// ../../node_modules/style-value-types/dist/es/color/index.mjs\nvar color = {\n  test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n  parse: (v) => {\n    if (rgba.test(v)) {\n      return rgba.parse(v);\n    } else if (hsla.test(v)) {\n      return hsla.parse(v);\n    } else {\n      return hex.parse(v);\n    }\n  },\n  transform: (v) => {\n    return isString(v) ? v : v.hasOwnProperty(\"red\") ? rgba.transform(v) : hsla.transform(v);\n  }\n};\n\n// ../../node_modules/style-value-types/dist/es/complex/index.mjs\nvar colorToken = \"${c}\";\nvar numberToken = \"${n}\";\nfunction test(v) {\n  var _a, _b, _c, _d;\n  return isNaN(v) && isString(v) && ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;\n}\nfunction analyse(v) {\n  if (typeof v === \"number\")\n    v = `${v}`;\n  const values = [];\n  let numColors = 0;\n  const colors = v.match(colorRegex);\n  if (colors) {\n    numColors = colors.length;\n    v = v.replace(colorRegex, colorToken);\n    values.push(...colors.map(color.parse));\n  }\n  const numbers = v.match(floatRegex);\n  if (numbers) {\n    v = v.replace(floatRegex, numberToken);\n    values.push(...numbers.map(number.parse));\n  }\n  return { values, numColors, tokenised: v };\n}\nfunction parse(v) {\n  return analyse(v).values;\n}\nfunction createTransformer(v) {\n  const { values, numColors, tokenised } = analyse(v);\n  const numValues = values.length;\n  return (v2) => {\n    let output = tokenised;\n    for (let i2 = 0; i2 < numValues; i2++) {\n      output = output.replace(i2 < numColors ? colorToken : numberToken, i2 < numColors ? color.transform(v2[i2]) : sanitize(v2[i2]));\n    }\n    return output;\n  };\n}\nvar convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone(v) {\n  const parsed = parse(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\nvar complex = { test, parse, createTransformer, getAnimatableNone };\n\n// ../../node_modules/style-value-types/dist/es/complex/filter.mjs\nvar maxDefaults = /* @__PURE__ */ new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n  let [name, value] = v.slice(0, -1).split(\"(\");\n  if (name === \"drop-shadow\")\n    return v;\n  const [number2] = value.match(floatRegex) || [];\n  if (!number2)\n    return v;\n  const unit = value.replace(number2, \"\");\n  let defaultValue = maxDefaults.has(name) ? 1 : 0;\n  if (number2 !== value)\n    defaultValue *= 100;\n  return name + \"(\" + defaultValue + unit + \")\";\n}\nvar functionRegex = /([a-z-]*)\\(.*?\\)/g;\nvar filter = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v) => {\n  const functions = v.match(functionRegex);\n  return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n} });\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs\nvar int = __spreadProps(__spreadValues({}, number), {\n  transform: Math.round\n});\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs\nvar numberValueTypes = {\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  transformPerspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  zIndex: int,\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n  const { style, vars, transform, transformKeys: transformKeys2, transformOrigin } = state;\n  transformKeys2.length = 0;\n  let hasTransform2 = false;\n  let hasTransformOrigin = false;\n  let transformIsNone = true;\n  for (const key in latestValues) {\n    const value = latestValues[key];\n    if (isCSSVariable(key)) {\n      vars[key] = value;\n      continue;\n    }\n    const valueType = numberValueTypes[key];\n    const valueAsType = getValueAsType(value, valueType);\n    if (transformProps.has(key)) {\n      hasTransform2 = true;\n      transform[key] = valueAsType;\n      transformKeys2.push(key);\n      if (!transformIsNone)\n        continue;\n      if (value !== (valueType.default || 0))\n        transformIsNone = false;\n    } else if (key.startsWith(\"origin\")) {\n      hasTransformOrigin = true;\n      transformOrigin[key] = valueAsType;\n    } else {\n      style[key] = valueAsType;\n    }\n  }\n  if (!latestValues.transform) {\n    if (hasTransform2 || transformTemplate) {\n      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n    } else if (style.transform) {\n      style.transform = \"none\";\n    }\n  }\n  if (hasTransformOrigin) {\n    const { originX = \"50%\", originY = \"50%\", originZ = 0 } = transformOrigin;\n    style.transformOrigin = `${originX} ${originY} ${originZ}`;\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs\nvar createHtmlRenderState = () => ({\n  style: {},\n  transform: {},\n  transformKeys: [],\n  transformOrigin: {},\n  vars: {}\n});\n\n// ../../node_modules/framer-motion/dist/es/render/html/use-props.mjs\nfunction copyRawValuesOnly(target, source, props) {\n  for (const key in source) {\n    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState, isStatic) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    const state = createHtmlRenderState();\n    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);\n    return Object.assign({}, state.vars, state.style);\n  }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n  const styleProp = props.style || {};\n  const style = {};\n  copyRawValuesOnly(style, styleProp, props);\n  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n  return props.transformValues ? props.transformValues(style) : style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n  const htmlProps = {};\n  const style = useStyle(props, visualState, isStatic);\n  if (props.drag && props.dragListener !== false) {\n    htmlProps.draggable = false;\n    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n    style.touchAction = props.drag === true ? \"none\" : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n  }\n  htmlProps.style = style;\n  return htmlProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs\nvar animationProps = [\n  \"animate\",\n  \"exit\",\n  \"variants\",\n  \"whileHover\",\n  \"whileTap\",\n  \"whileFocus\",\n  \"whileDrag\",\n  \"whileInView\"\n];\nvar tapProps = [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"];\nvar panProps = [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"];\nvar inViewProps = [\n  \"whileInView\",\n  \"onViewportEnter\",\n  \"onViewportLeave\",\n  \"viewport\"\n];\nvar validMotionProps = /* @__PURE__ */ new Set([\n  \"initial\",\n  \"style\",\n  \"values\",\n  \"variants\",\n  \"transition\",\n  \"transformTemplate\",\n  \"transformValues\",\n  \"custom\",\n  \"inherit\",\n  \"layout\",\n  \"layoutId\",\n  \"layoutDependency\",\n  \"onLayoutAnimationStart\",\n  \"onLayoutAnimationComplete\",\n  \"onLayoutMeasure\",\n  \"onBeforeLayoutMeasure\",\n  \"onAnimationStart\",\n  \"onAnimationComplete\",\n  \"onUpdate\",\n  \"onDragStart\",\n  \"onDrag\",\n  \"onDragEnd\",\n  \"onMeasureDragConstraints\",\n  \"onDirectionLock\",\n  \"onDragTransitionEnd\",\n  \"drag\",\n  \"dragControls\",\n  \"dragListener\",\n  \"dragConstraints\",\n  \"dragDirectionLock\",\n  \"dragSnapToOrigin\",\n  \"_dragX\",\n  \"_dragY\",\n  \"dragElastic\",\n  \"dragMomentum\",\n  \"dragPropagation\",\n  \"dragTransition\",\n  \"onHoverStart\",\n  \"onHoverEnd\",\n  \"layoutScroll\",\n  ...inViewProps,\n  ...tapProps,\n  ...animationProps,\n  ...panProps\n]);\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs\nvar shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n  if (!isValidProp)\n    return;\n  shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\ntry {\n  loadExternalIsValidProp((init_is_prop_valid_esm(), __toCommonJS(is_prop_valid_esm_exports)).default);\n} catch (_a) {\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n  const filteredProps = {};\n  for (const key in props) {\n    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props[\"draggable\"] && key.startsWith(\"onDrag\")) {\n      filteredProps[key] = props[key];\n    }\n  }\n  return filteredProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/use-props.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs\nfunction calcOrigin(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n  return `${pxOriginX} ${pxOriginY}`;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/path.mjs\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n  attrs.pathLength = 1;\n  const keys2 = useDashCase ? dashKeys : camelKeys;\n  attrs[keys2.offset] = px.transform(-offset);\n  const pathLength = px.transform(length);\n  const pathSpacing = px.transform(spacing);\n  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs\nfunction buildSVGAttrs(state, _a, options, transformTemplate) {\n  var _b = _a, {\n    attrX,\n    attrY,\n    originX,\n    originY,\n    pathLength,\n    pathSpacing = 1,\n    pathOffset = 0\n  } = _b, latest = __objRest(_b, [\n    \"attrX\",\n    \"attrY\",\n    \"originX\",\n    \"originY\",\n    \"pathLength\",\n    \"pathSpacing\",\n    \"pathOffset\"\n  ]);\n  buildHTMLStyles(state, latest, options, transformTemplate);\n  state.attrs = state.style;\n  state.style = {};\n  const { attrs, style, dimensions } = state;\n  if (attrs.transform) {\n    if (dimensions)\n      style.transform = attrs.transform;\n    delete attrs.transform;\n  }\n  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);\n  }\n  if (attrX !== void 0)\n    attrs.x = attrX;\n  if (attrY !== void 0)\n    attrs.y = attrY;\n  if (pathLength !== void 0) {\n    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs\nvar createSvgRenderState = () => __spreadProps(__spreadValues({}, createHtmlRenderState()), {\n  attrs: {}\n});\n\n// ../../node_modules/framer-motion/dist/es/render/svg/use-props.mjs\nfunction useSVGProps(props, visualState) {\n  const visualProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    const state = createSvgRenderState();\n    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);\n    return __spreadProps(__spreadValues({}, state.attrs), {\n      style: __spreadValues({}, state.style)\n    });\n  }, [visualState]);\n  if (props.style) {\n    const rawStyles = {};\n    copyRawValuesOnly(rawStyles, props.style, props);\n    visualProps.style = __spreadValues(__spreadValues({}, rawStyles), visualProps.style);\n  }\n  return visualProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/use-render.mjs\nfunction createUseRender(forwardMotionProps = false) {\n  const useRender = (Component, props, projectionId, ref, { latestValues }, isStatic) => {\n    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;\n    const visualProps = useVisualProps(props, latestValues, isStatic);\n    const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n    const elementProps = __spreadProps(__spreadValues(__spreadValues({}, filteredProps), visualProps), {\n      ref\n    });\n    if (projectionId) {\n      elementProps[\"data-projection-id\"] = projectionId;\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Component, elementProps);\n  };\n  return useRender;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs\nvar camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/render.mjs\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n  for (const key in vars) {\n    element.style.setProperty(key, vars[key]);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs\nvar camelCaseAttributes = /* @__PURE__ */ new Set([\n  \"baseFrequency\",\n  \"diffuseConstant\",\n  \"kernelMatrix\",\n  \"kernelUnitLength\",\n  \"keySplines\",\n  \"keyTimes\",\n  \"limitingConeAngle\",\n  \"markerHeight\",\n  \"markerWidth\",\n  \"numOctaves\",\n  \"targetX\",\n  \"targetY\",\n  \"surfaceScale\",\n  \"specularConstant\",\n  \"specularExponent\",\n  \"stdDeviation\",\n  \"tableValues\",\n  \"viewBox\",\n  \"gradientTransform\",\n  \"pathLength\"\n]);\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/render.mjs\nfunction renderSVG(element, renderState, _styleProp, projection) {\n  renderHTML(element, renderState, void 0, projection);\n  for (const key in renderState.attrs) {\n    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs\nfunction scrapeMotionValuesFromProps(props) {\n  const { style } = props;\n  const newValues = {};\n  for (const key in style) {\n    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n      newValues[key] = style[key];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs\nfunction scrapeMotionValuesFromProps2(props) {\n  const newValues = scrapeMotionValuesFromProps(props);\n  for (const key in props) {\n    if (isMotionValue(props[key])) {\n      const targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n      newValues[targetKey] = props[key];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs\nfunction resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n  }\n  if (typeof definition === \"string\") {\n    definition = props.variants && props.variants[definition];\n  }\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n  }\n  return definition;\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs\nvar isKeyframesTarget = (v) => {\n  return Array.isArray(v);\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/resolve-value.mjs\nvar isCustomValue = (v) => {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = (v) => {\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n// ../../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs\nfunction resolveMotionValue(value) {\n  const unwrappedValue = isMotionValue(value) ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\nfunction makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props, context, presenceContext) {\n  const state = {\n    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),\n    renderState: createRenderState()\n  };\n  if (onMount) {\n    state.mount = (instance) => onMount(props, instance, state);\n  }\n  return state;\n}\nvar makeUseVisualState = (config) => (props, isStatic) => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionContext);\n  const presenceContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PresenceContext);\n  const make = () => makeState(config, props, context, presenceContext);\n  return isStatic ? make() : useConstant(make);\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n  const values = {};\n  const motionValues = scrapeMotionValues(props);\n  for (const key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n  let { initial, animate: animate3 } = props;\n  const isControllingVariants$1 = isControllingVariants(props);\n  const isVariantNode$1 = isVariantNode(props);\n  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {\n    if (initial === void 0)\n      initial = context.initial;\n    if (animate3 === void 0)\n      animate3 = context.animate;\n  }\n  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;\n  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n  const variantToSet = isInitialAnimationBlocked ? animate3 : initial;\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n    list.forEach((definition) => {\n      const resolved = resolveVariantFromProps(props, definition);\n      if (!resolved)\n        return;\n      const _a = resolved, { transitionEnd, transition } = _a, target = __objRest(_a, [\"transitionEnd\", \"transition\"]);\n      for (const key in target) {\n        let valueTarget = target[key];\n        if (Array.isArray(valueTarget)) {\n          const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;\n          valueTarget = valueTarget[index2];\n        }\n        if (valueTarget !== null) {\n          values[key] = valueTarget;\n        }\n      }\n      for (const key in transitionEnd)\n        values[key] = transitionEnd[key];\n    });\n  }\n  return values;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/config-motion.mjs\nvar svgMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,\n    createRenderState: createSvgRenderState,\n    onMount: (props, instance, { renderState, latestValues }) => {\n      try {\n        renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n      } catch (e) {\n        renderState.dimensions = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);\n      renderSVG(instance, renderState);\n    }\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/config-motion.mjs\nvar htmlMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps,\n    createRenderState: createHtmlRenderState\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs\nfunction createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures, createVisualElement, projectionNodeConstructor) {\n  const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;\n  return __spreadProps(__spreadValues({}, baseConfig), {\n    preloadedFeatures,\n    useRender: createUseRender(forwardMotionProps),\n    createVisualElement,\n    projectionNodeConstructor,\n    Component\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/types.mjs\nvar AnimationType;\n(function(AnimationType2) {\n  AnimationType2[\"Animate\"] = \"animate\";\n  AnimationType2[\"Hover\"] = \"whileHover\";\n  AnimationType2[\"Tap\"] = \"whileTap\";\n  AnimationType2[\"Drag\"] = \"whileDrag\";\n  AnimationType2[\"Focus\"] = \"whileFocus\";\n  AnimationType2[\"InView\"] = \"whileInView\";\n  AnimationType2[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\n// ../../node_modules/framer-motion/dist/es/events/use-dom-event.mjs\n\nfunction addDomEvent(target, eventName, handler, options = { passive: true }) {\n  target.addEventListener(eventName, handler, options);\n  return () => target.removeEventListener(eventName, handler);\n}\nfunction useDomEvent(ref, eventName, handler, options) {\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const element = ref.current;\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-focus-gesture.mjs\nfunction useFocusGesture({ whileFocus, visualElement }) {\n  const { animationState } = visualElement;\n  const onFocus = () => {\n    animationState && animationState.setActive(AnimationType.Focus, true);\n  };\n  const onBlur = () => {\n    animationState && animationState.setActive(AnimationType.Focus, false);\n  };\n  useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : void 0);\n  useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : void 0);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/utils/event-type.mjs\nfunction isMouseEvent(event) {\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n  return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n  const hasTouches = !!event.touches;\n  return hasTouches;\n}\n\n// ../../node_modules/framer-motion/dist/es/events/event-info.mjs\nfunction filterPrimaryPointer(eventHandler) {\n  return (event) => {\n    const isMouseEvent2 = event instanceof MouseEvent;\n    const isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType = \"page\") {\n  const primaryTouch = e.touches[0] || e.changedTouches[0];\n  const point2 = primaryTouch || defaultPagePoint;\n  return {\n    x: point2[pointType + \"X\"],\n    y: point2[pointType + \"Y\"]\n  };\n}\nfunction pointFromMouse(point2, pointType = \"page\") {\n  return {\n    x: point2[pointType + \"X\"],\n    y: point2[pointType + \"Y\"]\n  };\n}\nfunction extractEventInfo(event, pointType = \"page\") {\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\nvar wrapHandler = (handler, shouldFilterPrimaryPointer = false) => {\n  const listener = (event) => handler(event, extractEventInfo(event));\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n\n// ../../node_modules/framer-motion/dist/es/events/utils.mjs\nvar supportsPointerEvents = () => isBrowser && window.onpointerdown === null;\nvar supportsTouchEvents = () => isBrowser && window.ontouchstart === null;\nvar supportsMouseEvents = () => isBrowser && window.onmousedown === null;\n\n// ../../node_modules/framer-motion/dist/es/events/use-pointer-event.mjs\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n  return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs\nfunction createLock(name) {\n  let lock = null;\n  return () => {\n    const openLock = () => {\n      lock = null;\n    };\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n    return false;\n  };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag2) {\n  let lock = false;\n  if (drag2 === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag2 === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    const openHorizontal = globalHorizontalLock();\n    const openVertical = globalVerticalLock();\n    if (openHorizontal && openVertical) {\n      lock = () => {\n        openHorizontal();\n        openVertical();\n      };\n    } else {\n      if (openHorizontal)\n        openHorizontal();\n      if (openVertical)\n        openVertical();\n    }\n  }\n  return lock;\n}\nfunction isDragActive() {\n  const openGestureLock = getGlobalLock(true);\n  if (!openGestureLock)\n    return true;\n  openGestureLock();\n  return false;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-hover-gesture.mjs\nfunction createHoverEvent(visualElement, isActive, callback) {\n  return (event, info) => {\n    if (!isMouseEvent(event) || isDragActive())\n      return;\n    if (visualElement.animationState) {\n      visualElement.animationState.setActive(AnimationType.Hover, isActive);\n    }\n    callback && callback(event, info);\n  };\n}\nfunction useHoverGesture({ onHoverStart, onHoverEnd, whileHover, visualElement }) {\n  usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover ? createHoverEvent(visualElement, true, onHoverStart) : void 0, { passive: !onHoverStart });\n  usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover ? createHoverEvent(visualElement, false, onHoverEnd) : void 0, { passive: !onHoverEnd });\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs\nvar isNodeOrChild = (parent, child) => {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs\n\nfunction useUnmountEffect(callback) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => () => callback(), []);\n}\n\n// ../../node_modules/popmotion/node_modules/tslib/modules/index.js\nvar import_tslib = __toESM(require_tslib(), 1);\nvar {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __exportStar,\n  __createBinding,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn\n} = import_tslib.default;\n\n// ../../node_modules/hey-listen/dist/hey-listen.es.js\nvar warning = function() {\n};\nvar invariant = function() {\n};\nif (true) {\n  warning = function(check, message) {\n    if (!check && typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n  };\n  invariant = function(check, message) {\n    if (!check) {\n      throw new Error(message);\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/clamp.mjs\nvar clamp2 = (min, max, v) => Math.min(Math.max(v, min), max);\n\n// ../../node_modules/popmotion/dist/es/animations/utils/find-spring.mjs\nvar safeMin = 1e-3;\nvar minDuration = 0.01;\nvar maxDuration = 10;\nvar minDamping = 0.05;\nvar maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {\n  let envelope;\n  let derivative;\n  warning(duration <= maxDuration * 1e3, \"Spring duration must be 10 seconds or less\");\n  let dampingRatio = 1 - bounce;\n  dampingRatio = clamp2(minDamping, maxDamping, dampingRatio);\n  duration = clamp2(minDuration, maxDuration, duration / 1e3);\n  if (dampingRatio < 1) {\n    envelope = (undampedFreq2) => {\n      const exponentialDecay = undampedFreq2 * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const a2 = exponentialDecay - velocity;\n      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);\n      const c3 = Math.exp(-delta);\n      return safeMin - a2 / b2 * c3;\n    };\n    derivative = (undampedFreq2) => {\n      const exponentialDecay = undampedFreq2 * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const d2 = delta * velocity + velocity;\n      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;\n      const f2 = Math.exp(-delta);\n      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);\n      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;\n      return factor * ((d2 - e) * f2) / g2;\n    };\n  } else {\n    envelope = (undampedFreq2) => {\n      const a2 = Math.exp(-undampedFreq2 * duration);\n      const b2 = (undampedFreq2 - velocity) * duration + 1;\n      return -safeMin + a2 * b2;\n    };\n    derivative = (undampedFreq2) => {\n      const a2 = Math.exp(-undampedFreq2 * duration);\n      const b2 = (velocity - undampedFreq2) * (duration * duration);\n      return a2 * b2;\n    };\n  }\n  const initialGuess = 5 / duration;\n  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = duration * 1e3;\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration\n    };\n  } else {\n    const stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\nvar rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  let result = initialGuess;\n  for (let i2 = 1; i2 < rootIterations; i2++) {\n    result = result - envelope(result) / derivative(result);\n  }\n  return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\n// ../../node_modules/popmotion/dist/es/animations/generators/spring.mjs\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys2) {\n  return keys2.some((key) => options[key] !== void 0);\n}\nfunction getSpringOptions(options) {\n  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\nfunction spring(_a) {\n  var { from = 0, to = 1, restSpeed = 2, restDelta } = _a, options = __rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n  const state = { done: false, value: from };\n  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);\n  let resolveSpring = zero;\n  let resolveVelocity = zero;\n  function createSpring() {\n    const initialVelocity = velocity ? -(velocity / 1e3) : 0;\n    const initialDelta = to - from;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;\n    if (restDelta === void 0) {\n      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n    }\n    if (dampingRatio < 1) {\n      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n      resolveSpring = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n      resolveVelocity = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      resolveSpring = (t) => to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n      resolveSpring = (t) => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n  createSpring();\n  return {\n    next: (t) => {\n      const current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        const currentVelocity = resolveVelocity(t) * 1e3;\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? to : current;\n      return state;\n    },\n    flipTarget: () => {\n      velocity = -velocity;\n      [from, to] = [to, from];\n      createSpring();\n    }\n  };\n}\nspring.needsInterpolation = (a2, b2) => typeof a2 === \"string\" || typeof b2 === \"string\";\nvar zero = (_t) => 0;\n\n// ../../node_modules/popmotion/dist/es/utils/progress.mjs\nvar progress = (from, to, value) => {\n  const toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\n// ../../node_modules/popmotion/dist/es/utils/mix.mjs\nvar mix = (from, to, progress3) => -progress3 * from + progress3 * to + from;\n\n// ../../node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs\nfunction hueToRgb(p2, q, t) {\n  if (t < 0)\n    t += 1;\n  if (t > 1)\n    t -= 1;\n  if (t < 1 / 6)\n    return p2 + (q - p2) * 6 * t;\n  if (t < 1 / 2)\n    return q;\n  if (t < 2 / 3)\n    return p2 + (q - p2) * (2 / 3 - t) * 6;\n  return p2;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {\n  hue /= 360;\n  saturation /= 100;\n  lightness /= 100;\n  let red = 0;\n  let green = 0;\n  let blue = 0;\n  if (!saturation) {\n    red = green = blue = lightness;\n  } else {\n    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n    const p2 = 2 * lightness - q;\n    red = hueToRgb(p2, q, hue + 1 / 3);\n    green = hueToRgb(p2, q, hue);\n    blue = hueToRgb(p2, q, hue - 1 / 3);\n  }\n  return {\n    red: Math.round(red * 255),\n    green: Math.round(green * 255),\n    blue: Math.round(blue * 255),\n    alpha: alpha2\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/mix-color.mjs\nvar mixLinearColor = (from, to, v) => {\n  const fromExpo = from * from;\n  const toExpo = to * to;\n  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nvar colorTypes = [hex, rgba, hsla];\nvar getColorType = (v) => colorTypes.find((type) => type.test(v));\nvar notAnimatable = (color2) => `'${color2}' is not an animatable color. Use the equivalent color code instead.`;\nvar mixColor = (from, to) => {\n  let fromColorType = getColorType(from);\n  let toColorType = getColorType(to);\n  invariant(!!fromColorType, notAnimatable(from));\n  invariant(!!toColorType, notAnimatable(to));\n  let fromColor = fromColorType.parse(from);\n  let toColor = toColorType.parse(to);\n  if (fromColorType === hsla) {\n    fromColor = hslaToRgba(fromColor);\n    fromColorType = rgba;\n  }\n  if (toColorType === hsla) {\n    toColor = hslaToRgba(toColor);\n    toColorType = rgba;\n  }\n  const blended = Object.assign({}, fromColor);\n  return (v) => {\n    for (const key in blended) {\n      if (key !== \"alpha\") {\n        blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n      }\n    }\n    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n    return fromColorType.transform(blended);\n  };\n};\n\n// ../../node_modules/popmotion/dist/es/utils/inc.mjs\nvar isNum = (v) => typeof v === \"number\";\n\n// ../../node_modules/popmotion/dist/es/utils/pipe.mjs\nvar combineFunctions = (a2, b2) => (v) => b2(a2(v));\nvar pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n// ../../node_modules/popmotion/dist/es/utils/mix-complex.mjs\nfunction getMixer(origin, target) {\n  if (isNum(origin)) {\n    return (v) => mix(origin, target, v);\n  } else if (color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return mixComplex(origin, target);\n  }\n}\nvar mixArray = (from, to) => {\n  const output = [...from];\n  const numValues = output.length;\n  const blendValue = from.map((fromThis, i2) => getMixer(fromThis, to[i2]));\n  return (v) => {\n    for (let i2 = 0; i2 < numValues; i2++) {\n      output[i2] = blendValue[i2](v);\n    }\n    return output;\n  };\n};\nvar mixObject = (origin, target) => {\n  const output = Object.assign(Object.assign({}, origin), target);\n  const blendValue = {};\n  for (const key in output) {\n    if (origin[key] !== void 0 && target[key] !== void 0) {\n      blendValue[key] = getMixer(origin[key], target[key]);\n    }\n  }\n  return (v) => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n    return output;\n  };\n};\nfunction analyse2(value) {\n  const parsed = complex.parse(value);\n  const numValues = parsed.length;\n  let numNumbers = 0;\n  let numRGB = 0;\n  let numHSL = 0;\n  for (let i2 = 0; i2 < numValues; i2++) {\n    if (numNumbers || typeof parsed[i2] === \"number\") {\n      numNumbers++;\n    } else {\n      if (parsed[i2].hue !== void 0) {\n        numHSL++;\n      } else {\n        numRGB++;\n      }\n    }\n  }\n  return { parsed, numNumbers, numRGB, numHSL };\n}\nvar mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyse2(origin);\n  const targetStats = analyse2(target);\n  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n  } else {\n    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return (p2) => `${p2 > 0 ? target : origin}`;\n  }\n};\n\n// ../../node_modules/popmotion/dist/es/utils/interpolate.mjs\nvar mixNumber = (from, to) => (p2) => mix(from, to, p2);\nfunction detectMixerFactory(v) {\n  if (typeof v === \"number\") {\n    return mixNumber;\n  } else if (typeof v === \"string\") {\n    if (color.test(v)) {\n      return mixColor;\n    } else {\n      return mixComplex;\n    }\n  } else if (Array.isArray(v)) {\n    return mixArray;\n  } else if (typeof v === \"object\") {\n    return mixObject;\n  }\n}\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || detectMixerFactory(output[0]);\n  const numMixers = output.length - 1;\n  for (let i2 = 0; i2 < numMixers; i2++) {\n    let mixer = mixerFactory(output[i2], output[i2 + 1]);\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i2] : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n    mixers.push(mixer);\n  }\n  return mixers;\n}\nfunction fastInterpolate([from, to], [mixer]) {\n  return (v) => mixer(progress(from, to, v));\n}\nfunction slowInterpolate(input, mixers) {\n  const inputLength = input.length;\n  const lastInputIndex = inputLength - 1;\n  return (v) => {\n    let mixerIndex = 0;\n    let foundMixerIndex = false;\n    if (v <= input[0]) {\n      foundMixerIndex = true;\n    } else if (v >= input[lastInputIndex]) {\n      mixerIndex = lastInputIndex - 1;\n      foundMixerIndex = true;\n    }\n    if (!foundMixerIndex) {\n      let i2 = 1;\n      for (; i2 < inputLength; i2++) {\n        if (input[i2] > v || i2 === lastInputIndex) {\n          break;\n        }\n      }\n      mixerIndex = i2 - 1;\n    }\n    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n    return mixers[mixerIndex](progressInRange);\n  };\n}\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n  const inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, \"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.\");\n  if (input[0] > input[inputLength - 1]) {\n    input = [].concat(input);\n    output = [].concat(output);\n    input.reverse();\n    output.reverse();\n  }\n  const mixers = createMixers(output, ease, mixer);\n  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);\n  return isClamp ? (v) => interpolator(clamp2(input[0], input[inputLength - 1], v)) : interpolator;\n}\n\n// ../../node_modules/popmotion/dist/es/easing/utils.mjs\nvar reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);\nvar mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;\nvar createExpoIn = (power) => (p2) => Math.pow(p2, power);\nvar createBackIn = (power) => (p2) => p2 * p2 * ((power + 1) * p2 - power);\nvar createAnticipate = (power) => {\n  const backEasing = createBackIn(power);\n  return (p2) => (p2 *= 2) < 1 ? 0.5 * backEasing(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));\n};\n\n// ../../node_modules/popmotion/dist/es/easing/index.mjs\nvar DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nvar BOUNCE_FIRST_THRESHOLD = 4 / 11;\nvar BOUNCE_SECOND_THRESHOLD = 8 / 11;\nvar BOUNCE_THIRD_THRESHOLD = 9 / 10;\nvar linear = (p2) => p2;\nvar easeIn = createExpoIn(2);\nvar easeOut = reverseEasing(easeIn);\nvar easeInOut = mirrorEasing(easeIn);\nvar circIn = (p2) => 1 - Math.sin(Math.acos(p2));\nvar circOut = reverseEasing(circIn);\nvar circInOut = mirrorEasing(circOut);\nvar backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nvar backOut = reverseEasing(backIn);\nvar backInOut = mirrorEasing(backIn);\nvar anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nvar ca = 4356 / 361;\nvar cb = 35442 / 1805;\nvar cc = 16061 / 1805;\nvar bounceOut = (p2) => {\n  if (p2 === 1 || p2 === 0)\n    return p2;\n  const p22 = p2 * p2;\n  return p2 < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p22 : p2 < BOUNCE_SECOND_THRESHOLD ? 9.075 * p22 - 9.9 * p2 + 3.4 : p2 < BOUNCE_THIRD_THRESHOLD ? ca * p22 - cb * p2 + cc : 10.8 * p2 * p2 - 20.52 * p2 + 10.72;\n};\nvar bounceIn = reverseEasing(bounceOut);\nvar bounceInOut = (p2) => p2 < 0.5 ? 0.5 * (1 - bounceOut(1 - p2 * 2)) : 0.5 * bounceOut(p2 * 2 - 1) + 0.5;\n\n// ../../node_modules/popmotion/dist/es/animations/generators/keyframes.mjs\nfunction defaultEasing(values, easing) {\n  return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n  const numValues = values.length;\n  return values.map((_value, i2) => i2 !== 0 ? i2 / (numValues - 1) : 0);\n}\nfunction convertOffsetToTimes(offset, duration) {\n  return offset.map((o) => o * duration);\n}\nfunction keyframes({ from = 0, to = 1, ease, offset, duration = 300 }) {\n  const state = { done: false, value: from };\n  const values = Array.isArray(to) ? to : [from, to];\n  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);\n  function createInterpolator() {\n    return interpolate(times, values, {\n      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)\n    });\n  }\n  let interpolator = createInterpolator();\n  return {\n    next: (t) => {\n      state.value = interpolator(t);\n      state.done = t >= duration;\n      return state;\n    },\n    flipTarget: () => {\n      values.reverse();\n      interpolator = createInterpolator();\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/animations/generators/decay.mjs\nfunction decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {\n  const state = { done: false, value: from };\n  let amplitude = power * velocity;\n  const ideal = from + amplitude;\n  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);\n  if (target !== ideal)\n    amplitude = target - from;\n  return {\n    next: (t) => {\n      const delta = -amplitude * Math.exp(-t / timeConstant);\n      state.done = !(delta > restDelta || delta < -restDelta);\n      state.value = state.done ? target : target + delta;\n      return state;\n    },\n    flipTarget: () => {\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs\nvar types = { keyframes, spring, decay };\nfunction detectAnimationFromOptions(config) {\n  if (Array.isArray(config.to)) {\n    return keyframes;\n  } else if (types[config.type]) {\n    return types[config.type];\n  }\n  const keys2 = new Set(Object.keys(config));\n  if (keys2.has(\"ease\") || keys2.has(\"duration\") && !keys2.has(\"dampingRatio\")) {\n    return keyframes;\n  } else if (keys2.has(\"dampingRatio\") || keys2.has(\"stiffness\") || keys2.has(\"mass\") || keys2.has(\"damping\") || keys2.has(\"restSpeed\") || keys2.has(\"restDelta\")) {\n    return spring;\n  }\n  return keyframes;\n}\n\n// ../../node_modules/framesync/dist/es/on-next-frame.mjs\nvar defaultTimestep = 1 / 60 * 1e3;\nvar getCurrentTime = typeof performance !== \"undefined\" ? () => performance.now() : () => Date.now();\nvar onNextFrame = typeof window !== \"undefined\" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);\n\n// ../../node_modules/framesync/dist/es/create-render-step.mjs\nfunction createRenderStep(runNextFrame2) {\n  let toRun = [];\n  let toRunNextFrame = [];\n  let numToRun = 0;\n  let isProcessing2 = false;\n  let flushNextFrame = false;\n  const toKeepAlive = /* @__PURE__ */ new WeakSet();\n  const step = {\n    schedule: (callback, keepAlive = false, immediate = false) => {\n      const addToCurrentFrame = immediate && isProcessing2;\n      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n      if (keepAlive)\n        toKeepAlive.add(callback);\n      if (buffer.indexOf(callback) === -1) {\n        buffer.push(callback);\n        if (addToCurrentFrame && isProcessing2)\n          numToRun = toRun.length;\n      }\n      return callback;\n    },\n    cancel: (callback) => {\n      const index2 = toRunNextFrame.indexOf(callback);\n      if (index2 !== -1)\n        toRunNextFrame.splice(index2, 1);\n      toKeepAlive.delete(callback);\n    },\n    process: (frameData) => {\n      if (isProcessing2) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing2 = true;\n      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\n      toRunNextFrame.length = 0;\n      numToRun = toRun.length;\n      if (numToRun) {\n        for (let i2 = 0; i2 < numToRun; i2++) {\n          const callback = toRun[i2];\n          callback(frameData);\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame2();\n          }\n        }\n      }\n      isProcessing2 = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\n\n// ../../node_modules/framesync/dist/es/index.mjs\nvar maxElapsed = 40;\nvar useDefaultElapsed = true;\nvar runNextFrame = false;\nvar isProcessing = false;\nvar frame = {\n  delta: 0,\n  timestamp: 0\n};\nvar stepsOrder = [\n  \"read\",\n  \"update\",\n  \"preRender\",\n  \"render\",\n  \"postRender\"\n];\nvar steps = stepsOrder.reduce((acc, key) => {\n  acc[key] = createRenderStep(() => runNextFrame = true);\n  return acc;\n}, {});\nvar sync = stepsOrder.reduce((acc, key) => {\n  const step = steps[key];\n  acc[key] = (process2, keepAlive = false, immediate = false) => {\n    if (!runNextFrame)\n      startLoop();\n    return step.schedule(process2, keepAlive, immediate);\n  };\n  return acc;\n}, {});\nvar cancelSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = steps[key].cancel;\n  return acc;\n}, {});\nvar flushSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = () => steps[key].process(frame);\n  return acc;\n}, {});\nvar processStep = (stepId) => steps[stepId].process(frame);\nvar processFrame = (timestamp) => {\n  runNextFrame = false;\n  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\n  frame.timestamp = timestamp;\n  isProcessing = true;\n  stepsOrder.forEach(processStep);\n  isProcessing = false;\n  if (runNextFrame) {\n    useDefaultElapsed = false;\n    onNextFrame(processFrame);\n  }\n};\nvar startLoop = () => {\n  runNextFrame = true;\n  useDefaultElapsed = true;\n  if (!isProcessing)\n    onNextFrame(processFrame);\n};\nvar getFrameData = () => frame;\nvar es_default = sync;\n\n// ../../node_modules/popmotion/dist/es/animations/utils/elapsed.mjs\nfunction loopElapsed(elapsed, duration, delay2 = 0) {\n  return elapsed - duration - delay2;\n}\nfunction reverseElapsed(elapsed, duration, delay2 = 0, isForwardPlayback = true) {\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay2) : duration - (elapsed - duration) + delay2;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay2, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay2 : elapsed <= -delay2;\n}\n\n// ../../node_modules/popmotion/dist/es/animations/index.mjs\nvar framesync = (update) => {\n  const passTimestamp = ({ delta }) => update(delta);\n  return {\n    start: () => es_default.update(passTimestamp, true),\n    stop: () => cancelSync.update(passTimestamp)\n  };\n};\nfunction animate(_a) {\n  var _b, _c;\n  var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n  let { to } = options;\n  let driverControls;\n  let repeatCount = 0;\n  let computedDuration = options.duration;\n  let latest;\n  let isComplete = false;\n  let isForwardPlayback = true;\n  let interpolateFromNumber;\n  const animator = detectAnimationFromOptions(options);\n  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n    interpolateFromNumber = interpolate([0, 100], [from, to], {\n      clamp: false\n    });\n    from = 0;\n    to = 100;\n  }\n  const animation = animator(Object.assign(Object.assign({}, options), { from, to }));\n  function repeat() {\n    repeatCount++;\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\")\n        animation.flipTarget();\n    }\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n  function complete() {\n    driverControls.stop();\n    onComplete && onComplete();\n  }\n  function update(delta) {\n    if (!isForwardPlayback)\n      delta = -delta;\n    elapsed += delta;\n    if (!isComplete) {\n      const state = animation.next(Math.max(0, elapsed));\n      latest = state.value;\n      if (interpolateFromNumber)\n        latest = interpolateFromNumber(latest);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n    if (isComplete) {\n      if (repeatCount === 0)\n        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n  function play() {\n    onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n  autoplay && play();\n  return {\n    stop: () => {\n      onStop === null || onStop === void 0 ? void 0 : onStop();\n      driverControls.stop();\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/velocity-per-second.mjs\nfunction velocityPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1e3 / frameDuration) : 0;\n}\n\n// ../../node_modules/popmotion/dist/es/animations/inertia.mjs\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {\n  let currentAnimation;\n  function isOutOfBounds(v) {\n    return min !== void 0 && v < min || max !== void 0 && v > max;\n  }\n  function boundaryNearest(v) {\n    if (min === void 0)\n      return max;\n    if (max === void 0)\n      return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  }\n  function startAnimation2(options) {\n    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n    currentAnimation = animate(Object.assign(Object.assign({}, options), {\n      driver,\n      onUpdate: (v) => {\n        var _a;\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n      },\n      onComplete,\n      onStop\n    }));\n  }\n  function startSpring(options) {\n    startAnimation2(Object.assign({ type: \"spring\", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));\n  }\n  if (isOutOfBounds(from)) {\n    startSpring({ from, velocity, to: boundaryNearest(from) });\n  } else {\n    let target = power * velocity + from;\n    if (typeof modifyTarget !== \"undefined\")\n      target = modifyTarget(target);\n    const boundary = boundaryNearest(target);\n    const heading = boundary === min ? -1 : 1;\n    let prev;\n    let current;\n    const checkBoundary = (v) => {\n      prev = current;\n      current = v;\n      velocity = velocityPerSecond(v - prev, getFrameData().delta);\n      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {\n        startSpring({ from: v, to: boundary, velocity });\n      }\n    };\n    startAnimation2({\n      type: \"decay\",\n      from,\n      velocity,\n      timeConstant,\n      power,\n      restDelta,\n      modifyTarget,\n      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0\n    });\n  }\n  return {\n    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/is-point.mjs\nvar isPoint = (point2) => point2.hasOwnProperty(\"x\") && point2.hasOwnProperty(\"y\");\n\n// ../../node_modules/popmotion/dist/es/utils/is-point-3d.mjs\nvar isPoint3D = (point2) => isPoint(point2) && point2.hasOwnProperty(\"z\");\n\n// ../../node_modules/popmotion/dist/es/utils/distance.mjs\nvar distance1D = (a2, b2) => Math.abs(a2 - b2);\nfunction distance(a2, b2) {\n  if (isNum(a2) && isNum(b2)) {\n    return distance1D(a2, b2);\n  } else if (isPoint(a2) && isPoint(b2)) {\n    const xDelta = distance1D(a2.x, b2.x);\n    const yDelta = distance1D(a2.y, b2.y);\n    const zDelta = isPoint3D(a2) && isPoint3D(b2) ? distance1D(a2.z, b2.z) : 0;\n    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n  }\n}\n\n// ../../node_modules/popmotion/dist/es/easing/cubic-bezier.mjs\nvar a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\nvar b = (a1, a2) => 3 * a2 - 6 * a1;\nvar c2 = (a1) => 3 * a1;\nvar calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c2(a1)) * t;\nvar getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c2(a1);\nvar subdivisionPrecision = 1e-7;\nvar subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX;\n  let currentT;\n  let i2 = 0;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);\n  return currentT;\n}\nvar newtonIterations = 8;\nvar newtonMinSlope = 1e-3;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i2 = 0; i2 < newtonIterations; ++i2) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0) {\n      return aGuessT;\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  if (mX1 === mY1 && mX2 === mY2)\n    return linear;\n  const sampleValues = new Float32Array(kSplineTableSize);\n  for (let i2 = 0; i2 < kSplineTableSize; ++i2) {\n    sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);\n  }\n  function getTForX(aX) {\n    let intervalStart = 0;\n    let currentSample = 1;\n    const lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= newtonMinSlope) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs\nfunction useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement }) {\n  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  const isPressing = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n  const cancelPointerEndListeners = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const eventOptions = {\n    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)\n  };\n  function removePointerEndListener() {\n    cancelPointerEndListeners.current && cancelPointerEndListeners.current();\n    cancelPointerEndListeners.current = null;\n  }\n  function checkPointerEnd() {\n    removePointerEndListener();\n    isPressing.current = false;\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, false);\n    return !isDragActive();\n  }\n  function onPointerUp(event, info) {\n    if (!checkPointerEnd())\n      return;\n    !isNodeOrChild(visualElement.current, event.target) ? onTapCancel && onTapCancel(event, info) : onTap && onTap(event, info);\n  }\n  function onPointerCancel(event, info) {\n    if (!checkPointerEnd())\n      return;\n    onTapCancel && onTapCancel(event, info);\n  }\n  function onPointerDown(event, info) {\n    removePointerEndListener();\n    if (isPressing.current)\n      return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, true);\n    onTapStart && onTapStart(event, info);\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : void 0, eventOptions);\n  useUnmountEffect(removePointerEndListener);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/process.mjs\nvar defaultEnvironment = \"production\";\nvar env = typeof process === \"undefined\" || process.env === void 0 ? defaultEnvironment : \"development\" || 0;\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/utils/warn-once.mjs\nvar warned = /* @__PURE__ */ new Set();\nfunction warnOnce(condition, message, element) {\n  if (condition || warned.has(message))\n    return;\n  console.warn(message);\n  if (element)\n    console.warn(element);\n  warned.add(message);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs\nvar observerCallbacks = /* @__PURE__ */ new WeakMap();\nvar observers = /* @__PURE__ */ new WeakMap();\nvar fireObserverCallback = (entry) => {\n  const callback = observerCallbacks.get(entry.target);\n  callback && callback(entry);\n};\nvar fireAllObserverCallbacks = (entries) => {\n  entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_a) {\n  var _b = _a, { root } = _b, options = __objRest(_b, [\"root\"]);\n  const lookupRoot = root || document;\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n  const rootObservers = observers.get(lookupRoot);\n  const key = JSON.stringify(options);\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __spreadValues({ root }, options));\n  }\n  return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n  const rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return () => {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs\nfunction useViewport({ visualElement, whileInView, onViewportEnter, onViewportLeave, viewport = {} }) {\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n    hasEnteredView: false,\n    isInView: false\n  });\n  let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n  if (viewport.once && state.current.hasEnteredView)\n    shouldObserve = false;\n  const useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n  useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nvar thresholdNames = {\n  some: 0,\n  all: 1\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, { root, margin: rootMargin, amount = \"some\", once }) {\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!shouldObserve || !visualElement.current)\n      return;\n    const options = {\n      root: root === null || root === void 0 ? void 0 : root.current,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    const intersectionCallback = (entry) => {\n      const { isIntersecting } = entry;\n      if (state.isInView === isIntersecting)\n        return;\n      state.isInView = isIntersecting;\n      if (once && !isIntersecting && state.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        state.hasEnteredView = true;\n      }\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, isIntersecting);\n      }\n      const props = visualElement.getProps();\n      const callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(visualElement.current, options, intersectionCallback);\n  }, [shouldObserve, root, rootMargin, amount]);\n}\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, { fallback = true }) {\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!shouldObserve || !fallback)\n      return;\n    if (env !== \"production\") {\n      warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n    }\n    requestAnimationFrame(() => {\n      state.hasEnteredView = true;\n      const { onViewportEnter } = visualElement.getProps();\n      onViewportEnter && onViewportEnter(null);\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, true);\n      }\n    });\n  }, [shouldObserve]);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/make-renderless-component.mjs\nvar makeRenderlessComponent = (hook) => (props) => {\n  hook(props);\n  return null;\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/gestures.mjs\nvar gestureAnimations = {\n  inView: makeRenderlessComponent(useViewport),\n  tap: makeRenderlessComponent(useTapGesture),\n  focus: makeRenderlessComponent(useFocusGesture),\n  hover: makeRenderlessComponent(useHoverGesture)\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/animations.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs\n\nfunction usePresence() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PresenceContext);\n  if (context === null)\n    return [true, null];\n  const { isPresent, onExitComplete, register } = context;\n  const id2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useId)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => register(id2), []);\n  const safeToRemove = () => onExitComplete && onExitComplete(id2);\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/shallow-compare.mjs\nfunction shallowCompare(next, prev) {\n  if (!Array.isArray(prev))\n    return false;\n  const prevLength = prev.length;\n  if (prevLength !== next.length)\n    return false;\n  for (let i2 = 0; i2 < prevLength; i2++) {\n    if (prev[i2] !== next[i2])\n      return false;\n  }\n  return true;\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/time-conversion.mjs\nvar secondsToMilliseconds = (seconds) => seconds * 1e3;\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/easing.mjs\nvar easingLookup = {\n  linear,\n  easeIn,\n  easeInOut,\n  easeOut,\n  circIn,\n  circInOut,\n  circOut,\n  backIn,\n  backInOut,\n  backOut,\n  anticipate,\n  bounceIn,\n  bounceInOut,\n  bounceOut\n};\nvar easingDefinitionToFunction = (definition) => {\n  if (Array.isArray(definition)) {\n    invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n    const [x1, y1, x2, y2] = definition;\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);\n    return easingLookup[definition];\n  }\n  return definition;\n};\nvar isEasingArray = (ease) => {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs\nvar isAnimatable = (key, value) => {\n  if (key === \"zIndex\")\n    return false;\n  if (typeof value === \"number\" || Array.isArray(value))\n    return true;\n  if (typeof value === \"string\" && complex.test(value) && !value.startsWith(\"url(\")) {\n    return true;\n  }\n  return false;\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs\nvar underDampedSpring = () => ({\n  type: \"spring\",\n  stiffness: 500,\n  damping: 25,\n  restSpeed: 10\n});\nvar criticallyDampedSpring = (to) => ({\n  type: \"spring\",\n  stiffness: 550,\n  damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n  restSpeed: 10\n});\nvar linearTween = () => ({\n  type: \"keyframes\",\n  ease: \"linear\",\n  duration: 0.3\n});\nvar keyframes2 = (values) => ({\n  type: \"keyframes\",\n  duration: 0.8,\n  values\n});\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: criticallyDampedSpring,\n  scaleY: criticallyDampedSpring,\n  scale: criticallyDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: criticallyDampedSpring\n};\nvar getDefaultTransition = (valueKey, to) => {\n  let transitionFactory;\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes2;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n  return __spreadValues({ to }, transitionFactory(to));\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs\nvar defaultValueTypes = __spreadProps(__spreadValues({}, numberValueTypes), {\n  color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  filter,\n  WebkitFilter: filter\n});\nvar getDefaultValueType = (key) => defaultValueTypes[key];\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs\nfunction getAnimatableNone2(key, value) {\n  var _a;\n  let defaultValueType = getDefaultValueType(key);\n  if (defaultValueType !== filter)\n    defaultValueType = complex;\n  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs\nvar instantAnimationState = {\n  current: false\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/delay.mjs\nfunction delay(callback, timeout) {\n  const start = performance.now();\n  const checkElapsed = ({ timestamp }) => {\n    const elapsed = timestamp - start;\n    if (elapsed >= timeout) {\n      cancelSync.read(checkElapsed);\n      callback(elapsed - timeout);\n    }\n  };\n  es_default.read(checkElapsed, true);\n  return () => cancelSync.read(checkElapsed);\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/transitions.mjs\nfunction isTransitionDefined(_a) {\n  var _b = _a, { when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from } = _b, transition = __objRest(_b, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n  return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\nfunction convertTransitionToAnimationOptions(_a) {\n  var _b = _a, { ease, times, yoyo, flip, loop } = _b, transition = __objRest(_b, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n  const options = __spreadValues({}, transition);\n  if (times)\n    options[\"offset\"] = times;\n  if (transition.duration)\n    options[\"duration\"] = secondsToMilliseconds(transition.duration);\n  if (transition.repeatDelay)\n    options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n  if (ease) {\n    options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  }\n  if (transition.type === \"tween\")\n    options.type = \"keyframes\";\n  if (yoyo || loop || flip) {\n    warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n    legacyRepeatWarning = true;\n    if (yoyo) {\n      options.repeatType = \"reverse\";\n    } else if (loop) {\n      options.repeatType = \"loop\";\n    } else if (flip) {\n      options.repeatType = \"mirror\";\n    }\n    options.repeat = loop || yoyo || flip || transition.repeat;\n  }\n  if (transition.type !== \"spring\")\n    options.type = \"keyframes\";\n  return options;\n}\nfunction getDelayFromTransition(transition, key) {\n  var _a, _b;\n  const valueTransition = getValueTransition(transition, key) || {};\n  return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\nfunction hydrateKeyframes(options) {\n  if (Array.isArray(options.to) && options.to[0] === null) {\n    options.to = [...options.to];\n    options.to[0] = options.from;\n  }\n  return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n  if (Array.isArray(options.to) && transition.duration === void 0) {\n    transition.duration = 0.8;\n  }\n  hydrateKeyframes(options);\n  if (!isTransitionDefined(transition)) {\n    transition = __spreadValues(__spreadValues({}, transition), getDefaultTransition(key, options.to));\n  }\n  return __spreadValues(__spreadValues({}, options), convertTransitionToAnimationOptions(transition));\n}\nfunction getAnimation(key, value, target, transition, onComplete) {\n  const valueTransition = getValueTransition(transition, key) || {};\n  let origin = valueTransition.from !== void 0 ? valueTransition.from : value.get();\n  const isTargetAnimatable = isAnimatable(key, target);\n  if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n    origin = getAnimatableNone2(key, target);\n  } else if (isZero(origin) && typeof target === \"string\") {\n    origin = getZeroUnit(target);\n  } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n    target = getZeroUnit(origin);\n  }\n  const isOriginAnimatable = isAnimatable(key, origin);\n  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${key} from \"${origin}\" to \"${target}\". ${origin} is not an animatable value - to enable this animation set ${origin} to a value animatable to ${target} via the \\`style\\` property.`);\n  function start() {\n    const options = {\n      from: origin,\n      to: target,\n      velocity: value.getVelocity(),\n      onComplete,\n      onUpdate: (v) => value.set(v)\n    };\n    return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? inertia(__spreadValues(__spreadValues({}, options), valueTransition)) : animate(__spreadProps(__spreadValues({}, getPopmotionAnimationOptions(valueTransition, options, key)), {\n      onUpdate: (v) => {\n        options.onUpdate(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: () => {\n        options.onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      }\n    }));\n  }\n  function set() {\n    const finalTarget = resolveFinalValueInKeyframes(target);\n    value.set(finalTarget);\n    onComplete();\n    valueTransition.onUpdate && valueTransition.onUpdate(finalTarget);\n    valueTransition.onComplete && valueTransition.onComplete();\n    return { stop: () => {\n    } };\n  }\n  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\nfunction isZero(value) {\n  return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\nfunction getZeroUnit(potentialUnitType) {\n  return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone2(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\nfunction startAnimation(key, value, target, transition = {}) {\n  if (instantAnimationState.current) {\n    transition = { type: false };\n  }\n  return value.start((onComplete) => {\n    let controls;\n    const animation = getAnimation(key, value, target, transition, onComplete);\n    const delayBy = getDelayFromTransition(transition, key);\n    const start = () => controls = animation();\n    let cancelDelay;\n    if (delayBy) {\n      cancelDelay = delay(start, secondsToMilliseconds(delayBy));\n    } else {\n      start();\n    }\n    return () => {\n      cancelDelay && cancelDelay();\n      controls && controls.stop();\n    };\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs\nvar isNumericalString = (v) => /^\\-?\\d*\\.?\\d+$/.test(v);\n\n// ../../node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs\nvar isZeroValueString = (v) => /^0[^.\\s]+$/.test(v);\n\n// ../../node_modules/framer-motion/dist/es/utils/array.mjs\nfunction addUniqueItem(arr, item) {\n  if (arr.indexOf(item) === -1)\n    arr.push(item);\n}\nfunction removeItem(arr, item) {\n  const index2 = arr.indexOf(item);\n  if (index2 > -1)\n    arr.splice(index2, 1);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/subscription-manager.mjs\nvar SubscriptionManager = class {\n  constructor() {\n    this.subscriptions = [];\n  }\n  add(handler) {\n    addUniqueItem(this.subscriptions, handler);\n    return () => removeItem(this.subscriptions, handler);\n  }\n  notify(a2, b2, c3) {\n    const numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions)\n      return;\n    if (numSubscriptions === 1) {\n      this.subscriptions[0](a2, b2, c3);\n    } else {\n      for (let i2 = 0; i2 < numSubscriptions; i2++) {\n        const handler = this.subscriptions[i2];\n        handler && handler(a2, b2, c3);\n      }\n    }\n  }\n  getSize() {\n    return this.subscriptions.length;\n  }\n  clear() {\n    this.subscriptions.length = 0;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/value/index.mjs\nvar isFloat = (value) => {\n  return !isNaN(parseFloat(value));\n};\nvar MotionValue = class {\n  constructor(init) {\n    this.version = \"7.6.7\";\n    this.timeDelta = 0;\n    this.lastUpdated = 0;\n    this.updateSubscribers = new SubscriptionManager();\n    this.velocityUpdateSubscribers = new SubscriptionManager();\n    this.renderSubscribers = new SubscriptionManager();\n    this.canTrackVelocity = false;\n    this.updateAndNotify = (v, render = true) => {\n      this.prev = this.current;\n      this.current = v;\n      const { delta, timestamp } = getFrameData();\n      if (this.lastUpdated !== timestamp) {\n        this.timeDelta = delta;\n        this.lastUpdated = timestamp;\n        es_default.postRender(this.scheduleVelocityCheck);\n      }\n      if (this.prev !== this.current) {\n        this.updateSubscribers.notify(this.current);\n      }\n      if (this.velocityUpdateSubscribers.getSize()) {\n        this.velocityUpdateSubscribers.notify(this.getVelocity());\n      }\n      if (render) {\n        this.renderSubscribers.notify(this.current);\n      }\n    };\n    this.scheduleVelocityCheck = () => es_default.postRender(this.velocityCheck);\n    this.velocityCheck = ({ timestamp }) => {\n      if (timestamp !== this.lastUpdated) {\n        this.prev = this.current;\n        this.velocityUpdateSubscribers.notify(this.getVelocity());\n      }\n    };\n    this.hasAnimated = false;\n    this.prev = this.current = init;\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  onChange(subscription) {\n    return this.updateSubscribers.add(subscription);\n  }\n  clearListeners() {\n    this.updateSubscribers.clear();\n  }\n  onRenderRequest(subscription) {\n    subscription(this.get());\n    return this.renderSubscribers.add(subscription);\n  }\n  attach(passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  }\n  set(v, render = true) {\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  }\n  get() {\n    return this.current;\n  }\n  getPrevious() {\n    return this.prev;\n  }\n  getVelocity() {\n    return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  }\n  start(animation) {\n    this.stop();\n    return new Promise((resolve) => {\n      this.hasAnimated = true;\n      this.stopAnimation = animation(resolve);\n    }).then(() => this.clearAnimation());\n  }\n  stop() {\n    if (this.stopAnimation)\n      this.stopAnimation();\n    this.clearAnimation();\n  }\n  isAnimating() {\n    return !!this.stopAnimation;\n  }\n  clearAnimation() {\n    this.stopAnimation = null;\n  }\n  destroy() {\n    this.updateSubscribers.clear();\n    this.renderSubscribers.clear();\n    this.stop();\n  }\n};\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs\nvar testValueType = (v) => (type) => type.test(v);\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs\nvar auto = {\n  test: (v) => v === \"auto\",\n  parse: (v) => v\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\nvar findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs\nvar valueTypes = [...dimensionValueTypes, color, complex];\nvar findValueType = (v) => valueTypes.find(testValueType(v));\n\n// ../../node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs\nfunction getCurrent(visualElement) {\n  const current = {};\n  visualElement.values.forEach((value, key) => current[key] = value.get());\n  return current;\n}\nfunction getVelocity(visualElement) {\n  const velocity = {};\n  visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());\n  return velocity;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n  const props = visualElement.getProps();\n  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/setters.mjs\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\nfunction setTarget(visualElement, definition) {\n  const resolved = resolveVariant(visualElement, definition);\n  let _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {}, { transitionEnd = {}, transition = {} } = _a, target = __objRest(_a, [\"transitionEnd\", \"transition\"]);\n  target = __spreadValues(__spreadValues({}, target), transitionEnd);\n  for (const key in target) {\n    const value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b;\n  const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));\n  const numNewValues = newValueKeys.length;\n  if (!numNewValues)\n    return;\n  for (let i2 = 0; i2 < numNewValues; i2++) {\n    const key = newValueKeys[i2];\n    const targetValue = target[key];\n    let value = null;\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    if (value === void 0 || value === null)\n      continue;\n    if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone2(key, targetValue);\n    }\n    visualElement.addValue(key, motionValue(value));\n    if (origin[key] === void 0) {\n      origin[key] = value;\n    }\n    if (value !== null)\n      visualElement.setBaseTarget(key, value);\n  }\n}\nfunction getOriginFromTransition(key, transition) {\n  if (!transition)\n    return;\n  const valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n  var _a;\n  const origin = {};\n  for (const key in target) {\n    const transitionOrigin = getOriginFromTransition(key, transition);\n    origin[key] = transitionOrigin !== void 0 ? transitionOrigin : (_a = visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.get();\n  }\n  return origin;\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-will-change/is.mjs\nfunction isWillChangeMotionValue(value) {\n  return Boolean(isMotionValue(value) && value.add);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/animation.mjs\nfunction animateVisualElement(visualElement, definition, options = {}) {\n  visualElement.notify(\"AnimationStart\", definition);\n  let animation;\n  if (Array.isArray(definition)) {\n    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));\n    animation = Promise.all(animations2);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    const resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n  return animation.then(() => visualElement.notify(\"AnimationComplete\", definition));\n}\nfunction animateVariant(visualElement, variant, options = {}) {\n  var _a;\n  const resolved = resolveVariant(visualElement, variant, options.custom);\n  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  const getAnimation2 = resolved ? () => animateTarget(visualElement, resolved, options) : () => Promise.resolve();\n  const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? (forwardDelay = 0) => {\n    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  const { when } = transition;\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2];\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);\n  }\n}\nfunction animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {\n  var _a;\n  let _a2 = visualElement.makeTargetAnimatable(definition), { transition = visualElement.getDefaultTransition(), transitionEnd } = _a2, target = __objRest(_a2, [\"transition\", \"transitionEnd\"]);\n  const willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride)\n    transition = transitionOverride;\n  const animations2 = [];\n  const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n  for (const key in target) {\n    const value = visualElement.getValue(key);\n    const valueTarget = target[key];\n    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n    let valueTransition = __spreadValues({ delay: delay2 }, transition);\n    if (visualElement.shouldReduceMotion && transformProps.has(key)) {\n      valueTransition = __spreadProps(__spreadValues({}, valueTransition), {\n        type: false,\n        delay: 0\n      });\n    }\n    let animation = startAnimation(key, value, valueTarget, valueTransition);\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation = animation.then(() => willChange.remove(key));\n    }\n    animations2.push(animation);\n  }\n  return Promise.all(animations2).then(() => {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n  const animations2 = [];\n  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {\n    animations2.push(animateVariant(child, variant, __spreadProps(__spreadValues({}, options), {\n      delay: delayChildren + generateStaggerDuration(i2)\n    })).then(() => child.notify(\"AnimationComplete\", variant)));\n  });\n  return Promise.all(animations2);\n}\nfunction sortByTreeOrder(a2, b2) {\n  return a2.sortNodePosition(b2);\n}\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs\nvar variantPriorityOrder = [\n  AnimationType.Animate,\n  AnimationType.InView,\n  AnimationType.Focus,\n  AnimationType.Hover,\n  AnimationType.Tap,\n  AnimationType.Drag,\n  AnimationType.Exit\n];\nvar reversePriorityOrder = [...variantPriorityOrder].reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n  let animate3 = animateList(visualElement);\n  const state = createState();\n  let isInitialRender = true;\n  const buildResolvedTypeValues = (acc, definition) => {\n    const resolved = resolveVariant(visualElement, definition);\n    if (resolved) {\n      const _a = resolved, { transition, transitionEnd } = _a, target = __objRest(_a, [\"transition\", \"transitionEnd\"]);\n      acc = __spreadValues(__spreadValues(__spreadValues({}, acc), target), transitionEnd);\n    }\n    return acc;\n  };\n  function setAnimateFunction(makeAnimator) {\n    animate3 = makeAnimator(visualElement);\n  }\n  function animateChanges(options, changedActiveType) {\n    var _a;\n    const props = visualElement.getProps();\n    const context = visualElement.getVariantContext(true) || {};\n    const animations2 = [];\n    const removedKeys = /* @__PURE__ */ new Set();\n    let encounteredKeys = {};\n    let removedVariantIndex = Infinity;\n    for (let i2 = 0; i2 < numAnimationTypes; i2++) {\n      const type = reversePriorityOrder[i2];\n      const typeState = state[type];\n      const prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      const propIsVariant = isVariantLabel(prop);\n      const activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false)\n        removedVariantIndex = i2;\n      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      typeState.protectedKeys = __spreadValues({}, encounteredKeys);\n      if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop === \"boolean\") {\n        continue;\n      }\n      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n      let shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i2 > removedVariantIndex && propIsVariant;\n      const definitionList = Array.isArray(prop) ? prop : [prop];\n      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false)\n        resolvedValues = {};\n      const { prevResolvedValues = {} } = typeState;\n      const allKeys = __spreadValues(__spreadValues({}, prevResolvedValues), resolvedValues);\n      const markToAnimate = (key) => {\n        shouldAnimateType = true;\n        removedKeys.delete(key);\n        typeState.needsAnimating[key] = true;\n      };\n      for (const key in allKeys) {\n        const next = resolvedValues[key];\n        const prev = prevResolvedValues[key];\n        if (encounteredKeys.hasOwnProperty(key))\n          continue;\n        if (next !== prev) {\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev) || variantDidChange) {\n              markToAnimate(key);\n            } else {\n              typeState.protectedKeys[key] = true;\n            }\n          } else if (next !== void 0) {\n            markToAnimate(key);\n          } else {\n            removedKeys.add(key);\n          }\n        } else if (next !== void 0 && removedKeys.has(key)) {\n          markToAnimate(key);\n        } else {\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      if (typeState.isActive) {\n        encounteredKeys = __spreadValues(__spreadValues({}, encounteredKeys), resolvedValues);\n      }\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      if (shouldAnimateType && !isInherited) {\n        animations2.push(...definitionList.map((animation) => ({\n          animation,\n          options: __spreadValues({ type }, options)\n        })));\n      }\n    }\n    if (removedKeys.size) {\n      const fallbackAnimation = {};\n      removedKeys.forEach((key) => {\n        const fallbackTarget = visualElement.getBaseTarget(key);\n        if (fallbackTarget !== void 0) {\n          fallbackAnimation[key] = fallbackTarget;\n        }\n      });\n      animations2.push({ animation: fallbackAnimation });\n    }\n    let shouldAnimate = Boolean(animations2.length);\n    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n    isInitialRender = false;\n    return shouldAnimate ? animate3(animations2) : Promise.resolve();\n  }\n  function setActive(type, isActive, options) {\n    var _a;\n    if (state[type].isActive === isActive)\n      return Promise.resolve();\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\n      var _a2;\n      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    const animations2 = animateChanges(options, type);\n    for (const key in state) {\n      state[key].protectedKeys = {};\n    }\n    return animations2;\n  }\n  return {\n    animateChanges,\n    setActive,\n    setAnimateFunction,\n    getState: () => state\n  };\n}\nfunction checkVariantsDidChange(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (Array.isArray(next)) {\n    return !shallowCompare(next, prev);\n  }\n  return false;\n}\nfunction createTypeState(isActive = false) {\n  return {\n    isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction createState() {\n  return {\n    [AnimationType.Animate]: createTypeState(true),\n    [AnimationType.InView]: createTypeState(),\n    [AnimationType.Hover]: createTypeState(),\n    [AnimationType.Tap]: createTypeState(),\n    [AnimationType.Drag]: createTypeState(),\n    [AnimationType.Focus]: createTypeState(),\n    [AnimationType.Exit]: createTypeState()\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/animations.mjs\nvar animations = {\n  animation: makeRenderlessComponent(({ visualElement, animate: animate3 }) => {\n    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n    if (isAnimationControls(animate3)) {\n      (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => animate3.subscribe(visualElement), [animate3]);\n    }\n  }),\n  exit: makeRenderlessComponent((props) => {\n    const { custom, visualElement } = props;\n    const [isPresent, safeToRemove] = usePresence();\n    const presenceContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PresenceContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      visualElement.isPresent = isPresent;\n      const animation = visualElement.animationState && visualElement.animationState.setActive(AnimationType.Exit, !isPresent, {\n        custom: presenceContext && presenceContext.custom || custom\n      });\n      if (animation && !isPresent) {\n        animation.then(safeToRemove);\n      }\n    }, [isPresent]);\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/gestures/PanSession.mjs\nvar PanSession = class {\n  constructor(event, handlers, { transformPagePoint } = {}) {\n    this.startEvent = null;\n    this.lastMoveEvent = null;\n    this.lastMoveEventInfo = null;\n    this.handlers = {};\n    this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n        return;\n      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      const isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold)\n        return;\n      const { point: point3 } = info2;\n      const { timestamp: timestamp2 } = getFrameData();\n      this.history.push(__spreadProps(__spreadValues({}, point3), { timestamp: timestamp2 }));\n      const { onStart, onMove } = this.handlers;\n      if (!isPanStarted) {\n        onStart && onStart(this.lastMoveEvent, info2);\n        this.startEvent = this.lastMoveEvent;\n      }\n      onMove && onMove(this.lastMoveEvent, info2);\n    };\n    this.handlePointerMove = (event2, info2) => {\n      this.lastMoveEvent = event2;\n      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);\n      if (isMouseEvent(event2) && event2.buttons === 0) {\n        this.handlePointerUp(event2, info2);\n        return;\n      }\n      es_default.update(this.updatePoint, true);\n    };\n    this.handlePointerUp = (event2, info2) => {\n      this.end();\n      const { onEnd, onSessionEnd } = this.handlers;\n      const panInfo = getPanInfo(transformPoint(info2, this.transformPagePoint), this.history);\n      if (this.startEvent && onEnd) {\n        onEnd(event2, panInfo);\n      }\n      onSessionEnd && onSessionEnd(event2, panInfo);\n    };\n    if (isTouchEvent(event) && event.touches.length > 1)\n      return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    const info = extractEventInfo(event);\n    const initialInfo = transformPoint(info, this.transformPagePoint);\n    const { point: point2 } = initialInfo;\n    const { timestamp } = getFrameData();\n    this.history = [__spreadProps(__spreadValues({}, point2), { timestamp })];\n    const { onSessionStart } = handlers;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n  }\n};\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a2, b2) {\n  return { x: a2.x - b2.x, y: a2.y - b2.y };\n}\nfunction getPanInfo({ point: point2 }, history) {\n  return {\n    point: point2,\n    delta: subtractPoint(point2, lastDevicePoint(history)),\n    offset: subtractPoint(point2, startDevicePoint(history)),\n    velocity: getVelocity2(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity2(history, timeDelta) {\n  if (history.length < 2) {\n    return { x: 0, y: 0 };\n  }\n  let i2 = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n  while (i2 >= 0) {\n    timestampedPoint = history[i2];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n    i2--;\n  }\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 };\n  }\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n  if (time === 0) {\n    return { x: 0, y: 0 };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\nfunction isNear(value, target = 0, maxDistance = 0.01) {\n  return distance(value, target) < maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n  delta.origin = origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))\n    delta.scale = 1;\n  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate) || isNaN(delta.translate))\n    delta.translate = 0;\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);\n  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n  calcRelativeAxis(target.x, relative.x, parent.x);\n  calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n  target.min = layout.min - parent.min;\n  target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n  calcRelativeAxisPosition(target.x, layout.x, parent.x);\n  calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs\nfunction applyConstraints(point2, { min, max }, elastic) {\n  if (min !== void 0 && point2 < min) {\n    point2 = elastic ? mix(min, point2, elastic.min) : Math.max(point2, min);\n  } else if (max !== void 0 && point2 > max) {\n    point2 = elastic ? mix(max, point2, elastic.max) : Math.min(point2, max);\n  }\n  return point2;\n}\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== void 0 ? axis.min + min : void 0,\n    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0\n  };\n}\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  let min = constraintsAxis.min - layoutAxis.min;\n  let max = constraintsAxis.max - layoutAxis.max;\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    [min, max] = [max, min];\n  }\n  return { min, max };\n}\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\nfunction calcOrigin2(source, target) {\n  let origin = 0.5;\n  const sourceLength = calcLength(source);\n  const targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n  return clamp2(0, 1, origin);\n}\nfunction rebaseAxisConstraints(layout, constraints) {\n  const relativeConstraints = {};\n  if (constraints.min !== void 0) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n  if (constraints.max !== void 0) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n  return relativeConstraints;\n}\nvar defaultElastic = 0.35;\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\nfunction resolvePointElastic(dragElastic, label) {\n  var _a;\n  return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/models.mjs\nvar createAxisDelta = () => ({\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n});\nvar createDelta = () => ({\n  x: createAxisDelta(),\n  y: createAxisDelta()\n});\nvar createAxis = () => ({ min: 0, max: 0 });\nvar createBox = () => ({\n  x: createAxis(),\n  y: createAxis()\n});\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs\nfunction eachAxis(callback) {\n  return [callback(\"x\"), callback(\"y\")];\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs\nfunction convertBoundingBoxToBox({ top, left, right, bottom }) {\n  return {\n    x: { min: left, max: right },\n    y: { min: top, max: bottom }\n  };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n  return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\nfunction transformBoxPoints(point2, transformPoint2) {\n  if (!transformPoint2)\n    return point2;\n  const topLeft = transformPoint2({ x: point2.left, y: point2.top });\n  const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs\nfunction isIdentityScale(scale2) {\n  return scale2 === void 0 || scale2 === 1;\n}\nfunction hasScale({ scale: scale2, scaleX, scaleY }) {\n  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);\n}\nfunction hasTransform(values) {\n  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;\n}\nfunction has2DTranslate(values) {\n  return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n  return value && value !== \"0%\";\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs\nfunction scalePoint(point2, scale2, originPoint) {\n  const distanceFromOrigin = point2 - originPoint;\n  const scaled = scale2 * distanceFromOrigin;\n  return originPoint + scaled;\n}\nfunction applyPointDelta(point2, translate, scale2, originPoint, boxScale) {\n  if (boxScale !== void 0) {\n    point2 = scalePoint(point2, boxScale, originPoint);\n  }\n  return scalePoint(point2, scale2, originPoint) + translate;\n}\nfunction applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {\n  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction applyBoxDelta(box, { x, y }) {\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n  var _a, _b;\n  const treeLength = treePath.length;\n  if (!treeLength)\n    return;\n  treeScale.x = treeScale.y = 1;\n  let node;\n  let delta;\n  for (let i2 = 0; i2 < treeLength; i2++) {\n    node = treePath[i2];\n    delta = node.projectionDelta;\n    if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === \"contents\")\n      continue;\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });\n    }\n    if (delta) {\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale;\n      applyBoxDelta(box, delta);\n    }\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n}\nfunction translateAxis(axis, distance2) {\n  axis.min = axis.min + distance2;\n  axis.max = axis.max + distance2;\n}\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\n  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;\n  const originPoint = mix(axis.min, axis.max, axisOrigin);\n  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform, xKeys);\n  transformAxis(box.y, transform, yKeys);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/utils/measure.mjs\nfunction measureViewportBox(instance, transformPoint2) {\n  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));\n}\nfunction measurePageBox(element, rootProjectionNode2, transformPagePoint) {\n  const viewportBox = measureViewportBox(element, transformPagePoint);\n  const { scroll: scroll2 } = rootProjectionNode2;\n  if (scroll2) {\n    translateAxis(viewportBox.x, scroll2.x);\n    translateAxis(viewportBox.y, scroll2.y);\n  }\n  return viewportBox;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs\nvar elementDragControls = /* @__PURE__ */ new WeakMap();\nvar VisualElementDragControls = class {\n  constructor(visualElement) {\n    this.openGlobalLock = null;\n    this.isDragging = false;\n    this.currentDirection = null;\n    this.originPoint = { x: 0, y: 0 };\n    this.constraints = false;\n    this.hasMutatedConstraints = false;\n    this.elastic = createBox();\n    this.visualElement = visualElement;\n  }\n  start(originEvent, { snapToCursor = false } = {}) {\n    if (this.visualElement.isPresent === false)\n      return;\n    const onSessionStart = (event) => {\n      this.stopAnimation();\n      if (snapToCursor) {\n        this.snapToCursor(extractEventInfo(event, \"page\").point);\n      }\n    };\n    const onStart = (event, info) => {\n      var _a;\n      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();\n      if (drag2 && !dragPropagation) {\n        if (this.openGlobalLock)\n          this.openGlobalLock();\n        this.openGlobalLock = getGlobalLock(drag2);\n        if (!this.openGlobalLock)\n          return;\n      }\n      this.isDragging = true;\n      this.currentDirection = null;\n      this.resolveConstraints();\n      if (this.visualElement.projection) {\n        this.visualElement.projection.isAnimationBlocked = true;\n        this.visualElement.projection.target = void 0;\n      }\n      eachAxis((axis) => {\n        var _a2, _b;\n        let current = this.getAxisMotionValue(axis).get() || 0;\n        if (percent.test(current)) {\n          const measuredAxis = (_b = (_a2 = this.visualElement.projection) === null || _a2 === void 0 ? void 0 : _a2.layout) === null || _b === void 0 ? void 0 : _b.layoutBox[axis];\n          if (measuredAxis) {\n            const length = calcLength(measuredAxis);\n            current = length * (parseFloat(current) / 100);\n          }\n        }\n        this.originPoint[axis] = current;\n      });\n      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);\n      (_a = this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Drag, true);\n    };\n    const onMove = (event, info) => {\n      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();\n      if (!dragPropagation && !this.openGlobalLock)\n        return;\n      const { offset } = info;\n      if (dragDirectionLock && this.currentDirection === null) {\n        this.currentDirection = getCurrentDirection(offset);\n        if (this.currentDirection !== null) {\n          onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(this.currentDirection);\n        }\n        return;\n      }\n      this.updateAxis(\"x\", info.point, offset);\n      this.updateAxis(\"y\", info.point, offset);\n      this.visualElement.render();\n      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);\n    };\n    const onSessionEnd = (event, info) => this.stop(event, info);\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart,\n      onStart,\n      onMove,\n      onSessionEnd\n    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });\n  }\n  stop(event, info) {\n    const isDragging = this.isDragging;\n    this.cancel();\n    if (!isDragging)\n      return;\n    const { velocity } = info;\n    this.startAnimation(velocity);\n    const { onDragEnd } = this.getProps();\n    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n  }\n  cancel() {\n    var _a, _b;\n    this.isDragging = false;\n    if (this.visualElement.projection) {\n      this.visualElement.projection.isAnimationBlocked = false;\n    }\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = void 0;\n    const { dragPropagation } = this.getProps();\n    if (!dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n  }\n  updateAxis(axis, _point, offset) {\n    const { drag: drag2 } = this.getProps();\n    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))\n      return;\n    const axisValue = this.getAxisMotionValue(axis);\n    let next = this.originPoint[axis] + offset[axis];\n    if (this.constraints && this.constraints[axis]) {\n      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n    }\n    axisValue.set(next);\n  }\n  resolveConstraints() {\n    const { dragConstraints, dragElastic } = this.getProps();\n    const { layout } = this.visualElement.projection || {};\n    const prevConstraints = this.constraints;\n    if (dragConstraints && isRefObject(dragConstraints)) {\n      if (!this.constraints) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    } else {\n      if (dragConstraints && layout) {\n        this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n      } else {\n        this.constraints = false;\n      }\n    }\n    this.elastic = resolveDragElastic(dragElastic);\n    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {\n      eachAxis((axis) => {\n        if (this.getAxisMotionValue(axis)) {\n          this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n        }\n      });\n    }\n  }\n  resolveRefConstraints() {\n    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n    if (!constraints || !isRefObject(constraints))\n      return false;\n    const constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    const { projection } = this.visualElement;\n    if (!projection || !projection.layout)\n      return false;\n    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n    if (onMeasureDragConstraints) {\n      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n      this.hasMutatedConstraints = !!userConstraints;\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToBox(userConstraints);\n      }\n    }\n    return measuredConstraints;\n  }\n  startAnimation(velocity) {\n    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();\n    const constraints = this.constraints || {};\n    const momentumAnimations = eachAxis((axis) => {\n      var _a;\n      if (!shouldDrag(axis, drag2, this.currentDirection)) {\n        return;\n      }\n      let transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n      if (dragSnapToOrigin)\n        transition = { min: 0, max: 0 };\n      const bounceStiffness = dragElastic ? 200 : 1e6;\n      const bounceDamping = dragElastic ? 40 : 1e7;\n      const inertia2 = __spreadValues(__spreadValues({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness,\n        bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition);\n      return this.startAxisValueAnimation(axis, inertia2);\n    });\n    return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n  }\n  startAxisValueAnimation(axis, transition) {\n    const axisValue = this.getAxisMotionValue(axis);\n    return startAnimation(axis, axisValue, 0, transition);\n  }\n  stopAnimation() {\n    eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n  }\n  getAxisMotionValue(axis) {\n    var _a, _b;\n    const dragKey = \"_drag\" + axis.toUpperCase();\n    const externalMotionValue = this.visualElement.getProps()[dragKey];\n    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);\n  }\n  snapToCursor(point2) {\n    eachAxis((axis) => {\n      const { drag: drag2 } = this.getProps();\n      if (!shouldDrag(axis, drag2, this.currentDirection))\n        return;\n      const { projection } = this.visualElement;\n      const axisValue = this.getAxisMotionValue(axis);\n      if (projection && projection.layout) {\n        const { min, max } = projection.layout.layoutBox[axis];\n        axisValue.set(point2[axis] - mix(min, max, 0.5));\n      }\n    });\n  }\n  scalePositionWithinConstraints() {\n    var _a;\n    if (!this.visualElement.current)\n      return;\n    const { drag: drag2, dragConstraints } = this.getProps();\n    const { projection } = this.visualElement;\n    if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n      return;\n    this.stopAnimation();\n    const boxProgress = { x: 0, y: 0 };\n    eachAxis((axis) => {\n      const axisValue = this.getAxisMotionValue(axis);\n      if (axisValue) {\n        const latest = axisValue.get();\n        boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);\n      }\n    });\n    const { transformTemplate } = this.visualElement.getProps();\n    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n    (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n    projection.updateLayout();\n    this.resolveConstraints();\n    eachAxis((axis) => {\n      if (!shouldDrag(axis, drag2, null))\n        return;\n      const axisValue = this.getAxisMotionValue(axis);\n      const { min, max } = this.constraints[axis];\n      axisValue.set(mix(min, max, boxProgress[axis]));\n    });\n  }\n  addListeners() {\n    var _a;\n    if (!this.visualElement.current)\n      return;\n    elementDragControls.set(this.visualElement, this);\n    const element = this.visualElement.current;\n    const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\n      const { drag: drag2, dragListener = true } = this.getProps();\n      drag2 && dragListener && this.start(event);\n    });\n    const measureDragConstraints = () => {\n      const { dragConstraints } = this.getProps();\n      if (isRefObject(dragConstraints)) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    };\n    const { projection } = this.visualElement;\n    const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n    if (projection && !projection.layout) {\n      (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n      projection.updateLayout();\n    }\n    measureDragConstraints();\n    const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n    const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged }) => {\n      if (this.isDragging && hasLayoutChanged) {\n        eachAxis((axis) => {\n          const motionValue2 = this.getAxisMotionValue(axis);\n          if (!motionValue2)\n            return;\n          this.originPoint[axis] += delta[axis].translate;\n          motionValue2.set(motionValue2.get() + delta[axis].translate);\n        });\n        this.visualElement.render();\n      }\n    });\n    return () => {\n      stopResizeListener();\n      stopPointerListener();\n      stopMeasureLayoutListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n    };\n  }\n  getProps() {\n    const props = this.visualElement.getProps();\n    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;\n    return __spreadProps(__spreadValues({}, props), {\n      drag: drag2,\n      dragDirectionLock,\n      dragPropagation,\n      dragConstraints,\n      dragElastic,\n      dragMomentum\n    });\n  }\n};\nfunction shouldDrag(direction, drag2, currentDirection) {\n  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);\n}\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n  let direction = null;\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n  return direction;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs\nfunction useDrag(props) {\n  const { dragControls: groupDragControls, visualElement } = props;\n  const dragControls = useConstant(() => new VisualElementDragControls(visualElement));\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => groupDragControls && groupDragControls.subscribe(dragControls), [dragControls, groupDragControls]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => dragControls.addListeners(), [dragControls]);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-pan-gesture.mjs\n\nfunction usePanGesture({ onPan, onPanStart, onPanEnd, onPanSessionStart, visualElement }) {\n  const hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  const panSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const { transformPagePoint } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MotionConfigContext);\n  const handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: (event, info) => {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint\n    });\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(() => panSession.current && panSession.current.end());\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/drag.mjs\nvar drag = {\n  pan: makeRenderlessComponent(usePanGesture),\n  drag: makeRenderlessComponent(useDrag)\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs\nfunction isCSSVariable2(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n  const match = cssVariableRegex.exec(current);\n  if (!match)\n    return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n  const [token, fallback] = parseCSSVariable(current);\n  if (!token)\n    return;\n  const resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariable2(fallback)) {\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var target = __objRest(_a, []);\n  const element = visualElement.current;\n  if (!(element instanceof Element))\n    return { target, transitionEnd };\n  if (transitionEnd) {\n    transitionEnd = __spreadValues({}, transitionEnd);\n  }\n  visualElement.values.forEach((value) => {\n    const current = value.get();\n    if (!isCSSVariable2(current))\n      return;\n    const resolved = getVariableValue(current, element);\n    if (resolved)\n      value.set(resolved);\n  });\n  for (const key in target) {\n    const current = target[key];\n    if (!isCSSVariable2(current))\n      continue;\n    const resolved = getVariableValue(current, element);\n    if (!resolved)\n      continue;\n    target[key] = resolved;\n    if (transitionEnd && transitionEnd[key] === void 0) {\n      transitionEnd[key] = current;\n    }\n  }\n  return { target, transitionEnd };\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs\nvar positionalKeys = /* @__PURE__ */ new Set([\n  \"width\",\n  \"height\",\n  \"top\",\n  \"left\",\n  \"right\",\n  \"bottom\",\n  \"x\",\n  \"y\"\n]);\nvar isPositionalKey = (key) => positionalKeys.has(key);\nvar hasPositionalKey = (target) => {\n  return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = (value, to) => {\n  value.set(to, false);\n  value.set(to);\n};\nvar isNumOrPxType = (v) => v === number || v === px;\nvar BoundingBoxDimension;\n(function(BoundingBoxDimension2) {\n  BoundingBoxDimension2[\"width\"] = \"width\";\n  BoundingBoxDimension2[\"height\"] = \"height\";\n  BoundingBoxDimension2[\"left\"] = \"left\";\n  BoundingBoxDimension2[\"right\"] = \"right\";\n  BoundingBoxDimension2[\"top\"] = \"top\";\n  BoundingBoxDimension2[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nvar getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n  if (transform === \"none\" || !transform)\n    return 0;\n  const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n  if (matrix3d) {\n    return getPosFromMatrix(matrix3d[1], pos3);\n  } else {\n    const matrix = transform.match(/^matrix\\((.+)\\)$/);\n    if (matrix) {\n      return getPosFromMatrix(matrix[1], pos2);\n    } else {\n      return 0;\n    }\n  }\n};\nvar transformKeys = /* @__PURE__ */ new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n  const removedTransforms = [];\n  nonTranslationalTransformKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    if (value !== void 0) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  if (removedTransforms.length)\n    visualElement.render();\n  return removedTransforms;\n}\nvar positionalValues = {\n  width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n  height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n  top: (_bbox, { top }) => parseFloat(top),\n  left: (_bbox, { left }) => parseFloat(left),\n  bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n  right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\nvar convertChangedValueTypes = (target, visualElement, changedKeys) => {\n  const originBbox = visualElement.measureViewportBox();\n  const element = visualElement.current;\n  const elementComputedStyle = getComputedStyle(element);\n  const { display } = elementComputedStyle;\n  const origin = {};\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  changedKeys.forEach((key) => {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  });\n  visualElement.render();\n  const targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    setAndResetVelocity(value, origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\nvar checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\n  target = __spreadValues({}, target);\n  transitionEnd = __spreadValues({}, transitionEnd);\n  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n  let removedTransformValues = [];\n  let hasAttemptedToRemoveTransformValues = false;\n  const changedValueTypeKeys = [];\n  targetPositionalKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key))\n      return;\n    let from = origin[key];\n    let fromType = findDimensionValueType(from);\n    const to = target[key];\n    let toType;\n    if (isKeyframesTarget(to)) {\n      const numKeyframes = to.length;\n      const fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n      for (let i2 = fromIndex; i2 < numKeyframes; i2++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i2]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i2]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n    if (fromType !== toType) {\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        const current = value.get();\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n  if (changedValueTypeKeys.length) {\n    const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(([key, value]) => {\n        visualElement.getValue(key).set(value);\n      });\n    }\n    visualElement.render();\n    if (isBrowser && scrollY !== null) {\n      window.scrollTo({ top: scrollY });\n    }\n    return { target: convertedTarget, transitionEnd };\n  } else {\n    return { target, transitionEnd };\n  }\n};\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs\nvar parseDomVariant = (visualElement, target, origin, transitionEnd) => {\n  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\n// ../../node_modules/framer-motion/dist/es/render/VisualElement.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs\nvar prefersReducedMotion = { current: null };\nvar hasReducedMotionListener = { current: false };\n\n// ../../node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs\nfunction initPrefersReducedMotion() {\n  hasReducedMotionListener.current = true;\n  if (!isBrowser)\n    return;\n  if (window.matchMedia) {\n    const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;\n    motionMediaQuery.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.current = false;\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/motion-values.mjs\nfunction updateMotionValuesFromProps(element, next, prev) {\n  const { willChange } = next;\n  for (const key in next) {\n    const nextValue = next[key];\n    const prevValue = prev[key];\n    if (isMotionValue(nextValue)) {\n      element.addValue(key, nextValue);\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.add(key);\n      }\n      if (true) {\n        warnOnce(nextValue.version === \"7.6.7\", `Attempting to mix Framer Motion versions ${nextValue.version} with 7.6.7 may not work as expected.`);\n      }\n    } else if (isMotionValue(prevValue)) {\n      element.addValue(key, motionValue(nextValue));\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.remove(key);\n      }\n    } else if (prevValue !== nextValue) {\n      if (element.hasValue(key)) {\n        const existingValue = element.getValue(key);\n        !existingValue.hasAnimated && existingValue.set(nextValue);\n      } else {\n        const latestValue = element.getStaticValue(key);\n        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue));\n      }\n    }\n  }\n  for (const key in prev) {\n    if (next[key] === void 0)\n      element.removeValue(key);\n  }\n  return next;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/VisualElement.mjs\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\nvar propEventHandlers = [\n  \"AnimationStart\",\n  \"AnimationComplete\",\n  \"Update\",\n  \"Unmount\",\n  \"BeforeLayoutMeasure\",\n  \"LayoutMeasure\",\n  \"LayoutAnimationStart\",\n  \"LayoutAnimationComplete\"\n];\nvar VisualElement = class {\n  constructor({ parent, props, reducedMotionConfig, visualState }, options = {}) {\n    this.current = null;\n    this.children = /* @__PURE__ */ new Set();\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    this.shouldReduceMotion = null;\n    this.values = /* @__PURE__ */ new Map();\n    this.isPresent = true;\n    this.valueSubscriptions = /* @__PURE__ */ new Map();\n    this.prevMotionValues = {};\n    this.events = {};\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n    this.render = () => {\n      if (!this.current)\n        return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n    this.scheduleRender = () => es_default.render(this.render, false, true);\n    const { latestValues, renderState } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = __spreadValues({}, latestValues);\n    this.initialValues = props.initial ? __spreadValues({}, latestValues) : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.options = options;\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n    if (this.isVariantNode) {\n      this.variantChildren = /* @__PURE__ */ new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    const _a = this.scrapeMotionValuesFromProps(props), { willChange } = _a, initialMotionValues = __objRest(_a, [\"willChange\"]);\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n      if (latestValues[key] !== void 0 && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n        if (isWillChangeMotionValue(willChange)) {\n          willChange.add(key);\n        }\n      }\n    }\n  }\n  scrapeMotionValuesFromProps(_props) {\n    return {};\n  }\n  mount(instance) {\n    var _a;\n    this.current = instance;\n    if (this.projection) {\n      this.projection.mount(instance);\n    }\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.addVariantChild(this);\n    }\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    if (!hasReducedMotionListener.current) {\n      initPrefersReducedMotion();\n    }\n    this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? false : this.reducedMotionConfig === \"always\" ? true : prefersReducedMotion.current;\n    if (this.parent)\n      this.parent.children.add(this);\n    this.setProps(this.props);\n  }\n  unmount() {\n    var _a, _b, _c;\n    (_a = this.projection) === null || _a === void 0 ? void 0 : _a.unmount();\n    cancelSync.update(this.notifyUpdate);\n    cancelSync.render(this.render);\n    this.valueSubscriptions.forEach((remove) => remove());\n    (_b = this.removeFromVariantTree) === null || _b === void 0 ? void 0 : _b.call(this);\n    (_c = this.parent) === null || _c === void 0 ? void 0 : _c.children.delete(this);\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n    this.current = null;\n  }\n  bindToMotionValue(key, value) {\n    const removeOnChange = value.onChange((latestValue) => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && es_default.update(this.notifyUpdate, false, true);\n    });\n    const removeOnRenderRequest = value.onRenderRequest(this.scheduleRender);\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      removeOnRenderRequest();\n    });\n  }\n  sortNodePosition(other) {\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type)\n      return 0;\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n  loadFeatures(renderedProps, isStrict, preloadedFeatures, projectionId, ProjectionNodeConstructor, initialLayoutGroupConfig) {\n    const features = [];\n    if (env !== \"production\" && preloadedFeatures && isStrict) {\n      invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n    }\n    for (let i2 = 0; i2 < numFeatures; i2++) {\n      const name = featureNames[i2];\n      const { isEnabled, Component } = featureDefinitions[name];\n      if (isEnabled(renderedProps) && Component) {\n        features.push((0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Component, __spreadProps(__spreadValues({\n          key: name\n        }, renderedProps), {\n          visualElement: this\n        })));\n      }\n    }\n    if (!this.projection && ProjectionNodeConstructor) {\n      this.projection = new ProjectionNodeConstructor(projectionId, this.latestValues, this.parent && this.parent.projection);\n      const { layoutId, layout, drag: drag2, dragConstraints, layoutScroll } = renderedProps;\n      this.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),\n        visualElement: this,\n        scheduleRender: () => this.scheduleRender(),\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig: initialLayoutGroupConfig,\n        layoutScroll\n      });\n    }\n    return features;\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.options, this.props);\n  }\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  makeTargetAnimatable(target, canMutate = true) {\n    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);\n  }\n  setProps(props) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n    this.props = props;\n    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {\n      const key = propEventHandlers[i2];\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n      const listener = props[\"on\" + key];\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props), this.prevMotionValues);\n  }\n  getProps() {\n    return this.props;\n  }\n  getVariant(name) {\n    var _a;\n    return (_a = this.props.variants) === null || _a === void 0 ? void 0 : _a[name];\n  }\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    var _a;\n    return this.isVariantNode ? this : (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getClosestVariantNode();\n  }\n  getVariantContext(startAtParent = false) {\n    var _a, _b;\n    if (startAtParent)\n      return (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getVariantContext();\n    if (!this.isControllingVariants) {\n      const context2 = ((_b = this.parent) === null || _b === void 0 ? void 0 : _b.getVariantContext()) || {};\n      if (this.props.initial !== void 0) {\n        context2.initial = this.props.initial;\n      }\n      return context2;\n    }\n    const context = {};\n    for (let i2 = 0; i2 < numVariantProps; i2++) {\n      const name = variantProps2[i2];\n      const prop = this.props[name];\n      if (isVariantLabel(prop) || prop === false) {\n        context[name] = prop;\n      }\n    }\n    return context;\n  }\n  addVariantChild(child) {\n    var _a;\n    const closestVariantNode = this.getClosestVariantNode();\n    if (closestVariantNode) {\n      (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  addValue(key, value) {\n    if (this.hasValue(key))\n      this.removeValue(key);\n    this.values.set(key, value);\n    this.latestValues[key] = value.get();\n    this.bindToMotionValue(key, value);\n  }\n  removeValue(key) {\n    var _a;\n    this.values.delete(key);\n    (_a = this.valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n    this.valueSubscriptions.delete(key);\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  hasValue(key) {\n    return this.values.has(key);\n  }\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n    let value = this.values.get(key);\n    if (value === void 0 && defaultValue !== void 0) {\n      value = motionValue(defaultValue);\n      this.addValue(key, value);\n    }\n    return value;\n  }\n  readValue(key) {\n    return this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.readValueFromInstance(this.current, key, this.options);\n  }\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  getBaseTarget(key) {\n    var _a;\n    const { initial } = this.props;\n    const valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : void 0;\n    if (initial && valueFromInitial !== void 0) {\n      return valueFromInitial;\n    }\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== void 0 && !isMotionValue(target))\n      return target;\n    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    return this.events[eventName].add(callback);\n  }\n  notify(eventName, ...args) {\n    var _a;\n    (_a = this.events[eventName]) === null || _a === void 0 ? void 0 : _a.notify(...args);\n  }\n};\nvar variantProps2 = [\"initial\", ...variantPriorityOrder];\nvar numVariantProps = variantProps2.length;\n\n// ../../node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs\nvar DOMVisualElement = class extends VisualElement {\n  sortInstanceNodePosition(a2, b2) {\n    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;\n  }\n  getBaseTargetFromProps(props, key) {\n    var _a;\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  }\n  removeValueFromRenderState(key, { vars, style }) {\n    delete vars[key];\n    delete style[key];\n  }\n  makeTargetAnimatableFromInstance(_a, { transformValues }, isMounted) {\n    var _b = _a, { transition, transitionEnd } = _b, target = __objRest(_b, [\"transition\", \"transitionEnd\"]);\n    let origin = getOrigin(target, transition || {}, this);\n    if (transformValues) {\n      if (transitionEnd)\n        transitionEnd = transformValues(transitionEnd);\n      if (target)\n        target = transformValues(target);\n      if (origin)\n        origin = transformValues(origin);\n    }\n    if (isMounted) {\n      checkTargetForNewValues(this, target, origin);\n      const parsed = parseDomVariant(this, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n    return __spreadValues({\n      transition,\n      transitionEnd\n    }, target);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs\nfunction getComputedStyle2(element) {\n  return window.getComputedStyle(element);\n}\nvar HTMLVisualElement = class extends DOMVisualElement {\n  readValueFromInstance(instance, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle2(instance);\n      const value = (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  }\n  measureInstanceViewportBox(instance, { transformPagePoint }) {\n    return measureViewportBox(instance, transformPagePoint);\n  }\n  build(renderState, latestValues, options, props) {\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  }\n  scrapeMotionValuesFromProps(props) {\n    return scrapeMotionValuesFromProps(props);\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderHTML(instance, renderState, styleProp, projection);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs\nvar SVGVisualElement = class extends DOMVisualElement {\n  getBaseTargetFromProps(props, key) {\n    return props[key];\n  }\n  readValueFromInstance(instance, key) {\n    var _a;\n    if (transformProps.has(key)) {\n      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n    }\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return instance.getAttribute(key);\n  }\n  measureInstanceViewportBox() {\n    return createBox();\n  }\n  scrapeMotionValuesFromProps(props) {\n    return scrapeMotionValuesFromProps2(props);\n  }\n  build(renderState, latestValues, options, props) {\n    buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderSVG(instance, renderState, styleProp, projection);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs\nvar createDomVisualElement = (Component, options) => {\n  return isSVGComponent(Component) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\n\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs\nfunction pixelsToPercent(pixels, axis) {\n  if (axis.max === axis.min)\n    return 0;\n  return pixels / (axis.max - axis.min) * 100;\n}\nvar correctBorderRadius = {\n  correct: (latest, node) => {\n    if (!node.target)\n      return latest;\n    if (typeof latest === \"string\") {\n      if (px.test(latest)) {\n        latest = parseFloat(latest);\n      } else {\n        return latest;\n      }\n    }\n    const x = pixelsToPercent(latest, node.target.x);\n    const y = pixelsToPercent(latest, node.target.y);\n    return `${x}% ${y}%`;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs\nvar varToken = \"_$css\";\nvar correctBoxShadow = {\n  correct: (latest, { treeScale, projectionDelta }) => {\n    const original = latest;\n    const containsCSSVariables = latest.includes(\"var(\");\n    const cssVariables = [];\n    if (containsCSSVariables) {\n      latest = latest.replace(cssVariableRegex, (match) => {\n        cssVariables.push(match);\n        return varToken;\n      });\n    }\n    const shadow = complex.parse(latest);\n    if (shadow.length > 5)\n      return original;\n    const template = complex.createTransformer(latest);\n    const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    const xScale = projectionDelta.x.scale * treeScale.x;\n    const yScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    const averageScale = mix(xScale, yScale, 0.5);\n    if (typeof shadow[2 + offset] === \"number\")\n      shadow[2 + offset] /= averageScale;\n    if (typeof shadow[3 + offset] === \"number\")\n      shadow[3 + offset] /= averageScale;\n    let output = template(shadow);\n    if (containsCSSVariables) {\n      let i2 = 0;\n      output = output.replace(varToken, () => {\n        const cssVariable = cssVariables[i2];\n        i2++;\n        return cssVariable;\n      });\n    }\n    return output;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\nvar MeasureLayoutWithContext = class extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  componentDidMount() {\n    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n    const { projection } = visualElement;\n    addScaleCorrector(defaultScaleCorrectors);\n    if (projection) {\n      if (layoutGroup.group)\n        layoutGroup.group.add(projection);\n      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n      projection.root.didUpdate();\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions(__spreadProps(__spreadValues({}, projection.options), {\n        onExitComplete: () => this.safeToRemove()\n      }));\n    }\n    globalProjectionState.hasEverUpdated = true;\n  }\n  getSnapshotBeforeUpdate(prevProps) {\n    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;\n    const projection = visualElement.projection;\n    if (!projection)\n      return null;\n    projection.isPresent = isPresent;\n    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        es_default.postRender(() => {\n          var _a;\n          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n    return null;\n  }\n  componentDidUpdate() {\n    const { projection } = this.props.visualElement;\n    if (projection) {\n      projection.root.didUpdate();\n      if (!projection.currentAnimation && projection.isLead()) {\n        this.safeToRemove();\n      }\n    }\n  }\n  componentWillUnmount() {\n    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;\n    const { projection } = visualElement;\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\n        layoutGroup.group.remove(projection);\n      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)\n        promoteContext.deregister(projection);\n    }\n  }\n  safeToRemove() {\n    const { safeToRemove } = this.props;\n    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n  }\n  render() {\n    return null;\n  }\n};\nfunction MeasureLayout(props) {\n  const [isPresent, safeToRemove] = usePresence();\n  const layoutGroup = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LayoutGroupContext);\n  return react__WEBPACK_IMPORTED_MODULE_1__.createElement(MeasureLayoutWithContext, __spreadProps(__spreadValues({}, props), { layoutGroup, switchLayoutGroup: (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove }));\n}\nvar defaultScaleCorrectors = {\n  borderRadius: __spreadProps(__spreadValues({}, correctBorderRadius), {\n    applyTo: [\n      \"borderTopLeftRadius\",\n      \"borderTopRightRadius\",\n      \"borderBottomLeftRadius\",\n      \"borderBottomRightRadius\"\n    ]\n  }),\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/index.mjs\nvar layoutFeatures = {\n  measureLayout: MeasureLayout\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/animate.mjs\nfunction animate2(from, to, transition = {}) {\n  const value = isMotionValue(from) ? from : motionValue(from);\n  startAnimation(\"\", value, to, transition);\n  return {\n    stop: () => value.stop(),\n    isAnimating: () => value.isAnimating()\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nvar asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nvar isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress3, shouldCrossfadeOpacity, isOnlyMember) {\n  var _a, _b, _c, _d;\n  if (shouldCrossfadeOpacity) {\n    target.opacity = mix(\n      0,\n      (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1,\n      easeCrossfadeIn(progress3)\n    );\n    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress3));\n  } else if (isOnlyMember) {\n    target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress3);\n  }\n  for (let i2 = 0; i2 < numBorders; i2++) {\n    const borderLabel = `border${borders[i2]}Radius`;\n    let followRadius = getRadius(follow, borderLabel);\n    let leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === void 0 && leadRadius === void 0)\n      continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n    if (canMix) {\n      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress3), 0);\n      if (percent.test(leadRadius) || percent.test(followRadius)) {\n        target[borderLabel] += \"%\";\n      }\n    } else {\n      target[borderLabel] = leadRadius;\n    }\n  }\n  if (follow.rotate || lead.rotate) {\n    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress3);\n  }\n}\nfunction getRadius(values, radiusName) {\n  var _a;\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n  return (p2) => {\n    if (p2 < min)\n      return 0;\n    if (p2 > max)\n      return 1;\n    return easing(progress(min, max, p2));\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/copy.mjs\nfunction copyAxisInto(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\nfunction copyBoxInto(box, originBox) {\n  copyAxisInto(box.x, originBox.x);\n  copyAxisInto(box.y, originBox.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs\nfunction removePointDelta(point2, translate, scale2, originPoint, boxScale) {\n  point2 -= translate;\n  point2 = scalePoint(point2, 1 / scale2, originPoint);\n  if (boxScale !== void 0) {\n    point2 = scalePoint(point2, 1 / boxScale, originPoint);\n  }\n  return point2;\n}\nfunction removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n  if (percent.test(translate)) {\n    translate = parseFloat(translate);\n    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);\n    translate = relativeProgress - sourceAxis.min;\n  }\n  if (typeof translate !== \"number\")\n    return;\n  let originPoint = mix(originAxis.min, originAxis.max, origin);\n  if (axis === originAxis)\n    originPoint -= translate;\n  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\nvar xKeys2 = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys2 = [\"y\", \"scaleY\", \"originY\"];\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n  removeAxisTransforms(box.x, transforms, xKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);\n  removeAxisTransforms(box.y, transforms, yKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/geometry/utils.mjs\nfunction isAxisDeltaZero(delta) {\n  return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction boxEquals(a2, b2) {\n  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;\n}\nfunction aspectRatio(box) {\n  return calcLength(box.x) / calcLength(box.y);\n}\nfunction isCloseTo(a2, b2, max = 0.1) {\n  return distance(a2, b2) <= max;\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/shared/stack.mjs\nvar NodeStack = class {\n  constructor() {\n    this.members = [];\n  }\n  add(node) {\n    addUniqueItem(this.members, node);\n    node.scheduleRender();\n  }\n  remove(node) {\n    removeItem(this.members, node);\n    if (node === this.prevLead) {\n      this.prevLead = void 0;\n    }\n    if (node === this.lead) {\n      const prevLead = this.members[this.members.length - 1];\n      if (prevLead) {\n        this.promote(prevLead);\n      }\n    }\n  }\n  relegate(node) {\n    const indexOfNode = this.members.findIndex((member) => node === member);\n    if (indexOfNode === 0)\n      return false;\n    let prevLead;\n    for (let i2 = indexOfNode; i2 >= 0; i2--) {\n      const member = this.members[i2];\n      if (member.isPresent !== false) {\n        prevLead = member;\n        break;\n      }\n    }\n    if (prevLead) {\n      this.promote(prevLead);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  promote(node, preserveFollowOpacity) {\n    var _a;\n    const prevLead = this.lead;\n    if (node === prevLead)\n      return;\n    this.prevLead = prevLead;\n    this.lead = node;\n    node.show();\n    if (prevLead) {\n      prevLead.instance && prevLead.scheduleRender();\n      node.scheduleRender();\n      node.resumeFrom = prevLead;\n      if (preserveFollowOpacity) {\n        node.resumeFrom.preserveOpacity = true;\n      }\n      if (prevLead.snapshot) {\n        node.snapshot = prevLead.snapshot;\n        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;\n        node.snapshot.isShared = true;\n      }\n      if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {\n        node.isLayoutDirty = true;\n      }\n      const { crossfade } = node.options;\n      if (crossfade === false) {\n        prevLead.hide();\n      }\n    }\n  }\n  exitAnimationComplete() {\n    this.members.forEach((node) => {\n      var _a, _b, _c, _d, _e;\n      (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n      (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);\n    });\n  }\n  scheduleRender() {\n    this.members.forEach((node) => {\n      node.instance && node.scheduleRender(false);\n    });\n  }\n  removeLeadSnapshot() {\n    if (this.lead && this.lead.snapshot) {\n      this.lead.snapshot = void 0;\n    }\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/styles/transform.mjs\nvar identityProjection = \"translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)\";\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n  const xTranslate = delta.x.translate / treeScale.x;\n  const yTranslate = delta.y.translate / treeScale.y;\n  let transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;\n  transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n  if (latestTransform) {\n    const { rotate, rotateX, rotateY } = latestTransform;\n    if (rotate)\n      transform += `rotate(${rotate}deg) `;\n    if (rotateX)\n      transform += `rotateX(${rotateX}deg) `;\n    if (rotateY)\n      transform += `rotateY(${rotateY}deg) `;\n  }\n  const elementScaleX = delta.x.scale * treeScale.x;\n  const elementScaleY = delta.y.scale * treeScale.y;\n  transform += `scale(${elementScaleX}, ${elementScaleY})`;\n  return transform === identityProjection ? \"none\" : transform;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs\nvar compareByDepth = (a2, b2) => a2.depth - b2.depth;\n\n// ../../node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs\nvar FlatTree = class {\n  constructor() {\n    this.children = [];\n    this.isDirty = false;\n  }\n  add(child) {\n    addUniqueItem(this.children, child);\n    this.isDirty = true;\n  }\n  remove(child) {\n    removeItem(this.children, child);\n    this.isDirty = true;\n  }\n  forEach(callback) {\n    this.isDirty && this.children.sort(compareByDepth);\n    this.isDirty = false;\n    this.children.forEach(callback);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\nvar animationTarget = 1e3;\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {\n  return class ProjectionNode {\n    constructor(elementId, latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\n      this.children = /* @__PURE__ */ new Set();\n      this.options = {};\n      this.isTreeAnimating = false;\n      this.isAnimationBlocked = false;\n      this.isLayoutDirty = false;\n      this.updateManuallyBlocked = false;\n      this.updateBlockedByResize = false;\n      this.isUpdating = false;\n      this.isSVG = false;\n      this.needsReset = false;\n      this.shouldResetTransform = false;\n      this.treeScale = { x: 1, y: 1 };\n      this.eventHandlers = /* @__PURE__ */ new Map();\n      this.potentialNodes = /* @__PURE__ */ new Map();\n      this.checkUpdateFailed = () => {\n        if (this.isUpdating) {\n          this.isUpdating = false;\n          this.clearAllSnapshots();\n        }\n      };\n      this.updateProjection = () => {\n        this.nodes.forEach(resolveTargetDelta);\n        this.nodes.forEach(calcProjection);\n      };\n      this.hasProjected = false;\n      this.isVisible = true;\n      this.animationProgress = 0;\n      this.sharedNodes = /* @__PURE__ */ new Map();\n      this.elementId = elementId;\n      this.latestValues = latestValues;\n      this.root = parent ? parent.root || parent : this;\n      this.path = parent ? [...parent.path, parent] : [];\n      this.parent = parent;\n      this.depth = parent ? parent.depth + 1 : 0;\n      elementId && this.root.registerPotentialNode(elementId, this);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        this.path[i2].shouldResetTransform = true;\n      }\n      if (this.root === this)\n        this.nodes = new FlatTree();\n    }\n    addEventListener(name, handler) {\n      if (!this.eventHandlers.has(name)) {\n        this.eventHandlers.set(name, new SubscriptionManager());\n      }\n      return this.eventHandlers.get(name).add(handler);\n    }\n    notifyListeners(name, ...args) {\n      const subscriptionManager = this.eventHandlers.get(name);\n      subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify(...args);\n    }\n    hasListeners(name) {\n      return this.eventHandlers.has(name);\n    }\n    registerPotentialNode(id2, node) {\n      this.potentialNodes.set(id2, node);\n    }\n    mount(instance, isLayoutDirty = false) {\n      var _a;\n      if (this.instance)\n        return;\n      this.isSVG = instance instanceof SVGElement && instance.tagName !== \"svg\";\n      this.instance = instance;\n      const { layoutId, layout, visualElement } = this.options;\n      if (visualElement && !visualElement.current) {\n        visualElement.mount(instance);\n      }\n      this.root.nodes.add(this);\n      (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);\n      this.elementId && this.root.potentialNodes.delete(this.elementId);\n      if (isLayoutDirty && (layout || layoutId)) {\n        this.isLayoutDirty = true;\n      }\n      if (attachResizeListener) {\n        let cancelDelay;\n        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;\n        attachResizeListener(instance, () => {\n          this.root.updateBlockedByResize = true;\n          cancelDelay && cancelDelay();\n          cancelDelay = delay(resizeUnblockUpdate, 250);\n          if (globalProjectionState.hasAnimatedSinceResize) {\n            globalProjectionState.hasAnimatedSinceResize = false;\n            this.nodes.forEach(finishAnimation);\n          }\n        });\n      }\n      if (layoutId) {\n        this.root.registerSharedNode(layoutId, this);\n      }\n      if (this.options.animate !== false && visualElement && (layoutId || layout)) {\n        this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {\n          var _a2, _b, _c, _d, _e;\n          if (this.isTreeAnimationBlocked()) {\n            this.target = void 0;\n            this.relativeTarget = void 0;\n            return;\n          }\n          const layoutTransition = (_b = (_a2 = this.options.transition) !== null && _a2 !== void 0 ? _a2 : visualElement.getDefaultTransition()) !== null && _b !== void 0 ? _b : defaultLayoutTransition;\n          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();\n          const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;\n          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n          if (((_c = this.resumeFrom) === null || _c === void 0 ? void 0 : _c.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {\n            if (this.resumeFrom) {\n              this.resumingFrom = this.resumeFrom;\n              this.resumingFrom.resumingFrom = void 0;\n            }\n            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n            const animationOptions = __spreadProps(__spreadValues({}, getValueTransition(layoutTransition, \"layout\")), {\n              onPlay: onLayoutAnimationStart,\n              onComplete: onLayoutAnimationComplete\n            });\n            if (visualElement.shouldReduceMotion) {\n              animationOptions.delay = 0;\n              animationOptions.type = false;\n            }\n            this.startAnimation(animationOptions);\n          } else {\n            if (!hasLayoutChanged && this.animationProgress === 0) {\n              finishAnimation(this);\n            }\n            this.isLead() && ((_e = (_d = this.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d));\n          }\n          this.targetLayout = newLayout;\n        });\n      }\n    }\n    unmount() {\n      var _a, _b;\n      this.options.layoutId && this.willUpdate();\n      this.root.nodes.remove(this);\n      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);\n      (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);\n      this.instance = void 0;\n      cancelSync.preRender(this.updateProjection);\n    }\n    blockUpdate() {\n      this.updateManuallyBlocked = true;\n    }\n    unblockUpdate() {\n      this.updateManuallyBlocked = false;\n    }\n    isUpdateBlocked() {\n      return this.updateManuallyBlocked || this.updateBlockedByResize;\n    }\n    isTreeAnimationBlocked() {\n      var _a;\n      return this.isAnimationBlocked || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) || false;\n    }\n    startUpdate() {\n      var _a;\n      if (this.isUpdateBlocked())\n        return;\n      this.isUpdating = true;\n      (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);\n    }\n    willUpdate(shouldNotifyListeners = true) {\n      var _a, _b, _c;\n      if (this.root.isUpdateBlocked()) {\n        (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n        return;\n      }\n      !this.root.isUpdating && this.root.startUpdate();\n      if (this.isLayoutDirty)\n        return;\n      this.isLayoutDirty = true;\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        node.shouldResetTransform = true;\n        node.updateScroll();\n      }\n      const { layoutId, layout } = this.options;\n      if (layoutId === void 0 && !layout)\n        return;\n      const transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;\n      this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n      this.updateSnapshot();\n      shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n    }\n    didUpdate() {\n      const updateWasBlocked = this.isUpdateBlocked();\n      if (updateWasBlocked) {\n        this.unblockUpdate();\n        this.clearAllSnapshots();\n        this.nodes.forEach(clearMeasurements);\n        return;\n      }\n      if (!this.isUpdating)\n        return;\n      this.isUpdating = false;\n      if (this.potentialNodes.size) {\n        this.potentialNodes.forEach(mountNodeEarly);\n        this.potentialNodes.clear();\n      }\n      this.nodes.forEach(resetTransformStyle);\n      this.nodes.forEach(updateLayout);\n      this.nodes.forEach(notifyLayoutUpdate);\n      this.clearAllSnapshots();\n      flushSync.update();\n      flushSync.preRender();\n      flushSync.render();\n    }\n    clearAllSnapshots() {\n      this.nodes.forEach(clearSnapshot);\n      this.sharedNodes.forEach(removeLeadSnapshots);\n    }\n    scheduleUpdateProjection() {\n      es_default.preRender(this.updateProjection, false, true);\n    }\n    scheduleCheckAfterUnmount() {\n      es_default.postRender(() => {\n        if (this.isLayoutDirty) {\n          this.root.didUpdate();\n        } else {\n          this.root.checkUpdateFailed();\n        }\n      });\n    }\n    updateSnapshot() {\n      if (this.snapshot || !this.instance)\n        return;\n      this.snapshot = this.measure();\n    }\n    updateLayout() {\n      var _a;\n      if (!this.instance)\n        return;\n      this.updateScroll();\n      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {\n        return;\n      }\n      if (this.resumeFrom && !this.resumeFrom.instance) {\n        for (let i2 = 0; i2 < this.path.length; i2++) {\n          const node = this.path[i2];\n          node.updateScroll();\n        }\n      }\n      const prevLayout = this.layout;\n      this.layout = this.measure(false);\n      this.layoutCorrected = createBox();\n      this.isLayoutDirty = false;\n      this.projectionDelta = void 0;\n      this.notifyListeners(\"measure\", this.layout.layoutBox);\n      (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.layoutBox);\n    }\n    updateScroll() {\n      if (this.options.layoutScroll && this.instance) {\n        this.isScrollRoot = checkIsScrollRoot(this.instance);\n        this.scroll = measureScroll(this.instance);\n      }\n    }\n    resetTransform() {\n      var _a;\n      if (!resetTransform)\n        return;\n      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;\n      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n      const transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n      const transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {\n        resetTransform(this.instance, transformTemplateValue);\n        this.shouldResetTransform = false;\n        this.scheduleRender();\n      }\n    }\n    measure(removeTransform = true) {\n      const pageBox = this.measurePageBox();\n      let layoutBox = this.removeElementScroll(pageBox);\n      if (removeTransform) {\n        layoutBox = this.removeTransform(layoutBox);\n      }\n      roundBox(layoutBox);\n      return {\n        measuredBox: pageBox,\n        layoutBox,\n        latestValues: {}\n      };\n    }\n    measurePageBox() {\n      const { visualElement } = this.options;\n      if (!visualElement)\n        return createBox();\n      const box = visualElement.measureViewportBox();\n      const { scroll: scroll2 } = this.root;\n      if (scroll2) {\n        translateAxis(box.x, scroll2.x);\n        translateAxis(box.y, scroll2.y);\n      }\n      return box;\n    }\n    removeElementScroll(box) {\n      const boxWithoutScroll = createBox();\n      copyBoxInto(boxWithoutScroll, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        const { scroll: scroll2, options, isScrollRoot } = node;\n        if (node !== this.root && scroll2 && options.layoutScroll) {\n          if (isScrollRoot) {\n            copyBoxInto(boxWithoutScroll, box);\n            const { scroll: rootScroll } = this.root;\n            if (rootScroll) {\n              translateAxis(boxWithoutScroll.x, -rootScroll.x);\n              translateAxis(boxWithoutScroll.y, -rootScroll.y);\n            }\n          }\n          translateAxis(boxWithoutScroll.x, scroll2.x);\n          translateAxis(boxWithoutScroll.y, scroll2.y);\n        }\n      }\n      return boxWithoutScroll;\n    }\n    applyTransform(box, transformOnly = false) {\n      const withTransforms = createBox();\n      copyBoxInto(withTransforms, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {\n          transformBox(withTransforms, {\n            x: -node.scroll.x,\n            y: -node.scroll.y\n          });\n        }\n        if (!hasTransform(node.latestValues))\n          continue;\n        transformBox(withTransforms, node.latestValues);\n      }\n      if (hasTransform(this.latestValues)) {\n        transformBox(withTransforms, this.latestValues);\n      }\n      return withTransforms;\n    }\n    removeTransform(box) {\n      var _a;\n      const boxWithoutTransform = createBox();\n      copyBoxInto(boxWithoutTransform, box);\n      for (let i2 = 0; i2 < this.path.length; i2++) {\n        const node = this.path[i2];\n        if (!node.instance)\n          continue;\n        if (!hasTransform(node.latestValues))\n          continue;\n        hasScale(node.latestValues) && node.updateSnapshot();\n        const sourceBox = createBox();\n        const nodeBox = node.measurePageBox();\n        copyBoxInto(sourceBox, nodeBox);\n        removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layoutBox, sourceBox);\n      }\n      if (hasTransform(this.latestValues)) {\n        removeBoxTransforms(boxWithoutTransform, this.latestValues);\n      }\n      return boxWithoutTransform;\n    }\n    setTargetDelta(delta) {\n      this.targetDelta = delta;\n      this.root.scheduleUpdateProjection();\n    }\n    setOptions(options) {\n      this.options = __spreadProps(__spreadValues(__spreadValues({}, this.options), options), {\n        crossfade: options.crossfade !== void 0 ? options.crossfade : true\n      });\n    }\n    clearMeasurements() {\n      this.scroll = void 0;\n      this.layout = void 0;\n      this.snapshot = void 0;\n      this.prevTransformTemplateValue = void 0;\n      this.targetDelta = void 0;\n      this.target = void 0;\n      this.isLayoutDirty = false;\n    }\n    resolveTargetDelta() {\n      var _a;\n      const { layout, layoutId } = this.options;\n      if (!this.layout || !(layout || layoutId))\n        return;\n      if (!this.targetDelta && !this.relativeTarget) {\n        const relativeParent = this.getClosestProjectingParent();\n        if (relativeParent && relativeParent.layout) {\n          this.relativeParent = relativeParent;\n          this.relativeTarget = createBox();\n          this.relativeTargetOrigin = createBox();\n          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n        } else {\n          this.relativeParent = this.relativeTarget = void 0;\n        }\n      }\n      if (!this.relativeTarget && !this.targetDelta)\n        return;\n      if (!this.target) {\n        this.target = createBox();\n        this.targetWithTransforms = createBox();\n      }\n      if (this.relativeTarget && this.relativeTargetOrigin && ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {\n        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n      } else if (this.targetDelta) {\n        if (Boolean(this.resumingFrom)) {\n          this.target = this.applyTransform(this.layout.layoutBox);\n        } else {\n          copyBoxInto(this.target, this.layout.layoutBox);\n        }\n        applyBoxDelta(this.target, this.targetDelta);\n      } else {\n        copyBoxInto(this.target, this.layout.layoutBox);\n      }\n      if (this.attemptToResolveRelativeTarget) {\n        this.attemptToResolveRelativeTarget = false;\n        const relativeParent = this.getClosestProjectingParent();\n        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target) {\n          this.relativeParent = relativeParent;\n          this.relativeTarget = createBox();\n          this.relativeTargetOrigin = createBox();\n          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n        } else {\n          this.relativeParent = this.relativeTarget = void 0;\n        }\n      }\n    }\n    getClosestProjectingParent() {\n      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues))\n        return void 0;\n      if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {\n        return this.parent;\n      } else {\n        return this.parent.getClosestProjectingParent();\n      }\n    }\n    calcProjection() {\n      var _a;\n      const { layout, layoutId } = this.options;\n      this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);\n      if (!this.isTreeAnimating) {\n        this.targetDelta = this.relativeTarget = void 0;\n      }\n      if (!this.layout || !(layout || layoutId))\n        return;\n      const lead = this.getLead();\n      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);\n      const { target } = lead;\n      if (!target)\n        return;\n      if (!this.projectionDelta) {\n        this.projectionDelta = createDelta();\n        this.projectionDeltaWithTransform = createDelta();\n      }\n      const prevTreeScaleX = this.treeScale.x;\n      const prevTreeScaleY = this.treeScale.y;\n      const prevProjectionTransform = this.projectionTransform;\n      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);\n      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {\n        this.hasProjected = true;\n        this.scheduleRender();\n        this.notifyListeners(\"projectionUpdate\", target);\n      }\n    }\n    hide() {\n      this.isVisible = false;\n    }\n    show() {\n      this.isVisible = true;\n    }\n    scheduleRender(notifyAll2 = true) {\n      var _a, _b, _c;\n      (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);\n      notifyAll2 && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());\n      if (this.resumingFrom && !this.resumingFrom.instance) {\n        this.resumingFrom = void 0;\n      }\n    }\n    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n      var _a;\n      const snapshot = this.snapshot;\n      const snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};\n      const mixedValues = __spreadValues({}, this.latestValues);\n      const targetDelta = createDelta();\n      this.relativeTarget = this.relativeTargetOrigin = void 0;\n      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n      const relativeLayout = createBox();\n      const isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;\n      const isOnlyMember = (((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.members.length) || 0) <= 1;\n      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));\n      this.animationProgress = 0;\n      this.mixTargetDelta = (latest) => {\n        var _a2;\n        const progress3 = latest / 1e3;\n        mixAxisDelta(targetDelta.x, delta.x, progress3);\n        mixAxisDelta(targetDelta.y, delta.y, progress3);\n        this.setTargetDelta(targetDelta);\n        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && ((_a2 = this.relativeParent) === null || _a2 === void 0 ? void 0 : _a2.layout)) {\n          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress3);\n        }\n        if (isSharedLayoutAnimation) {\n          this.animationValues = mixedValues;\n          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress3, shouldCrossfadeOpacity, isOnlyMember);\n        }\n        this.root.scheduleUpdateProjection();\n        this.scheduleRender();\n        this.animationProgress = progress3;\n      };\n      this.mixTargetDelta(0);\n    }\n    startAnimation(options) {\n      var _a, _b;\n      this.notifyListeners(\"animationStart\");\n      (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n      if (this.resumingFrom) {\n        (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();\n      }\n      if (this.pendingAnimation) {\n        cancelSync.update(this.pendingAnimation);\n        this.pendingAnimation = void 0;\n      }\n      this.pendingAnimation = es_default.update(() => {\n        globalProjectionState.hasAnimatedSinceResize = true;\n        this.currentAnimation = animate2(0, animationTarget, __spreadProps(__spreadValues({}, options), {\n          onUpdate: (latest) => {\n            var _a2;\n            this.mixTargetDelta(latest);\n            (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, latest);\n          },\n          onComplete: () => {\n            var _a2;\n            (_a2 = options.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(options);\n            this.completeAnimation();\n          }\n        }));\n        if (this.resumingFrom) {\n          this.resumingFrom.currentAnimation = this.currentAnimation;\n        }\n        this.pendingAnimation = void 0;\n      });\n    }\n    completeAnimation() {\n      var _a;\n      if (this.resumingFrom) {\n        this.resumingFrom.currentAnimation = void 0;\n        this.resumingFrom.preserveOpacity = void 0;\n      }\n      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();\n      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;\n      this.notifyListeners(\"animationComplete\");\n    }\n    finishAnimation() {\n      var _a;\n      if (this.currentAnimation) {\n        (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);\n        this.currentAnimation.stop();\n      }\n      this.completeAnimation();\n    }\n    applyTransformsToTarget() {\n      const lead = this.getLead();\n      let { targetWithTransforms, target, layout, latestValues } = lead;\n      if (!targetWithTransforms || !target || !layout)\n        return;\n      if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n        target = this.target || createBox();\n        const xLength = calcLength(this.layout.layoutBox.x);\n        target.x.min = lead.target.x.min;\n        target.x.max = target.x.min + xLength;\n        const yLength = calcLength(this.layout.layoutBox.y);\n        target.y.min = lead.target.y.min;\n        target.y.max = target.y.min + yLength;\n      }\n      copyBoxInto(targetWithTransforms, target);\n      transformBox(targetWithTransforms, latestValues);\n      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n    }\n    registerSharedNode(layoutId, node) {\n      var _a, _b, _c;\n      if (!this.sharedNodes.has(layoutId)) {\n        this.sharedNodes.set(layoutId, new NodeStack());\n      }\n      const stack = this.sharedNodes.get(layoutId);\n      stack.add(node);\n      node.promote({\n        transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,\n        preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)\n      });\n    }\n    isLead() {\n      const stack = this.getStack();\n      return stack ? stack.lead === this : true;\n    }\n    getLead() {\n      var _a;\n      const { layoutId } = this.options;\n      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n    }\n    getPrevLead() {\n      var _a;\n      const { layoutId } = this.options;\n      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;\n    }\n    getStack() {\n      const { layoutId } = this.options;\n      if (layoutId)\n        return this.root.sharedNodes.get(layoutId);\n    }\n    promote({ needsReset, transition, preserveFollowOpacity } = {}) {\n      const stack = this.getStack();\n      if (stack)\n        stack.promote(this, preserveFollowOpacity);\n      if (needsReset) {\n        this.projectionDelta = void 0;\n        this.needsReset = true;\n      }\n      if (transition)\n        this.setOptions({ transition });\n    }\n    relegate() {\n      const stack = this.getStack();\n      if (stack) {\n        return stack.relegate(this);\n      } else {\n        return false;\n      }\n    }\n    resetRotation() {\n      const { visualElement } = this.options;\n      if (!visualElement)\n        return;\n      let hasRotate = false;\n      const resetValues = {};\n      for (let i2 = 0; i2 < transformAxes.length; i2++) {\n        const axis = transformAxes[i2];\n        const key = \"rotate\" + axis;\n        if (!visualElement.getStaticValue(key)) {\n          continue;\n        }\n        hasRotate = true;\n        resetValues[key] = visualElement.getStaticValue(key);\n        visualElement.setStaticValue(key, 0);\n      }\n      if (!hasRotate)\n        return;\n      visualElement === null || visualElement === void 0 ? void 0 : visualElement.render();\n      for (const key in resetValues) {\n        visualElement.setStaticValue(key, resetValues[key]);\n      }\n      visualElement.scheduleRender();\n    }\n    getProjectionStyles(styleProp = {}) {\n      var _a, _b, _c;\n      const styles = {};\n      if (!this.instance || this.isSVG)\n        return styles;\n      if (!this.isVisible) {\n        return { visibility: \"hidden\" };\n      } else {\n        styles.visibility = \"\";\n      }\n      const transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n      if (this.needsReset) {\n        this.needsReset = false;\n        styles.opacity = \"\";\n        styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n        styles.transform = transformTemplate ? transformTemplate(this.latestValues, \"\") : \"none\";\n        return styles;\n      }\n      const lead = this.getLead();\n      if (!this.projectionDelta || !this.layout || !lead.target) {\n        const emptyStyles = {};\n        if (this.options.layoutId) {\n          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;\n          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n        }\n        if (this.hasProjected && !hasTransform(this.latestValues)) {\n          emptyStyles.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n          this.hasProjected = false;\n        }\n        return emptyStyles;\n      }\n      const valuesToRender = lead.animationValues || lead.latestValues;\n      this.applyTransformsToTarget();\n      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n      if (transformTemplate) {\n        styles.transform = transformTemplate(valuesToRender, styles.transform);\n      }\n      const { x, y } = this.projectionDelta;\n      styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n      if (lead.animationValues) {\n        styles.opacity = lead === this ? (_c = (_b = valuesToRender.opacity) !== null && _b !== void 0 ? _b : this.latestValues.opacity) !== null && _c !== void 0 ? _c : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;\n      } else {\n        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : \"\" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;\n      }\n      for (const key in scaleCorrectors) {\n        if (valuesToRender[key] === void 0)\n          continue;\n        const { correct, applyTo } = scaleCorrectors[key];\n        const corrected = correct(valuesToRender[key], lead);\n        if (applyTo) {\n          const num = applyTo.length;\n          for (let i2 = 0; i2 < num; i2++) {\n            styles[applyTo[i2]] = corrected;\n          }\n        } else {\n          styles[key] = corrected;\n        }\n      }\n      if (this.options.layoutId) {\n        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || \"\" : \"none\";\n      }\n      return styles;\n    }\n    clearSnapshot() {\n      this.resumeFrom = this.snapshot = void 0;\n    }\n    resetTree() {\n      this.root.nodes.forEach((node) => {\n        var _a;\n        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n      });\n      this.root.nodes.forEach(clearMeasurements);\n      this.root.sharedNodes.clear();\n    }\n  };\n}\nfunction updateLayout(node) {\n  node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n  var _a, _b, _c;\n  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\n  if (node.isLead() && node.layout && snapshot && node.hasListeners(\"didUpdate\")) {\n    const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\n    const { animationType } = node.options;\n    if (animationType === \"size\") {\n      eachAxis((axis) => {\n        const axisSnapshot = snapshot.isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n        const length = calcLength(axisSnapshot);\n        axisSnapshot.min = layout[axis].min;\n        axisSnapshot.max = axisSnapshot.min + length;\n      });\n    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\n      eachAxis((axis) => {\n        const axisSnapshot = snapshot.isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n        const length = calcLength(layout[axis]);\n        axisSnapshot.max = axisSnapshot.min + length;\n      });\n    }\n    const layoutDelta = createDelta();\n    calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\n    const visualDelta = createDelta();\n    if (snapshot.isShared) {\n      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n    } else {\n      calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n    }\n    const hasLayoutChanged = !isDeltaZero(layoutDelta);\n    let hasRelativeTargetChanged = false;\n    if (!node.resumeFrom) {\n      const relativeParent = node.getClosestProjectingParent();\n      if (relativeParent && !relativeParent.resumeFrom) {\n        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n        if (parentSnapshot && parentLayout) {\n          const relativeSnapshot = createBox();\n          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n          const relativeLayout = createBox();\n          calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n          if (!boxEquals(relativeSnapshot, relativeLayout)) {\n            hasRelativeTargetChanged = true;\n          }\n        }\n      }\n    }\n    node.notifyListeners(\"didUpdate\", {\n      layout,\n      snapshot,\n      delta: visualDelta,\n      layoutDelta,\n      hasLayoutChanged,\n      hasRelativeTargetChanged\n    });\n  } else if (node.isLead()) {\n    (_c = (_b = node.options).onExitComplete) === null || _c === void 0 ? void 0 : _c.call(_b);\n  }\n  node.options.transition = void 0;\n}\nfunction clearSnapshot(node) {\n  node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n  node.clearMeasurements();\n}\nfunction resetTransformStyle(node) {\n  const { visualElement } = node.options;\n  if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {\n    visualElement.notify(\"BeforeLayoutMeasure\");\n  }\n  node.resetTransform();\n}\nfunction finishAnimation(node) {\n  node.finishAnimation();\n  node.targetDelta = node.relativeTarget = node.target = void 0;\n}\nfunction resolveTargetDelta(node) {\n  node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n  node.calcProjection();\n}\nfunction resetRotation(node) {\n  node.resetRotation();\n}\nfunction removeLeadSnapshots(stack) {\n  stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p2) {\n  output.translate = mix(delta.translate, 0, p2);\n  output.scale = mix(delta.scale, 1, p2);\n  output.origin = delta.origin;\n  output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p2) {\n  output.min = mix(from.min, to.min, p2);\n  output.max = mix(from.max, to.max, p2);\n}\nfunction mixBox(output, from, to, p2) {\n  mixAxis(output.x, from.x, to.x, p2);\n  mixAxis(output.y, from.y, to.y, p2);\n}\nfunction hasOpacityCrossfade(node) {\n  return node.animationValues && node.animationValues.opacityExit !== void 0;\n}\nvar defaultLayoutTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\nfunction mountNodeEarly(node, id2) {\n  let searchNode = node.root;\n  for (let i2 = node.path.length - 1; i2 >= 0; i2--) {\n    if (Boolean(node.path[i2].instance)) {\n      searchNode = node.path[i2];\n      break;\n    }\n  }\n  const searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;\n  const element = searchElement.querySelector(`[data-projection-id=\"${id2}\"]`);\n  if (element)\n    node.mount(element, true);\n}\nfunction roundAxis(axis) {\n  axis.min = Math.round(axis.min);\n  axis.max = Math.round(axis.max);\n}\nfunction roundBox(box) {\n  roundAxis(box.x);\n  roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\n  return animationType === \"position\" || animationType === \"preserve-aspect\" && !isCloseTo(aspectRatio(snapshot), aspectRatio(layout), 0.2);\n}\n\n// ../../node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs\nvar DocumentProjectionNode = createProjectionNode({\n  attachResizeListener: (ref, notify) => addDomEvent(ref, \"resize\", notify),\n  measureScroll: () => ({\n    x: document.documentElement.scrollLeft || document.body.scrollLeft,\n    y: document.documentElement.scrollTop || document.body.scrollTop\n  }),\n  checkIsScrollRoot: () => true\n});\n\n// ../../node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs\nvar rootProjectionNode = {\n  current: void 0\n};\nvar HTMLProjectionNode = createProjectionNode({\n  measureScroll: (instance) => ({\n    x: instance.scrollLeft,\n    y: instance.scrollTop\n  }),\n  defaultParent: () => {\n    if (!rootProjectionNode.current) {\n      const documentNode = new DocumentProjectionNode(0, {});\n      documentNode.mount(window);\n      documentNode.setOptions({ layoutScroll: true });\n      rootProjectionNode.current = documentNode;\n    }\n    return rootProjectionNode.current;\n  },\n  resetTransform: (instance, value) => {\n    instance.style.transform = value !== void 0 ? value : \"none\";\n  },\n  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \"fixed\")\n});\n\n// ../../node_modules/framer-motion/dist/es/render/dom/motion.mjs\nvar featureBundle = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, animations), gestureAnimations), drag), layoutFeatures);\nvar motion = /* @__PURE__ */ createMotionProxy((Component, config) => createDomMotionConfig(Component, config, featureBundle, createDomVisualElement, HTMLProjectionNode));\n\n// ../../node_modules/@motionone/utils/dist/clamp.es.js\nvar clamp3 = (min, max, v) => Math.min(Math.max(v, min), max);\n\n// ../../node_modules/@motionone/utils/dist/is-number.es.js\nvar isNumber = (value) => typeof value === \"number\";\n\n// ../../node_modules/@motionone/utils/dist/is-easing-list.es.js\nvar isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\n\n// ../../node_modules/@motionone/utils/dist/wrap.es.js\nvar wrap = (min, max, v) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\n// ../../node_modules/@motionone/utils/dist/easing.es.js\nfunction getEasingForSegment(easing, i2) {\n  return isEasingList(easing) ? easing[wrap(0, easing.length, i2)] : easing;\n}\n\n// ../../node_modules/@motionone/utils/dist/mix.es.js\nvar mix2 = (min, max, progress3) => -progress3 * min + progress3 * max + min;\n\n// ../../node_modules/@motionone/utils/dist/noop.es.js\nvar noopReturn = (v) => v;\n\n// ../../node_modules/@motionone/utils/dist/progress.es.js\nvar progress2 = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\n// ../../node_modules/@motionone/utils/dist/offset.es.js\nfunction fillOffset(offset, remaining) {\n  const min = offset[offset.length - 1];\n  for (let i2 = 1; i2 <= remaining; i2++) {\n    const offsetProgress = progress2(0, remaining, i2);\n    offset.push(mix2(min, 1, offsetProgress));\n  }\n}\nfunction defaultOffset2(length) {\n  const offset = [0];\n  fillOffset(offset, length - 1);\n  return offset;\n}\n\n// ../../node_modules/@motionone/utils/dist/interpolate.es.js\nfunction interpolate2(output, input = defaultOffset2(output.length), easing = noopReturn) {\n  const length = output.length;\n  const remainder = length - input.length;\n  remainder > 0 && fillOffset(input, remainder);\n  return (t) => {\n    let i2 = 0;\n    for (; i2 < length - 2; i2++) {\n      if (t < input[i2 + 1])\n        break;\n    }\n    let progressInRange = clamp3(0, 1, progress2(input[i2], input[i2 + 1], t));\n    const segmentEasing = getEasingForSegment(easing, i2);\n    progressInRange = segmentEasing(progressInRange);\n    return mix2(output[i2], output[i2 + 1], progressInRange);\n  };\n}\n\n// ../../node_modules/@motionone/utils/dist/is-function.es.js\nvar isFunction = (value) => typeof value === \"function\";\n\n// ../../node_modules/@motionone/utils/dist/is-string.es.js\nvar isString2 = (value) => typeof value === \"string\";\n\n// ../../node_modules/@motionone/utils/dist/velocity.es.js\nfunction velocityPerSecond2(velocity, frameDuration) {\n  return frameDuration ? velocity * (1e3 / frameDuration) : 0;\n}\n\n// ../../node_modules/@motionone/dom/dist/utils/resolve-elements.es.js\nfunction resolveElements(elements, selectorCache) {\n  var _a;\n  if (typeof elements === \"string\") {\n    if (selectorCache) {\n      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = document.querySelectorAll(elements);\n      elements = selectorCache[elements];\n    } else {\n      elements = document.querySelectorAll(elements);\n    }\n  } else if (elements instanceof Element) {\n    elements = [elements];\n  }\n  return Array.from(elements || []);\n}\n\n// ../../node_modules/tslib/modules/index.js\nvar import_tslib4 = __toESM(require_tslib2(), 1);\nvar {\n  __extends: __extends2,\n  __assign: __assign2,\n  __rest: __rest2,\n  __decorate: __decorate2,\n  __param: __param2,\n  __metadata: __metadata2,\n  __awaiter: __awaiter2,\n  __generator: __generator2,\n  __exportStar: __exportStar2,\n  __createBinding: __createBinding2,\n  __values: __values2,\n  __read: __read2,\n  __spread: __spread2,\n  __spreadArrays: __spreadArrays2,\n  __spreadArray: __spreadArray2,\n  __await: __await2,\n  __asyncGenerator: __asyncGenerator2,\n  __asyncDelegator: __asyncDelegator2,\n  __asyncValues: __asyncValues2,\n  __makeTemplateObject: __makeTemplateObject2,\n  __importStar: __importStar2,\n  __importDefault: __importDefault2,\n  __classPrivateFieldGet: __classPrivateFieldGet2,\n  __classPrivateFieldSet: __classPrivateFieldSet2,\n  __classPrivateFieldIn: __classPrivateFieldIn2\n} = import_tslib4.default;\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/handle-element.es.js\nvar resizeHandlers = /* @__PURE__ */ new WeakMap();\nvar observer;\nfunction getElementSize(target, borderBoxSize) {\n  if (borderBoxSize) {\n    const { inlineSize, blockSize } = borderBoxSize[0];\n    return { width: inlineSize, height: blockSize };\n  } else if (target instanceof SVGElement && \"getBBox\" in target) {\n    return target.getBBox();\n  } else {\n    return {\n      width: target.offsetWidth,\n      height: target.offsetHeight\n    };\n  }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize }) {\n  var _a;\n  (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n    handler({\n      target,\n      contentSize: contentRect,\n      get size() {\n        return getElementSize(target, borderBoxSize);\n      }\n    });\n  });\n}\nfunction notifyAll(entries) {\n  entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n  if (typeof ResizeObserver === \"undefined\")\n    return;\n  observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n  if (!observer)\n    createResizeObserver();\n  const elements = resolveElements(target);\n  elements.forEach((element) => {\n    let elementHandlers = resizeHandlers.get(element);\n    if (!elementHandlers) {\n      elementHandlers = /* @__PURE__ */ new Set();\n      resizeHandlers.set(element, elementHandlers);\n    }\n    elementHandlers.add(handler);\n    observer === null || observer === void 0 ? void 0 : observer.observe(element);\n  });\n  return () => {\n    elements.forEach((element) => {\n      const elementHandlers = resizeHandlers.get(element);\n      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n        observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n      }\n    });\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/handle-window.es.js\nvar windowCallbacks = /* @__PURE__ */ new Set();\nvar windowResizeHandler;\nfunction createWindowResizeHandler() {\n  windowResizeHandler = () => {\n    const size = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n    const info = {\n      target: window,\n      size,\n      contentSize: size\n    };\n    windowCallbacks.forEach((callback) => callback(info));\n  };\n  window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n  windowCallbacks.add(callback);\n  if (!windowResizeHandler)\n    createWindowResizeHandler();\n  return () => {\n    windowCallbacks.delete(callback);\n    if (!windowCallbacks.size && windowResizeHandler) {\n      windowResizeHandler = void 0;\n    }\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/resize/index.es.js\nfunction resize(a2, b2) {\n  return isFunction(a2) ? resizeWindow(a2) : resizeElement(a2, b2);\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/info.es.js\nvar maxElapsed2 = 50;\nvar createAxisInfo = () => ({\n  current: 0,\n  offset: [],\n  progress: 0,\n  scrollLength: 0,\n  targetOffset: 0,\n  targetLength: 0,\n  containerLength: 0,\n  velocity: 0\n});\nvar createScrollInfo = () => ({\n  time: 0,\n  x: createAxisInfo(),\n  y: createAxisInfo()\n});\nvar keys = {\n  x: {\n    length: \"Width\",\n    position: \"Left\"\n  },\n  y: {\n    length: \"Height\",\n    position: \"Top\"\n  }\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n  const axis = info[axisName];\n  const { length, position } = keys[axisName];\n  const prev = axis.current;\n  const prevTime = info.time;\n  axis.current = element[\"scroll\" + position];\n  axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n  axis.offset.length = 0;\n  axis.offset[0] = 0;\n  axis.offset[1] = axis.scrollLength;\n  axis.progress = progress2(0, axis.scrollLength, axis.current);\n  const elapsed = time - prevTime;\n  axis.velocity = elapsed > maxElapsed2 ? 0 : velocityPerSecond2(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n  updateAxisInfo(element, \"x\", info, time);\n  updateAxisInfo(element, \"y\", info, time);\n  info.time = time;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/inset.es.js\nfunction calcInset(element, container) {\n  let inset = { x: 0, y: 0 };\n  let current = element;\n  while (current && current !== container) {\n    if (current instanceof HTMLElement) {\n      inset.x += current.offsetLeft;\n      inset.y += current.offsetTop;\n      current = current.offsetParent;\n    } else if (current instanceof SVGGraphicsElement && \"getBBox\" in current) {\n      const { top, left } = current.getBBox();\n      inset.x += left;\n      inset.y += top;\n      while (current && current.tagName !== \"svg\") {\n        current = current.parentNode;\n      }\n    }\n  }\n  return inset;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/presets.es.js\nvar ScrollOffset = {\n  Enter: [\n    [0, 1],\n    [1, 1]\n  ],\n  Exit: [\n    [0, 0],\n    [1, 0]\n  ],\n  Any: [\n    [1, 0],\n    [0, 1]\n  ],\n  All: [\n    [0, 0],\n    [1, 1]\n  ]\n};\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/edge.es.js\nvar namedEdges = {\n  start: 0,\n  center: 0.5,\n  end: 1\n};\nfunction resolveEdge(edge, length, inset = 0) {\n  let delta = 0;\n  if (namedEdges[edge] !== void 0) {\n    edge = namedEdges[edge];\n  }\n  if (isString2(edge)) {\n    const asNumber2 = parseFloat(edge);\n    if (edge.endsWith(\"px\")) {\n      delta = asNumber2;\n    } else if (edge.endsWith(\"%\")) {\n      edge = asNumber2 / 100;\n    } else if (edge.endsWith(\"vw\")) {\n      delta = asNumber2 / 100 * document.documentElement.clientWidth;\n    } else if (edge.endsWith(\"vh\")) {\n      delta = asNumber2 / 100 * document.documentElement.clientHeight;\n    } else {\n      edge = asNumber2;\n    }\n  }\n  if (isNumber(edge)) {\n    delta = length * edge;\n  }\n  return inset + delta;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/offset.es.js\nvar defaultOffset3 = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset3;\n  let targetPoint = 0;\n  let containerPoint = 0;\n  if (isNumber(offset)) {\n    offsetDefinition = [offset, offset];\n  } else if (isString2(offset)) {\n    offset = offset.trim();\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n    }\n  }\n  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/index.es.js\nvar point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n  let { offset: offsetDefinition = ScrollOffset.All } = options;\n  const { target = container, axis = \"y\" } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset = target !== container ? calcInset(target, container) : point;\n  const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight } : { width: target.clientWidth, height: target.clientHeight };\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  info[axis].offset.length = 0;\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n  for (let i2 = 0; i2 < numOffsets; i2++) {\n    const offset = resolveOffset(offsetDefinition[i2], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i2]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i2] = offset;\n  }\n  if (hasChanged) {\n    info[axis].interpolate = interpolate2(defaultOffset2(numOffsets), info[axis].offset);\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/on-scroll-handler.es.js\nfunction measure(container, target = container, info) {\n  info.x.targetOffset = 0;\n  info.y.targetOffset = 0;\n  if (target !== container) {\n    let node = target;\n    while (node && node != container) {\n      info.x.targetOffset += node.offsetLeft;\n      info.y.targetOffset += node.offsetTop;\n      node = node.offsetParent;\n    }\n  }\n  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;\n  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;\n  info.x.containerLength = container.clientWidth;\n  info.y.containerLength = container.clientHeight;\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n  const axis = options.axis || \"y\";\n  return {\n    measure: () => measure(element, options.target, info),\n    update: (time) => {\n      updateScrollInfo(element, info, time);\n      if (options.offset || options.target) {\n        resolveOffsets(element, info, options);\n      }\n    },\n    notify: isFunction(onScroll) ? () => onScroll(info) : scrubAnimation(onScroll, info[axis])\n  };\n}\nfunction scrubAnimation(controls, axisInfo) {\n  controls.pause();\n  controls.forEachNative((animation, { easing }) => {\n    var _a, _b;\n    if (animation.updateDuration) {\n      if (!easing)\n        animation.easing = noopReturn;\n      animation.updateDuration(1);\n    } else {\n      const timingOptions = { duration: 1e3 };\n      if (!easing)\n        timingOptions.easing = \"linear\";\n      (_b = (_a = animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming) === null || _b === void 0 ? void 0 : _b.call(_a, timingOptions);\n    }\n  });\n  return () => {\n    controls.currentTime = axisInfo.progress;\n  };\n}\n\n// ../../node_modules/@motionone/dom/dist/gestures/scroll/index.es.js\nvar scrollListeners = /* @__PURE__ */ new WeakMap();\nvar resizeListeners = /* @__PURE__ */ new WeakMap();\nvar onScrollHandlers = /* @__PURE__ */ new WeakMap();\nvar getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction scroll(onScroll, _a = {}) {\n  var { container = document.documentElement } = _a, options = __rest2(_a, [\"container\"]);\n  let containerHandlers = onScrollHandlers.get(container);\n  if (!containerHandlers) {\n    containerHandlers = /* @__PURE__ */ new Set();\n    onScrollHandlers.set(container, containerHandlers);\n  }\n  const info = createScrollInfo();\n  const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n  containerHandlers.add(containerHandler);\n  if (!scrollListeners.has(container)) {\n    const listener2 = () => {\n      const time = performance.now();\n      for (const handler of containerHandlers)\n        handler.measure();\n      for (const handler of containerHandlers)\n        handler.update(time);\n      for (const handler of containerHandlers)\n        handler.notify();\n    };\n    scrollListeners.set(container, listener2);\n    const target = getEventTarget(container);\n    window.addEventListener(\"resize\", listener2, { passive: true });\n    if (container !== document.documentElement) {\n      resizeListeners.set(container, resize(container, listener2));\n    }\n    target.addEventListener(\"scroll\", listener2, { passive: true });\n  }\n  const listener = scrollListeners.get(container);\n  const onLoadProcesss = requestAnimationFrame(listener);\n  return () => {\n    var _a2;\n    if (typeof onScroll !== \"function\")\n      onScroll.stop();\n    cancelAnimationFrame(onLoadProcesss);\n    const containerHandlers2 = onScrollHandlers.get(container);\n    if (!containerHandlers2)\n      return;\n    containerHandlers2.delete(containerHandler);\n    if (containerHandlers2.size)\n      return;\n    const listener2 = scrollListeners.get(container);\n    scrollListeners.delete(container);\n    if (listener2) {\n      getEventTarget(container).removeEventListener(\"scroll\", listener2);\n      (_a2 = resizeListeners.get(container)) === null || _a2 === void 0 ? void 0 : _a2();\n      window.removeEventListener(\"resize\", listener2);\n    }\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-scroll.mjs\n\nvar createScrollMotionValues = () => ({\n  scrollX: motionValue(0),\n  scrollY: motionValue(0),\n  scrollXProgress: motionValue(0),\n  scrollYProgress: motionValue(0)\n});\nfunction useScroll(_a = {}) {\n  var _b = _a, { container, target, layoutEffect = true } = _b, options = __objRest(_b, [\"container\", \"target\", \"layoutEffect\"]);\n  const values = useConstant(createScrollMotionValues);\n  const useLifecycleEffect = layoutEffect ? useIsomorphicLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n  useLifecycleEffect(() => {\n    return scroll(({ x, y }) => {\n      values.scrollX.set(x.current);\n      values.scrollXProgress.set(x.progress);\n      values.scrollY.set(y.current);\n      values.scrollYProgress.set(y.progress);\n    }, __spreadProps(__spreadValues({}, options), {\n      container: (container === null || container === void 0 ? void 0 : container.current) || void 0,\n      target: (target === null || target === void 0 ? void 0 : target.current) || void 0\n    }));\n  }, []);\n  return values;\n}\n\n// src/Menu.tsx\n\n{\n  new Date().toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"numeric\"\n  });\n}\nvar Menu = () => {\n  const { scrollYProgress } = useScroll();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n    className: \"hidden sm:block\",\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.div, {\n        className: \"progress-bar\",\n        style: { scaleX: scrollYProgress }\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"flex flex-row items-center justify-between bg-gradient-to-r from-blue-400 to-blue-500\",\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"/\",\n              children: \"Pylar\\u2122 AI by SUPERDATAS\"\n            })\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"/blog\",\n              children: \"Daily Work\"\n            })\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"/what-is-pylar\",\n              children: \"About\"\n            })\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"/pylar-license\",\n              children: \"The License\"\n            })\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n            className: \"rounded-xl py-2 px-4 font-bold text-white\",\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"https://pencil.domains\",\n              target: \"_blank\",\n              rel: \"noreferrer\",\n              children: \"Pencil Domains\"\n            })\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n            className: \"hidden py-2 px-4 font-bold text-white md:block\",\n            style: {\n              display: \"flex\",\n              justifyContent: \"center\",\n              alignItems: \"center\"\n            },\n            children: [\n              \" \",\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n                className: \"hidden py-2 px-4 font-bold text-white md:block\",\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n                  href: \"http://twitter.com/superdatas\",\n                  target: \"_blank\",\n                  rel: \"noopener noreferrer\",\n                  children: \"Twitter\"\n                })\n              }),\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n                href: \"http://github.com/miguelgargallo/next13-gallery-image-turbo\",\n                target: \"_blank\",\n                rel: \"noopener noreferrer\",\n                className: \"hidden py-2 px-4 font-bold text-white md:block\",\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"picture\", {\n                  children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                    src: \"https://img.shields.io/github/stars/miguelgargallo/Next13-gallery-image-turbo?style=social\",\n                    alt: \"Landscape picture\",\n                    width: 100,\n                    height: 20\n                  })\n                })\n              }),\n              \" \",\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Version, {})\n            ]\n          })\n        ]\n      })\n    ]\n  });\n};\n\n// src/MenuPylar.tsx\n\nvar MenuPylar = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    className: \"flex hidden flex-row items-center justify-between bg-gradient-to-r from-blue-400 to-blue-500 sm:block\",\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n      className: \"flex flex-row\",\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"/blog\",\n            children: \"Our Daily Work\"\n          })\n        }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"/what-is-pylar\",\n            children: \"What is Pylar AI\"\n          })\n        }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n          className: \"rounded-xl py-2 px-4 font-bold text-white\",\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"/pylar-license\",\n            children: \"License\"\n          })\n        })\n      ]\n    })\n  });\n};\n\n// src/TitlePylar.tsx\n\nvar TitlePylar = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"h1\", {\n        className: \"py-8 text-center text-5xl font-bold\",\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.5, duration: 1.5 },\n            children: \"P\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.6, duration: 1.5 },\n            children: \"y\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.7, duration: 1.5 },\n            children: \"l\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.8, duration: 1.5 },\n            children: \"a\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 0.9, duration: 1.5 },\n            children: \"r\\u2122\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1, duration: 1.5 },\n            children: \"\\xA0\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1.1, duration: 1.5 },\n            children: \"A\"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.span, {\n            initial: { opacity: 0 },\n            animate: { opacity: 1 },\n            transition: { delay: 1.2, duration: 1.5 },\n            children: \"I\"\n          })\n        ]\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(motion.h2, {\n        className: \"py-8 text-center text-4xl font-bold\",\n        initial: { opacity: 0 },\n        animate: { opacity: 1 },\n        transition: { delay: 1.4, duration: 1.5 },\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"Py\"\n          }),\n          \"thon\",\n          \" \",\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"L\"\n          }),\n          \"earning\",\n          \" \",\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"A\"\n          }),\n          \"rtificial\",\n          \" \",\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"R\"\n          }),\n          \"esearch\\u2122\",\n          \" \",\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-black\",\n            children: \" \"\n          }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"A\"\n          }),\n          \"rtificial\",\n          \" \",\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            className: \"text-blue-500\",\n            children: \"I\"\n          }),\n          \"ntelligence\",\n          \" \"\n        ]\n      })\n    ]\n  });\n};\n\n// src/ListPylar.tsx\n\nvar ListPylar = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    className: \"mt-8 flex flex-row justify-center\",\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n      className: \"flex w-3/4 flex-col\",\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n          className: \"text-2xl font-bold\",\n          children: \"Welcome to the Pylar AI Blog\"\n        }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n          className: \"mt-4 text-lg\",\n          children: [\n            \"Pylar AI is:\",\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"ul\", {\n              className: \"list-inside list-disc\",\n              children: [\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n                  children: \"Generative art results\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n                  children: \"What is generative art? Generative art is a form of art that uses a computer to create art. The computer is programmed to create art based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n                  children: \"Promt Engineering design\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n                  children: \"Promt Engineering is a form of engineering that uses a computer to create engineering. The computer is programmed to create engineering based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n                  children: \"StableDiffusion 2.0 modified\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n                  children: \"StableDiffusion 2.0 is a computer program that is used to create art based on a set of rules.\"\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                  children: \"\\xA0\"\n                })\n              ]\n            })\n          ]\n        })\n      ]\n    })\n  });\n};\n\n// src/Footer.tsx\n\nvar Footer = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"footer\", {\n    className: \"bg-white py-8 text-center\",\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"a\", {\n          children: [\n            \"Made with \\u2764\\uFE0F by\",\n            \" \",\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"https://twitter.com/miguelgargallo\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hover:text-blue text-indigo-600\",\n              children: \"Miguel Gargallo\"\n            }),\n            \".\"\n          ]\n        })\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"a\", {\n          children: [\n            \"2022 \\xA9\",\n            \" \",\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"https://huggingface.co/spaces/superdatas/LICENSE\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hover:text-blue text-indigo-600\",\n              children: \"Pylar\\u2122 AI creative ML license\"\n            }),\n            \".\"\n          ]\n        })\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"hidden sm:block\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n          className: \"flex w-full items-center justify-center\",\n          children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fmiguelgargallo%2FNext13-Fetch-Data-turbo&project-name=miguelgargallo-next13-fetch-data-turbo&repo-name=miguelgargallo-next13-fetch-data-turbo\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hidden p-2 md:block\",\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"picture\", {\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                  src: \"https://vercel.com/button\",\n                  alt: \"Landscape picture\",\n                  width: 75,\n                  height: 20\n                })\n              })\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n              href: \"https://huggingface.co/spaces/superdatas/LICENSE\",\n              target: \"_blank\",\n              rel: \"noopener noreferrer\",\n              className: \"hidden p-2 md:block\",\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"picture\", {\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                  src: \"https://huggingface.co/front/assets/huggingface_logo.svg\",\n                  alt: \"Landscape picture\",\n                  width: 40,\n                  height: 20\n                })\n              })\n            })\n          ]\n        })\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n        children: \"Please do not consider the score as investment advice.\"\n      })\n    ]\n  });\n};\n\n// src/Scrollable.tsx\n\nvar Scrollable = () => {\n  const { scrollYProgress } = useScroll();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(motion.div, {\n    className: \"progress-bar\",\n    style: { scaleX: scrollYProgress }\n  });\n};\n\n// src/BlogPylar/blog.tsx\n\nvar ELEMENTS2 = 5;\nvar blog = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: \"95\",\n      height: \"95\",\n      stroke: \"#FFF\",\n      \"stroke-width\": \"0\",\n      viewBox: \"0 0 95 95\",\n      className: \"m-2 rounded-xl py-2 shadow-md hover:shadow-xl\",\n      style: k(ELEMENTS2),\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M32.816,12.95,30.349,8.568h4.78a.439.439,0,0,1,.346.2l.931,1.534c.558.92,1.225,2.02,1.607,2.648ZM23.975,39.495a.339.339,0,0,1-.315.207H18.772l7.595-13.635a.731.731,0,0,0-.636-1.087h0L12.787,25l-2.574-4.456H29.076c.011,0,.02,0,.031,0a.677.677,0,0,0,.217-.045l.047-.02a.722.722,0,0,0,.346-.313l3.108-5.745h5.13Zm-6.468-.518-.613-1.009c-.785-1.3-1.791-2.955-1.9-3.137a.385.385,0,0,1,.024-.355l4.457-8.027,5.019-.006ZM8.948,30.444,6.453,26.011,8.968,21.3l2.522,4.367C10.706,27.14,9.483,29.442,8.948,30.444Zm-3.348.69H2.881a.443.443,0,0,1-.343-.2L1.726,29.6C1.147,28.641.409,27.425,0,26.752H5.2l2.466,4.383ZM14.037.208A.338.338,0,0,1,14.351,0h4.91L11.646,13.636c-.006.011-.01.023-.016.035s-.021.046-.03.07-.015.046-.021.069-.011.044-.014.066a.648.648,0,0,0-.008.081c0,.012,0,.023,0,.036s0,.018,0,.027a.591.591,0,0,0,.008.079.538.538,0,0,0,.012.066c.006.023.013.045.021.068s.016.045.025.066.021.041.033.062.023.04.037.059a.644.644,0,0,0,.045.055c.016.017.031.035.048.051s.035.029.053.043a.634.634,0,0,0,.063.045l.023.016c.008,0,.018.006.027.011a.729.729,0,0,0,.119.048c.015,0,.029.01.044.013a.7.7,0,0,0,.164.021h.33l12.619-.017c.334.58.957,1.673,1.489,2.6q.612,1.072,1.01,1.768H8.949c-.008,0-.016,0-.024,0a.725.725,0,0,0-.631.382L5.185,25.29H.059Zm6.479.534.456.75c.8,1.321,1.932,3.185,2.052,3.379A.383.383,0,0,1,23,5.227l-4.457,8.027-5.017.006Zm8.546,8.511,2.5,4.435-2.545,4.7c-.3-.529-.68-1.189-1.034-1.808-.7-1.224-1.208-2.115-1.495-2.613C27.028,12.977,28.462,10.349,29.062,9.253Z\",\n        id: \"Fill-1\",\n        className: \"fill-yellow-500\"\n      })\n    })\n  });\n};\n\n// src/BlogPylar/post12032022.tsx\n\nvar ELEMENTS3 = 5;\nvar post12032022 = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: \"95\",\n      height: \"95\",\n      stroke: \"#FFF\",\n      \"stroke-width\": \"0\",\n      viewBox: \"0 0 95 95\",\n      className: \"m-2 rounded-xl py-2 shadow-md hover:shadow-xl\",\n      style: k(ELEMENTS3),\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M32.816,12.95,30.349,8.568h4.78a.439.439,0,0,1,.346.2l.931,1.534c.558.92,1.225,2.02,1.607,2.648ZM23.975,39.495a.339.339,0,0,1-.315.207H18.772l7.595-13.635a.731.731,0,0,0-.636-1.087h0L12.787,25l-2.574-4.456H29.076c.011,0,.02,0,.031,0a.677.677,0,0,0,.217-.045l.047-.02a.722.722,0,0,0,.346-.313l3.108-5.745h5.13Zm-6.468-.518-.613-1.009c-.785-1.3-1.791-2.955-1.9-3.137a.385.385,0,0,1,.024-.355l4.457-8.027,5.019-.006ZM8.948,30.444,6.453,26.011,8.968,21.3l2.522,4.367C10.706,27.14,9.483,29.442,8.948,30.444Zm-3.348.69H2.881a.443.443,0,0,1-.343-.2L1.726,29.6C1.147,28.641.409,27.425,0,26.752H5.2l2.466,4.383ZM14.037.208A.338.338,0,0,1,14.351,0h4.91L11.646,13.636c-.006.011-.01.023-.016.035s-.021.046-.03.07-.015.046-.021.069-.011.044-.014.066a.648.648,0,0,0-.008.081c0,.012,0,.023,0,.036s0,.018,0,.027a.591.591,0,0,0,.008.079.538.538,0,0,0,.012.066c.006.023.013.045.021.068s.016.045.025.066.021.041.033.062.023.04.037.059a.644.644,0,0,0,.045.055c.016.017.031.035.048.051s.035.029.053.043a.634.634,0,0,0,.063.045l.023.016c.008,0,.018.006.027.011a.729.729,0,0,0,.119.048c.015,0,.029.01.044.013a.7.7,0,0,0,.164.021h.33l12.619-.017c.334.58.957,1.673,1.489,2.6q.612,1.072,1.01,1.768H8.949c-.008,0-.016,0-.024,0a.725.725,0,0,0-.631.382L5.185,25.29H.059Zm6.479.534.456.75c.8,1.321,1.932,3.185,2.052,3.379A.383.383,0,0,1,23,5.227l-4.457,8.027-5.017.006Zm8.546,8.511,2.5,4.435-2.545,4.7c-.3-.529-.68-1.189-1.034-1.808-.7-1.224-1.208-2.115-1.495-2.613C27.028,12.977,28.462,10.349,29.062,9.253Z\",\n        id: \"Fill-1\",\n        className: \"fill-yellow-500\"\n      })\n    })\n  });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNLQUFzSztBQUM5SyxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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TTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNO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WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9wYWNrYWdlcy91aS9kaXN0L2luZGV4Lm1qcz82OGY4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhMiwgYjIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiMiB8fCAoYjIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIyLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhMiwgcHJvcCwgYjJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYjIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYjIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYTIsIHByb3AsIGIyW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhMjtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhMiwgYjIpID0+IF9fZGVmUHJvcHMoYTIsIF9fZ2V0T3duUHJvcERlc2NzKGIyKSk7XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX2VzbSA9IChmbiwgcmVzKSA9PiBmdW5jdGlvbiBfX2luaXQoKSB7XG4gIHJldHVybiBmbiAmJiAocmVzID0gKDAsIGZuW19fZ2V0T3duUHJvcE5hbWVzKGZuKVswXV0pKGZuID0gMCkpLCByZXM7XG59O1xudmFyIF9fY29tbW9uSlMgPSAoY2IyLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHtcbiAgcmV0dXJuIG1vZCB8fCAoMCwgY2IyW19fZ2V0T3duUHJvcE5hbWVzKGNiMilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vbWVtb2l6ZS9kaXN0L21lbW9pemUuZXNtLmpzXG5mdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKGNhY2hlW2FyZ10gPT09IHZvaWQgMClcbiAgICAgIGNhY2hlW2FyZ10gPSBmbihhcmcpO1xuICAgIHJldHVybiBjYWNoZVthcmddO1xuICB9O1xufVxudmFyIG1lbW9pemVfZXNtX2RlZmF1bHQ7XG52YXIgaW5pdF9tZW1vaXplX2VzbSA9IF9fZXNtKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vbWVtb2l6ZS9kaXN0L21lbW9pemUuZXNtLmpzXCIoKSB7XG4gICAgbWVtb2l6ZV9lc21fZGVmYXVsdCA9IG1lbW9pemU7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vaXMtcHJvcC12YWxpZC9kaXN0L2lzLXByb3AtdmFsaWQuZXNtLmpzXG52YXIgaXNfcHJvcF92YWxpZF9lc21fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaXNfcHJvcF92YWxpZF9lc21fZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBpc19wcm9wX3ZhbGlkX2VzbV9kZWZhdWx0XG59KTtcbnZhciByZWFjdFByb3BzUmVnZXgsIGluZGV4LCBpc19wcm9wX3ZhbGlkX2VzbV9kZWZhdWx0O1xudmFyIGluaXRfaXNfcHJvcF92YWxpZF9lc20gPSBfX2VzbSh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL2lzLXByb3AtdmFsaWQvZGlzdC9pcy1wcm9wLXZhbGlkLmVzbS5qc1wiKCkge1xuICAgIGluaXRfbWVtb2l6ZV9lc20oKTtcbiAgICByZWFjdFByb3BzUmVnZXggPSAvXigoY2hpbGRyZW58ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUx8a2V5fHJlZnxhdXRvRm9jdXN8ZGVmYXVsdFZhbHVlfGRlZmF1bHRDaGVja2VkfGlubmVySFRNTHxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmd8c3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nfHZhbHVlTGlua3xhY2NlcHR8YWNjZXB0Q2hhcnNldHxhY2Nlc3NLZXl8YWN0aW9ufGFsbG93fGFsbG93VXNlck1lZGlhfGFsbG93UGF5bWVudFJlcXVlc3R8YWxsb3dGdWxsU2NyZWVufGFsbG93VHJhbnNwYXJlbmN5fGFsdHxhc3luY3xhdXRvQ29tcGxldGV8YXV0b1BsYXl8Y2FwdHVyZXxjZWxsUGFkZGluZ3xjZWxsU3BhY2luZ3xjaGFsbGVuZ2V8Y2hhclNldHxjaGVja2VkfGNpdGV8Y2xhc3NJRHxjbGFzc05hbWV8Y29sc3xjb2xTcGFufGNvbnRlbnR8Y29udGVudEVkaXRhYmxlfGNvbnRleHRNZW51fGNvbnRyb2xzfGNvbnRyb2xzTGlzdHxjb29yZHN8Y3Jvc3NPcmlnaW58ZGF0YXxkYXRlVGltZXxkZWNvZGluZ3xkZWZhdWx0fGRlZmVyfGRpcnxkaXNhYmxlZHxkaXNhYmxlUGljdHVyZUluUGljdHVyZXxkb3dubG9hZHxkcmFnZ2FibGV8ZW5jVHlwZXxmb3JtfGZvcm1BY3Rpb258Zm9ybUVuY1R5cGV8Zm9ybU1ldGhvZHxmb3JtTm9WYWxpZGF0ZXxmb3JtVGFyZ2V0fGZyYW1lQm9yZGVyfGhlYWRlcnN8aGVpZ2h0fGhpZGRlbnxoaWdofGhyZWZ8aHJlZkxhbmd8aHRtbEZvcnxodHRwRXF1aXZ8aWR8aW5wdXRNb2RlfGludGVncml0eXxpc3xrZXlQYXJhbXN8a2V5VHlwZXxraW5kfGxhYmVsfGxhbmd8bGlzdHxsb2FkaW5nfGxvb3B8bG93fG1hcmdpbkhlaWdodHxtYXJnaW5XaWR0aHxtYXh8bWF4TGVuZ3RofG1lZGlhfG1lZGlhR3JvdXB8bWV0aG9kfG1pbnxtaW5MZW5ndGh8bXVsdGlwbGV8bXV0ZWR8bmFtZXxub25jZXxub1ZhbGlkYXRlfG9wZW58b3B0aW11bXxwYXR0ZXJufHBsYWNlaG9sZGVyfHBsYXlzSW5saW5lfHBvc3RlcnxwcmVsb2FkfHByb2ZpbGV8cmFkaW9Hcm91cHxyZWFkT25seXxyZWZlcnJlclBvbGljeXxyZWx8cmVxdWlyZWR8cmV2ZXJzZWR8cm9sZXxyb3dzfHJvd1NwYW58c2FuZGJveHxzY29wZXxzY29wZWR8c2Nyb2xsaW5nfHNlYW1sZXNzfHNlbGVjdGVkfHNoYXBlfHNpemV8c2l6ZXN8c2xvdHxzcGFufHNwZWxsQ2hlY2t8c3JjfHNyY0RvY3xzcmNMYW5nfHNyY1NldHxzdGFydHxzdGVwfHN0eWxlfHN1bW1hcnl8dGFiSW5kZXh8dGFyZ2V0fHRpdGxlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufHJlc3VsdHN8c2VjdXJpdHl8dW5zZWxlY3RhYmxlfGFjY2VudEhlaWdodHxhY2N1bXVsYXRlfGFkZGl0aXZlfGFsaWdubWVudEJhc2VsaW5lfGFsbG93UmVvcmRlcnxhbHBoYWJldGljfGFtcGxpdHVkZXxhcmFiaWNGb3JtfGFzY2VudHxhdHRyaWJ1dGVOYW1lfGF0dHJpYnV0ZVR5cGV8YXV0b1JldmVyc2V8YXppbXV0aHxiYXNlRnJlcXVlbmN5fGJhc2VsaW5lU2hpZnR8YmFzZVByb2ZpbGV8YmJveHxiZWdpbnxiaWFzfGJ5fGNhbGNNb2RlfGNhcEhlaWdodHxjbGlwfGNsaXBQYXRoVW5pdHN8Y2xpcFBhdGh8Y2xpcFJ1bGV8Y29sb3JJbnRlcnBvbGF0aW9ufGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnN8Y29sb3JQcm9maWxlfGNvbG9yUmVuZGVyaW5nfGNvbnRlbnRTY3JpcHRUeXBlfGNvbnRlbnRTdHlsZVR5cGV8Y3Vyc29yfGN4fGN5fGR8ZGVjZWxlcmF0ZXxkZXNjZW50fGRpZmZ1c2VDb25zdGFudHxkaXJlY3Rpb258ZGlzcGxheXxkaXZpc29yfGRvbWluYW50QmFzZWxpbmV8ZHVyfGR4fGR5fGVkZ2VNb2RlfGVsZXZhdGlvbnxlbmFibGVCYWNrZ3JvdW5kfGVuZHxleHBvbmVudHxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkfGZpbGx8ZmlsbE9wYWNpdHl8ZmlsbFJ1bGV8ZmlsdGVyfGZpbHRlclJlc3xmaWx0ZXJVbml0c3xmbG9vZENvbG9yfGZsb29kT3BhY2l0eXxmb2N1c2FibGV8Zm9udEZhbWlseXxmb250U2l6ZXxmb250U2l6ZUFkanVzdHxmb250U3RyZXRjaHxmb250U3R5bGV8Zm9udFZhcmlhbnR8Zm9udFdlaWdodHxmb3JtYXR8ZnJvbXxmcnxmeHxmeXxnMXxnMnxnbHlwaE5hbWV8Z2x5cGhPcmllbnRhdGlvbkhvcml6b250YWx8Z2x5cGhPcmllbnRhdGlvblZlcnRpY2FsfGdseXBoUmVmfGdyYWRpZW50VHJhbnNmb3JtfGdyYWRpZW50VW5pdHN8aGFuZ2luZ3xob3JpekFkdlh8aG9yaXpPcmlnaW5YfGlkZW9ncmFwaGljfGltYWdlUmVuZGVyaW5nfGlufGluMnxpbnRlcmNlcHR8a3xrMXxrMnxrM3xrNHxrZXJuZWxNYXRyaXh8a2VybmVsVW5pdExlbmd0aHxrZXJuaW5nfGtleVBvaW50c3xrZXlTcGxpbmVzfGtleVRpbWVzfGxlbmd0aEFkanVzdHxsZXR0ZXJTcGFjaW5nfGxpZ2h0aW5nQ29sb3J8bGltaXRpbmdDb25lQW5nbGV8bG9jYWx8bWFya2VyRW5kfG1hcmtlck1pZHxtYXJrZXJTdGFydHxtYXJrZXJIZWlnaHR8bWFya2VyVW5pdHN8bWFya2VyV2lkdGh8bWFza3xtYXNrQ29udGVudFVuaXRzfG1hc2tVbml0c3xtYXRoZW1hdGljYWx8bW9kZXxudW1PY3RhdmVzfG9mZnNldHxvcGFjaXR5fG9wZXJhdG9yfG9yZGVyfG9yaWVudHxvcmllbnRhdGlvbnxvcmlnaW58b3ZlcmZsb3d8b3ZlcmxpbmVQb3NpdGlvbnxvdmVybGluZVRoaWNrbmVzc3xwYW5vc2UxfHBhaW50T3JkZXJ8cGF0aExlbmd0aHxwYXR0ZXJuQ29udGVudFVuaXRzfHBhdHRlcm5UcmFuc2Zvcm18cGF0dGVyblVuaXRzfHBvaW50ZXJFdmVudHN8cG9pbnRzfHBvaW50c0F0WHxwb2ludHNBdFl8cG9pbnRzQXRafHByZXNlcnZlQWxwaGF8cHJlc2VydmVBc3BlY3RSYXRpb3xwcmltaXRpdmVVbml0c3xyfHJhZGl1c3xyZWZYfHJlZll8cmVuZGVyaW5nSW50ZW50fHJlcGVhdENvdW50fHJlcGVhdER1cnxyZXF1aXJlZEV4dGVuc2lvbnN8cmVxdWlyZWRGZWF0dXJlc3xyZXN0YXJ0fHJlc3VsdHxyb3RhdGV8cnh8cnl8c2NhbGV8c2VlZHxzaGFwZVJlbmRlcmluZ3xzbG9wZXxzcGFjaW5nfHNwZWN1bGFyQ29uc3RhbnR8c3BlY3VsYXJFeHBvbmVudHxzcGVlZHxzcHJlYWRNZXRob2R8c3RhcnRPZmZzZXR8c3RkRGV2aWF0aW9ufHN0ZW1ofHN0ZW12fHN0aXRjaFRpbGVzfHN0b3BDb2xvcnxzdG9wT3BhY2l0eXxzdHJpa2V0aHJvdWdoUG9zaXRpb258c3RyaWtldGhyb3VnaFRoaWNrbmVzc3xzdHJpbmd8c3Ryb2tlfHN0cm9rZURhc2hhcnJheXxzdHJva2VEYXNob2Zmc2V0fHN0cm9rZUxpbmVjYXB8c3Ryb2tlTGluZWpvaW58c3Ryb2tlTWl0ZXJsaW1pdHxzdHJva2VPcGFjaXR5fHN0cm9rZVdpZHRofHN1cmZhY2VTY2FsZXxzeXN0ZW1MYW5ndWFnZXx0YWJsZVZhbHVlc3x0YXJnZXRYfHRhcmdldFl8dGV4dEFuY2hvcnx0ZXh0RGVjb3JhdGlvbnx0ZXh0UmVuZGVyaW5nfHRleHRMZW5ndGh8dG98dHJhbnNmb3JtfHUxfHUyfHVuZGVybGluZVBvc2l0aW9ufHVuZGVybGluZVRoaWNrbmVzc3x1bmljb2RlfHVuaWNvZGVCaWRpfHVuaWNvZGVSYW5nZXx1bml0c1BlckVtfHZBbHBoYWJldGljfHZIYW5naW5nfHZJZGVvZ3JhcGhpY3x2TWF0aGVtYXRpY2FsfHZhbHVlc3x2ZWN0b3JFZmZlY3R8dmVyc2lvbnx2ZXJ0QWR2WXx2ZXJ0T3JpZ2luWHx2ZXJ0T3JpZ2luWXx2aWV3Qm94fHZpZXdUYXJnZXR8dmlzaWJpbGl0eXx3aWR0aHN8d29yZFNwYWNpbmd8d3JpdGluZ01vZGV8eHx4SGVpZ2h0fHgxfHgyfHhDaGFubmVsU2VsZWN0b3J8eGxpbmtBY3R1YXRlfHhsaW5rQXJjcm9sZXx4bGlua0hyZWZ8eGxpbmtSb2xlfHhsaW5rU2hvd3x4bGlua1RpdGxlfHhsaW5rVHlwZXx4bWxCYXNlfHhtbG5zfHhtbG5zWGxpbmt8eG1sTGFuZ3x4bWxTcGFjZXx5fHkxfHkyfHlDaGFubmVsU2VsZWN0b3J8enx6b29tQW5kUGFufGZvcnxjbGFzc3xhdXRvZm9jdXMpfCgoW0RkXVtBYV1bVHRdW0FhXXxbQWFdW1JyXVtJaV1bQWFdfHgpLS4qKSkkLztcbiAgICBpbmRleCA9IG1lbW9pemVfZXNtX2RlZmF1bHQoXG4gICAgICBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiByZWFjdFByb3BzUmVnZXgudGVzdChwcm9wKSB8fCBwcm9wLmNoYXJDb2RlQXQoMCkgPT09IDExMSAmJiBwcm9wLmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiBwcm9wLmNoYXJDb2RlQXQoMikgPCA5MTtcbiAgICAgIH1cbiAgICApO1xuICAgIGlzX3Byb3BfdmFsaWRfZXNtX2RlZmF1bHQgPSBpbmRleDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzXG52YXIgcmVxdWlyZV90c2xpYiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgdmFyIF9fZXh0ZW5kczM7XG4gICAgdmFyIF9fYXNzaWduMztcbiAgICB2YXIgX19yZXN0MztcbiAgICB2YXIgX19kZWNvcmF0ZTM7XG4gICAgdmFyIF9fcGFyYW0zO1xuICAgIHZhciBfX21ldGFkYXRhMztcbiAgICB2YXIgX19hd2FpdGVyMztcbiAgICB2YXIgX19nZW5lcmF0b3IzO1xuICAgIHZhciBfX2V4cG9ydFN0YXIzO1xuICAgIHZhciBfX3ZhbHVlczM7XG4gICAgdmFyIF9fcmVhZDM7XG4gICAgdmFyIF9fc3ByZWFkMztcbiAgICB2YXIgX19zcHJlYWRBcnJheXMzO1xuICAgIHZhciBfX3NwcmVhZEFycmF5MztcbiAgICB2YXIgX19hd2FpdDM7XG4gICAgdmFyIF9fYXN5bmNHZW5lcmF0b3IzO1xuICAgIHZhciBfX2FzeW5jRGVsZWdhdG9yMztcbiAgICB2YXIgX19hc3luY1ZhbHVlczM7XG4gICAgdmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0MztcbiAgICB2YXIgX19pbXBvcnRTdGFyMztcbiAgICB2YXIgX19pbXBvcnREZWZhdWx0MztcbiAgICB2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldDM7XG4gICAgdmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQzO1xuICAgIHZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4zO1xuICAgIHZhciBfX2NyZWF0ZUJpbmRpbmczO1xuICAgIChmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcbiAgICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbihleHBvcnRzMikge1xuICAgICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0czIpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzMiwgcHJldmlvdXMpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMyICE9PSByb290KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydHMyLl9fZXNNb2R1bGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaWQyLCB2KSB7XG4gICAgICAgICAgcmV0dXJuIGV4cG9ydHMyW2lkMl0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkMiwgdikgOiB2O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pKGZ1bmN0aW9uKGV4cG9ydGVyKSB7XG4gICAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGQyLCBiMikge1xuICAgICAgICBkMi5fX3Byb3RvX18gPSBiMjtcbiAgICAgIH0gfHwgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgIGZvciAodmFyIHAyIGluIGIyKVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYjIsIHAyKSlcbiAgICAgICAgICAgIGQyW3AyXSA9IGIyW3AyXTtcbiAgICAgIH07XG4gICAgICBfX2V4dGVuZHMzID0gZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYjIgIT09IFwiZnVuY3Rpb25cIiAmJiBiMiAhPT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiMikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQyLCBiMik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkMjtcbiAgICAgICAgfVxuICAgICAgICBkMi5wcm90b3R5cGUgPSBiMiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYjIpIDogKF9fLnByb3RvdHlwZSA9IGIyLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgICAgfTtcbiAgICAgIF9fYXNzaWduMyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpMiA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpMiA8IG47IGkyKyspIHtcbiAgICAgICAgICBzID0gYXJndW1lbnRzW2kyXTtcbiAgICAgICAgICBmb3IgKHZhciBwMiBpbiBzKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwMikpXG4gICAgICAgICAgICAgIHRbcDJdID0gc1twMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9O1xuICAgICAgX19yZXN0MyA9IGZ1bmN0aW9uKHMsIGUpIHtcbiAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gcylcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHAyKSAmJiBlLmluZGV4T2YocDIpIDwgMClcbiAgICAgICAgICAgIHRbcDJdID0gc1twMl07XG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDAsIHAyID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaTIgPCBwMi5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocDJbaTJdKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHAyW2kyXSkpXG4gICAgICAgICAgICAgIHRbcDJbaTJdXSA9IHNbcDJbaTJdXTtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfTtcbiAgICAgIF9fZGVjb3JhdGUzID0gZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICAgICAgdmFyIGMzID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMzIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkMjtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICh2YXIgaTIgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pXG4gICAgICAgICAgICBpZiAoZDIgPSBkZWNvcmF0b3JzW2kyXSlcbiAgICAgICAgICAgICAgciA9IChjMyA8IDMgPyBkMihyKSA6IGMzID4gMyA/IGQyKHRhcmdldCwga2V5LCByKSA6IGQyKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICAgICAgcmV0dXJuIGMzID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gICAgICB9O1xuICAgICAgX19wYXJhbTMgPSBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBfX21ldGFkYXRhMyA9IGZ1bmN0aW9uKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcbiAgICAgIH07XG4gICAgICBfX2F3YWl0ZXIzID0gZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBfX2dlbmVyYXRvcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBib2R5KSB7XG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRbMF0gJiAxKVxuICAgICAgICAgICAgdGhyb3cgdFsxXTtcbiAgICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgICAgfSwgdHJ5czogW10sIG9wczogW10gfSwgZjIsIHksIHQsIGcyO1xuICAgICAgICByZXR1cm4gZzIgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGcyW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSksIGcyO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgICBpZiAoZjIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgICB3aGlsZSAoXylcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChmMiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KVxuICAgICAgICAgICAgICAgIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pXG4gICAgICAgICAgICAgICAgICAgIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGYyID0gdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wWzBdICYgNSlcbiAgICAgICAgICAgIHRocm93IG9wWzFdO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX2V4cG9ydFN0YXIzID0gZnVuY3Rpb24obSwgbykge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBtKVxuICAgICAgICAgIGlmIChwMiAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwMikpXG4gICAgICAgICAgICBfX2NyZWF0ZUJpbmRpbmczKG8sIG0sIHAyKTtcbiAgICAgIH07XG4gICAgICBfX2NyZWF0ZUJpbmRpbmczID0gT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uKG8sIG0sIGsyLCBrMjIpIHtcbiAgICAgICAgaWYgKGsyMiA9PT0gdm9pZCAwKVxuICAgICAgICAgIGsyMiA9IGsyO1xuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgazIpO1xuICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbVtrMl07XG4gICAgICAgICAgfSB9O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMjIsIGRlc2MpO1xuICAgICAgfSA6IGZ1bmN0aW9uKG8sIG0sIGsyLCBrMjIpIHtcbiAgICAgICAgaWYgKGsyMiA9PT0gdm9pZCAwKVxuICAgICAgICAgIGsyMiA9IGsyO1xuICAgICAgICBvW2syMl0gPSBtW2syXTtcbiAgICAgIH07XG4gICAgICBfX3ZhbHVlczMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaTIgPSAwO1xuICAgICAgICBpZiAobSlcbiAgICAgICAgICByZXR1cm4gbS5jYWxsKG8pO1xuICAgICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAobyAmJiBpMiA+PSBvLmxlbmd0aClcbiAgICAgICAgICAgICAgICBvID0gdm9pZCAwO1xuICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2kyKytdLCBkb25lOiAhbyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIH07XG4gICAgICBfX3JlYWQzID0gZnVuY3Rpb24obywgbikge1xuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICAgIGlmICghbSlcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgdmFyIGkyID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkyLm5leHQoKSkuZG9uZSlcbiAgICAgICAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgZSA9IHsgZXJyb3IgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGkyW1wicmV0dXJuXCJdKSlcbiAgICAgICAgICAgICAgbS5jYWxsKGkyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcjtcbiAgICAgIH07XG4gICAgICBfX3NwcmVhZDMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaTIgPSAwOyBpMiA8IGFyZ3VtZW50cy5sZW5ndGg7IGkyKyspXG4gICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkMyhhcmd1bWVudHNbaTJdKSk7XG4gICAgICAgIHJldHVybiBhcjtcbiAgICAgIH07XG4gICAgICBfX3NwcmVhZEFycmF5czMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkyID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpMiA8IGlsOyBpMisrKVxuICAgICAgICAgIHMgKz0gYXJndW1lbnRzW2kyXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgazIgPSAwLCBpMiA9IDA7IGkyIDwgaWw7IGkyKyspXG4gICAgICAgICAgZm9yICh2YXIgYTIgPSBhcmd1bWVudHNbaTJdLCBqID0gMCwgamwgPSBhMi5sZW5ndGg7IGogPCBqbDsgaisrLCBrMisrKVxuICAgICAgICAgICAgcltrMl0gPSBhMltqXTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgICAgX19zcHJlYWRBcnJheTMgPSBmdW5jdGlvbih0bywgZnJvbSwgcGFjaykge1xuICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgICAgIGZvciAodmFyIGkyID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaTIgPCBsOyBpMisrKSB7XG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpMiBpbiBmcm9tKSkge1xuICAgICAgICAgICAgICBpZiAoIWFyKVxuICAgICAgICAgICAgICAgIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaTIpO1xuICAgICAgICAgICAgICBhcltpMl0gPSBmcm9tW2kyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xuICAgICAgfTtcbiAgICAgIF9fYXdhaXQzID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQzID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQzKHYpO1xuICAgICAgfTtcbiAgICAgIF9fYXN5bmNHZW5lcmF0b3IzID0gZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgdmFyIGcyID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpMiwgcSA9IFtdO1xuICAgICAgICByZXR1cm4gaTIgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaTJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGkyO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICBpZiAoZzJbbl0pXG4gICAgICAgICAgICBpMltuXSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGEyLCBiMikge1xuICAgICAgICAgICAgICAgIHEucHVzaChbbiwgdiwgYTIsIGIyXSkgPiAxIHx8IHJlc3VtZShuLCB2KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZzJbbl0odikpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHNldHRsZShxWzBdWzNdLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7XG4gICAgICAgICAgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQzID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICAgICAgICByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHtcbiAgICAgICAgICByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYyLCB2KSB7XG4gICAgICAgICAgaWYgKGYyKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKVxuICAgICAgICAgICAgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19hc3luY0RlbGVnYXRvcjMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBpMiwgcDI7XG4gICAgICAgIHJldHVybiBpMiA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KSwgdmVyYihcInJldHVyblwiKSwgaTJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBpMjtcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmMikge1xuICAgICAgICAgIGkyW25dID0gb1tuXSA/IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiAocDIgPSAhcDIpID8geyB2YWx1ZTogX19hd2FpdDMob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYyID8gZjIodikgOiB2O1xuICAgICAgICAgIH0gOiBmMjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fYXN5bmNWYWx1ZXMzID0gZnVuY3Rpb24obykge1xuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGkyO1xuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzMyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkyID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGkyW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBpMik7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICAgIGkyW25dID0gb1tuXSAmJiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkMiwgdikge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYyKSB7XG4gICAgICAgICAgICByZXNvbHZlKHsgdmFsdWU6IHYyLCBkb25lOiBkMiB9KTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19tYWtlVGVtcGxhdGVPYmplY3QzID0gZnVuY3Rpb24oY29va2VkLCByYXcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb29rZWQucmF3ID0gcmF3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29rZWQ7XG4gICAgICB9O1xuICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbihvLCB2KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbiAgICAgIH0gOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgIH07XG4gICAgICBfX2ltcG9ydFN0YXIzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBrMiBpbiBtb2QpXG4gICAgICAgICAgICBpZiAoazIgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGsyKSlcbiAgICAgICAgICAgICAgX19jcmVhdGVCaW5kaW5nMyhyZXN1bHQsIG1vZCwgazIpO1xuICAgICAgICB9XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX19pbXBvcnREZWZhdWx0MyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG4gICAgICB9O1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldDMgPSBmdW5jdGlvbihyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYyKSB7XG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZjIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmMiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYyIDoga2luZCA9PT0gXCJhXCIgPyBmMi5jYWxsKHJlY2VpdmVyKSA6IGYyID8gZjIudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xuICAgICAgfTtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQzID0gZnVuY3Rpb24ocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZjIpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwibVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZjIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmMiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwiYVwiID8gZjIuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZjIgPyBmMi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSksIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRJbjMgPSBmdW5jdGlvbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8IHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG4gICAgICB9O1xuICAgICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzMyk7XG4gICAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduMyk7XG4gICAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlMyk7XG4gICAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbTMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyMyk7XG4gICAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmczKTtcbiAgICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19yZWFkXCIsIF9fcmVhZDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5c1wiLCBfX3NwcmVhZEFycmF5czMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5XCIsIF9fc3ByZWFkQXJyYXkzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0Myk7XG4gICAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzMyk7XG4gICAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0Myk7XG4gICAgICBleHBvcnRlcihcIl9faW1wb3J0U3RhclwiLCBfX2ltcG9ydFN0YXIzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZFNldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0Myk7XG4gICAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRJblwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4zKTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5qc1xudmFyIHJlcXVpcmVfdHNsaWIyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgdmFyIF9fZXh0ZW5kczM7XG4gICAgdmFyIF9fYXNzaWduMztcbiAgICB2YXIgX19yZXN0MztcbiAgICB2YXIgX19kZWNvcmF0ZTM7XG4gICAgdmFyIF9fcGFyYW0zO1xuICAgIHZhciBfX21ldGFkYXRhMztcbiAgICB2YXIgX19hd2FpdGVyMztcbiAgICB2YXIgX19nZW5lcmF0b3IzO1xuICAgIHZhciBfX2V4cG9ydFN0YXIzO1xuICAgIHZhciBfX3ZhbHVlczM7XG4gICAgdmFyIF9fcmVhZDM7XG4gICAgdmFyIF9fc3ByZWFkMztcbiAgICB2YXIgX19zcHJlYWRBcnJheXMzO1xuICAgIHZhciBfX3NwcmVhZEFycmF5MztcbiAgICB2YXIgX19hd2FpdDM7XG4gICAgdmFyIF9fYXN5bmNHZW5lcmF0b3IzO1xuICAgIHZhciBfX2FzeW5jRGVsZWdhdG9yMztcbiAgICB2YXIgX19hc3luY1ZhbHVlczM7XG4gICAgdmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0MztcbiAgICB2YXIgX19pbXBvcnRTdGFyMztcbiAgICB2YXIgX19pbXBvcnREZWZhdWx0MztcbiAgICB2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldDM7XG4gICAgdmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQzO1xuICAgIHZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4zO1xuICAgIHZhciBfX2NyZWF0ZUJpbmRpbmczO1xuICAgIChmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcbiAgICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbihleHBvcnRzMikge1xuICAgICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0czIpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzMiwgcHJldmlvdXMpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMyICE9PSByb290KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydHMyLl9fZXNNb2R1bGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaWQyLCB2KSB7XG4gICAgICAgICAgcmV0dXJuIGV4cG9ydHMyW2lkMl0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkMiwgdikgOiB2O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pKGZ1bmN0aW9uKGV4cG9ydGVyKSB7XG4gICAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGQyLCBiMikge1xuICAgICAgICBkMi5fX3Byb3RvX18gPSBiMjtcbiAgICAgIH0gfHwgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgIGZvciAodmFyIHAyIGluIGIyKVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYjIsIHAyKSlcbiAgICAgICAgICAgIGQyW3AyXSA9IGIyW3AyXTtcbiAgICAgIH07XG4gICAgICBfX2V4dGVuZHMzID0gZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYjIgIT09IFwiZnVuY3Rpb25cIiAmJiBiMiAhPT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiMikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQyLCBiMik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkMjtcbiAgICAgICAgfVxuICAgICAgICBkMi5wcm90b3R5cGUgPSBiMiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYjIpIDogKF9fLnByb3RvdHlwZSA9IGIyLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgICAgfTtcbiAgICAgIF9fYXNzaWduMyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpMiA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpMiA8IG47IGkyKyspIHtcbiAgICAgICAgICBzID0gYXJndW1lbnRzW2kyXTtcbiAgICAgICAgICBmb3IgKHZhciBwMiBpbiBzKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwMikpXG4gICAgICAgICAgICAgIHRbcDJdID0gc1twMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9O1xuICAgICAgX19yZXN0MyA9IGZ1bmN0aW9uKHMsIGUpIHtcbiAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gcylcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHAyKSAmJiBlLmluZGV4T2YocDIpIDwgMClcbiAgICAgICAgICAgIHRbcDJdID0gc1twMl07XG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDAsIHAyID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaTIgPCBwMi5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocDJbaTJdKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHAyW2kyXSkpXG4gICAgICAgICAgICAgIHRbcDJbaTJdXSA9IHNbcDJbaTJdXTtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfTtcbiAgICAgIF9fZGVjb3JhdGUzID0gZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICAgICAgdmFyIGMzID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMzIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkMjtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICh2YXIgaTIgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pXG4gICAgICAgICAgICBpZiAoZDIgPSBkZWNvcmF0b3JzW2kyXSlcbiAgICAgICAgICAgICAgciA9IChjMyA8IDMgPyBkMihyKSA6IGMzID4gMyA/IGQyKHRhcmdldCwga2V5LCByKSA6IGQyKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICAgICAgcmV0dXJuIGMzID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gICAgICB9O1xuICAgICAgX19wYXJhbTMgPSBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBfX21ldGFkYXRhMyA9IGZ1bmN0aW9uKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcbiAgICAgIH07XG4gICAgICBfX2F3YWl0ZXIzID0gZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBfX2dlbmVyYXRvcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBib2R5KSB7XG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRbMF0gJiAxKVxuICAgICAgICAgICAgdGhyb3cgdFsxXTtcbiAgICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgICAgfSwgdHJ5czogW10sIG9wczogW10gfSwgZjIsIHksIHQsIGcyO1xuICAgICAgICByZXR1cm4gZzIgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGcyW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSksIGcyO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgICBpZiAoZjIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgICB3aGlsZSAoZzIgJiYgKGcyID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoZjIgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgIGlmICh5ID0gMCwgdClcbiAgICAgICAgICAgICAgICBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICBvcCA9IFswXTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKVxuICAgICAgICAgICAgICAgICAgICBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBvcCA9IFs2LCBlXTtcbiAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBmMiA9IHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcFswXSAmIDUpXG4gICAgICAgICAgICB0aHJvdyBvcFsxXTtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19leHBvcnRTdGFyMyA9IGZ1bmN0aW9uKG0sIG8pIHtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gbSlcbiAgICAgICAgICBpZiAocDIgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcDIpKVxuICAgICAgICAgICAgX19jcmVhdGVCaW5kaW5nMyhvLCBtLCBwMik7XG4gICAgICB9O1xuICAgICAgX19jcmVhdGVCaW5kaW5nMyA9IE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbihvLCBtLCBrMiwgazIyKSB7XG4gICAgICAgIGlmIChrMjIgPT09IHZvaWQgMClcbiAgICAgICAgICBrMjIgPSBrMjtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGsyKTtcbiAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1bazJdO1xuICAgICAgICAgIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIyLCBkZXNjKTtcbiAgICAgIH0gOiBmdW5jdGlvbihvLCBtLCBrMiwgazIyKSB7XG4gICAgICAgIGlmIChrMjIgPT09IHZvaWQgMClcbiAgICAgICAgICBrMjIgPSBrMjtcbiAgICAgICAgb1trMjJdID0gbVtrMl07XG4gICAgICB9O1xuICAgICAgX192YWx1ZXMzID0gZnVuY3Rpb24obykge1xuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkyID0gMDtcbiAgICAgICAgaWYgKG0pXG4gICAgICAgICAgcmV0dXJuIG0uY2FsbChvKTtcbiAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKG8gJiYgaTIgPj0gby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpMisrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICB9O1xuICAgICAgX19yZWFkMyA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIHZhciBpMiA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpMi5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGUgPSB7IGVycm9yIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpMltcInJldHVyblwiXSkpXG4gICAgICAgICAgICAgIG0uY2FsbChpMik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXI7XG4gICAgICB9O1xuICAgICAgX19zcHJlYWQzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGFyID0gW10sIGkyID0gMDsgaTIgPCBhcmd1bWVudHMubGVuZ3RoOyBpMisrKVxuICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZDMoYXJndW1lbnRzW2kyXSkpO1xuICAgICAgICByZXR1cm4gYXI7XG4gICAgICB9O1xuICAgICAgX19zcHJlYWRBcnJheXMzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBpMiA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaTIgPCBpbDsgaTIrKylcbiAgICAgICAgICBzICs9IGFyZ3VtZW50c1tpMl0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsyID0gMCwgaTIgPSAwOyBpMiA8IGlsOyBpMisrKVxuICAgICAgICAgIGZvciAodmFyIGEyID0gYXJndW1lbnRzW2kyXSwgaiA9IDAsIGpsID0gYTIubGVuZ3RoOyBqIDwgamw7IGorKywgazIrKylcbiAgICAgICAgICAgIHJbazJdID0gYTJbal07XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICAgIF9fc3ByZWFkQXJyYXkzID0gZnVuY3Rpb24odG8sIGZyb20sIHBhY2spIHtcbiAgICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkyIDwgbDsgaTIrKykge1xuICAgICAgICAgICAgaWYgKGFyIHx8ICEoaTIgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFhcilcbiAgICAgICAgICAgICAgICBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkyKTtcbiAgICAgICAgICAgICAgYXJbaTJdID0gZnJvbVtpMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbiAgICAgIH07XG4gICAgICBfX2F3YWl0MyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0MyA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0Myh2KTtcbiAgICAgIH07XG4gICAgICBfX2FzeW5jR2VuZXJhdG9yMyA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIHZhciBnMiA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaTIsIHEgPSBbXTtcbiAgICAgICAgcmV0dXJuIGkyID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGkyW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBpMjtcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgICAgaWYgKGcyW25dKVxuICAgICAgICAgICAgaTJbbl0gPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihhMiwgYjIpIHtcbiAgICAgICAgICAgICAgICBxLnB1c2goW24sIHYsIGEyLCBiMl0pID4gMSB8fCByZXN1bWUobiwgdik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwKGcyW25dKHYpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZXR0bGUocVswXVszXSwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikge1xuICAgICAgICAgIHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0MyA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmMiwgdikge1xuICAgICAgICAgIGlmIChmMih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aClcbiAgICAgICAgICAgIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fYXN5bmNEZWxlZ2F0b3IzID0gZnVuY3Rpb24obykge1xuICAgICAgICB2YXIgaTIsIHAyO1xuICAgICAgICByZXR1cm4gaTIgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSksIHZlcmIoXCJyZXR1cm5cIiksIGkyW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgaTI7XG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZjIpIHtcbiAgICAgICAgICBpMltuXSA9IG9bbl0gPyBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gKHAyID0gIXAyKSA/IHsgdmFsdWU6IF9fYXdhaXQzKG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmMiA/IGYyKHYpIDogdjtcbiAgICAgICAgICB9IDogZjI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX2FzeW5jVmFsdWVzMyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpMjtcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlczMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzMyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpMiA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpMltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgaTIpO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICBpMltuXSA9IG9bbl0gJiYgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZDIsIHYpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2Mikge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB2MiwgZG9uZTogZDIgfSk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0MyA9IGZ1bmN0aW9uKGNvb2tlZCwgcmF3KSB7XG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29va2VkLnJhdyA9IHJhdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29va2VkO1xuICAgICAgfTtcbiAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24obywgdikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG4gICAgICB9IDogZnVuY3Rpb24obywgdikge1xuICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICB9O1xuICAgICAgX19pbXBvcnRTdGFyMyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgazIgaW4gbW9kKVxuICAgICAgICAgICAgaWYgKGsyICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrMikpXG4gICAgICAgICAgICAgIF9fY3JlYXRlQmluZGluZzMocmVzdWx0LCBtb2QsIGsyKTtcbiAgICAgICAgfVxuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9faW1wb3J0RGVmYXVsdDMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xuICAgICAgfTtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQzID0gZnVuY3Rpb24ocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmMikge1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYyKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZjIgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgICAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmMiA6IGtpbmQgPT09IFwiYVwiID8gZjIuY2FsbChyZWNlaXZlcikgOiBmMiA/IGYyLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbiAgICAgIH07XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MyA9IGZ1bmN0aW9uKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYyKSB7XG4gICAgICAgIGlmIChraW5kID09PSBcIm1cIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYyKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZjIgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgICAgIHJldHVybiBraW5kID09PSBcImFcIiA/IGYyLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYyID8gZjIudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpLCB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4zID0gZnVuY3Rpb24oc3RhdGUsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCB0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xuICAgICAgfTtcbiAgICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kczMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2Fzc2lnblwiLCBfX2Fzc2lnbjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0Myk7XG4gICAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZTMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3BhcmFtXCIsIF9fcGFyYW0zKTtcbiAgICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhMyk7XG4gICAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19nZW5lcmF0b3JcIiwgX19nZW5lcmF0b3IzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3RhcjMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NyZWF0ZUJpbmRpbmdcIiwgX19jcmVhdGVCaW5kaW5nMyk7XG4gICAgICBleHBvcnRlcihcIl9fdmFsdWVzXCIsIF9fdmFsdWVzMyk7XG4gICAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheXNcIiwgX19zcHJlYWRBcnJheXMzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5Myk7XG4gICAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIF9fYXN5bmNHZW5lcmF0b3IzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yMyk7XG4gICAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlczMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBfX21ha2VUZW1wbGF0ZU9iamVjdDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyMyk7XG4gICAgICBleHBvcnRlcihcIl9faW1wb3J0RGVmYXVsdFwiLCBfX2ltcG9ydERlZmF1bHQzKTtcbiAgICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZEdldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0Myk7XG4gICAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldDMpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkSW5cIiwgX19jbGFzc1ByaXZhdGVGaWVsZEluMyk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbWVzaGdyYWQvZGlzdC9pbmRleC5tanNcbnZhciBpID0gKCkgPT4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMzYwKTtcbnZhciBjID0gKG4pID0+IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChuICogMTAwKSAlIDEwMCk7XG52YXIgZyA9IChuLCB0LCBlKSA9PiBNYXRoLnJvdW5kKHQgLyBlICogKG4gKiAxMDApICUgMTAwKTtcbnZhciBkID0gKG4pID0+IHtcbiAgaWYgKCEhbikge1xuICAgIG4gPSBuLnJlcGxhY2UoLyMvZywgXCJcIiksIG4ubGVuZ3RoID09PSAzICYmIChuID0gbi5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24oYjIpIHtcbiAgICAgIHJldHVybiBiMiArIGIyO1xuICAgIH0pLmpvaW4oXCJcIikpO1xuICAgIHZhciB0ID0gL14oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSlbXFxkYS16XXswLDB9JC9pLmV4ZWMobik7XG4gICAgaWYgKCEhdCkge1xuICAgICAgdmFyIGUgPSBwYXJzZUludCh0WzFdLCAxNiksIHIgPSBwYXJzZUludCh0WzJdLCAxNiksIGEyID0gcGFyc2VJbnQodFszXSwgMTYpO1xuICAgICAgZSAvPSAyNTUsIHIgLz0gMjU1LCBhMiAvPSAyNTU7XG4gICAgICB2YXIgbyA9IE1hdGgubWF4KGUsIHIsIGEyKSwgcyA9IE1hdGgubWluKGUsIHIsIGEyKSwgdSA9IChvICsgcykgLyAyO1xuICAgICAgaWYgKG8gPT0gcylcbiAgICAgICAgdSA9IDA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIG0gPSBvIC0gcztcbiAgICAgICAgc3dpdGNoIChvKSB7XG4gICAgICAgICAgY2FzZSBlOlxuICAgICAgICAgICAgdSA9IChyIC0gYTIpIC8gbSArIChyIDwgYTIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICB1ID0gKGEyIC0gZSkgLyBtICsgMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYTI6XG4gICAgICAgICAgICB1ID0gKGUgLSByKSAvIG0gKyA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdSAvPSA2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHUgPSBNYXRoLnJvdW5kKDM2MCAqIHUpLCB1O1xuICAgIH1cbiAgfVxufTtcbnZhciBwID0gKG4sIHQpID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IG4gfSwgKGUsIHIpID0+IHIgPT09IDAgPyBgaHNsKCR7dH0sIDEwMCUsIDgwJSlgIDogciA8IG4gLyAxLjQgPyBgaHNsKCR7dCAtIDMwICogKDEgLSAyICogKHIgJSAyKSkgKiAociA+IDIgPyByIC8gMiA6IHIpfSwgMTAwJSwgJHs3NiAtIHIgKiAoMSAtIDIgKiAociAlIDIpKSAqIDEuNzV9JSlgIDogYGhzbCgke3QgLSAxNTAgKiAoMSAtIDIgKiAociAlIDIpKX0sIDEwMCUsICR7NzYgLSByICogKDEgLSAyICogKHIgJSAyKSkgKiAxLjI1fSUpYCk7XG52YXIgTSA9IChuLCB0LCBlKSA9PiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sIChyLCBhMikgPT4gYHJhZGlhbC1ncmFkaWVudChhdCAke2UgPyBnKGEyLCBlLCBuKSA6IGMoYTIpfSUgJHtlID8gZyhhMiAqIDEwLCBlLCBuKSA6IGMoYTIgKiAxMCl9JSwgJHt0W2EyXX0gMHB4LCB0cmFuc3BhcmVudCA1MCUpXG5gKTtcbnZhciBmID0gKG4sIHQsIGUpID0+IHtcbiAgbGV0IHIgPSBwKG4sIHQgfHwgaSgpKSwgYTIgPSBNKG4sIHIsIGUgfHwgdm9pZCAwKTtcbiAgcmV0dXJuIFtyWzBdLCBhMi5qb2luKFwiLFwiKV07XG59O1xudmFyIGsgPSAobiwgdCwgZSkgPT4ge1xuICBsZXQgW3IsIGEyXSA9IGYobiwgZCh0KSA/IGQodCkgOiB2b2lkIDAsIGUgfHwgdm9pZCAwKTtcbiAgcmV0dXJuIHsgYmFja2dyb3VuZENvbG9yOiByLCBiYWNrZ3JvdW5kSW1hZ2U6IGEyIH07XG59O1xuXG4vLyBzcmMvVmVyc2lvbi50c3hcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEVMRU1FTlRTID0gODtcbnZhciBWZXJzaW9uID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImJ1dHRvblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm0tMiBoaWRkZW4gcm91bmRlZC1mdWxsIHB5LTIgcHgtNCB0ZXh0LXhzIGZvbnQtYm9sZCB0ZXh0LWJsYWNrIHNoYWRvdy1tZCBob3ZlcjpzaGFkb3cteGwgbWQ6YmxvY2tcIixcbiAgICBzdHlsZTogayhFTEVNRU5UUyksXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJhXCIsIHtcbiAgICAgIGhyZWY6IFwiaHR0cDovL2dpdGh1Yi5jb20vbWlndWVsZ2FyZ2FsbG8vbmV4dDEzLWdhbGxlcnktaW1hZ2UtdHVyYm9cIixcbiAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsXG4gICAgICBjaGlsZHJlbjogXCJ2MS4wLjBcIlxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vaW5kZXgubWpzXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGZvcndhcmRSZWYsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTW90aW9uQ29uZmlnQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICB0cmFuc2Zvcm1QYWdlUG9pbnQ6IChwMikgPT4gcDIsXG4gIGlzU3RhdGljOiBmYWxzZSxcbiAgcmVkdWNlZE1vdGlvbjogXCJuZXZlclwiXG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbnRleHQvaW5kZXgubWpzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQyLCB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTW90aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQyKHt9KTtcbmZ1bmN0aW9uIHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0KCkge1xuICByZXR1cm4gdXNlQ29udGV4dChNb3Rpb25Db250ZXh0KS52aXN1YWxFbGVtZW50O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLWVsZW1lbnQubWpzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyLCB1c2VSZWYsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQzIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgUHJlc2VuY2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dDMobnVsbCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWlzb21vcnBoaWMtZWZmZWN0Lm1qc1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pcy1icm93c2VyLm1qc1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtaXNvbW9ycGhpYy1lZmZlY3QubWpzXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGlzQnJvd3NlciA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L0xhenlDb250ZXh0Lm1qc1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIExhenlDb250ZXh0ID0gY3JlYXRlQ29udGV4dDQoeyBzdHJpY3Q6IGZhbHNlIH0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLWVsZW1lbnQubWpzXG5mdW5jdGlvbiB1c2VWaXN1YWxFbGVtZW50KENvbXBvbmVudCwgdmlzdWFsU3RhdGUsIHByb3BzLCBjcmVhdGVWaXN1YWxFbGVtZW50KSB7XG4gIGNvbnN0IHBhcmVudCA9IHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0KCk7XG4gIGNvbnN0IGxhenlDb250ZXh0ID0gdXNlQ29udGV4dDIoTGF6eUNvbnRleHQpO1xuICBjb25zdCBwcmVzZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MihQcmVzZW5jZUNvbnRleHQpO1xuICBjb25zdCByZWR1Y2VkTW90aW9uQ29uZmlnID0gdXNlQ29udGV4dDIoTW90aW9uQ29uZmlnQ29udGV4dCkucmVkdWNlZE1vdGlvbjtcbiAgY29uc3QgdmlzdWFsRWxlbWVudFJlZiA9IHVzZVJlZigpO1xuICBjcmVhdGVWaXN1YWxFbGVtZW50ID0gY3JlYXRlVmlzdWFsRWxlbWVudCB8fCBsYXp5Q29udGV4dC5yZW5kZXJlcjtcbiAgaWYgKCF2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQgJiYgY3JlYXRlVmlzdWFsRWxlbWVudCkge1xuICAgIHZpc3VhbEVsZW1lbnRSZWYuY3VycmVudCA9IGNyZWF0ZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50LCB7XG4gICAgICB2aXN1YWxTdGF0ZSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHByb3BzLFxuICAgICAgcHJlc2VuY2VJZDogcHJlc2VuY2VDb250ZXh0ID8gcHJlc2VuY2VDb250ZXh0LmlkIDogdm9pZCAwLFxuICAgICAgYmxvY2tJbml0aWFsQW5pbWF0aW9uOiBwcmVzZW5jZUNvbnRleHQgPyBwcmVzZW5jZUNvbnRleHQuaW5pdGlhbCA9PT0gZmFsc2UgOiBmYWxzZSxcbiAgICAgIHJlZHVjZWRNb3Rpb25Db25maWdcbiAgICB9KTtcbiAgfVxuICBjb25zdCB2aXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50O1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB2aXN1YWxFbGVtZW50ICYmIHZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gIH0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAodmlzdWFsRWxlbWVudCAmJiB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSB7XG4gICAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlLmFuaW1hdGVDaGFuZ2VzKCk7XG4gICAgfVxuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiAoKSA9PiB2aXN1YWxFbGVtZW50ICYmIHZpc3VhbEVsZW1lbnQubm90aWZ5KFwiVW5tb3VudFwiKSwgW10pO1xuICByZXR1cm4gdmlzdWFsRWxlbWVudDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdXNlLW1vdGlvbi1yZWYubWpzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLXJlZi1vYmplY3QubWpzXG5mdW5jdGlvbiBpc1JlZk9iamVjdChyZWYpIHtcbiAgcmV0dXJuIHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZiwgXCJjdXJyZW50XCIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtbW90aW9uLXJlZi5tanNcbmZ1bmN0aW9uIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgdmlzdWFsRWxlbWVudCwgZXh0ZXJuYWxSZWYpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrKFxuICAgIChpbnN0YW5jZSkgPT4ge1xuICAgICAgaW5zdGFuY2UgJiYgdmlzdWFsU3RhdGUubW91bnQgJiYgdmlzdWFsU3RhdGUubW91bnQoaW5zdGFuY2UpO1xuICAgICAgaWYgKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgaW5zdGFuY2UgPyB2aXN1YWxFbGVtZW50Lm1vdW50KGluc3RhbmNlKSA6IHZpc3VhbEVsZW1lbnQudW5tb3VudCgpO1xuICAgICAgfVxuICAgICAgaWYgKGV4dGVybmFsUmVmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXh0ZXJuYWxSZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGV4dGVybmFsUmVmKGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlZk9iamVjdChleHRlcm5hbFJlZikpIHtcbiAgICAgICAgICBleHRlcm5hbFJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFt2aXN1YWxFbGVtZW50XVxuICApO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29udGV4dC9jcmVhdGUubWpzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2lzLXZhcmlhbnQtbGFiZWwubWpzXG5mdW5jdGlvbiBpc1ZhcmlhbnRMYWJlbCh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KHYpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRpb24tY29udHJvbHMubWpzXG5mdW5jdGlvbiBpc0FuaW1hdGlvbkNvbnRyb2xzKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2LnN0YXJ0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2lzLWNvbnRyb2xsaW5nLXZhcmlhbnRzLm1qc1xudmFyIHZhcmlhbnRQcm9wcyA9IFtcbiAgXCJpbml0aWFsXCIsXG4gIFwiYW5pbWF0ZVwiLFxuICBcImV4aXRcIixcbiAgXCJ3aGlsZUhvdmVyXCIsXG4gIFwid2hpbGVEcmFnXCIsXG4gIFwid2hpbGVUYXBcIixcbiAgXCJ3aGlsZUZvY3VzXCIsXG4gIFwid2hpbGVJblZpZXdcIlxuXTtcbmZ1bmN0aW9uIGlzQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcykge1xuICByZXR1cm4gaXNBbmltYXRpb25Db250cm9scyhwcm9wcy5hbmltYXRlKSB8fCB2YXJpYW50UHJvcHMuc29tZSgobmFtZSkgPT4gaXNWYXJpYW50TGFiZWwocHJvcHNbbmFtZV0pKTtcbn1cbmZ1bmN0aW9uIGlzVmFyaWFudE5vZGUocHJvcHMpIHtcbiAgcmV0dXJuIEJvb2xlYW4oaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSB8fCBwcm9wcy52YXJpYW50cyk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db250ZXh0L3V0aWxzLm1qc1xuZnVuY3Rpb24gZ2V0Q3VycmVudFRyZWVWYXJpYW50cyhwcm9wcywgY29udGV4dCkge1xuICBpZiAoaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSkge1xuICAgIGNvbnN0IHsgaW5pdGlhbCwgYW5pbWF0ZTogYW5pbWF0ZTMgfSA9IHByb3BzO1xuICAgIHJldHVybiB7XG4gICAgICBpbml0aWFsOiBpbml0aWFsID09PSBmYWxzZSB8fCBpc1ZhcmlhbnRMYWJlbChpbml0aWFsKSA/IGluaXRpYWwgOiB2b2lkIDAsXG4gICAgICBhbmltYXRlOiBpc1ZhcmlhbnRMYWJlbChhbmltYXRlMykgPyBhbmltYXRlMyA6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHByb3BzLmluaGVyaXQgIT09IGZhbHNlID8gY29udGV4dCA6IHt9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29udGV4dC9jcmVhdGUubWpzXG5mdW5jdGlvbiB1c2VDcmVhdGVNb3Rpb25Db250ZXh0KHByb3BzKSB7XG4gIGNvbnN0IHsgaW5pdGlhbCwgYW5pbWF0ZTogYW5pbWF0ZTMgfSA9IGdldEN1cnJlbnRUcmVlVmFyaWFudHMocHJvcHMsIHVzZUNvbnRleHQzKE1vdGlvbkNvbnRleHQpKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHsgaW5pdGlhbCwgYW5pbWF0ZTogYW5pbWF0ZTMgfSksIFt2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KGluaXRpYWwpLCB2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KGFuaW1hdGUzKV0pO1xufVxuZnVuY3Rpb24gdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShwcm9wKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHByb3ApID8gcHJvcC5qb2luKFwiIFwiKSA6IHByb3A7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2RlZmluaXRpb25zLm1qc1xudmFyIGNyZWF0ZURlZmluaXRpb24gPSAocHJvcE5hbWVzKSA9PiAoe1xuICBpc0VuYWJsZWQ6IChwcm9wcykgPT4gcHJvcE5hbWVzLnNvbWUoKG5hbWUpID0+ICEhcHJvcHNbbmFtZV0pXG59KTtcbnZhciBmZWF0dXJlRGVmaW5pdGlvbnMgPSB7XG4gIG1lYXN1cmVMYXlvdXQ6IGNyZWF0ZURlZmluaXRpb24oW1wibGF5b3V0XCIsIFwibGF5b3V0SWRcIiwgXCJkcmFnXCJdKSxcbiAgYW5pbWF0aW9uOiBjcmVhdGVEZWZpbml0aW9uKFtcbiAgICBcImFuaW1hdGVcIixcbiAgICBcImV4aXRcIixcbiAgICBcInZhcmlhbnRzXCIsXG4gICAgXCJ3aGlsZUhvdmVyXCIsXG4gICAgXCJ3aGlsZVRhcFwiLFxuICAgIFwid2hpbGVGb2N1c1wiLFxuICAgIFwid2hpbGVEcmFnXCIsXG4gICAgXCJ3aGlsZUluVmlld1wiXG4gIF0pLFxuICBleGl0OiBjcmVhdGVEZWZpbml0aW9uKFtcImV4aXRcIl0pLFxuICBkcmFnOiBjcmVhdGVEZWZpbml0aW9uKFtcImRyYWdcIiwgXCJkcmFnQ29udHJvbHNcIl0pLFxuICBmb2N1czogY3JlYXRlRGVmaW5pdGlvbihbXCJ3aGlsZUZvY3VzXCJdKSxcbiAgaG92ZXI6IGNyZWF0ZURlZmluaXRpb24oW1wid2hpbGVIb3ZlclwiLCBcIm9uSG92ZXJTdGFydFwiLCBcIm9uSG92ZXJFbmRcIl0pLFxuICB0YXA6IGNyZWF0ZURlZmluaXRpb24oW1wid2hpbGVUYXBcIiwgXCJvblRhcFwiLCBcIm9uVGFwU3RhcnRcIiwgXCJvblRhcENhbmNlbFwiXSksXG4gIHBhbjogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgXCJvblBhblwiLFxuICAgIFwib25QYW5TdGFydFwiLFxuICAgIFwib25QYW5TZXNzaW9uU3RhcnRcIixcbiAgICBcIm9uUGFuRW5kXCJcbiAgXSksXG4gIGluVmlldzogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgXCJ3aGlsZUluVmlld1wiLFxuICAgIFwib25WaWV3cG9ydEVudGVyXCIsXG4gICAgXCJvblZpZXdwb3J0TGVhdmVcIlxuICBdKVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvbG9hZC1mZWF0dXJlcy5tanNcbmZ1bmN0aW9uIGxvYWRGZWF0dXJlcyhmZWF0dXJlcykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBmZWF0dXJlcykge1xuICAgIGlmIChrZXkgPT09IFwicHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvclwiKSB7XG4gICAgICBmZWF0dXJlRGVmaW5pdGlvbnMucHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciA9IGZlYXR1cmVzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZlYXR1cmVEZWZpbml0aW9uc1trZXldLkNvbXBvbmVudCA9IGZlYXR1cmVzW2tleV07XG4gICAgfVxuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWNvbnN0YW50Lm1qc1xuaW1wb3J0IHsgdXNlUmVmIGFzIHVzZVJlZjIgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUNvbnN0YW50KGluaXQpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmMihudWxsKTtcbiAgaWYgKHJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgcmVmLmN1cnJlbnQgPSBpbml0KCk7XG4gIH1cbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9zdGF0ZS5tanNcbnZhciBnbG9iYWxQcm9qZWN0aW9uU3RhdGUgPSB7XG4gIGhhc0FuaW1hdGVkU2luY2VSZXNpemU6IHRydWUsXG4gIGhhc0V2ZXJVcGRhdGVkOiBmYWxzZVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvaWQubWpzXG52YXIgaWQgPSAxO1xuZnVuY3Rpb24gdXNlUHJvamVjdGlvbklkKCkge1xuICByZXR1cm4gdXNlQ29uc3RhbnQoKCkgPT4ge1xuICAgIGlmIChnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzRXZlclVwZGF0ZWQpIHtcbiAgICAgIHJldHVybiBpZCsrO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9MYXlvdXRHcm91cENvbnRleHQubWpzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ1IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTGF5b3V0R3JvdXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dDUoe30pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9WaXN1YWxFbGVtZW50SGFuZGxlci5tanNcbmltcG9ydCBSZWFjdF9fZGVmYXVsdCBmcm9tIFwicmVhY3RcIjtcbnZhciBWaXN1YWxFbGVtZW50SGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgUmVhY3RfX2RlZmF1bHQuQ29tcG9uZW50IHtcbiAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSB7XG4gICAgY29uc3QgeyB2aXN1YWxFbGVtZW50LCBwcm9wcyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAodmlzdWFsRWxlbWVudClcbiAgICAgIHZpc3VhbEVsZW1lbnQuc2V0UHJvcHMocHJvcHMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Td2l0Y2hMYXlvdXRHcm91cENvbnRleHQubWpzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ2IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dDYoe30pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9zeW1ib2wubWpzXG52YXIgbW90aW9uQ29tcG9uZW50U3ltYm9sID0gU3ltYm9sLmZvcihcIm1vdGlvbkNvbXBvbmVudFN5bWJvbFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vaW5kZXgubWpzXG5mdW5jdGlvbiBjcmVhdGVNb3Rpb25Db21wb25lbnQoeyBwcmVsb2FkZWRGZWF0dXJlcywgY3JlYXRlVmlzdWFsRWxlbWVudCwgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciwgdXNlUmVuZGVyLCB1c2VWaXN1YWxTdGF0ZSwgQ29tcG9uZW50IH0pIHtcbiAgcHJlbG9hZGVkRmVhdHVyZXMgJiYgbG9hZEZlYXR1cmVzKHByZWxvYWRlZEZlYXR1cmVzKTtcbiAgZnVuY3Rpb24gTW90aW9uQ29tcG9uZW50KHByb3BzLCBleHRlcm5hbFJlZikge1xuICAgIGNvbnN0IGNvbmZpZ0FuZFByb3BzID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdXNlQ29udGV4dDQoTW90aW9uQ29uZmlnQ29udGV4dCkpLCBwcm9wcyksIHtcbiAgICAgIGxheW91dElkOiB1c2VMYXlvdXRJZChwcm9wcylcbiAgICB9KTtcbiAgICBjb25zdCB7IGlzU3RhdGljIH0gPSBjb25maWdBbmRQcm9wcztcbiAgICBsZXQgZmVhdHVyZXMgPSBudWxsO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDcmVhdGVNb3Rpb25Db250ZXh0KHByb3BzKTtcbiAgICBjb25zdCBwcm9qZWN0aW9uSWQgPSBpc1N0YXRpYyA/IHZvaWQgMCA6IHVzZVByb2plY3Rpb25JZCgpO1xuICAgIGNvbnN0IHZpc3VhbFN0YXRlID0gdXNlVmlzdWFsU3RhdGUocHJvcHMsIGlzU3RhdGljKTtcbiAgICBpZiAoIWlzU3RhdGljICYmIGlzQnJvd3Nlcikge1xuICAgICAgY29udGV4dC52aXN1YWxFbGVtZW50ID0gdXNlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHZpc3VhbFN0YXRlLCBjb25maWdBbmRQcm9wcywgY3JlYXRlVmlzdWFsRWxlbWVudCk7XG4gICAgICBjb25zdCBsYXp5U3RyaWN0TW9kZSA9IHVzZUNvbnRleHQ0KExhenlDb250ZXh0KS5zdHJpY3Q7XG4gICAgICBjb25zdCBpbml0aWFsTGF5b3V0R3JvdXBDb25maWcgPSB1c2VDb250ZXh0NChTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQpO1xuICAgICAgaWYgKGNvbnRleHQudmlzdWFsRWxlbWVudCkge1xuICAgICAgICBmZWF0dXJlcyA9IGNvbnRleHQudmlzdWFsRWxlbWVudC5sb2FkRmVhdHVyZXMoXG4gICAgICAgICAgY29uZmlnQW5kUHJvcHMsXG4gICAgICAgICAgbGF6eVN0cmljdE1vZGUsXG4gICAgICAgICAgcHJlbG9hZGVkRmVhdHVyZXMsXG4gICAgICAgICAgcHJvamVjdGlvbklkLFxuICAgICAgICAgIHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IgfHwgZmVhdHVyZURlZmluaXRpb25zLnByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsXG4gICAgICAgICAgaW5pdGlhbExheW91dEdyb3VwQ29uZmlnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgVmlzdWFsRWxlbWVudEhhbmRsZXIsXG4gICAgICB7IHZpc3VhbEVsZW1lbnQ6IGNvbnRleHQudmlzdWFsRWxlbWVudCwgcHJvcHM6IGNvbmZpZ0FuZFByb3BzIH0sXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW90aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCB1c2VSZW5kZXIoQ29tcG9uZW50LCBwcm9wcywgcHJvamVjdGlvbklkLCB1c2VNb3Rpb25SZWYodmlzdWFsU3RhdGUsIGNvbnRleHQudmlzdWFsRWxlbWVudCwgZXh0ZXJuYWxSZWYpLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMsIGNvbnRleHQudmlzdWFsRWxlbWVudCkpXG4gICAgKTtcbiAgfVxuICBjb25zdCBGb3J3YXJkUmVmQ29tcG9uZW50ID0gZm9yd2FyZFJlZihNb3Rpb25Db21wb25lbnQpO1xuICBGb3J3YXJkUmVmQ29tcG9uZW50W21vdGlvbkNvbXBvbmVudFN5bWJvbF0gPSBDb21wb25lbnQ7XG4gIHJldHVybiBGb3J3YXJkUmVmQ29tcG9uZW50O1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0SWQoeyBsYXlvdXRJZCB9KSB7XG4gIGNvbnN0IGxheW91dEdyb3VwSWQgPSB1c2VDb250ZXh0NChMYXlvdXRHcm91cENvbnRleHQpLmlkO1xuICByZXR1cm4gbGF5b3V0R3JvdXBJZCAmJiBsYXlvdXRJZCAhPT0gdm9pZCAwID8gbGF5b3V0R3JvdXBJZCArIFwiLVwiICsgbGF5b3V0SWQgOiBsYXlvdXRJZDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL21vdGlvbi1wcm94eS5tanNcbmZ1bmN0aW9uIGNyZWF0ZU1vdGlvblByb3h5KGNyZWF0ZUNvbmZpZykge1xuICBmdW5jdGlvbiBjdXN0b20oQ29tcG9uZW50LCBjdXN0b21Nb3Rpb25Db21wb25lbnRDb25maWcgPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVNb3Rpb25Db21wb25lbnQoY3JlYXRlQ29uZmlnKENvbXBvbmVudCwgY3VzdG9tTW90aW9uQ29tcG9uZW50Q29uZmlnKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBjdXN0b207XG4gIH1cbiAgY29uc3QgY29tcG9uZW50Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gbmV3IFByb3h5KGN1c3RvbSwge1xuICAgIGdldDogKF90YXJnZXQsIGtleSkgPT4ge1xuICAgICAgaWYgKCFjb21wb25lbnRDYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICBjb21wb25lbnRDYWNoZS5zZXQoa2V5LCBjdXN0b20oa2V5KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcG9uZW50Q2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL2xvd2VyY2FzZS1lbGVtZW50cy5tanNcbnZhciBsb3dlcmNhc2VTVkdFbGVtZW50cyA9IFtcbiAgXCJhbmltYXRlXCIsXG4gIFwiY2lyY2xlXCIsXG4gIFwiZGVmc1wiLFxuICBcImRlc2NcIixcbiAgXCJlbGxpcHNlXCIsXG4gIFwiZ1wiLFxuICBcImltYWdlXCIsXG4gIFwibGluZVwiLFxuICBcImZpbHRlclwiLFxuICBcIm1hcmtlclwiLFxuICBcIm1hc2tcIixcbiAgXCJtZXRhZGF0YVwiLFxuICBcInBhdGhcIixcbiAgXCJwYXR0ZXJuXCIsXG4gIFwicG9seWdvblwiLFxuICBcInBvbHlsaW5lXCIsXG4gIFwicmVjdFwiLFxuICBcInN0b3BcIixcbiAgXCJzdmdcIixcbiAgXCJzd2l0Y2hcIixcbiAgXCJzeW1ib2xcIixcbiAgXCJ0ZXh0XCIsXG4gIFwidHNwYW5cIixcbiAgXCJ1c2VcIixcbiAgXCJ2aWV3XCJcbl07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9pcy1zdmctY29tcG9uZW50Lm1qc1xuZnVuY3Rpb24gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2YgQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiIHx8IENvbXBvbmVudC5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAobG93ZXJjYXNlU1ZHRWxlbWVudHMuaW5kZXhPZihDb21wb25lbnQpID4gLTEgfHwgL1tBLVpdLy50ZXN0KENvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91c2UtcmVuZGVyLm1qc1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3VzZS1wcm9wcy5tanNcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzIgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1jb3JyZWN0aW9uLm1qc1xudmFyIHNjYWxlQ29ycmVjdG9ycyA9IHt9O1xuZnVuY3Rpb24gYWRkU2NhbGVDb3JyZWN0b3IoY29ycmVjdG9ycykge1xuICBPYmplY3QuYXNzaWduKHNjYWxlQ29ycmVjdG9ycywgY29ycmVjdG9ycyk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvdHJhbnNmb3JtLm1qc1xudmFyIHRyYW5zZm9ybVByb3BPcmRlciA9IFtcbiAgXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLFxuICBcInhcIixcbiAgXCJ5XCIsXG4gIFwielwiLFxuICBcInRyYW5zbGF0ZVhcIixcbiAgXCJ0cmFuc2xhdGVZXCIsXG4gIFwidHJhbnNsYXRlWlwiLFxuICBcInNjYWxlXCIsXG4gIFwic2NhbGVYXCIsXG4gIFwic2NhbGVZXCIsXG4gIFwicm90YXRlXCIsXG4gIFwicm90YXRlWFwiLFxuICBcInJvdGF0ZVlcIixcbiAgXCJyb3RhdGVaXCIsXG4gIFwic2tld1wiLFxuICBcInNrZXdYXCIsXG4gIFwic2tld1lcIlxuXTtcbnZhciB0cmFuc2Zvcm1Qcm9wcyA9IG5ldyBTZXQodHJhbnNmb3JtUHJvcE9yZGVyKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvaXMtZm9yY2VkLW1vdGlvbi12YWx1ZS5tanNcbmZ1bmN0aW9uIGlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCB7IGxheW91dCwgbGF5b3V0SWQgfSkge1xuICByZXR1cm4gdHJhbnNmb3JtUHJvcHMuaGFzKGtleSkgfHwga2V5LnN0YXJ0c1dpdGgoXCJvcmlnaW5cIikgfHwgKGxheW91dCB8fCBsYXlvdXRJZCAhPT0gdm9pZCAwKSAmJiAoISFzY2FsZUNvcnJlY3RvcnNba2V5XSB8fCBrZXkgPT09IFwib3BhY2l0eVwiKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzXG52YXIgaXNNb3Rpb25WYWx1ZSA9ICh2YWx1ZSkgPT4gISEodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmdldFZlbG9jaXR5KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9idWlsZC10cmFuc2Zvcm0ubWpzXG52YXIgdHJhbnNsYXRlQWxpYXMgPSB7XG4gIHg6IFwidHJhbnNsYXRlWFwiLFxuICB5OiBcInRyYW5zbGF0ZVlcIixcbiAgejogXCJ0cmFuc2xhdGVaXCIsXG4gIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBcInBlcnNwZWN0aXZlXCJcbn07XG52YXIgc29ydFRyYW5zZm9ybVByb3BzID0gKGEyLCBiMikgPT4gdHJhbnNmb3JtUHJvcE9yZGVyLmluZGV4T2YoYTIpIC0gdHJhbnNmb3JtUHJvcE9yZGVyLmluZGV4T2YoYjIpO1xuZnVuY3Rpb24gYnVpbGRUcmFuc2Zvcm0oeyB0cmFuc2Zvcm0sIHRyYW5zZm9ybUtleXM6IHRyYW5zZm9ybUtleXMyIH0sIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24gPSB0cnVlLCBhbGxvd1RyYW5zZm9ybU5vbmUgPSB0cnVlIH0sIHRyYW5zZm9ybUlzRGVmYXVsdCwgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgbGV0IHRyYW5zZm9ybVN0cmluZyA9IFwiXCI7XG4gIHRyYW5zZm9ybUtleXMyLnNvcnQoc29ydFRyYW5zZm9ybVByb3BzKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgdHJhbnNmb3JtS2V5czIpIHtcbiAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gYCR7dHJhbnNsYXRlQWxpYXNba2V5XSB8fCBrZXl9KCR7dHJhbnNmb3JtW2tleV19KSBgO1xuICB9XG4gIGlmIChlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbiAmJiAhdHJhbnNmb3JtLnopIHtcbiAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gXCJ0cmFuc2xhdGVaKDApXCI7XG4gIH1cbiAgdHJhbnNmb3JtU3RyaW5nID0gdHJhbnNmb3JtU3RyaW5nLnRyaW0oKTtcbiAgaWYgKHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgdHJhbnNmb3JtU3RyaW5nID0gdHJhbnNmb3JtVGVtcGxhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm1Jc0RlZmF1bHQgPyBcIlwiIDogdHJhbnNmb3JtU3RyaW5nKTtcbiAgfSBlbHNlIGlmIChhbGxvd1RyYW5zZm9ybU5vbmUgJiYgdHJhbnNmb3JtSXNEZWZhdWx0KSB7XG4gICAgdHJhbnNmb3JtU3RyaW5nID0gXCJub25lXCI7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybVN0cmluZztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2lzLWNzcy12YXJpYWJsZS5tanNcbmZ1bmN0aW9uIGlzQ1NTVmFyaWFibGUoa2V5KSB7XG4gIHJldHVybiBrZXkuc3RhcnRzV2l0aChcIi0tXCIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZ2V0LWFzLXR5cGUubWpzXG52YXIgZ2V0VmFsdWVBc1R5cGUgPSAodmFsdWUsIHR5cGUpID0+IHtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdHlwZS50cmFuc2Zvcm0odmFsdWUpIDogdmFsdWU7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy91dGlscy5tanNcbnZhciBjbGFtcCA9IChtaW4sIG1heCkgPT4gKHYpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIG1heCksIG1pbik7XG52YXIgc2FuaXRpemUgPSAodikgPT4gdiAlIDEgPyBOdW1iZXIodi50b0ZpeGVkKDUpKSA6IHY7XG52YXIgZmxvYXRSZWdleCA9IC8oLSk/KFtcXGRdKlxcLj9bXFxkXSkrL2c7XG52YXIgY29sb3JSZWdleCA9IC8oI1swLTlhLWZdezZ9fCNbMC05YS1mXXszfXwjKD86WzAtOWEtZl17Mn0pezIsNH18KHJnYnxoc2wpYT9cXCgoLT9bXFxkXFwuXSslP1ssXFxzXSspezJ9KC0/W1xcZFxcLl0rJT8pXFxzKltcXCxcXC9dP1xccypbXFxkXFwuXSolP1xcKSkvZ2k7XG52YXIgc2luZ2xlQ29sb3JSZWdleCA9IC9eKCNbMC05YS1mXXszfXwjKD86WzAtOWEtZl17Mn0pezIsNH18KHJnYnxoc2wpYT9cXCgoLT9bXFxkXFwuXSslP1ssXFxzXSspezJ9KC0/W1xcZFxcLl0rJT8pXFxzKltcXCxcXC9dP1xccypbXFxkXFwuXSolP1xcKSkkL2k7XG5mdW5jdGlvbiBpc1N0cmluZyh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvbnVtYmVycy9pbmRleC5tanNcbnZhciBudW1iZXIgPSB7XG4gIHRlc3Q6ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIixcbiAgcGFyc2U6IHBhcnNlRmxvYXQsXG4gIHRyYW5zZm9ybTogKHYpID0+IHZcbn07XG52YXIgYWxwaGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG51bWJlciksIHsgdHJhbnNmb3JtOiBjbGFtcCgwLCAxKSB9KTtcbnZhciBzY2FsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyKSwgeyBkZWZhdWx0OiAxIH0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9udW1iZXJzL3VuaXRzLm1qc1xudmFyIGNyZWF0ZVVuaXRUeXBlID0gKHVuaXQpID0+ICh7XG4gIHRlc3Q6ICh2KSA9PiBpc1N0cmluZyh2KSAmJiB2LmVuZHNXaXRoKHVuaXQpICYmIHYuc3BsaXQoXCIgXCIpLmxlbmd0aCA9PT0gMSxcbiAgcGFyc2U6IHBhcnNlRmxvYXQsXG4gIHRyYW5zZm9ybTogKHYpID0+IGAke3Z9JHt1bml0fWBcbn0pO1xudmFyIGRlZ3JlZXMgPSBjcmVhdGVVbml0VHlwZShcImRlZ1wiKTtcbnZhciBwZXJjZW50ID0gY3JlYXRlVW5pdFR5cGUoXCIlXCIpO1xudmFyIHB4ID0gY3JlYXRlVW5pdFR5cGUoXCJweFwiKTtcbnZhciB2aCA9IGNyZWF0ZVVuaXRUeXBlKFwidmhcIik7XG52YXIgdncgPSBjcmVhdGVVbml0VHlwZShcInZ3XCIpO1xudmFyIHByb2dyZXNzUGVyY2VudGFnZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGVyY2VudCksIHsgcGFyc2U6ICh2KSA9PiBwZXJjZW50LnBhcnNlKHYpIC8gMTAwLCB0cmFuc2Zvcm06ICh2KSA9PiBwZXJjZW50LnRyYW5zZm9ybSh2ICogMTAwKSB9KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvY29sb3IvdXRpbHMubWpzXG52YXIgaXNDb2xvclN0cmluZyA9ICh0eXBlLCB0ZXN0UHJvcCkgPT4gKHYpID0+IHtcbiAgcmV0dXJuIEJvb2xlYW4oaXNTdHJpbmcodikgJiYgc2luZ2xlQ29sb3JSZWdleC50ZXN0KHYpICYmIHYuc3RhcnRzV2l0aCh0eXBlKSB8fCB0ZXN0UHJvcCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodiwgdGVzdFByb3ApKTtcbn07XG52YXIgc3BsaXRDb2xvciA9IChhTmFtZSwgYk5hbWUsIGNOYW1lKSA9PiAodikgPT4ge1xuICBpZiAoIWlzU3RyaW5nKHYpKVxuICAgIHJldHVybiB2O1xuICBjb25zdCBbYTIsIGIyLCBjMywgYWxwaGEyXSA9IHYubWF0Y2goZmxvYXRSZWdleCk7XG4gIHJldHVybiB7XG4gICAgW2FOYW1lXTogcGFyc2VGbG9hdChhMiksXG4gICAgW2JOYW1lXTogcGFyc2VGbG9hdChiMiksXG4gICAgW2NOYW1lXTogcGFyc2VGbG9hdChjMyksXG4gICAgYWxwaGE6IGFscGhhMiAhPT0gdm9pZCAwID8gcGFyc2VGbG9hdChhbHBoYTIpIDogMVxuICB9O1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvY29sb3IvaHNsYS5tanNcbnZhciBoc2xhID0ge1xuICB0ZXN0OiBpc0NvbG9yU3RyaW5nKFwiaHNsXCIsIFwiaHVlXCIpLFxuICBwYXJzZTogc3BsaXRDb2xvcihcImh1ZVwiLCBcInNhdHVyYXRpb25cIiwgXCJsaWdodG5lc3NcIiksXG4gIHRyYW5zZm9ybTogKHsgaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhOiBhbHBoYSQxID0gMSB9KSA9PiB7XG4gICAgcmV0dXJuIFwiaHNsYShcIiArIE1hdGgucm91bmQoaHVlKSArIFwiLCBcIiArIHBlcmNlbnQudHJhbnNmb3JtKHNhbml0aXplKHNhdHVyYXRpb24pKSArIFwiLCBcIiArIHBlcmNlbnQudHJhbnNmb3JtKHNhbml0aXplKGxpZ2h0bmVzcykpICsgXCIsIFwiICsgc2FuaXRpemUoYWxwaGEudHJhbnNmb3JtKGFscGhhJDEpKSArIFwiKVwiO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9yZ2JhLm1qc1xudmFyIGNsYW1wUmdiVW5pdCA9IGNsYW1wKDAsIDI1NSk7XG52YXIgcmdiVW5pdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyKSwgeyB0cmFuc2Zvcm06ICh2KSA9PiBNYXRoLnJvdW5kKGNsYW1wUmdiVW5pdCh2KSkgfSk7XG52YXIgcmdiYSA9IHtcbiAgdGVzdDogaXNDb2xvclN0cmluZyhcInJnYlwiLCBcInJlZFwiKSxcbiAgcGFyc2U6IHNwbGl0Q29sb3IoXCJyZWRcIiwgXCJncmVlblwiLCBcImJsdWVcIiksXG4gIHRyYW5zZm9ybTogKHsgcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGE6IGFscGhhJDEgPSAxIH0pID0+IFwicmdiYShcIiArIHJnYlVuaXQudHJhbnNmb3JtKHJlZCkgKyBcIiwgXCIgKyByZ2JVbml0LnRyYW5zZm9ybShncmVlbikgKyBcIiwgXCIgKyByZ2JVbml0LnRyYW5zZm9ybShibHVlKSArIFwiLCBcIiArIHNhbml0aXplKGFscGhhLnRyYW5zZm9ybShhbHBoYSQxKSkgKyBcIilcIlxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvY29sb3IvaGV4Lm1qc1xuZnVuY3Rpb24gcGFyc2VIZXgodikge1xuICBsZXQgciA9IFwiXCI7XG4gIGxldCBnMiA9IFwiXCI7XG4gIGxldCBiMiA9IFwiXCI7XG4gIGxldCBhMiA9IFwiXCI7XG4gIGlmICh2Lmxlbmd0aCA+IDUpIHtcbiAgICByID0gdi5zdWJzdHIoMSwgMik7XG4gICAgZzIgPSB2LnN1YnN0cigzLCAyKTtcbiAgICBiMiA9IHYuc3Vic3RyKDUsIDIpO1xuICAgIGEyID0gdi5zdWJzdHIoNywgMik7XG4gIH0gZWxzZSB7XG4gICAgciA9IHYuc3Vic3RyKDEsIDEpO1xuICAgIGcyID0gdi5zdWJzdHIoMiwgMSk7XG4gICAgYjIgPSB2LnN1YnN0cigzLCAxKTtcbiAgICBhMiA9IHYuc3Vic3RyKDQsIDEpO1xuICAgIHIgKz0gcjtcbiAgICBnMiArPSBnMjtcbiAgICBiMiArPSBiMjtcbiAgICBhMiArPSBhMjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlZDogcGFyc2VJbnQociwgMTYpLFxuICAgIGdyZWVuOiBwYXJzZUludChnMiwgMTYpLFxuICAgIGJsdWU6IHBhcnNlSW50KGIyLCAxNiksXG4gICAgYWxwaGE6IGEyID8gcGFyc2VJbnQoYTIsIDE2KSAvIDI1NSA6IDFcbiAgfTtcbn1cbnZhciBoZXggPSB7XG4gIHRlc3Q6IGlzQ29sb3JTdHJpbmcoXCIjXCIpLFxuICBwYXJzZTogcGFyc2VIZXgsXG4gIHRyYW5zZm9ybTogcmdiYS50cmFuc2Zvcm1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbG9yL2luZGV4Lm1qc1xudmFyIGNvbG9yID0ge1xuICB0ZXN0OiAodikgPT4gcmdiYS50ZXN0KHYpIHx8IGhleC50ZXN0KHYpIHx8IGhzbGEudGVzdCh2KSxcbiAgcGFyc2U6ICh2KSA9PiB7XG4gICAgaWYgKHJnYmEudGVzdCh2KSkge1xuICAgICAgcmV0dXJuIHJnYmEucGFyc2Uodik7XG4gICAgfSBlbHNlIGlmIChoc2xhLnRlc3QodikpIHtcbiAgICAgIHJldHVybiBoc2xhLnBhcnNlKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaGV4LnBhcnNlKHYpO1xuICAgIH1cbiAgfSxcbiAgdHJhbnNmb3JtOiAodikgPT4ge1xuICAgIHJldHVybiBpc1N0cmluZyh2KSA/IHYgOiB2Lmhhc093blByb3BlcnR5KFwicmVkXCIpID8gcmdiYS50cmFuc2Zvcm0odikgOiBoc2xhLnRyYW5zZm9ybSh2KTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvY29tcGxleC9pbmRleC5tanNcbnZhciBjb2xvclRva2VuID0gXCIke2N9XCI7XG52YXIgbnVtYmVyVG9rZW4gPSBcIiR7bn1cIjtcbmZ1bmN0aW9uIHRlc3Qodikge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIHJldHVybiBpc05hTih2KSAmJiBpc1N0cmluZyh2KSAmJiAoKF9iID0gKF9hID0gdi5tYXRjaChmbG9hdFJlZ2V4KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgKyAoKF9kID0gKF9jID0gdi5tYXRjaChjb2xvclJlZ2V4KSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCkgPiAwO1xufVxuZnVuY3Rpb24gYW5hbHlzZSh2KSB7XG4gIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIilcbiAgICB2ID0gYCR7dn1gO1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgbGV0IG51bUNvbG9ycyA9IDA7XG4gIGNvbnN0IGNvbG9ycyA9IHYubWF0Y2goY29sb3JSZWdleCk7XG4gIGlmIChjb2xvcnMpIHtcbiAgICBudW1Db2xvcnMgPSBjb2xvcnMubGVuZ3RoO1xuICAgIHYgPSB2LnJlcGxhY2UoY29sb3JSZWdleCwgY29sb3JUb2tlbik7XG4gICAgdmFsdWVzLnB1c2goLi4uY29sb3JzLm1hcChjb2xvci5wYXJzZSkpO1xuICB9XG4gIGNvbnN0IG51bWJlcnMgPSB2Lm1hdGNoKGZsb2F0UmVnZXgpO1xuICBpZiAobnVtYmVycykge1xuICAgIHYgPSB2LnJlcGxhY2UoZmxvYXRSZWdleCwgbnVtYmVyVG9rZW4pO1xuICAgIHZhbHVlcy5wdXNoKC4uLm51bWJlcnMubWFwKG51bWJlci5wYXJzZSkpO1xuICB9XG4gIHJldHVybiB7IHZhbHVlcywgbnVtQ29sb3JzLCB0b2tlbmlzZWQ6IHYgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlKHYpIHtcbiAgcmV0dXJuIGFuYWx5c2UodikudmFsdWVzO1xufVxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtZXIodikge1xuICBjb25zdCB7IHZhbHVlcywgbnVtQ29sb3JzLCB0b2tlbmlzZWQgfSA9IGFuYWx5c2Uodik7XG4gIGNvbnN0IG51bVZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiAodjIpID0+IHtcbiAgICBsZXQgb3V0cHV0ID0gdG9rZW5pc2VkO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1WYWx1ZXM7IGkyKyspIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKGkyIDwgbnVtQ29sb3JzID8gY29sb3JUb2tlbiA6IG51bWJlclRva2VuLCBpMiA8IG51bUNvbG9ycyA/IGNvbG9yLnRyYW5zZm9ybSh2MltpMl0pIDogc2FuaXRpemUodjJbaTJdKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG52YXIgY29udmVydE51bWJlcnNUb1plcm8gPSAodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgPyAwIDogdjtcbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVOb25lKHYpIHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2Uodik7XG4gIGNvbnN0IHRyYW5zZm9ybWVyID0gY3JlYXRlVHJhbnNmb3JtZXIodik7XG4gIHJldHVybiB0cmFuc2Zvcm1lcihwYXJzZWQubWFwKGNvbnZlcnROdW1iZXJzVG9aZXJvKSk7XG59XG52YXIgY29tcGxleCA9IHsgdGVzdCwgcGFyc2UsIGNyZWF0ZVRyYW5zZm9ybWVyLCBnZXRBbmltYXRhYmxlTm9uZSB9O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb21wbGV4L2ZpbHRlci5tanNcbnZhciBtYXhEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImJyaWdodG5lc3NcIiwgXCJjb250cmFzdFwiLCBcInNhdHVyYXRlXCIsIFwib3BhY2l0eVwiXSk7XG5mdW5jdGlvbiBhcHBseURlZmF1bHRGaWx0ZXIodikge1xuICBsZXQgW25hbWUsIHZhbHVlXSA9IHYuc2xpY2UoMCwgLTEpLnNwbGl0KFwiKFwiKTtcbiAgaWYgKG5hbWUgPT09IFwiZHJvcC1zaGFkb3dcIilcbiAgICByZXR1cm4gdjtcbiAgY29uc3QgW251bWJlcjJdID0gdmFsdWUubWF0Y2goZmxvYXRSZWdleCkgfHwgW107XG4gIGlmICghbnVtYmVyMilcbiAgICByZXR1cm4gdjtcbiAgY29uc3QgdW5pdCA9IHZhbHVlLnJlcGxhY2UobnVtYmVyMiwgXCJcIik7XG4gIGxldCBkZWZhdWx0VmFsdWUgPSBtYXhEZWZhdWx0cy5oYXMobmFtZSkgPyAxIDogMDtcbiAgaWYgKG51bWJlcjIgIT09IHZhbHVlKVxuICAgIGRlZmF1bHRWYWx1ZSAqPSAxMDA7XG4gIHJldHVybiBuYW1lICsgXCIoXCIgKyBkZWZhdWx0VmFsdWUgKyB1bml0ICsgXCIpXCI7XG59XG52YXIgZnVuY3Rpb25SZWdleCA9IC8oW2Etei1dKilcXCguKj9cXCkvZztcbnZhciBmaWx0ZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbXBsZXgpLCB7IGdldEFuaW1hdGFibGVOb25lOiAodikgPT4ge1xuICBjb25zdCBmdW5jdGlvbnMgPSB2Lm1hdGNoKGZ1bmN0aW9uUmVnZXgpO1xuICByZXR1cm4gZnVuY3Rpb25zID8gZnVuY3Rpb25zLm1hcChhcHBseURlZmF1bHRGaWx0ZXIpLmpvaW4oXCIgXCIpIDogdjtcbn0gfSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy90eXBlLWludC5tanNcbnZhciBpbnQgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBudW1iZXIpLCB7XG4gIHRyYW5zZm9ybTogTWF0aC5yb3VuZFxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9udW1iZXIubWpzXG52YXIgbnVtYmVyVmFsdWVUeXBlcyA9IHtcbiAgYm9yZGVyV2lkdGg6IHB4LFxuICBib3JkZXJUb3BXaWR0aDogcHgsXG4gIGJvcmRlclJpZ2h0V2lkdGg6IHB4LFxuICBib3JkZXJCb3R0b21XaWR0aDogcHgsXG4gIGJvcmRlckxlZnRXaWR0aDogcHgsXG4gIGJvcmRlclJhZGl1czogcHgsXG4gIHJhZGl1czogcHgsXG4gIGJvcmRlclRvcExlZnRSYWRpdXM6IHB4LFxuICBib3JkZXJUb3BSaWdodFJhZGl1czogcHgsXG4gIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiBweCxcbiAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogcHgsXG4gIHdpZHRoOiBweCxcbiAgbWF4V2lkdGg6IHB4LFxuICBoZWlnaHQ6IHB4LFxuICBtYXhIZWlnaHQ6IHB4LFxuICBzaXplOiBweCxcbiAgdG9wOiBweCxcbiAgcmlnaHQ6IHB4LFxuICBib3R0b206IHB4LFxuICBsZWZ0OiBweCxcbiAgcGFkZGluZzogcHgsXG4gIHBhZGRpbmdUb3A6IHB4LFxuICBwYWRkaW5nUmlnaHQ6IHB4LFxuICBwYWRkaW5nQm90dG9tOiBweCxcbiAgcGFkZGluZ0xlZnQ6IHB4LFxuICBtYXJnaW46IHB4LFxuICBtYXJnaW5Ub3A6IHB4LFxuICBtYXJnaW5SaWdodDogcHgsXG4gIG1hcmdpbkJvdHRvbTogcHgsXG4gIG1hcmdpbkxlZnQ6IHB4LFxuICByb3RhdGU6IGRlZ3JlZXMsXG4gIHJvdGF0ZVg6IGRlZ3JlZXMsXG4gIHJvdGF0ZVk6IGRlZ3JlZXMsXG4gIHJvdGF0ZVo6IGRlZ3JlZXMsXG4gIHNjYWxlLFxuICBzY2FsZVg6IHNjYWxlLFxuICBzY2FsZVk6IHNjYWxlLFxuICBzY2FsZVo6IHNjYWxlLFxuICBza2V3OiBkZWdyZWVzLFxuICBza2V3WDogZGVncmVlcyxcbiAgc2tld1k6IGRlZ3JlZXMsXG4gIGRpc3RhbmNlOiBweCxcbiAgdHJhbnNsYXRlWDogcHgsXG4gIHRyYW5zbGF0ZVk6IHB4LFxuICB0cmFuc2xhdGVaOiBweCxcbiAgeDogcHgsXG4gIHk6IHB4LFxuICB6OiBweCxcbiAgcGVyc3BlY3RpdmU6IHB4LFxuICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogcHgsXG4gIG9wYWNpdHk6IGFscGhhLFxuICBvcmlnaW5YOiBwcm9ncmVzc1BlcmNlbnRhZ2UsXG4gIG9yaWdpblk6IHByb2dyZXNzUGVyY2VudGFnZSxcbiAgb3JpZ2luWjogcHgsXG4gIHpJbmRleDogaW50LFxuICBmaWxsT3BhY2l0eTogYWxwaGEsXG4gIHN0cm9rZU9wYWNpdHk6IGFscGhhLFxuICBudW1PY3RhdmVzOiBpbnRcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvYnVpbGQtc3R5bGVzLm1qc1xuZnVuY3Rpb24gYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gIGNvbnN0IHsgc3R5bGUsIHZhcnMsIHRyYW5zZm9ybSwgdHJhbnNmb3JtS2V5czogdHJhbnNmb3JtS2V5czIsIHRyYW5zZm9ybU9yaWdpbiB9ID0gc3RhdGU7XG4gIHRyYW5zZm9ybUtleXMyLmxlbmd0aCA9IDA7XG4gIGxldCBoYXNUcmFuc2Zvcm0yID0gZmFsc2U7XG4gIGxldCBoYXNUcmFuc2Zvcm1PcmlnaW4gPSBmYWxzZTtcbiAgbGV0IHRyYW5zZm9ybUlzTm9uZSA9IHRydWU7XG4gIGZvciAoY29uc3Qga2V5IGluIGxhdGVzdFZhbHVlcykge1xuICAgIGNvbnN0IHZhbHVlID0gbGF0ZXN0VmFsdWVzW2tleV07XG4gICAgaWYgKGlzQ1NTVmFyaWFibGUoa2V5KSkge1xuICAgICAgdmFyc1trZXldID0gdmFsdWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVUeXBlID0gbnVtYmVyVmFsdWVUeXBlc1trZXldO1xuICAgIGNvbnN0IHZhbHVlQXNUeXBlID0gZ2V0VmFsdWVBc1R5cGUodmFsdWUsIHZhbHVlVHlwZSk7XG4gICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICBoYXNUcmFuc2Zvcm0yID0gdHJ1ZTtcbiAgICAgIHRyYW5zZm9ybVtrZXldID0gdmFsdWVBc1R5cGU7XG4gICAgICB0cmFuc2Zvcm1LZXlzMi5wdXNoKGtleSk7XG4gICAgICBpZiAoIXRyYW5zZm9ybUlzTm9uZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAodmFsdWUgIT09ICh2YWx1ZVR5cGUuZGVmYXVsdCB8fCAwKSlcbiAgICAgICAgdHJhbnNmb3JtSXNOb25lID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChrZXkuc3RhcnRzV2l0aChcIm9yaWdpblwiKSkge1xuICAgICAgaGFzVHJhbnNmb3JtT3JpZ2luID0gdHJ1ZTtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbltrZXldID0gdmFsdWVBc1R5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFsYXRlc3RWYWx1ZXMudHJhbnNmb3JtKSB7XG4gICAgaWYgKGhhc1RyYW5zZm9ybTIgfHwgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGJ1aWxkVHJhbnNmb3JtKHN0YXRlLCBvcHRpb25zLCB0cmFuc2Zvcm1Jc05vbmUsIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLnRyYW5zZm9ybSkge1xuICAgICAgc3R5bGUudHJhbnNmb3JtID0gXCJub25lXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNUcmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBjb25zdCB7IG9yaWdpblggPSBcIjUwJVwiLCBvcmlnaW5ZID0gXCI1MCVcIiwgb3JpZ2luWiA9IDAgfSA9IHRyYW5zZm9ybU9yaWdpbjtcbiAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBgJHtvcmlnaW5YfSAke29yaWdpbll9ICR7b3JpZ2luWn1gO1xuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanNcbnZhciBjcmVhdGVIdG1sUmVuZGVyU3RhdGUgPSAoKSA9PiAoe1xuICBzdHlsZToge30sXG4gIHRyYW5zZm9ybToge30sXG4gIHRyYW5zZm9ybUtleXM6IFtdLFxuICB0cmFuc2Zvcm1PcmlnaW46IHt9LFxuICB2YXJzOiB7fVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXNlLXByb3BzLm1qc1xuZnVuY3Rpb24gY29weVJhd1ZhbHVlc09ubHkodGFyZ2V0LCBzb3VyY2UsIHByb3BzKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgIGlmICghaXNNb3Rpb25WYWx1ZShzb3VyY2Vba2V5XSkgJiYgIWlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1c2VJbml0aWFsTW90aW9uVmFsdWVzKHsgdHJhbnNmb3JtVGVtcGxhdGUgfSwgdmlzdWFsU3RhdGUsIGlzU3RhdGljKSB7XG4gIHJldHVybiB1c2VNZW1vMigoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVIdG1sUmVuZGVyU3RhdGUoKTtcbiAgICBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIHZpc3VhbFN0YXRlLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiAhaXNTdGF0aWMgfSwgdHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS52YXJzLCBzdGF0ZS5zdHlsZSk7XG4gIH0sIFt2aXN1YWxTdGF0ZV0pO1xufVxuZnVuY3Rpb24gdXNlU3R5bGUocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykge1xuICBjb25zdCBzdHlsZVByb3AgPSBwcm9wcy5zdHlsZSB8fCB7fTtcbiAgY29uc3Qgc3R5bGUgPSB7fTtcbiAgY29weVJhd1ZhbHVlc09ubHkoc3R5bGUsIHN0eWxlUHJvcCwgcHJvcHMpO1xuICBPYmplY3QuYXNzaWduKHN0eWxlLCB1c2VJbml0aWFsTW90aW9uVmFsdWVzKHByb3BzLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpKTtcbiAgcmV0dXJuIHByb3BzLnRyYW5zZm9ybVZhbHVlcyA/IHByb3BzLnRyYW5zZm9ybVZhbHVlcyhzdHlsZSkgOiBzdHlsZTtcbn1cbmZ1bmN0aW9uIHVzZUhUTUxQcm9wcyhwcm9wcywgdmlzdWFsU3RhdGUsIGlzU3RhdGljKSB7XG4gIGNvbnN0IGh0bWxQcm9wcyA9IHt9O1xuICBjb25zdCBzdHlsZSA9IHVzZVN0eWxlKHByb3BzLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpO1xuICBpZiAocHJvcHMuZHJhZyAmJiBwcm9wcy5kcmFnTGlzdGVuZXIgIT09IGZhbHNlKSB7XG4gICAgaHRtbFByb3BzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHN0eWxlLnVzZXJTZWxlY3QgPSBzdHlsZS5XZWJraXRVc2VyU2VsZWN0ID0gc3R5bGUuV2Via2l0VG91Y2hDYWxsb3V0ID0gXCJub25lXCI7XG4gICAgc3R5bGUudG91Y2hBY3Rpb24gPSBwcm9wcy5kcmFnID09PSB0cnVlID8gXCJub25lXCIgOiBgcGFuLSR7cHJvcHMuZHJhZyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwifWA7XG4gIH1cbiAgaHRtbFByb3BzLnN0eWxlID0gc3R5bGU7XG4gIHJldHVybiBodG1sUHJvcHM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3ZhbGlkLXByb3AubWpzXG52YXIgYW5pbWF0aW9uUHJvcHMgPSBbXG4gIFwiYW5pbWF0ZVwiLFxuICBcImV4aXRcIixcbiAgXCJ2YXJpYW50c1wiLFxuICBcIndoaWxlSG92ZXJcIixcbiAgXCJ3aGlsZVRhcFwiLFxuICBcIndoaWxlRm9jdXNcIixcbiAgXCJ3aGlsZURyYWdcIixcbiAgXCJ3aGlsZUluVmlld1wiXG5dO1xudmFyIHRhcFByb3BzID0gW1wid2hpbGVUYXBcIiwgXCJvblRhcFwiLCBcIm9uVGFwU3RhcnRcIiwgXCJvblRhcENhbmNlbFwiXTtcbnZhciBwYW5Qcm9wcyA9IFtcIm9uUGFuXCIsIFwib25QYW5TdGFydFwiLCBcIm9uUGFuU2Vzc2lvblN0YXJ0XCIsIFwib25QYW5FbmRcIl07XG52YXIgaW5WaWV3UHJvcHMgPSBbXG4gIFwid2hpbGVJblZpZXdcIixcbiAgXCJvblZpZXdwb3J0RW50ZXJcIixcbiAgXCJvblZpZXdwb3J0TGVhdmVcIixcbiAgXCJ2aWV3cG9ydFwiXG5dO1xudmFyIHZhbGlkTW90aW9uUHJvcHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiaW5pdGlhbFwiLFxuICBcInN0eWxlXCIsXG4gIFwidmFsdWVzXCIsXG4gIFwidmFyaWFudHNcIixcbiAgXCJ0cmFuc2l0aW9uXCIsXG4gIFwidHJhbnNmb3JtVGVtcGxhdGVcIixcbiAgXCJ0cmFuc2Zvcm1WYWx1ZXNcIixcbiAgXCJjdXN0b21cIixcbiAgXCJpbmhlcml0XCIsXG4gIFwibGF5b3V0XCIsXG4gIFwibGF5b3V0SWRcIixcbiAgXCJsYXlvdXREZXBlbmRlbmN5XCIsXG4gIFwib25MYXlvdXRBbmltYXRpb25TdGFydFwiLFxuICBcIm9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGVcIixcbiAgXCJvbkxheW91dE1lYXN1cmVcIixcbiAgXCJvbkJlZm9yZUxheW91dE1lYXN1cmVcIixcbiAgXCJvbkFuaW1hdGlvblN0YXJ0XCIsXG4gIFwib25BbmltYXRpb25Db21wbGV0ZVwiLFxuICBcIm9uVXBkYXRlXCIsXG4gIFwib25EcmFnU3RhcnRcIixcbiAgXCJvbkRyYWdcIixcbiAgXCJvbkRyYWdFbmRcIixcbiAgXCJvbk1lYXN1cmVEcmFnQ29uc3RyYWludHNcIixcbiAgXCJvbkRpcmVjdGlvbkxvY2tcIixcbiAgXCJvbkRyYWdUcmFuc2l0aW9uRW5kXCIsXG4gIFwiZHJhZ1wiLFxuICBcImRyYWdDb250cm9sc1wiLFxuICBcImRyYWdMaXN0ZW5lclwiLFxuICBcImRyYWdDb25zdHJhaW50c1wiLFxuICBcImRyYWdEaXJlY3Rpb25Mb2NrXCIsXG4gIFwiZHJhZ1NuYXBUb09yaWdpblwiLFxuICBcIl9kcmFnWFwiLFxuICBcIl9kcmFnWVwiLFxuICBcImRyYWdFbGFzdGljXCIsXG4gIFwiZHJhZ01vbWVudHVtXCIsXG4gIFwiZHJhZ1Byb3BhZ2F0aW9uXCIsXG4gIFwiZHJhZ1RyYW5zaXRpb25cIixcbiAgXCJvbkhvdmVyU3RhcnRcIixcbiAgXCJvbkhvdmVyRW5kXCIsXG4gIFwibGF5b3V0U2Nyb2xsXCIsXG4gIC4uLmluVmlld1Byb3BzLFxuICAuLi50YXBQcm9wcyxcbiAgLi4uYW5pbWF0aW9uUHJvcHMsXG4gIC4uLnBhblByb3BzXG5dKTtcbmZ1bmN0aW9uIGlzVmFsaWRNb3Rpb25Qcm9wKGtleSkge1xuICByZXR1cm4gdmFsaWRNb3Rpb25Qcm9wcy5oYXMoa2V5KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2ZpbHRlci1wcm9wcy5tanNcbnZhciBzaG91bGRGb3J3YXJkID0gKGtleSkgPT4gIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSk7XG5mdW5jdGlvbiBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcChpc1ZhbGlkUHJvcCkge1xuICBpZiAoIWlzVmFsaWRQcm9wKVxuICAgIHJldHVybjtcbiAgc2hvdWxkRm9yd2FyZCA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwib25cIikgPyAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KSA6IGlzVmFsaWRQcm9wKGtleSk7XG59XG50cnkge1xuICBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcCgoaW5pdF9pc19wcm9wX3ZhbGlkX2VzbSgpLCBfX3RvQ29tbW9uSlMoaXNfcHJvcF92YWxpZF9lc21fZXhwb3J0cykpLmRlZmF1bHQpO1xufSBjYXRjaCAoX2EpIHtcbn1cbmZ1bmN0aW9uIGZpbHRlclByb3BzKHByb3BzLCBpc0RvbSwgZm9yd2FyZE1vdGlvblByb3BzKSB7XG4gIGNvbnN0IGZpbHRlcmVkUHJvcHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoc2hvdWxkRm9yd2FyZChrZXkpIHx8IGZvcndhcmRNb3Rpb25Qcm9wcyA9PT0gdHJ1ZSAmJiBpc1ZhbGlkTW90aW9uUHJvcChrZXkpIHx8ICFpc0RvbSAmJiAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KSB8fCBwcm9wc1tcImRyYWdnYWJsZVwiXSAmJiBrZXkuc3RhcnRzV2l0aChcIm9uRHJhZ1wiKSkge1xuICAgICAgZmlsdGVyZWRQcm9wc1trZXldID0gcHJvcHNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkUHJvcHM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91c2UtcHJvcHMubWpzXG5pbXBvcnQgeyB1c2VNZW1vIGFzIHVzZU1lbW8zIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy90cmFuc2Zvcm0tb3JpZ2luLm1qc1xuZnVuY3Rpb24gY2FsY09yaWdpbihvcmlnaW4sIG9mZnNldCwgc2l6ZSkge1xuICByZXR1cm4gdHlwZW9mIG9yaWdpbiA9PT0gXCJzdHJpbmdcIiA/IG9yaWdpbiA6IHB4LnRyYW5zZm9ybShvZmZzZXQgKyBzaXplICogb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGNhbGNTVkdUcmFuc2Zvcm1PcmlnaW4oZGltZW5zaW9ucywgb3JpZ2luWCwgb3JpZ2luWSkge1xuICBjb25zdCBweE9yaWdpblggPSBjYWxjT3JpZ2luKG9yaWdpblgsIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy53aWR0aCk7XG4gIGNvbnN0IHB4T3JpZ2luWSA9IGNhbGNPcmlnaW4ob3JpZ2luWSwgZGltZW5zaW9ucy55LCBkaW1lbnNpb25zLmhlaWdodCk7XG4gIHJldHVybiBgJHtweE9yaWdpblh9ICR7cHhPcmlnaW5ZfWA7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9wYXRoLm1qc1xudmFyIGRhc2hLZXlzID0ge1xuICBvZmZzZXQ6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgYXJyYXk6IFwic3Ryb2tlLWRhc2hhcnJheVwiXG59O1xudmFyIGNhbWVsS2V5cyA9IHtcbiAgb2Zmc2V0OiBcInN0cm9rZURhc2hvZmZzZXRcIixcbiAgYXJyYXk6IFwic3Ryb2tlRGFzaGFycmF5XCJcbn07XG5mdW5jdGlvbiBidWlsZFNWR1BhdGgoYXR0cnMsIGxlbmd0aCwgc3BhY2luZyA9IDEsIG9mZnNldCA9IDAsIHVzZURhc2hDYXNlID0gdHJ1ZSkge1xuICBhdHRycy5wYXRoTGVuZ3RoID0gMTtcbiAgY29uc3Qga2V5czIgPSB1c2VEYXNoQ2FzZSA/IGRhc2hLZXlzIDogY2FtZWxLZXlzO1xuICBhdHRyc1trZXlzMi5vZmZzZXRdID0gcHgudHJhbnNmb3JtKC1vZmZzZXQpO1xuICBjb25zdCBwYXRoTGVuZ3RoID0gcHgudHJhbnNmb3JtKGxlbmd0aCk7XG4gIGNvbnN0IHBhdGhTcGFjaW5nID0gcHgudHJhbnNmb3JtKHNwYWNpbmcpO1xuICBhdHRyc1trZXlzMi5hcnJheV0gPSBgJHtwYXRoTGVuZ3RofSAke3BhdGhTcGFjaW5nfWA7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9idWlsZC1hdHRycy5tanNcbmZ1bmN0aW9uIGJ1aWxkU1ZHQXR0cnMoc3RhdGUsIF9hLCBvcHRpb25zLCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICB2YXIgX2IgPSBfYSwge1xuICAgIGF0dHJYLFxuICAgIGF0dHJZLFxuICAgIG9yaWdpblgsXG4gICAgb3JpZ2luWSxcbiAgICBwYXRoTGVuZ3RoLFxuICAgIHBhdGhTcGFjaW5nID0gMSxcbiAgICBwYXRoT2Zmc2V0ID0gMFxuICB9ID0gX2IsIGxhdGVzdCA9IF9fb2JqUmVzdChfYiwgW1xuICAgIFwiYXR0clhcIixcbiAgICBcImF0dHJZXCIsXG4gICAgXCJvcmlnaW5YXCIsXG4gICAgXCJvcmlnaW5ZXCIsXG4gICAgXCJwYXRoTGVuZ3RoXCIsXG4gICAgXCJwYXRoU3BhY2luZ1wiLFxuICAgIFwicGF0aE9mZnNldFwiXG4gIF0pO1xuICBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIGxhdGVzdCwgb3B0aW9ucywgdHJhbnNmb3JtVGVtcGxhdGUpO1xuICBzdGF0ZS5hdHRycyA9IHN0YXRlLnN0eWxlO1xuICBzdGF0ZS5zdHlsZSA9IHt9O1xuICBjb25zdCB7IGF0dHJzLCBzdHlsZSwgZGltZW5zaW9ucyB9ID0gc3RhdGU7XG4gIGlmIChhdHRycy50cmFuc2Zvcm0pIHtcbiAgICBpZiAoZGltZW5zaW9ucylcbiAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGF0dHJzLnRyYW5zZm9ybTtcbiAgICBkZWxldGUgYXR0cnMudHJhbnNmb3JtO1xuICB9XG4gIGlmIChkaW1lbnNpb25zICYmIChvcmlnaW5YICE9PSB2b2lkIDAgfHwgb3JpZ2luWSAhPT0gdm9pZCAwIHx8IHN0eWxlLnRyYW5zZm9ybSkpIHtcbiAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luKGRpbWVuc2lvbnMsIG9yaWdpblggIT09IHZvaWQgMCA/IG9yaWdpblggOiAwLjUsIG9yaWdpblkgIT09IHZvaWQgMCA/IG9yaWdpblkgOiAwLjUpO1xuICB9XG4gIGlmIChhdHRyWCAhPT0gdm9pZCAwKVxuICAgIGF0dHJzLnggPSBhdHRyWDtcbiAgaWYgKGF0dHJZICE9PSB2b2lkIDApXG4gICAgYXR0cnMueSA9IGF0dHJZO1xuICBpZiAocGF0aExlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgYnVpbGRTVkdQYXRoKGF0dHJzLCBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZywgcGF0aE9mZnNldCwgZmFsc2UpO1xuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qc1xudmFyIGNyZWF0ZVN2Z1JlbmRlclN0YXRlID0gKCkgPT4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgY3JlYXRlSHRtbFJlbmRlclN0YXRlKCkpLCB7XG4gIGF0dHJzOiB7fVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91c2UtcHJvcHMubWpzXG5mdW5jdGlvbiB1c2VTVkdQcm9wcyhwcm9wcywgdmlzdWFsU3RhdGUpIHtcbiAgY29uc3QgdmlzdWFsUHJvcHMgPSB1c2VNZW1vMygoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdmdSZW5kZXJTdGF0ZSgpO1xuICAgIGJ1aWxkU1ZHQXR0cnMoc3RhdGUsIHZpc3VhbFN0YXRlLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiBmYWxzZSB9LCBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHN0YXRlLmF0dHJzKSwge1xuICAgICAgc3R5bGU6IF9fc3ByZWFkVmFsdWVzKHt9LCBzdGF0ZS5zdHlsZSlcbiAgICB9KTtcbiAgfSwgW3Zpc3VhbFN0YXRlXSk7XG4gIGlmIChwcm9wcy5zdHlsZSkge1xuICAgIGNvbnN0IHJhd1N0eWxlcyA9IHt9O1xuICAgIGNvcHlSYXdWYWx1ZXNPbmx5KHJhd1N0eWxlcywgcHJvcHMuc3R5bGUsIHByb3BzKTtcbiAgICB2aXN1YWxQcm9wcy5zdHlsZSA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCByYXdTdHlsZXMpLCB2aXN1YWxQcm9wcy5zdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHZpc3VhbFByb3BzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXNlLXJlbmRlci5tanNcbmZ1bmN0aW9uIGNyZWF0ZVVzZVJlbmRlcihmb3J3YXJkTW90aW9uUHJvcHMgPSBmYWxzZSkge1xuICBjb25zdCB1c2VSZW5kZXIgPSAoQ29tcG9uZW50LCBwcm9wcywgcHJvamVjdGlvbklkLCByZWYsIHsgbGF0ZXN0VmFsdWVzIH0sIGlzU3RhdGljKSA9PiB7XG4gICAgY29uc3QgdXNlVmlzdWFsUHJvcHMgPSBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpID8gdXNlU1ZHUHJvcHMgOiB1c2VIVE1MUHJvcHM7XG4gICAgY29uc3QgdmlzdWFsUHJvcHMgPSB1c2VWaXN1YWxQcm9wcyhwcm9wcywgbGF0ZXN0VmFsdWVzLCBpc1N0YXRpYyk7XG4gICAgY29uc3QgZmlsdGVyZWRQcm9wcyA9IGZpbHRlclByb3BzKHByb3BzLCB0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiLCBmb3J3YXJkTW90aW9uUHJvcHMpO1xuICAgIGNvbnN0IGVsZW1lbnRQcm9wcyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGZpbHRlcmVkUHJvcHMpLCB2aXN1YWxQcm9wcyksIHtcbiAgICAgIHJlZlxuICAgIH0pO1xuICAgIGlmIChwcm9qZWN0aW9uSWQpIHtcbiAgICAgIGVsZW1lbnRQcm9wc1tcImRhdGEtcHJvamVjdGlvbi1pZFwiXSA9IHByb2plY3Rpb25JZDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQyKENvbXBvbmVudCwgZWxlbWVudFByb3BzKTtcbiAgfTtcbiAgcmV0dXJuIHVzZVJlbmRlcjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2NhbWVsLXRvLWRhc2gubWpzXG52YXIgY2FtZWxUb0Rhc2ggPSAoc3RyKSA9PiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL3JlbmRlci5tanNcbmZ1bmN0aW9uIHJlbmRlckhUTUwoZWxlbWVudCwgeyBzdHlsZSwgdmFycyB9LCBzdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSwgcHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLmdldFByb2plY3Rpb25TdHlsZXMoc3R5bGVQcm9wKSk7XG4gIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcbiAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFyc1trZXldKTtcbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvY2FtZWwtY2FzZS1hdHRycy5tanNcbnZhciBjYW1lbENhc2VBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImJhc2VGcmVxdWVuY3lcIixcbiAgXCJkaWZmdXNlQ29uc3RhbnRcIixcbiAgXCJrZXJuZWxNYXRyaXhcIixcbiAgXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gIFwia2V5U3BsaW5lc1wiLFxuICBcImtleVRpbWVzXCIsXG4gIFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgXCJtYXJrZXJIZWlnaHRcIixcbiAgXCJtYXJrZXJXaWR0aFwiLFxuICBcIm51bU9jdGF2ZXNcIixcbiAgXCJ0YXJnZXRYXCIsXG4gIFwidGFyZ2V0WVwiLFxuICBcInN1cmZhY2VTY2FsZVwiLFxuICBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gIFwic3RkRGV2aWF0aW9uXCIsXG4gIFwidGFibGVWYWx1ZXNcIixcbiAgXCJ2aWV3Qm94XCIsXG4gIFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgXCJwYXRoTGVuZ3RoXCJcbl0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvcmVuZGVyLm1qc1xuZnVuY3Rpb24gcmVuZGVyU1ZHKGVsZW1lbnQsIHJlbmRlclN0YXRlLCBfc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gIHJlbmRlckhUTUwoZWxlbWVudCwgcmVuZGVyU3RhdGUsIHZvaWQgMCwgcHJvamVjdGlvbik7XG4gIGZvciAoY29uc3Qga2V5IGluIHJlbmRlclN0YXRlLmF0dHJzKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoIWNhbWVsQ2FzZUF0dHJpYnV0ZXMuaGFzKGtleSkgPyBjYW1lbFRvRGFzaChrZXkpIDoga2V5LCByZW5kZXJTdGF0ZS5hdHRyc1trZXldKTtcbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qc1xuZnVuY3Rpb24gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKSB7XG4gIGNvbnN0IHsgc3R5bGUgfSA9IHByb3BzO1xuICBjb25zdCBuZXdWYWx1ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGUpIHtcbiAgICBpZiAoaXNNb3Rpb25WYWx1ZShzdHlsZVtrZXldKSB8fCBpc0ZvcmNlZE1vdGlvblZhbHVlKGtleSwgcHJvcHMpKSB7XG4gICAgICBuZXdWYWx1ZXNba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdWYWx1ZXM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanNcbmZ1bmN0aW9uIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczIocHJvcHMpIHtcbiAgY29uc3QgbmV3VmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaXNNb3Rpb25WYWx1ZShwcm9wc1trZXldKSkge1xuICAgICAgY29uc3QgdGFyZ2V0S2V5ID0ga2V5ID09PSBcInhcIiB8fCBrZXkgPT09IFwieVwiID8gXCJhdHRyXCIgKyBrZXkudG9VcHBlckNhc2UoKSA6IGtleTtcbiAgICAgIG5ld1ZhbHVlc1t0YXJnZXRLZXldID0gcHJvcHNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1ZhbHVlcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1zdGF0ZS5tanNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDUgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvcmVzb2x2ZS12YXJpYW50cy5tanNcbmZ1bmN0aW9uIHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uLCBjdXN0b20sIGN1cnJlbnRWYWx1ZXMgPSB7fSwgY3VycmVudFZlbG9jaXR5ID0ge30pIHtcbiAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbihjdXN0b20gIT09IHZvaWQgMCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgY3VycmVudFZhbHVlcywgY3VycmVudFZlbG9jaXR5KTtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICBkZWZpbml0aW9uID0gcHJvcHMudmFyaWFudHMgJiYgcHJvcHMudmFyaWFudHNbZGVmaW5pdGlvbl07XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbihjdXN0b20gIT09IHZvaWQgMCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgY3VycmVudFZhbHVlcywgY3VycmVudFZlbG9jaXR5KTtcbiAgfVxuICByZXR1cm4gZGVmaW5pdGlvbjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvaXMta2V5ZnJhbWVzLXRhcmdldC5tanNcbnZhciBpc0tleWZyYW1lc1RhcmdldCA9ICh2KSA9PiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHYpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9yZXNvbHZlLXZhbHVlLm1qc1xudmFyIGlzQ3VzdG9tVmFsdWUgPSAodikgPT4ge1xuICByZXR1cm4gQm9vbGVhbih2ICYmIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYubWl4ICYmIHYudG9WYWx1ZSk7XG59O1xudmFyIHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMgPSAodikgPT4ge1xuICByZXR1cm4gaXNLZXlmcmFtZXNUYXJnZXQodikgPyB2W3YubGVuZ3RoIC0gMV0gfHwgMCA6IHY7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3V0aWxzL3Jlc29sdmUtbW90aW9uLXZhbHVlLm1qc1xuZnVuY3Rpb24gcmVzb2x2ZU1vdGlvblZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IHVud3JhcHBlZFZhbHVlID0gaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZS5nZXQoKSA6IHZhbHVlO1xuICByZXR1cm4gaXNDdXN0b21WYWx1ZSh1bndyYXBwZWRWYWx1ZSkgPyB1bndyYXBwZWRWYWx1ZS50b1ZhbHVlKCkgOiB1bndyYXBwZWRWYWx1ZTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1zdGF0ZS5tanNcbmZ1bmN0aW9uIG1ha2VTdGF0ZSh7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMywgY3JlYXRlUmVuZGVyU3RhdGUsIG9uTW91bnQgfSwgcHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBsYXRlc3RWYWx1ZXM6IG1ha2VMYXRlc3RWYWx1ZXMocHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMyksXG4gICAgcmVuZGVyU3RhdGU6IGNyZWF0ZVJlbmRlclN0YXRlKClcbiAgfTtcbiAgaWYgKG9uTW91bnQpIHtcbiAgICBzdGF0ZS5tb3VudCA9IChpbnN0YW5jZSkgPT4gb25Nb3VudChwcm9wcywgaW5zdGFuY2UsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG52YXIgbWFrZVVzZVZpc3VhbFN0YXRlID0gKGNvbmZpZykgPT4gKHByb3BzLCBpc1N0YXRpYykgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDUoTW90aW9uQ29udGV4dCk7XG4gIGNvbnN0IHByZXNlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQ1KFByZXNlbmNlQ29udGV4dCk7XG4gIGNvbnN0IG1ha2UgPSAoKSA9PiBtYWtlU3RhdGUoY29uZmlnLCBwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0KTtcbiAgcmV0dXJuIGlzU3RhdGljID8gbWFrZSgpIDogdXNlQ29uc3RhbnQobWFrZSk7XG59O1xuZnVuY3Rpb24gbWFrZUxhdGVzdFZhbHVlcyhwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0LCBzY3JhcGVNb3Rpb25WYWx1ZXMpIHtcbiAgY29uc3QgdmFsdWVzID0ge307XG4gIGNvbnN0IG1vdGlvblZhbHVlcyA9IHNjcmFwZU1vdGlvblZhbHVlcyhwcm9wcyk7XG4gIGZvciAoY29uc3Qga2V5IGluIG1vdGlvblZhbHVlcykge1xuICAgIHZhbHVlc1trZXldID0gcmVzb2x2ZU1vdGlvblZhbHVlKG1vdGlvblZhbHVlc1trZXldKTtcbiAgfVxuICBsZXQgeyBpbml0aWFsLCBhbmltYXRlOiBhbmltYXRlMyB9ID0gcHJvcHM7XG4gIGNvbnN0IGlzQ29udHJvbGxpbmdWYXJpYW50cyQxID0gaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKTtcbiAgY29uc3QgaXNWYXJpYW50Tm9kZSQxID0gaXNWYXJpYW50Tm9kZShwcm9wcyk7XG4gIGlmIChjb250ZXh0ICYmIGlzVmFyaWFudE5vZGUkMSAmJiAhaXNDb250cm9sbGluZ1ZhcmlhbnRzJDEgJiYgcHJvcHMuaW5oZXJpdCAhPT0gZmFsc2UpIHtcbiAgICBpZiAoaW5pdGlhbCA9PT0gdm9pZCAwKVxuICAgICAgaW5pdGlhbCA9IGNvbnRleHQuaW5pdGlhbDtcbiAgICBpZiAoYW5pbWF0ZTMgPT09IHZvaWQgMClcbiAgICAgIGFuaW1hdGUzID0gY29udGV4dC5hbmltYXRlO1xuICB9XG4gIGxldCBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkID0gcHJlc2VuY2VDb250ZXh0ID8gcHJlc2VuY2VDb250ZXh0LmluaXRpYWwgPT09IGZhbHNlIDogZmFsc2U7XG4gIGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPSBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkIHx8IGluaXRpYWwgPT09IGZhbHNlO1xuICBjb25zdCB2YXJpYW50VG9TZXQgPSBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkID8gYW5pbWF0ZTMgOiBpbml0aWFsO1xuICBpZiAodmFyaWFudFRvU2V0ICYmIHR5cGVvZiB2YXJpYW50VG9TZXQgIT09IFwiYm9vbGVhblwiICYmICFpc0FuaW1hdGlvbkNvbnRyb2xzKHZhcmlhbnRUb1NldCkpIHtcbiAgICBjb25zdCBsaXN0ID0gQXJyYXkuaXNBcnJheSh2YXJpYW50VG9TZXQpID8gdmFyaWFudFRvU2V0IDogW3ZhcmlhbnRUb1NldF07XG4gICAgbGlzdC5mb3JFYWNoKChkZWZpbml0aW9uKSA9PiB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uKTtcbiAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IF9hID0gcmVzb2x2ZWQsIHsgdHJhbnNpdGlvbkVuZCwgdHJhbnNpdGlvbiB9ID0gX2EsIHRhcmdldCA9IF9fb2JqUmVzdChfYSwgW1widHJhbnNpdGlvbkVuZFwiLCBcInRyYW5zaXRpb25cIl0pO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIGxldCB2YWx1ZVRhcmdldCA9IHRhcmdldFtrZXldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVRhcmdldCkpIHtcbiAgICAgICAgICBjb25zdCBpbmRleDIgPSBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkID8gdmFsdWVUYXJnZXQubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgICAgdmFsdWVUYXJnZXQgPSB2YWx1ZVRhcmdldFtpbmRleDJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZVRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlc1trZXldID0gdmFsdWVUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRyYW5zaXRpb25FbmQpXG4gICAgICAgIHZhbHVlc1trZXldID0gdHJhbnNpdGlvbkVuZFtrZXldO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy9jb25maWctbW90aW9uLm1qc1xudmFyIHN2Z01vdGlvbkNvbmZpZyA9IHtcbiAgdXNlVmlzdWFsU3RhdGU6IG1ha2VVc2VWaXN1YWxTdGF0ZSh7XG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMyLFxuICAgIGNyZWF0ZVJlbmRlclN0YXRlOiBjcmVhdGVTdmdSZW5kZXJTdGF0ZSxcbiAgICBvbk1vdW50OiAocHJvcHMsIGluc3RhbmNlLCB7IHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMgfSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyU3RhdGUuZGltZW5zaW9ucyA9IHR5cGVvZiBpbnN0YW5jZS5nZXRCQm94ID09PSBcImZ1bmN0aW9uXCIgPyBpbnN0YW5jZS5nZXRCQm94KCkgOiBpbnN0YW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVuZGVyU3RhdGUuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBidWlsZFNWR0F0dHJzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IGZhbHNlIH0sIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgIHJlbmRlclNWRyhpbnN0YW5jZSwgcmVuZGVyU3RhdGUpO1xuICAgIH1cbiAgfSlcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvY29uZmlnLW1vdGlvbi5tanNcbnZhciBodG1sTW90aW9uQ29uZmlnID0ge1xuICB1c2VWaXN1YWxTdGF0ZTogbWFrZVVzZVZpc3VhbFN0YXRlKHtcbiAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMsXG4gICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZVxuICB9KVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2NyZWF0ZS1jb25maWcubWpzXG5mdW5jdGlvbiBjcmVhdGVEb21Nb3Rpb25Db25maWcoQ29tcG9uZW50LCB7IGZvcndhcmRNb3Rpb25Qcm9wcyA9IGZhbHNlIH0sIHByZWxvYWRlZEZlYXR1cmVzLCBjcmVhdGVWaXN1YWxFbGVtZW50LCBwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKSB7XG4gIGNvbnN0IGJhc2VDb25maWcgPSBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpID8gc3ZnTW90aW9uQ29uZmlnIDogaHRtbE1vdGlvbkNvbmZpZztcbiAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGJhc2VDb25maWcpLCB7XG4gICAgcHJlbG9hZGVkRmVhdHVyZXMsXG4gICAgdXNlUmVuZGVyOiBjcmVhdGVVc2VSZW5kZXIoZm9yd2FyZE1vdGlvblByb3BzKSxcbiAgICBjcmVhdGVWaXN1YWxFbGVtZW50LFxuICAgIHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsXG4gICAgQ29tcG9uZW50XG4gIH0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy90eXBlcy5tanNcbnZhciBBbmltYXRpb25UeXBlO1xuKGZ1bmN0aW9uKEFuaW1hdGlvblR5cGUyKSB7XG4gIEFuaW1hdGlvblR5cGUyW1wiQW5pbWF0ZVwiXSA9IFwiYW5pbWF0ZVwiO1xuICBBbmltYXRpb25UeXBlMltcIkhvdmVyXCJdID0gXCJ3aGlsZUhvdmVyXCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiVGFwXCJdID0gXCJ3aGlsZVRhcFwiO1xuICBBbmltYXRpb25UeXBlMltcIkRyYWdcIl0gPSBcIndoaWxlRHJhZ1wiO1xuICBBbmltYXRpb25UeXBlMltcIkZvY3VzXCJdID0gXCJ3aGlsZUZvY3VzXCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiSW5WaWV3XCJdID0gXCJ3aGlsZUluVmlld1wiO1xuICBBbmltYXRpb25UeXBlMltcIkV4aXRcIl0gPSBcImV4aXRcIjtcbn0pKEFuaW1hdGlvblR5cGUgfHwgKEFuaW1hdGlvblR5cGUgPSB7fSkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy91c2UtZG9tLWV2ZW50Lm1qc1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIGFkZERvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH0pIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG59XG5mdW5jdGlvbiB1c2VEb21FdmVudChyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKGhhbmRsZXIgJiYgZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGFkZERvbUV2ZW50KGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfVxuICB9LCBbcmVmLCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnNdKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy91c2UtZm9jdXMtZ2VzdHVyZS5tanNcbmZ1bmN0aW9uIHVzZUZvY3VzR2VzdHVyZSh7IHdoaWxlRm9jdXMsIHZpc3VhbEVsZW1lbnQgfSkge1xuICBjb25zdCB7IGFuaW1hdGlvblN0YXRlIH0gPSB2aXN1YWxFbGVtZW50O1xuICBjb25zdCBvbkZvY3VzID0gKCkgPT4ge1xuICAgIGFuaW1hdGlvblN0YXRlICYmIGFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkZvY3VzLCB0cnVlKTtcbiAgfTtcbiAgY29uc3Qgb25CbHVyID0gKCkgPT4ge1xuICAgIGFuaW1hdGlvblN0YXRlICYmIGFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkZvY3VzLCBmYWxzZSk7XG4gIH07XG4gIHVzZURvbUV2ZW50KHZpc3VhbEVsZW1lbnQsIFwiZm9jdXNcIiwgd2hpbGVGb2N1cyA/IG9uRm9jdXMgOiB2b2lkIDApO1xuICB1c2VEb21FdmVudCh2aXN1YWxFbGVtZW50LCBcImJsdXJcIiwgd2hpbGVGb2N1cyA/IG9uQmx1ciA6IHZvaWQgMCk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXRpbHMvZXZlbnQtdHlwZS5tanNcbmZ1bmN0aW9uIGlzTW91c2VFdmVudChldmVudCkge1xuICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBldmVudCBpbnN0YW5jZW9mIFBvaW50ZXJFdmVudCkge1xuICAgIHJldHVybiAhIShldmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiKTtcbiAgfVxuICByZXR1cm4gZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50O1xufVxuZnVuY3Rpb24gaXNUb3VjaEV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGhhc1RvdWNoZXMgPSAhIWV2ZW50LnRvdWNoZXM7XG4gIHJldHVybiBoYXNUb3VjaGVzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy9ldmVudC1pbmZvLm1qc1xuZnVuY3Rpb24gZmlsdGVyUHJpbWFyeVBvaW50ZXIoZXZlbnRIYW5kbGVyKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBpc01vdXNlRXZlbnQyID0gZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50O1xuICAgIGNvbnN0IGlzUHJpbWFyeVBvaW50ZXIgPSAhaXNNb3VzZUV2ZW50MiB8fCBpc01vdXNlRXZlbnQyICYmIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbiAgICBpZiAoaXNQcmltYXJ5UG9pbnRlcikge1xuICAgICAgZXZlbnRIYW5kbGVyKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG52YXIgZGVmYXVsdFBhZ2VQb2ludCA9IHsgcGFnZVg6IDAsIHBhZ2VZOiAwIH07XG5mdW5jdGlvbiBwb2ludEZyb21Ub3VjaChlLCBwb2ludFR5cGUgPSBcInBhZ2VcIikge1xuICBjb25zdCBwcmltYXJ5VG91Y2ggPSBlLnRvdWNoZXNbMF0gfHwgZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgY29uc3QgcG9pbnQyID0gcHJpbWFyeVRvdWNoIHx8IGRlZmF1bHRQYWdlUG9pbnQ7XG4gIHJldHVybiB7XG4gICAgeDogcG9pbnQyW3BvaW50VHlwZSArIFwiWFwiXSxcbiAgICB5OiBwb2ludDJbcG9pbnRUeXBlICsgXCJZXCJdXG4gIH07XG59XG5mdW5jdGlvbiBwb2ludEZyb21Nb3VzZShwb2ludDIsIHBvaW50VHlwZSA9IFwicGFnZVwiKSB7XG4gIHJldHVybiB7XG4gICAgeDogcG9pbnQyW3BvaW50VHlwZSArIFwiWFwiXSxcbiAgICB5OiBwb2ludDJbcG9pbnRUeXBlICsgXCJZXCJdXG4gIH07XG59XG5mdW5jdGlvbiBleHRyYWN0RXZlbnRJbmZvKGV2ZW50LCBwb2ludFR5cGUgPSBcInBhZ2VcIikge1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBpc1RvdWNoRXZlbnQoZXZlbnQpID8gcG9pbnRGcm9tVG91Y2goZXZlbnQsIHBvaW50VHlwZSkgOiBwb2ludEZyb21Nb3VzZShldmVudCwgcG9pbnRUeXBlKVxuICB9O1xufVxudmFyIHdyYXBIYW5kbGVyID0gKGhhbmRsZXIsIHNob3VsZEZpbHRlclByaW1hcnlQb2ludGVyID0gZmFsc2UpID0+IHtcbiAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IGhhbmRsZXIoZXZlbnQsIGV4dHJhY3RFdmVudEluZm8oZXZlbnQpKTtcbiAgcmV0dXJuIHNob3VsZEZpbHRlclByaW1hcnlQb2ludGVyID8gZmlsdGVyUHJpbWFyeVBvaW50ZXIobGlzdGVuZXIpIDogbGlzdGVuZXI7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy91dGlscy5tanNcbnZhciBzdXBwb3J0c1BvaW50ZXJFdmVudHMgPSAoKSA9PiBpc0Jyb3dzZXIgJiYgd2luZG93Lm9ucG9pbnRlcmRvd24gPT09IG51bGw7XG52YXIgc3VwcG9ydHNUb3VjaEV2ZW50cyA9ICgpID0+IGlzQnJvd3NlciAmJiB3aW5kb3cub250b3VjaHN0YXJ0ID09PSBudWxsO1xudmFyIHN1cHBvcnRzTW91c2VFdmVudHMgPSAoKSA9PiBpc0Jyb3dzZXIgJiYgd2luZG93Lm9ubW91c2Vkb3duID09PSBudWxsO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy91c2UtcG9pbnRlci1ldmVudC5tanNcbnZhciBtb3VzZUV2ZW50TmFtZXMgPSB7XG4gIHBvaW50ZXJkb3duOiBcIm1vdXNlZG93blwiLFxuICBwb2ludGVybW92ZTogXCJtb3VzZW1vdmVcIixcbiAgcG9pbnRlcnVwOiBcIm1vdXNldXBcIixcbiAgcG9pbnRlcmNhbmNlbDogXCJtb3VzZWNhbmNlbFwiLFxuICBwb2ludGVyb3ZlcjogXCJtb3VzZW92ZXJcIixcbiAgcG9pbnRlcm91dDogXCJtb3VzZW91dFwiLFxuICBwb2ludGVyZW50ZXI6IFwibW91c2VlbnRlclwiLFxuICBwb2ludGVybGVhdmU6IFwibW91c2VsZWF2ZVwiXG59O1xudmFyIHRvdWNoRXZlbnROYW1lcyA9IHtcbiAgcG9pbnRlcmRvd246IFwidG91Y2hzdGFydFwiLFxuICBwb2ludGVybW92ZTogXCJ0b3VjaG1vdmVcIixcbiAgcG9pbnRlcnVwOiBcInRvdWNoZW5kXCIsXG4gIHBvaW50ZXJjYW5jZWw6IFwidG91Y2hjYW5jZWxcIlxufTtcbmZ1bmN0aW9uIGdldFBvaW50ZXJFdmVudE5hbWUobmFtZSkge1xuICBpZiAoc3VwcG9ydHNQb2ludGVyRXZlbnRzKCkpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfSBlbHNlIGlmIChzdXBwb3J0c1RvdWNoRXZlbnRzKCkpIHtcbiAgICByZXR1cm4gdG91Y2hFdmVudE5hbWVzW25hbWVdO1xuICB9IGVsc2UgaWYgKHN1cHBvcnRzTW91c2VFdmVudHMoKSkge1xuICAgIHJldHVybiBtb3VzZUV2ZW50TmFtZXNbbmFtZV07XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBhZGRQb2ludGVyRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGFkZERvbUV2ZW50KHRhcmdldCwgZ2V0UG9pbnRlckV2ZW50TmFtZShldmVudE5hbWUpLCB3cmFwSGFuZGxlcihoYW5kbGVyLCBldmVudE5hbWUgPT09IFwicG9pbnRlcmRvd25cIiksIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdXNlUG9pbnRlckV2ZW50KHJlZiwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiB1c2VEb21FdmVudChyZWYsIGdldFBvaW50ZXJFdmVudE5hbWUoZXZlbnROYW1lKSwgaGFuZGxlciAmJiB3cmFwSGFuZGxlcihoYW5kbGVyLCBldmVudE5hbWUgPT09IFwicG9pbnRlcmRvd25cIiksIG9wdGlvbnMpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2RyYWcvdXRpbHMvbG9jay5tanNcbmZ1bmN0aW9uIGNyZWF0ZUxvY2sobmFtZSkge1xuICBsZXQgbG9jayA9IG51bGw7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3Qgb3BlbkxvY2sgPSAoKSA9PiB7XG4gICAgICBsb2NrID0gbnVsbDtcbiAgICB9O1xuICAgIGlmIChsb2NrID09PSBudWxsKSB7XG4gICAgICBsb2NrID0gbmFtZTtcbiAgICAgIHJldHVybiBvcGVuTG9jaztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxudmFyIGdsb2JhbEhvcml6b250YWxMb2NrID0gY3JlYXRlTG9jayhcImRyYWdIb3Jpem9udGFsXCIpO1xudmFyIGdsb2JhbFZlcnRpY2FsTG9jayA9IGNyZWF0ZUxvY2soXCJkcmFnVmVydGljYWxcIik7XG5mdW5jdGlvbiBnZXRHbG9iYWxMb2NrKGRyYWcyKSB7XG4gIGxldCBsb2NrID0gZmFsc2U7XG4gIGlmIChkcmFnMiA9PT0gXCJ5XCIpIHtcbiAgICBsb2NrID0gZ2xvYmFsVmVydGljYWxMb2NrKCk7XG4gIH0gZWxzZSBpZiAoZHJhZzIgPT09IFwieFwiKSB7XG4gICAgbG9jayA9IGdsb2JhbEhvcml6b250YWxMb2NrKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb3Blbkhvcml6b250YWwgPSBnbG9iYWxIb3Jpem9udGFsTG9jaygpO1xuICAgIGNvbnN0IG9wZW5WZXJ0aWNhbCA9IGdsb2JhbFZlcnRpY2FsTG9jaygpO1xuICAgIGlmIChvcGVuSG9yaXpvbnRhbCAmJiBvcGVuVmVydGljYWwpIHtcbiAgICAgIGxvY2sgPSAoKSA9PiB7XG4gICAgICAgIG9wZW5Ib3Jpem9udGFsKCk7XG4gICAgICAgIG9wZW5WZXJ0aWNhbCgpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wZW5Ib3Jpem9udGFsKVxuICAgICAgICBvcGVuSG9yaXpvbnRhbCgpO1xuICAgICAgaWYgKG9wZW5WZXJ0aWNhbClcbiAgICAgICAgb3BlblZlcnRpY2FsKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsb2NrO1xufVxuZnVuY3Rpb24gaXNEcmFnQWN0aXZlKCkge1xuICBjb25zdCBvcGVuR2VzdHVyZUxvY2sgPSBnZXRHbG9iYWxMb2NrKHRydWUpO1xuICBpZiAoIW9wZW5HZXN0dXJlTG9jaylcbiAgICByZXR1cm4gdHJ1ZTtcbiAgb3Blbkdlc3R1cmVMb2NrKCk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy91c2UtaG92ZXItZ2VzdHVyZS5tanNcbmZ1bmN0aW9uIGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudCwgaXNBY3RpdmUsIGNhbGxiYWNrKSB7XG4gIHJldHVybiAoZXZlbnQsIGluZm8pID0+IHtcbiAgICBpZiAoIWlzTW91c2VFdmVudChldmVudCkgfHwgaXNEcmFnQWN0aXZlKCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuSG92ZXIsIGlzQWN0aXZlKTtcbiAgICB9XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZXZlbnQsIGluZm8pO1xuICB9O1xufVxuZnVuY3Rpb24gdXNlSG92ZXJHZXN0dXJlKHsgb25Ib3ZlclN0YXJ0LCBvbkhvdmVyRW5kLCB3aGlsZUhvdmVyLCB2aXN1YWxFbGVtZW50IH0pIHtcbiAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmVudGVyXCIsIG9uSG92ZXJTdGFydCB8fCB3aGlsZUhvdmVyID8gY3JlYXRlSG92ZXJFdmVudCh2aXN1YWxFbGVtZW50LCB0cnVlLCBvbkhvdmVyU3RhcnQpIDogdm9pZCAwLCB7IHBhc3NpdmU6ICFvbkhvdmVyU3RhcnQgfSk7XG4gIHVzZVBvaW50ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBcInBvaW50ZXJsZWF2ZVwiLCBvbkhvdmVyRW5kIHx8IHdoaWxlSG92ZXIgPyBjcmVhdGVIb3ZlckV2ZW50KHZpc3VhbEVsZW1lbnQsIGZhbHNlLCBvbkhvdmVyRW5kKSA6IHZvaWQgMCwgeyBwYXNzaXZlOiAhb25Ib3ZlckVuZCB9KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy91c2UtdGFwLWdlc3R1cmUubWpzXG5pbXBvcnQgeyB1c2VSZWYgYXMgdXNlUmVmMyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3V0aWxzL2lzLW5vZGUtb3ItY2hpbGQubWpzXG52YXIgaXNOb2RlT3JDaGlsZCA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIGlmICghY2hpbGQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAocGFyZW50ID09PSBjaGlsZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpc05vZGVPckNoaWxkKHBhcmVudCwgY2hpbGQucGFyZW50RWxlbWVudCk7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLXVubW91bnQtZWZmZWN0Lm1qc1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDQgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVVubW91bnRFZmZlY3QoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHVzZUVmZmVjdDQoKCkgPT4gKCkgPT4gY2FsbGJhY2soKSwgW10pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL25vZGVfbW9kdWxlcy90c2xpYi9tb2R1bGVzL2luZGV4LmpzXG52YXIgaW1wb3J0X3RzbGliID0gX190b0VTTShyZXF1aXJlX3RzbGliKCksIDEpO1xudmFyIHtcbiAgX19leHRlbmRzLFxuICBfX2Fzc2lnbixcbiAgX19yZXN0LFxuICBfX2RlY29yYXRlLFxuICBfX3BhcmFtLFxuICBfX21ldGFkYXRhLFxuICBfX2F3YWl0ZXIsXG4gIF9fZ2VuZXJhdG9yLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fY3JlYXRlQmluZGluZyxcbiAgX192YWx1ZXMsXG4gIF9fcmVhZCxcbiAgX19zcHJlYWQsXG4gIF9fc3ByZWFkQXJyYXlzLFxuICBfX3NwcmVhZEFycmF5LFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yLFxuICBfX2FzeW5jRGVsZWdhdG9yLFxuICBfX2FzeW5jVmFsdWVzLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgX19pbXBvcnRTdGFyLFxuICBfX2ltcG9ydERlZmF1bHQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJblxufSA9IGltcG9ydF90c2xpYi5kZWZhdWx0O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvaGV5LWxpc3Rlbi9kaXN0L2hleS1saXN0ZW4uZXMuanNcbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7XG59O1xudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKCkge1xufTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjaGVjayAmJiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbiAgaW52YXJpYW50ID0gZnVuY3Rpb24oY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvY2xhbXAubWpzXG52YXIgY2xhbXAyID0gKG1pbiwgbWF4LCB2KSA9PiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy91dGlscy9maW5kLXNwcmluZy5tanNcbnZhciBzYWZlTWluID0gMWUtMztcbnZhciBtaW5EdXJhdGlvbiA9IDAuMDE7XG52YXIgbWF4RHVyYXRpb24gPSAxMDtcbnZhciBtaW5EYW1waW5nID0gMC4wNTtcbnZhciBtYXhEYW1waW5nID0gMTtcbmZ1bmN0aW9uIGZpbmRTcHJpbmcoeyBkdXJhdGlvbiA9IDgwMCwgYm91bmNlID0gMC4yNSwgdmVsb2NpdHkgPSAwLCBtYXNzID0gMSB9KSB7XG4gIGxldCBlbnZlbG9wZTtcbiAgbGV0IGRlcml2YXRpdmU7XG4gIHdhcm5pbmcoZHVyYXRpb24gPD0gbWF4RHVyYXRpb24gKiAxZTMsIFwiU3ByaW5nIGR1cmF0aW9uIG11c3QgYmUgMTAgc2Vjb25kcyBvciBsZXNzXCIpO1xuICBsZXQgZGFtcGluZ1JhdGlvID0gMSAtIGJvdW5jZTtcbiAgZGFtcGluZ1JhdGlvID0gY2xhbXAyKG1pbkRhbXBpbmcsIG1heERhbXBpbmcsIGRhbXBpbmdSYXRpbyk7XG4gIGR1cmF0aW9uID0gY2xhbXAyKG1pbkR1cmF0aW9uLCBtYXhEdXJhdGlvbiwgZHVyYXRpb24gLyAxZTMpO1xuICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgIGVudmVsb3BlID0gKHVuZGFtcGVkRnJlcTIpID0+IHtcbiAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVjYXkgPSB1bmRhbXBlZEZyZXEyICogZGFtcGluZ1JhdGlvO1xuICAgICAgY29uc3QgZGVsdGEgPSBleHBvbmVudGlhbERlY2F5ICogZHVyYXRpb247XG4gICAgICBjb25zdCBhMiA9IGV4cG9uZW50aWFsRGVjYXkgLSB2ZWxvY2l0eTtcbiAgICAgIGNvbnN0IGIyID0gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcTIsIGRhbXBpbmdSYXRpbyk7XG4gICAgICBjb25zdCBjMyA9IE1hdGguZXhwKC1kZWx0YSk7XG4gICAgICByZXR1cm4gc2FmZU1pbiAtIGEyIC8gYjIgKiBjMztcbiAgICB9O1xuICAgIGRlcml2YXRpdmUgPSAodW5kYW1wZWRGcmVxMikgPT4ge1xuICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWNheSA9IHVuZGFtcGVkRnJlcTIgKiBkYW1waW5nUmF0aW87XG4gICAgICBjb25zdCBkZWx0YSA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgIGNvbnN0IGQyID0gZGVsdGEgKiB2ZWxvY2l0eSArIHZlbG9jaXR5O1xuICAgICAgY29uc3QgZSA9IE1hdGgucG93KGRhbXBpbmdSYXRpbywgMikgKiBNYXRoLnBvdyh1bmRhbXBlZEZyZXEyLCAyKSAqIGR1cmF0aW9uO1xuICAgICAgY29uc3QgZjIgPSBNYXRoLmV4cCgtZGVsdGEpO1xuICAgICAgY29uc3QgZzIgPSBjYWxjQW5ndWxhckZyZXEoTWF0aC5wb3codW5kYW1wZWRGcmVxMiwgMiksIGRhbXBpbmdSYXRpbyk7XG4gICAgICBjb25zdCBmYWN0b3IgPSAtZW52ZWxvcGUodW5kYW1wZWRGcmVxMikgKyBzYWZlTWluID4gMCA/IC0xIDogMTtcbiAgICAgIHJldHVybiBmYWN0b3IgKiAoKGQyIC0gZSkgKiBmMikgLyBnMjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGVudmVsb3BlID0gKHVuZGFtcGVkRnJlcTIpID0+IHtcbiAgICAgIGNvbnN0IGEyID0gTWF0aC5leHAoLXVuZGFtcGVkRnJlcTIgKiBkdXJhdGlvbik7XG4gICAgICBjb25zdCBiMiA9ICh1bmRhbXBlZEZyZXEyIC0gdmVsb2NpdHkpICogZHVyYXRpb24gKyAxO1xuICAgICAgcmV0dXJuIC1zYWZlTWluICsgYTIgKiBiMjtcbiAgICB9O1xuICAgIGRlcml2YXRpdmUgPSAodW5kYW1wZWRGcmVxMikgPT4ge1xuICAgICAgY29uc3QgYTIgPSBNYXRoLmV4cCgtdW5kYW1wZWRGcmVxMiAqIGR1cmF0aW9uKTtcbiAgICAgIGNvbnN0IGIyID0gKHZlbG9jaXR5IC0gdW5kYW1wZWRGcmVxMikgKiAoZHVyYXRpb24gKiBkdXJhdGlvbik7XG4gICAgICByZXR1cm4gYTIgKiBiMjtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGluaXRpYWxHdWVzcyA9IDUgLyBkdXJhdGlvbjtcbiAgY29uc3QgdW5kYW1wZWRGcmVxID0gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpO1xuICBkdXJhdGlvbiA9IGR1cmF0aW9uICogMWUzO1xuICBpZiAoaXNOYU4odW5kYW1wZWRGcmVxKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGlmZm5lc3M6IDEwMCxcbiAgICAgIGRhbXBpbmc6IDEwLFxuICAgICAgZHVyYXRpb25cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0aWZmbmVzcyA9IE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMikgKiBtYXNzO1xuICAgIHJldHVybiB7XG4gICAgICBzdGlmZm5lc3MsXG4gICAgICBkYW1waW5nOiBkYW1waW5nUmF0aW8gKiAyICogTWF0aC5zcXJ0KG1hc3MgKiBzdGlmZm5lc3MpLFxuICAgICAgZHVyYXRpb25cbiAgICB9O1xuICB9XG59XG52YXIgcm9vdEl0ZXJhdGlvbnMgPSAxMjtcbmZ1bmN0aW9uIGFwcHJveGltYXRlUm9vdChlbnZlbG9wZSwgZGVyaXZhdGl2ZSwgaW5pdGlhbEd1ZXNzKSB7XG4gIGxldCByZXN1bHQgPSBpbml0aWFsR3Vlc3M7XG4gIGZvciAobGV0IGkyID0gMTsgaTIgPCByb290SXRlcmF0aW9uczsgaTIrKykge1xuICAgIHJlc3VsdCA9IHJlc3VsdCAtIGVudmVsb3BlKHJlc3VsdCkgLyBkZXJpdmF0aXZlKHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhbGNBbmd1bGFyRnJlcSh1bmRhbXBlZEZyZXEsIGRhbXBpbmdSYXRpbykge1xuICByZXR1cm4gdW5kYW1wZWRGcmVxICogTWF0aC5zcXJ0KDEgLSBkYW1waW5nUmF0aW8gKiBkYW1waW5nUmF0aW8pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy9nZW5lcmF0b3JzL3NwcmluZy5tanNcbnZhciBkdXJhdGlvbktleXMgPSBbXCJkdXJhdGlvblwiLCBcImJvdW5jZVwiXTtcbnZhciBwaHlzaWNzS2V5cyA9IFtcInN0aWZmbmVzc1wiLCBcImRhbXBpbmdcIiwgXCJtYXNzXCJdO1xuZnVuY3Rpb24gaXNTcHJpbmdUeXBlKG9wdGlvbnMsIGtleXMyKSB7XG4gIHJldHVybiBrZXlzMi5zb21lKChrZXkpID0+IG9wdGlvbnNba2V5XSAhPT0gdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIGdldFNwcmluZ09wdGlvbnMob3B0aW9ucykge1xuICBsZXQgc3ByaW5nT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB2ZWxvY2l0eTogMCwgc3RpZmZuZXNzOiAxMDAsIGRhbXBpbmc6IDEwLCBtYXNzOiAxLCBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgaWYgKCFpc1NwcmluZ1R5cGUob3B0aW9ucywgcGh5c2ljc0tleXMpICYmIGlzU3ByaW5nVHlwZShvcHRpb25zLCBkdXJhdGlvbktleXMpKSB7XG4gICAgY29uc3QgZGVyaXZlZCA9IGZpbmRTcHJpbmcob3B0aW9ucyk7XG4gICAgc3ByaW5nT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzcHJpbmdPcHRpb25zKSwgZGVyaXZlZCksIHsgdmVsb2NpdHk6IDAsIG1hc3M6IDEgfSk7XG4gICAgc3ByaW5nT3B0aW9ucy5pc1Jlc29sdmVkRnJvbUR1cmF0aW9uID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gc3ByaW5nT3B0aW9ucztcbn1cbmZ1bmN0aW9uIHNwcmluZyhfYSkge1xuICB2YXIgeyBmcm9tID0gMCwgdG8gPSAxLCByZXN0U3BlZWQgPSAyLCByZXN0RGVsdGEgfSA9IF9hLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJmcm9tXCIsIFwidG9cIiwgXCJyZXN0U3BlZWRcIiwgXCJyZXN0RGVsdGFcIl0pO1xuICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmcm9tIH07XG4gIGxldCB7IHN0aWZmbmVzcywgZGFtcGluZywgbWFzcywgdmVsb2NpdHksIGR1cmF0aW9uLCBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uIH0gPSBnZXRTcHJpbmdPcHRpb25zKG9wdGlvbnMpO1xuICBsZXQgcmVzb2x2ZVNwcmluZyA9IHplcm87XG4gIGxldCByZXNvbHZlVmVsb2NpdHkgPSB6ZXJvO1xuICBmdW5jdGlvbiBjcmVhdGVTcHJpbmcoKSB7XG4gICAgY29uc3QgaW5pdGlhbFZlbG9jaXR5ID0gdmVsb2NpdHkgPyAtKHZlbG9jaXR5IC8gMWUzKSA6IDA7XG4gICAgY29uc3QgaW5pdGlhbERlbHRhID0gdG8gLSBmcm9tO1xuICAgIGNvbnN0IGRhbXBpbmdSYXRpbyA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gICAgY29uc3QgdW5kYW1wZWRBbmd1bGFyRnJlcSA9IE1hdGguc3FydChzdGlmZm5lc3MgLyBtYXNzKSAvIDFlMztcbiAgICBpZiAocmVzdERlbHRhID09PSB2b2lkIDApIHtcbiAgICAgIHJlc3REZWx0YSA9IE1hdGgubWluKE1hdGguYWJzKHRvIC0gZnJvbSkgLyAxMDAsIDAuNCk7XG4gICAgfVxuICAgIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgICBjb25zdCBhbmd1bGFyRnJlcSA9IGNhbGNBbmd1bGFyRnJlcSh1bmRhbXBlZEFuZ3VsYXJGcmVxLCBkYW1waW5nUmF0aW8pO1xuICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgcmV0dXJuIHRvIC0gZW52ZWxvcGUgKiAoKGluaXRpYWxWZWxvY2l0eSArIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpIC8gYW5ndWxhckZyZXEgKiBNYXRoLnNpbihhbmd1bGFyRnJlcSAqIHQpICsgaW5pdGlhbERlbHRhICogTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSk7XG4gICAgICB9O1xuICAgICAgcmVzb2x2ZVZlbG9jaXR5ID0gKHQpID0+IHtcbiAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICByZXR1cm4gZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGVudmVsb3BlICogKE1hdGguc2luKGFuZ3VsYXJGcmVxICogdCkgKiAoaW5pdGlhbFZlbG9jaXR5ICsgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgLyBhbmd1bGFyRnJlcSArIGluaXRpYWxEZWx0YSAqIE1hdGguY29zKGFuZ3VsYXJGcmVxICogdCkpIC0gZW52ZWxvcGUgKiAoTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSAqIChpbml0aWFsVmVsb2NpdHkgKyBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAtIGFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhICogTWF0aC5zaW4oYW5ndWxhckZyZXEgKiB0KSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGFtcGluZ1JhdGlvID09PSAxKSB7XG4gICAgICByZXNvbHZlU3ByaW5nID0gKHQpID0+IHRvIC0gTWF0aC5leHAoLXVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KSAqIChpbml0aWFsRGVsdGEgKyAoaW5pdGlhbFZlbG9jaXR5ICsgdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgKiB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGFtcGVkQW5ndWxhckZyZXEgPSB1bmRhbXBlZEFuZ3VsYXJGcmVxICogTWF0aC5zcXJ0KGRhbXBpbmdSYXRpbyAqIGRhbXBpbmdSYXRpbyAtIDEpO1xuICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgY29uc3QgZnJlcUZvclQgPSBNYXRoLm1pbihkYW1wZWRBbmd1bGFyRnJlcSAqIHQsIDMwMCk7XG4gICAgICAgIHJldHVybiB0byAtIGVudmVsb3BlICogKChpbml0aWFsVmVsb2NpdHkgKyBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAqIE1hdGguc2luaChmcmVxRm9yVCkgKyBkYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSAqIE1hdGguY29zaChmcmVxRm9yVCkpIC8gZGFtcGVkQW5ndWxhckZyZXE7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBjcmVhdGVTcHJpbmcoKTtcbiAgcmV0dXJuIHtcbiAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IHJlc29sdmVTcHJpbmcodCk7XG4gICAgICBpZiAoIWlzUmVzb2x2ZWRGcm9tRHVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgY3VycmVudFZlbG9jaXR5ID0gcmVzb2x2ZVZlbG9jaXR5KHQpICogMWUzO1xuICAgICAgICBjb25zdCBpc0JlbG93VmVsb2NpdHlUaHJlc2hvbGQgPSBNYXRoLmFicyhjdXJyZW50VmVsb2NpdHkpIDw9IHJlc3RTcGVlZDtcbiAgICAgICAgY29uc3QgaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZCA9IE1hdGguYWJzKHRvIC0gY3VycmVudCkgPD0gcmVzdERlbHRhO1xuICAgICAgICBzdGF0ZS5kb25lID0gaXNCZWxvd1ZlbG9jaXR5VGhyZXNob2xkICYmIGlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5kb25lID0gdCA+PSBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnZhbHVlID0gc3RhdGUuZG9uZSA/IHRvIDogY3VycmVudDtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGZsaXBUYXJnZXQ6ICgpID0+IHtcbiAgICAgIHZlbG9jaXR5ID0gLXZlbG9jaXR5O1xuICAgICAgW2Zyb20sIHRvXSA9IFt0bywgZnJvbV07XG4gICAgICBjcmVhdGVTcHJpbmcoKTtcbiAgICB9XG4gIH07XG59XG5zcHJpbmcubmVlZHNJbnRlcnBvbGF0aW9uID0gKGEyLCBiMikgPT4gdHlwZW9mIGEyID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBiMiA9PT0gXCJzdHJpbmdcIjtcbnZhciB6ZXJvID0gKF90KSA9PiAwO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvcHJvZ3Jlc3MubWpzXG52YXIgcHJvZ3Jlc3MgPSAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gIGNvbnN0IHRvRnJvbURpZmZlcmVuY2UgPSB0byAtIGZyb207XG4gIHJldHVybiB0b0Zyb21EaWZmZXJlbmNlID09PSAwID8gMSA6ICh2YWx1ZSAtIGZyb20pIC8gdG9Gcm9tRGlmZmVyZW5jZTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9taXgubWpzXG52YXIgbWl4ID0gKGZyb20sIHRvLCBwcm9ncmVzczMpID0+IC1wcm9ncmVzczMgKiBmcm9tICsgcHJvZ3Jlc3MzICogdG8gKyBmcm9tO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaHNsYS10by1yZ2JhLm1qc1xuZnVuY3Rpb24gaHVlVG9SZ2IocDIsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKVxuICAgIHQgKz0gMTtcbiAgaWYgKHQgPiAxKVxuICAgIHQgLT0gMTtcbiAgaWYgKHQgPCAxIC8gNilcbiAgICByZXR1cm4gcDIgKyAocSAtIHAyKSAqIDYgKiB0O1xuICBpZiAodCA8IDEgLyAyKVxuICAgIHJldHVybiBxO1xuICBpZiAodCA8IDIgLyAzKVxuICAgIHJldHVybiBwMiArIChxIC0gcDIpICogKDIgLyAzIC0gdCkgKiA2O1xuICByZXR1cm4gcDI7XG59XG5mdW5jdGlvbiBoc2xhVG9SZ2JhKHsgaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhOiBhbHBoYTIgfSkge1xuICBodWUgLz0gMzYwO1xuICBzYXR1cmF0aW9uIC89IDEwMDtcbiAgbGlnaHRuZXNzIC89IDEwMDtcbiAgbGV0IHJlZCA9IDA7XG4gIGxldCBncmVlbiA9IDA7XG4gIGxldCBibHVlID0gMDtcbiAgaWYgKCFzYXR1cmF0aW9uKSB7XG4gICAgcmVkID0gZ3JlZW4gPSBibHVlID0gbGlnaHRuZXNzO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHEgPSBsaWdodG5lc3MgPCAwLjUgPyBsaWdodG5lc3MgKiAoMSArIHNhdHVyYXRpb24pIDogbGlnaHRuZXNzICsgc2F0dXJhdGlvbiAtIGxpZ2h0bmVzcyAqIHNhdHVyYXRpb247XG4gICAgY29uc3QgcDIgPSAyICogbGlnaHRuZXNzIC0gcTtcbiAgICByZWQgPSBodWVUb1JnYihwMiwgcSwgaHVlICsgMSAvIDMpO1xuICAgIGdyZWVuID0gaHVlVG9SZ2IocDIsIHEsIGh1ZSk7XG4gICAgYmx1ZSA9IGh1ZVRvUmdiKHAyLCBxLCBodWUgLSAxIC8gMyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZWQ6IE1hdGgucm91bmQocmVkICogMjU1KSxcbiAgICBncmVlbjogTWF0aC5yb3VuZChncmVlbiAqIDI1NSksXG4gICAgYmx1ZTogTWF0aC5yb3VuZChibHVlICogMjU1KSxcbiAgICBhbHBoYTogYWxwaGEyXG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9taXgtY29sb3IubWpzXG52YXIgbWl4TGluZWFyQ29sb3IgPSAoZnJvbSwgdG8sIHYpID0+IHtcbiAgY29uc3QgZnJvbUV4cG8gPSBmcm9tICogZnJvbTtcbiAgY29uc3QgdG9FeHBvID0gdG8gKiB0bztcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLm1heCgwLCB2ICogKHRvRXhwbyAtIGZyb21FeHBvKSArIGZyb21FeHBvKSk7XG59O1xudmFyIGNvbG9yVHlwZXMgPSBbaGV4LCByZ2JhLCBoc2xhXTtcbnZhciBnZXRDb2xvclR5cGUgPSAodikgPT4gY29sb3JUeXBlcy5maW5kKCh0eXBlKSA9PiB0eXBlLnRlc3QodikpO1xudmFyIG5vdEFuaW1hdGFibGUgPSAoY29sb3IyKSA9PiBgJyR7Y29sb3IyfScgaXMgbm90IGFuIGFuaW1hdGFibGUgY29sb3IuIFVzZSB0aGUgZXF1aXZhbGVudCBjb2xvciBjb2RlIGluc3RlYWQuYDtcbnZhciBtaXhDb2xvciA9IChmcm9tLCB0bykgPT4ge1xuICBsZXQgZnJvbUNvbG9yVHlwZSA9IGdldENvbG9yVHlwZShmcm9tKTtcbiAgbGV0IHRvQ29sb3JUeXBlID0gZ2V0Q29sb3JUeXBlKHRvKTtcbiAgaW52YXJpYW50KCEhZnJvbUNvbG9yVHlwZSwgbm90QW5pbWF0YWJsZShmcm9tKSk7XG4gIGludmFyaWFudCghIXRvQ29sb3JUeXBlLCBub3RBbmltYXRhYmxlKHRvKSk7XG4gIGxldCBmcm9tQ29sb3IgPSBmcm9tQ29sb3JUeXBlLnBhcnNlKGZyb20pO1xuICBsZXQgdG9Db2xvciA9IHRvQ29sb3JUeXBlLnBhcnNlKHRvKTtcbiAgaWYgKGZyb21Db2xvclR5cGUgPT09IGhzbGEpIHtcbiAgICBmcm9tQ29sb3IgPSBoc2xhVG9SZ2JhKGZyb21Db2xvcik7XG4gICAgZnJvbUNvbG9yVHlwZSA9IHJnYmE7XG4gIH1cbiAgaWYgKHRvQ29sb3JUeXBlID09PSBoc2xhKSB7XG4gICAgdG9Db2xvciA9IGhzbGFUb1JnYmEodG9Db2xvcik7XG4gICAgdG9Db2xvclR5cGUgPSByZ2JhO1xuICB9XG4gIGNvbnN0IGJsZW5kZWQgPSBPYmplY3QuYXNzaWduKHt9LCBmcm9tQ29sb3IpO1xuICByZXR1cm4gKHYpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBibGVuZGVkKSB7XG4gICAgICBpZiAoa2V5ICE9PSBcImFscGhhXCIpIHtcbiAgICAgICAgYmxlbmRlZFtrZXldID0gbWl4TGluZWFyQ29sb3IoZnJvbUNvbG9yW2tleV0sIHRvQ29sb3Jba2V5XSwgdik7XG4gICAgICB9XG4gICAgfVxuICAgIGJsZW5kZWQuYWxwaGEgPSBtaXgoZnJvbUNvbG9yLmFscGhhLCB0b0NvbG9yLmFscGhhLCB2KTtcbiAgICByZXR1cm4gZnJvbUNvbG9yVHlwZS50cmFuc2Zvcm0oYmxlbmRlZCk7XG4gIH07XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaW5jLm1qc1xudmFyIGlzTnVtID0gKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvcGlwZS5tanNcbnZhciBjb21iaW5lRnVuY3Rpb25zID0gKGEyLCBiMikgPT4gKHYpID0+IGIyKGEyKHYpKTtcbnZhciBwaXBlID0gKC4uLnRyYW5zZm9ybWVycykgPT4gdHJhbnNmb3JtZXJzLnJlZHVjZShjb21iaW5lRnVuY3Rpb25zKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC1jb21wbGV4Lm1qc1xuZnVuY3Rpb24gZ2V0TWl4ZXIob3JpZ2luLCB0YXJnZXQpIHtcbiAgaWYgKGlzTnVtKG9yaWdpbikpIHtcbiAgICByZXR1cm4gKHYpID0+IG1peChvcmlnaW4sIHRhcmdldCwgdik7XG4gIH0gZWxzZSBpZiAoY29sb3IudGVzdChvcmlnaW4pKSB7XG4gICAgcmV0dXJuIG1peENvbG9yKG9yaWdpbiwgdGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWl4Q29tcGxleChvcmlnaW4sIHRhcmdldCk7XG4gIH1cbn1cbnZhciBtaXhBcnJheSA9IChmcm9tLCB0bykgPT4ge1xuICBjb25zdCBvdXRwdXQgPSBbLi4uZnJvbV07XG4gIGNvbnN0IG51bVZhbHVlcyA9IG91dHB1dC5sZW5ndGg7XG4gIGNvbnN0IGJsZW5kVmFsdWUgPSBmcm9tLm1hcCgoZnJvbVRoaXMsIGkyKSA9PiBnZXRNaXhlcihmcm9tVGhpcywgdG9baTJdKSk7XG4gIHJldHVybiAodikgPT4ge1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1WYWx1ZXM7IGkyKyspIHtcbiAgICAgIG91dHB1dFtpMl0gPSBibGVuZFZhbHVlW2kyXSh2KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn07XG52YXIgbWl4T2JqZWN0ID0gKG9yaWdpbiwgdGFyZ2V0KSA9PiB7XG4gIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luKSwgdGFyZ2V0KTtcbiAgY29uc3QgYmxlbmRWYWx1ZSA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvdXRwdXQpIHtcbiAgICBpZiAob3JpZ2luW2tleV0gIT09IHZvaWQgMCAmJiB0YXJnZXRba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICBibGVuZFZhbHVlW2tleV0gPSBnZXRNaXhlcihvcmlnaW5ba2V5XSwgdGFyZ2V0W2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKHYpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBibGVuZFZhbHVlKSB7XG4gICAgICBvdXRwdXRba2V5XSA9IGJsZW5kVmFsdWVba2V5XSh2KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn07XG5mdW5jdGlvbiBhbmFseXNlMih2YWx1ZSkge1xuICBjb25zdCBwYXJzZWQgPSBjb21wbGV4LnBhcnNlKHZhbHVlKTtcbiAgY29uc3QgbnVtVmFsdWVzID0gcGFyc2VkLmxlbmd0aDtcbiAgbGV0IG51bU51bWJlcnMgPSAwO1xuICBsZXQgbnVtUkdCID0gMDtcbiAgbGV0IG51bUhTTCA9IDA7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1WYWx1ZXM7IGkyKyspIHtcbiAgICBpZiAobnVtTnVtYmVycyB8fCB0eXBlb2YgcGFyc2VkW2kyXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbnVtTnVtYmVycysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyc2VkW2kyXS5odWUgIT09IHZvaWQgMCkge1xuICAgICAgICBudW1IU0wrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG51bVJHQisrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4geyBwYXJzZWQsIG51bU51bWJlcnMsIG51bVJHQiwgbnVtSFNMIH07XG59XG52YXIgbWl4Q29tcGxleCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICBjb25zdCB0ZW1wbGF0ZSA9IGNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIodGFyZ2V0KTtcbiAgY29uc3Qgb3JpZ2luU3RhdHMgPSBhbmFseXNlMihvcmlnaW4pO1xuICBjb25zdCB0YXJnZXRTdGF0cyA9IGFuYWx5c2UyKHRhcmdldCk7XG4gIGNvbnN0IGNhbkludGVycG9sYXRlID0gb3JpZ2luU3RhdHMubnVtSFNMID09PSB0YXJnZXRTdGF0cy5udW1IU0wgJiYgb3JpZ2luU3RhdHMubnVtUkdCID09PSB0YXJnZXRTdGF0cy5udW1SR0IgJiYgb3JpZ2luU3RhdHMubnVtTnVtYmVycyA+PSB0YXJnZXRTdGF0cy5udW1OdW1iZXJzO1xuICBpZiAoY2FuSW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gcGlwZShtaXhBcnJheShvcmlnaW5TdGF0cy5wYXJzZWQsIHRhcmdldFN0YXRzLnBhcnNlZCksIHRlbXBsYXRlKTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuaW5nKHRydWUsIGBDb21wbGV4IHZhbHVlcyAnJHtvcmlnaW59JyBhbmQgJyR7dGFyZ2V0fScgdG9vIGRpZmZlcmVudCB0byBtaXguIEVuc3VyZSBhbGwgY29sb3JzIGFyZSBvZiB0aGUgc2FtZSB0eXBlLCBhbmQgdGhhdCBlYWNoIGNvbnRhaW5zIHRoZSBzYW1lIHF1YW50aXR5IG9mIG51bWJlciBhbmQgY29sb3IgdmFsdWVzLiBGYWxsaW5nIGJhY2sgdG8gaW5zdGFudCB0cmFuc2l0aW9uLmApO1xuICAgIHJldHVybiAocDIpID0+IGAke3AyID4gMCA/IHRhcmdldCA6IG9yaWdpbn1gO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaW50ZXJwb2xhdGUubWpzXG52YXIgbWl4TnVtYmVyID0gKGZyb20sIHRvKSA9PiAocDIpID0+IG1peChmcm9tLCB0bywgcDIpO1xuZnVuY3Rpb24gZGV0ZWN0TWl4ZXJGYWN0b3J5KHYpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG1peE51bWJlcjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChjb2xvci50ZXN0KHYpKSB7XG4gICAgICByZXR1cm4gbWl4Q29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaXhDb21wbGV4O1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIG1peEFycmF5O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG1peE9iamVjdDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTWl4ZXJzKG91dHB1dCwgZWFzZSwgY3VzdG9tTWl4ZXIpIHtcbiAgY29uc3QgbWl4ZXJzID0gW107XG4gIGNvbnN0IG1peGVyRmFjdG9yeSA9IGN1c3RvbU1peGVyIHx8IGRldGVjdE1peGVyRmFjdG9yeShvdXRwdXRbMF0pO1xuICBjb25zdCBudW1NaXhlcnMgPSBvdXRwdXQubGVuZ3RoIC0gMTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bU1peGVyczsgaTIrKykge1xuICAgIGxldCBtaXhlciA9IG1peGVyRmFjdG9yeShvdXRwdXRbaTJdLCBvdXRwdXRbaTIgKyAxXSk7XG4gICAgaWYgKGVhc2UpIHtcbiAgICAgIGNvbnN0IGVhc2luZ0Z1bmN0aW9uID0gQXJyYXkuaXNBcnJheShlYXNlKSA/IGVhc2VbaTJdIDogZWFzZTtcbiAgICAgIG1peGVyID0gcGlwZShlYXNpbmdGdW5jdGlvbiwgbWl4ZXIpO1xuICAgIH1cbiAgICBtaXhlcnMucHVzaChtaXhlcik7XG4gIH1cbiAgcmV0dXJuIG1peGVycztcbn1cbmZ1bmN0aW9uIGZhc3RJbnRlcnBvbGF0ZShbZnJvbSwgdG9dLCBbbWl4ZXJdKSB7XG4gIHJldHVybiAodikgPT4gbWl4ZXIocHJvZ3Jlc3MoZnJvbSwgdG8sIHYpKTtcbn1cbmZ1bmN0aW9uIHNsb3dJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKSB7XG4gIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBjb25zdCBsYXN0SW5wdXRJbmRleCA9IGlucHV0TGVuZ3RoIC0gMTtcbiAgcmV0dXJuICh2KSA9PiB7XG4gICAgbGV0IG1peGVySW5kZXggPSAwO1xuICAgIGxldCBmb3VuZE1peGVySW5kZXggPSBmYWxzZTtcbiAgICBpZiAodiA8PSBpbnB1dFswXSkge1xuICAgICAgZm91bmRNaXhlckluZGV4ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gaW5wdXRbbGFzdElucHV0SW5kZXhdKSB7XG4gICAgICBtaXhlckluZGV4ID0gbGFzdElucHV0SW5kZXggLSAxO1xuICAgICAgZm91bmRNaXhlckluZGV4ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFmb3VuZE1peGVySW5kZXgpIHtcbiAgICAgIGxldCBpMiA9IDE7XG4gICAgICBmb3IgKDsgaTIgPCBpbnB1dExlbmd0aDsgaTIrKykge1xuICAgICAgICBpZiAoaW5wdXRbaTJdID4gdiB8fCBpMiA9PT0gbGFzdElucHV0SW5kZXgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWl4ZXJJbmRleCA9IGkyIC0gMTtcbiAgICB9XG4gICAgY29uc3QgcHJvZ3Jlc3NJblJhbmdlID0gcHJvZ3Jlc3MoaW5wdXRbbWl4ZXJJbmRleF0sIGlucHV0W21peGVySW5kZXggKyAxXSwgdik7XG4gICAgcmV0dXJuIG1peGVyc1ttaXhlckluZGV4XShwcm9ncmVzc0luUmFuZ2UpO1xuICB9O1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIG91dHB1dCwgeyBjbGFtcDogaXNDbGFtcCA9IHRydWUsIGVhc2UsIG1peGVyIH0gPSB7fSkge1xuICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgaW52YXJpYW50KGlucHV0TGVuZ3RoID09PSBvdXRwdXQubGVuZ3RoLCBcIkJvdGggaW5wdXQgYW5kIG91dHB1dCByYW5nZXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gIGludmFyaWFudCghZWFzZSB8fCAhQXJyYXkuaXNBcnJheShlYXNlKSB8fCBlYXNlLmxlbmd0aCA9PT0gaW5wdXRMZW5ndGggLSAxLCBcIkFycmF5IG9mIGVhc2luZyBmdW5jdGlvbnMgbXVzdCBiZSBvZiBsZW5ndGggYGlucHV0Lmxlbmd0aCAtIDFgLCBhcyBpdCBhcHBsaWVzIHRvIHRoZSB0cmFuc2l0aW9ucyAqKmJldHdlZW4qKiB0aGUgZGVmaW5lZCB2YWx1ZXMuXCIpO1xuICBpZiAoaW5wdXRbMF0gPiBpbnB1dFtpbnB1dExlbmd0aCAtIDFdKSB7XG4gICAgaW5wdXQgPSBbXS5jb25jYXQoaW5wdXQpO1xuICAgIG91dHB1dCA9IFtdLmNvbmNhdChvdXRwdXQpO1xuICAgIGlucHV0LnJldmVyc2UoKTtcbiAgICBvdXRwdXQucmV2ZXJzZSgpO1xuICB9XG4gIGNvbnN0IG1peGVycyA9IGNyZWF0ZU1peGVycyhvdXRwdXQsIGVhc2UsIG1peGVyKTtcbiAgY29uc3QgaW50ZXJwb2xhdG9yID0gaW5wdXRMZW5ndGggPT09IDIgPyBmYXN0SW50ZXJwb2xhdGUoaW5wdXQsIG1peGVycykgOiBzbG93SW50ZXJwb2xhdGUoaW5wdXQsIG1peGVycyk7XG4gIHJldHVybiBpc0NsYW1wID8gKHYpID0+IGludGVycG9sYXRvcihjbGFtcDIoaW5wdXRbMF0sIGlucHV0W2lucHV0TGVuZ3RoIC0gMV0sIHYpKSA6IGludGVycG9sYXRvcjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2Vhc2luZy91dGlscy5tanNcbnZhciByZXZlcnNlRWFzaW5nID0gKGVhc2luZykgPT4gKHAyKSA9PiAxIC0gZWFzaW5nKDEgLSBwMik7XG52YXIgbWlycm9yRWFzaW5nID0gKGVhc2luZykgPT4gKHAyKSA9PiBwMiA8PSAwLjUgPyBlYXNpbmcoMiAqIHAyKSAvIDIgOiAoMiAtIGVhc2luZygyICogKDEgLSBwMikpKSAvIDI7XG52YXIgY3JlYXRlRXhwb0luID0gKHBvd2VyKSA9PiAocDIpID0+IE1hdGgucG93KHAyLCBwb3dlcik7XG52YXIgY3JlYXRlQmFja0luID0gKHBvd2VyKSA9PiAocDIpID0+IHAyICogcDIgKiAoKHBvd2VyICsgMSkgKiBwMiAtIHBvd2VyKTtcbnZhciBjcmVhdGVBbnRpY2lwYXRlID0gKHBvd2VyKSA9PiB7XG4gIGNvbnN0IGJhY2tFYXNpbmcgPSBjcmVhdGVCYWNrSW4ocG93ZXIpO1xuICByZXR1cm4gKHAyKSA9PiAocDIgKj0gMikgPCAxID8gMC41ICogYmFja0Vhc2luZyhwMikgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwMiAtIDEpKSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvZWFzaW5nL2luZGV4Lm1qc1xudmFyIERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIID0gMS41MjU7XG52YXIgQk9VTkNFX0ZJUlNUX1RIUkVTSE9MRCA9IDQgLyAxMTtcbnZhciBCT1VOQ0VfU0VDT05EX1RIUkVTSE9MRCA9IDggLyAxMTtcbnZhciBCT1VOQ0VfVEhJUkRfVEhSRVNIT0xEID0gOSAvIDEwO1xudmFyIGxpbmVhciA9IChwMikgPT4gcDI7XG52YXIgZWFzZUluID0gY3JlYXRlRXhwb0luKDIpO1xudmFyIGVhc2VPdXQgPSByZXZlcnNlRWFzaW5nKGVhc2VJbik7XG52YXIgZWFzZUluT3V0ID0gbWlycm9yRWFzaW5nKGVhc2VJbik7XG52YXIgY2lyY0luID0gKHAyKSA9PiAxIC0gTWF0aC5zaW4oTWF0aC5hY29zKHAyKSk7XG52YXIgY2lyY091dCA9IHJldmVyc2VFYXNpbmcoY2lyY0luKTtcbnZhciBjaXJjSW5PdXQgPSBtaXJyb3JFYXNpbmcoY2lyY091dCk7XG52YXIgYmFja0luID0gY3JlYXRlQmFja0luKERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIKTtcbnZhciBiYWNrT3V0ID0gcmV2ZXJzZUVhc2luZyhiYWNrSW4pO1xudmFyIGJhY2tJbk91dCA9IG1pcnJvckVhc2luZyhiYWNrSW4pO1xudmFyIGFudGljaXBhdGUgPSBjcmVhdGVBbnRpY2lwYXRlKERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIKTtcbnZhciBjYSA9IDQzNTYgLyAzNjE7XG52YXIgY2IgPSAzNTQ0MiAvIDE4MDU7XG52YXIgY2MgPSAxNjA2MSAvIDE4MDU7XG52YXIgYm91bmNlT3V0ID0gKHAyKSA9PiB7XG4gIGlmIChwMiA9PT0gMSB8fCBwMiA9PT0gMClcbiAgICByZXR1cm4gcDI7XG4gIGNvbnN0IHAyMiA9IHAyICogcDI7XG4gIHJldHVybiBwMiA8IEJPVU5DRV9GSVJTVF9USFJFU0hPTEQgPyA3LjU2MjUgKiBwMjIgOiBwMiA8IEJPVU5DRV9TRUNPTkRfVEhSRVNIT0xEID8gOS4wNzUgKiBwMjIgLSA5LjkgKiBwMiArIDMuNCA6IHAyIDwgQk9VTkNFX1RISVJEX1RIUkVTSE9MRCA/IGNhICogcDIyIC0gY2IgKiBwMiArIGNjIDogMTAuOCAqIHAyICogcDIgLSAyMC41MiAqIHAyICsgMTAuNzI7XG59O1xudmFyIGJvdW5jZUluID0gcmV2ZXJzZUVhc2luZyhib3VuY2VPdXQpO1xudmFyIGJvdW5jZUluT3V0ID0gKHAyKSA9PiBwMiA8IDAuNSA/IDAuNSAqICgxIC0gYm91bmNlT3V0KDEgLSBwMiAqIDIpKSA6IDAuNSAqIGJvdW5jZU91dChwMiAqIDIgLSAxKSArIDAuNTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvZ2VuZXJhdG9ycy9rZXlmcmFtZXMubWpzXG5mdW5jdGlvbiBkZWZhdWx0RWFzaW5nKHZhbHVlcywgZWFzaW5nKSB7XG4gIHJldHVybiB2YWx1ZXMubWFwKCgpID0+IGVhc2luZyB8fCBlYXNlSW5PdXQpLnNwbGljZSgwLCB2YWx1ZXMubGVuZ3RoIC0gMSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T2Zmc2V0KHZhbHVlcykge1xuICBjb25zdCBudW1WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuICByZXR1cm4gdmFsdWVzLm1hcCgoX3ZhbHVlLCBpMikgPT4gaTIgIT09IDAgPyBpMiAvIChudW1WYWx1ZXMgLSAxKSA6IDApO1xufVxuZnVuY3Rpb24gY29udmVydE9mZnNldFRvVGltZXMob2Zmc2V0LCBkdXJhdGlvbikge1xuICByZXR1cm4gb2Zmc2V0Lm1hcCgobykgPT4gbyAqIGR1cmF0aW9uKTtcbn1cbmZ1bmN0aW9uIGtleWZyYW1lcyh7IGZyb20gPSAwLCB0byA9IDEsIGVhc2UsIG9mZnNldCwgZHVyYXRpb24gPSAzMDAgfSkge1xuICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmcm9tIH07XG4gIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodG8pID8gdG8gOiBbZnJvbSwgdG9dO1xuICBjb25zdCB0aW1lcyA9IGNvbnZlcnRPZmZzZXRUb1RpbWVzKG9mZnNldCAmJiBvZmZzZXQubGVuZ3RoID09PSB2YWx1ZXMubGVuZ3RoID8gb2Zmc2V0IDogZGVmYXVsdE9mZnNldCh2YWx1ZXMpLCBkdXJhdGlvbik7XG4gIGZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRvcigpIHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUodGltZXMsIHZhbHVlcywge1xuICAgICAgZWFzZTogQXJyYXkuaXNBcnJheShlYXNlKSA/IGVhc2UgOiBkZWZhdWx0RWFzaW5nKHZhbHVlcywgZWFzZSlcbiAgICB9KTtcbiAgfVxuICBsZXQgaW50ZXJwb2xhdG9yID0gY3JlYXRlSW50ZXJwb2xhdG9yKCk7XG4gIHJldHVybiB7XG4gICAgbmV4dDogKHQpID0+IHtcbiAgICAgIHN0YXRlLnZhbHVlID0gaW50ZXJwb2xhdG9yKHQpO1xuICAgICAgc3RhdGUuZG9uZSA9IHQgPj0gZHVyYXRpb247XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBmbGlwVGFyZ2V0OiAoKSA9PiB7XG4gICAgICB2YWx1ZXMucmV2ZXJzZSgpO1xuICAgICAgaW50ZXJwb2xhdG9yID0gY3JlYXRlSW50ZXJwb2xhdG9yKCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy9nZW5lcmF0b3JzL2RlY2F5Lm1qc1xuZnVuY3Rpb24gZGVjYXkoeyB2ZWxvY2l0eSA9IDAsIGZyb20gPSAwLCBwb3dlciA9IDAuOCwgdGltZUNvbnN0YW50ID0gMzUwLCByZXN0RGVsdGEgPSAwLjUsIG1vZGlmeVRhcmdldCB9KSB7XG4gIGNvbnN0IHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IGZyb20gfTtcbiAgbGV0IGFtcGxpdHVkZSA9IHBvd2VyICogdmVsb2NpdHk7XG4gIGNvbnN0IGlkZWFsID0gZnJvbSArIGFtcGxpdHVkZTtcbiAgY29uc3QgdGFyZ2V0ID0gbW9kaWZ5VGFyZ2V0ID09PSB2b2lkIDAgPyBpZGVhbCA6IG1vZGlmeVRhcmdldChpZGVhbCk7XG4gIGlmICh0YXJnZXQgIT09IGlkZWFsKVxuICAgIGFtcGxpdHVkZSA9IHRhcmdldCAtIGZyb207XG4gIHJldHVybiB7XG4gICAgbmV4dDogKHQpID0+IHtcbiAgICAgIGNvbnN0IGRlbHRhID0gLWFtcGxpdHVkZSAqIE1hdGguZXhwKC10IC8gdGltZUNvbnN0YW50KTtcbiAgICAgIHN0YXRlLmRvbmUgPSAhKGRlbHRhID4gcmVzdERlbHRhIHx8IGRlbHRhIDwgLXJlc3REZWx0YSk7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHN0YXRlLmRvbmUgPyB0YXJnZXQgOiB0YXJnZXQgKyBkZWx0YTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGZsaXBUYXJnZXQ6ICgpID0+IHtcbiAgICB9XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL3V0aWxzL2RldGVjdC1hbmltYXRpb24tZnJvbS1vcHRpb25zLm1qc1xudmFyIHR5cGVzID0geyBrZXlmcmFtZXMsIHNwcmluZywgZGVjYXkgfTtcbmZ1bmN0aW9uIGRldGVjdEFuaW1hdGlvbkZyb21PcHRpb25zKGNvbmZpZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcudG8pKSB7XG4gICAgcmV0dXJuIGtleWZyYW1lcztcbiAgfSBlbHNlIGlmICh0eXBlc1tjb25maWcudHlwZV0pIHtcbiAgICByZXR1cm4gdHlwZXNbY29uZmlnLnR5cGVdO1xuICB9XG4gIGNvbnN0IGtleXMyID0gbmV3IFNldChPYmplY3Qua2V5cyhjb25maWcpKTtcbiAgaWYgKGtleXMyLmhhcyhcImVhc2VcIikgfHwga2V5czIuaGFzKFwiZHVyYXRpb25cIikgJiYgIWtleXMyLmhhcyhcImRhbXBpbmdSYXRpb1wiKSkge1xuICAgIHJldHVybiBrZXlmcmFtZXM7XG4gIH0gZWxzZSBpZiAoa2V5czIuaGFzKFwiZGFtcGluZ1JhdGlvXCIpIHx8IGtleXMyLmhhcyhcInN0aWZmbmVzc1wiKSB8fCBrZXlzMi5oYXMoXCJtYXNzXCIpIHx8IGtleXMyLmhhcyhcImRhbXBpbmdcIikgfHwga2V5czIuaGFzKFwicmVzdFNwZWVkXCIpIHx8IGtleXMyLmhhcyhcInJlc3REZWx0YVwiKSkge1xuICAgIHJldHVybiBzcHJpbmc7XG4gIH1cbiAgcmV0dXJuIGtleWZyYW1lcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lc3luYy9kaXN0L2VzL29uLW5leHQtZnJhbWUubWpzXG52YXIgZGVmYXVsdFRpbWVzdGVwID0gMSAvIDYwICogMWUzO1xudmFyIGdldEN1cnJlbnRUaW1lID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSBcInVuZGVmaW5lZFwiID8gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCkgOiAoKSA9PiBEYXRlLm5vdygpO1xudmFyIG9uTmV4dEZyYW1lID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IChjYWxsYmFjaykgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykgOiAoY2FsbGJhY2spID0+IHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soZ2V0Q3VycmVudFRpbWUoKSksIGRlZmF1bHRUaW1lc3RlcCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXN5bmMvZGlzdC9lcy9jcmVhdGUtcmVuZGVyLXN0ZXAubWpzXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJTdGVwKHJ1bk5leHRGcmFtZTIpIHtcbiAgbGV0IHRvUnVuID0gW107XG4gIGxldCB0b1J1bk5leHRGcmFtZSA9IFtdO1xuICBsZXQgbnVtVG9SdW4gPSAwO1xuICBsZXQgaXNQcm9jZXNzaW5nMiA9IGZhbHNlO1xuICBsZXQgZmx1c2hOZXh0RnJhbWUgPSBmYWxzZTtcbiAgY29uc3QgdG9LZWVwQWxpdmUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgY29uc3Qgc3RlcCA9IHtcbiAgICBzY2hlZHVsZTogKGNhbGxiYWNrLCBrZWVwQWxpdmUgPSBmYWxzZSwgaW1tZWRpYXRlID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IGFkZFRvQ3VycmVudEZyYW1lID0gaW1tZWRpYXRlICYmIGlzUHJvY2Vzc2luZzI7XG4gICAgICBjb25zdCBidWZmZXIgPSBhZGRUb0N1cnJlbnRGcmFtZSA/IHRvUnVuIDogdG9SdW5OZXh0RnJhbWU7XG4gICAgICBpZiAoa2VlcEFsaXZlKVxuICAgICAgICB0b0tlZXBBbGl2ZS5hZGQoY2FsbGJhY2spO1xuICAgICAgaWYgKGJ1ZmZlci5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTEpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goY2FsbGJhY2spO1xuICAgICAgICBpZiAoYWRkVG9DdXJyZW50RnJhbWUgJiYgaXNQcm9jZXNzaW5nMilcbiAgICAgICAgICBudW1Ub1J1biA9IHRvUnVuLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9LFxuICAgIGNhbmNlbDogKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBpbmRleDIgPSB0b1J1bk5leHRGcmFtZS5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgIGlmIChpbmRleDIgIT09IC0xKVxuICAgICAgICB0b1J1bk5leHRGcmFtZS5zcGxpY2UoaW5kZXgyLCAxKTtcbiAgICAgIHRvS2VlcEFsaXZlLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfSxcbiAgICBwcm9jZXNzOiAoZnJhbWVEYXRhKSA9PiB7XG4gICAgICBpZiAoaXNQcm9jZXNzaW5nMikge1xuICAgICAgICBmbHVzaE5leHRGcmFtZSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlzUHJvY2Vzc2luZzIgPSB0cnVlO1xuICAgICAgW3RvUnVuLCB0b1J1bk5leHRGcmFtZV0gPSBbdG9SdW5OZXh0RnJhbWUsIHRvUnVuXTtcbiAgICAgIHRvUnVuTmV4dEZyYW1lLmxlbmd0aCA9IDA7XG4gICAgICBudW1Ub1J1biA9IHRvUnVuLmxlbmd0aDtcbiAgICAgIGlmIChudW1Ub1J1bikge1xuICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtVG9SdW47IGkyKyspIHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRvUnVuW2kyXTtcbiAgICAgICAgICBjYWxsYmFjayhmcmFtZURhdGEpO1xuICAgICAgICAgIGlmICh0b0tlZXBBbGl2ZS5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBzdGVwLnNjaGVkdWxlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJ1bk5leHRGcmFtZTIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzUHJvY2Vzc2luZzIgPSBmYWxzZTtcbiAgICAgIGlmIChmbHVzaE5leHRGcmFtZSkge1xuICAgICAgICBmbHVzaE5leHRGcmFtZSA9IGZhbHNlO1xuICAgICAgICBzdGVwLnByb2Nlc3MoZnJhbWVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBzdGVwO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVzeW5jL2Rpc3QvZXMvaW5kZXgubWpzXG52YXIgbWF4RWxhcHNlZCA9IDQwO1xudmFyIHVzZURlZmF1bHRFbGFwc2VkID0gdHJ1ZTtcbnZhciBydW5OZXh0RnJhbWUgPSBmYWxzZTtcbnZhciBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbnZhciBmcmFtZSA9IHtcbiAgZGVsdGE6IDAsXG4gIHRpbWVzdGFtcDogMFxufTtcbnZhciBzdGVwc09yZGVyID0gW1xuICBcInJlYWRcIixcbiAgXCJ1cGRhdGVcIixcbiAgXCJwcmVSZW5kZXJcIixcbiAgXCJyZW5kZXJcIixcbiAgXCJwb3N0UmVuZGVyXCJcbl07XG52YXIgc3RlcHMgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgYWNjW2tleV0gPSBjcmVhdGVSZW5kZXJTdGVwKCgpID0+IHJ1bk5leHRGcmFtZSA9IHRydWUpO1xuICByZXR1cm4gYWNjO1xufSwge30pO1xudmFyIHN5bmMgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgY29uc3Qgc3RlcCA9IHN0ZXBzW2tleV07XG4gIGFjY1trZXldID0gKHByb2Nlc3MyLCBrZWVwQWxpdmUgPSBmYWxzZSwgaW1tZWRpYXRlID0gZmFsc2UpID0+IHtcbiAgICBpZiAoIXJ1bk5leHRGcmFtZSlcbiAgICAgIHN0YXJ0TG9vcCgpO1xuICAgIHJldHVybiBzdGVwLnNjaGVkdWxlKHByb2Nlc3MyLCBrZWVwQWxpdmUsIGltbWVkaWF0ZSk7XG4gIH07XG4gIHJldHVybiBhY2M7XG59LCB7fSk7XG52YXIgY2FuY2VsU3luYyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICBhY2Nba2V5XSA9IHN0ZXBzW2tleV0uY2FuY2VsO1xuICByZXR1cm4gYWNjO1xufSwge30pO1xudmFyIGZsdXNoU3luYyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICBhY2Nba2V5XSA9ICgpID0+IHN0ZXBzW2tleV0ucHJvY2VzcyhmcmFtZSk7XG4gIHJldHVybiBhY2M7XG59LCB7fSk7XG52YXIgcHJvY2Vzc1N0ZXAgPSAoc3RlcElkKSA9PiBzdGVwc1tzdGVwSWRdLnByb2Nlc3MoZnJhbWUpO1xudmFyIHByb2Nlc3NGcmFtZSA9ICh0aW1lc3RhbXApID0+IHtcbiAgcnVuTmV4dEZyYW1lID0gZmFsc2U7XG4gIGZyYW1lLmRlbHRhID0gdXNlRGVmYXVsdEVsYXBzZWQgPyBkZWZhdWx0VGltZXN0ZXAgOiBNYXRoLm1heChNYXRoLm1pbih0aW1lc3RhbXAgLSBmcmFtZS50aW1lc3RhbXAsIG1heEVsYXBzZWQpLCAxKTtcbiAgZnJhbWUudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICBpc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICBzdGVwc09yZGVyLmZvckVhY2gocHJvY2Vzc1N0ZXApO1xuICBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgaWYgKHJ1bk5leHRGcmFtZSkge1xuICAgIHVzZURlZmF1bHRFbGFwc2VkID0gZmFsc2U7XG4gICAgb25OZXh0RnJhbWUocHJvY2Vzc0ZyYW1lKTtcbiAgfVxufTtcbnZhciBzdGFydExvb3AgPSAoKSA9PiB7XG4gIHJ1bk5leHRGcmFtZSA9IHRydWU7XG4gIHVzZURlZmF1bHRFbGFwc2VkID0gdHJ1ZTtcbiAgaWYgKCFpc1Byb2Nlc3NpbmcpXG4gICAgb25OZXh0RnJhbWUocHJvY2Vzc0ZyYW1lKTtcbn07XG52YXIgZ2V0RnJhbWVEYXRhID0gKCkgPT4gZnJhbWU7XG52YXIgZXNfZGVmYXVsdCA9IHN5bmM7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL3V0aWxzL2VsYXBzZWQubWpzXG5mdW5jdGlvbiBsb29wRWxhcHNlZChlbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkyID0gMCkge1xuICByZXR1cm4gZWxhcHNlZCAtIGR1cmF0aW9uIC0gZGVsYXkyO1xufVxuZnVuY3Rpb24gcmV2ZXJzZUVsYXBzZWQoZWxhcHNlZCwgZHVyYXRpb24sIGRlbGF5MiA9IDAsIGlzRm9yd2FyZFBsYXliYWNrID0gdHJ1ZSkge1xuICByZXR1cm4gaXNGb3J3YXJkUGxheWJhY2sgPyBsb29wRWxhcHNlZChkdXJhdGlvbiArIC1lbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkyKSA6IGR1cmF0aW9uIC0gKGVsYXBzZWQgLSBkdXJhdGlvbikgKyBkZWxheTI7XG59XG5mdW5jdGlvbiBoYXNSZXBlYXREZWxheUVsYXBzZWQoZWxhcHNlZCwgZHVyYXRpb24sIGRlbGF5MiwgaXNGb3J3YXJkUGxheWJhY2spIHtcbiAgcmV0dXJuIGlzRm9yd2FyZFBsYXliYWNrID8gZWxhcHNlZCA+PSBkdXJhdGlvbiArIGRlbGF5MiA6IGVsYXBzZWQgPD0gLWRlbGF5Mjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvaW5kZXgubWpzXG52YXIgZnJhbWVzeW5jID0gKHVwZGF0ZSkgPT4ge1xuICBjb25zdCBwYXNzVGltZXN0YW1wID0gKHsgZGVsdGEgfSkgPT4gdXBkYXRlKGRlbHRhKTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogKCkgPT4gZXNfZGVmYXVsdC51cGRhdGUocGFzc1RpbWVzdGFtcCwgdHJ1ZSksXG4gICAgc3RvcDogKCkgPT4gY2FuY2VsU3luYy51cGRhdGUocGFzc1RpbWVzdGFtcClcbiAgfTtcbn07XG5mdW5jdGlvbiBhbmltYXRlKF9hKSB7XG4gIHZhciBfYiwgX2M7XG4gIHZhciB7IGZyb20sIGF1dG9wbGF5ID0gdHJ1ZSwgZHJpdmVyID0gZnJhbWVzeW5jLCBlbGFwc2VkID0gMCwgcmVwZWF0OiByZXBlYXRNYXggPSAwLCByZXBlYXRUeXBlID0gXCJsb29wXCIsIHJlcGVhdERlbGF5ID0gMCwgb25QbGF5LCBvblN0b3AsIG9uQ29tcGxldGUsIG9uUmVwZWF0LCBvblVwZGF0ZSB9ID0gX2EsIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcImZyb21cIiwgXCJhdXRvcGxheVwiLCBcImRyaXZlclwiLCBcImVsYXBzZWRcIiwgXCJyZXBlYXRcIiwgXCJyZXBlYXRUeXBlXCIsIFwicmVwZWF0RGVsYXlcIiwgXCJvblBsYXlcIiwgXCJvblN0b3BcIiwgXCJvbkNvbXBsZXRlXCIsIFwib25SZXBlYXRcIiwgXCJvblVwZGF0ZVwiXSk7XG4gIGxldCB7IHRvIH0gPSBvcHRpb25zO1xuICBsZXQgZHJpdmVyQ29udHJvbHM7XG4gIGxldCByZXBlYXRDb3VudCA9IDA7XG4gIGxldCBjb21wdXRlZER1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgbGV0IGxhdGVzdDtcbiAgbGV0IGlzQ29tcGxldGUgPSBmYWxzZTtcbiAgbGV0IGlzRm9yd2FyZFBsYXliYWNrID0gdHJ1ZTtcbiAgbGV0IGludGVycG9sYXRlRnJvbU51bWJlcjtcbiAgY29uc3QgYW5pbWF0b3IgPSBkZXRlY3RBbmltYXRpb25Gcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgaWYgKChfYyA9IChfYiA9IGFuaW1hdG9yKS5uZWVkc0ludGVycG9sYXRpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCBmcm9tLCB0bykpIHtcbiAgICBpbnRlcnBvbGF0ZUZyb21OdW1iZXIgPSBpbnRlcnBvbGF0ZShbMCwgMTAwXSwgW2Zyb20sIHRvXSwge1xuICAgICAgY2xhbXA6IGZhbHNlXG4gICAgfSk7XG4gICAgZnJvbSA9IDA7XG4gICAgdG8gPSAxMDA7XG4gIH1cbiAgY29uc3QgYW5pbWF0aW9uID0gYW5pbWF0b3IoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmcm9tLCB0byB9KSk7XG4gIGZ1bmN0aW9uIHJlcGVhdCgpIHtcbiAgICByZXBlYXRDb3VudCsrO1xuICAgIGlmIChyZXBlYXRUeXBlID09PSBcInJldmVyc2VcIikge1xuICAgICAgaXNGb3J3YXJkUGxheWJhY2sgPSByZXBlYXRDb3VudCAlIDIgPT09IDA7XG4gICAgICBlbGFwc2VkID0gcmV2ZXJzZUVsYXBzZWQoZWxhcHNlZCwgY29tcHV0ZWREdXJhdGlvbiwgcmVwZWF0RGVsYXksIGlzRm9yd2FyZFBsYXliYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxhcHNlZCA9IGxvb3BFbGFwc2VkKGVsYXBzZWQsIGNvbXB1dGVkRHVyYXRpb24sIHJlcGVhdERlbGF5KTtcbiAgICAgIGlmIChyZXBlYXRUeXBlID09PSBcIm1pcnJvclwiKVxuICAgICAgICBhbmltYXRpb24uZmxpcFRhcmdldCgpO1xuICAgIH1cbiAgICBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgb25SZXBlYXQgJiYgb25SZXBlYXQoKTtcbiAgfVxuICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICBkcml2ZXJDb250cm9scy5zdG9wKCk7XG4gICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKCk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKGRlbHRhKSB7XG4gICAgaWYgKCFpc0ZvcndhcmRQbGF5YmFjaylcbiAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgIGVsYXBzZWQgKz0gZGVsdGE7XG4gICAgaWYgKCFpc0NvbXBsZXRlKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGFuaW1hdGlvbi5uZXh0KE1hdGgubWF4KDAsIGVsYXBzZWQpKTtcbiAgICAgIGxhdGVzdCA9IHN0YXRlLnZhbHVlO1xuICAgICAgaWYgKGludGVycG9sYXRlRnJvbU51bWJlcilcbiAgICAgICAgbGF0ZXN0ID0gaW50ZXJwb2xhdGVGcm9tTnVtYmVyKGxhdGVzdCk7XG4gICAgICBpc0NvbXBsZXRlID0gaXNGb3J3YXJkUGxheWJhY2sgPyBzdGF0ZS5kb25lIDogZWxhcHNlZCA8PSAwO1xuICAgIH1cbiAgICBvblVwZGF0ZSA9PT0gbnVsbCB8fCBvblVwZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25VcGRhdGUobGF0ZXN0KTtcbiAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgaWYgKHJlcGVhdENvdW50ID09PSAwKVxuICAgICAgICBjb21wdXRlZER1cmF0aW9uICE9PSBudWxsICYmIGNvbXB1dGVkRHVyYXRpb24gIT09IHZvaWQgMCA/IGNvbXB1dGVkRHVyYXRpb24gOiBjb21wdXRlZER1cmF0aW9uID0gZWxhcHNlZDtcbiAgICAgIGlmIChyZXBlYXRDb3VudCA8IHJlcGVhdE1heCkge1xuICAgICAgICBoYXNSZXBlYXREZWxheUVsYXBzZWQoZWxhcHNlZCwgY29tcHV0ZWREdXJhdGlvbiwgcmVwZWF0RGVsYXksIGlzRm9yd2FyZFBsYXliYWNrKSAmJiByZXBlYXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgb25QbGF5ID09PSBudWxsIHx8IG9uUGxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25QbGF5KCk7XG4gICAgZHJpdmVyQ29udHJvbHMgPSBkcml2ZXIodXBkYXRlKTtcbiAgICBkcml2ZXJDb250cm9scy5zdGFydCgpO1xuICB9XG4gIGF1dG9wbGF5ICYmIHBsYXkoKTtcbiAgcmV0dXJuIHtcbiAgICBzdG9wOiAoKSA9PiB7XG4gICAgICBvblN0b3AgPT09IG51bGwgfHwgb25TdG9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblN0b3AoKTtcbiAgICAgIGRyaXZlckNvbnRyb2xzLnN0b3AoKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy92ZWxvY2l0eS1wZXItc2Vjb25kLm1qc1xuZnVuY3Rpb24gdmVsb2NpdHlQZXJTZWNvbmQodmVsb2NpdHksIGZyYW1lRHVyYXRpb24pIHtcbiAgcmV0dXJuIGZyYW1lRHVyYXRpb24gPyB2ZWxvY2l0eSAqICgxZTMgLyBmcmFtZUR1cmF0aW9uKSA6IDA7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL2luZXJ0aWEubWpzXG5mdW5jdGlvbiBpbmVydGlhKHsgZnJvbSA9IDAsIHZlbG9jaXR5ID0gMCwgbWluLCBtYXgsIHBvd2VyID0gMC44LCB0aW1lQ29uc3RhbnQgPSA3NTAsIGJvdW5jZVN0aWZmbmVzcyA9IDUwMCwgYm91bmNlRGFtcGluZyA9IDEwLCByZXN0RGVsdGEgPSAxLCBtb2RpZnlUYXJnZXQsIGRyaXZlciwgb25VcGRhdGUsIG9uQ29tcGxldGUsIG9uU3RvcCB9KSB7XG4gIGxldCBjdXJyZW50QW5pbWF0aW9uO1xuICBmdW5jdGlvbiBpc091dE9mQm91bmRzKHYpIHtcbiAgICByZXR1cm4gbWluICE9PSB2b2lkIDAgJiYgdiA8IG1pbiB8fCBtYXggIT09IHZvaWQgMCAmJiB2ID4gbWF4O1xuICB9XG4gIGZ1bmN0aW9uIGJvdW5kYXJ5TmVhcmVzdCh2KSB7XG4gICAgaWYgKG1pbiA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG1heDtcbiAgICBpZiAobWF4ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbWluO1xuICAgIHJldHVybiBNYXRoLmFicyhtaW4gLSB2KSA8IE1hdGguYWJzKG1heCAtIHYpID8gbWluIDogbWF4O1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uMihvcHRpb25zKSB7XG4gICAgY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICBjdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICBkcml2ZXIsXG4gICAgICBvblVwZGF0ZTogKHYpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBvblVwZGF0ZSA9PT0gbnVsbCB8fCBvblVwZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25VcGRhdGUodik7XG4gICAgICAgIChfYSA9IG9wdGlvbnMub25VcGRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIHYpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGUsXG4gICAgICBvblN0b3BcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRTcHJpbmcob3B0aW9ucykge1xuICAgIHN0YXJ0QW5pbWF0aW9uMihPYmplY3QuYXNzaWduKHsgdHlwZTogXCJzcHJpbmdcIiwgc3RpZmZuZXNzOiBib3VuY2VTdGlmZm5lc3MsIGRhbXBpbmc6IGJvdW5jZURhbXBpbmcsIHJlc3REZWx0YSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgaWYgKGlzT3V0T2ZCb3VuZHMoZnJvbSkpIHtcbiAgICBzdGFydFNwcmluZyh7IGZyb20sIHZlbG9jaXR5LCB0bzogYm91bmRhcnlOZWFyZXN0KGZyb20pIH0pO1xuICB9IGVsc2Uge1xuICAgIGxldCB0YXJnZXQgPSBwb3dlciAqIHZlbG9jaXR5ICsgZnJvbTtcbiAgICBpZiAodHlwZW9mIG1vZGlmeVRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIHRhcmdldCA9IG1vZGlmeVRhcmdldCh0YXJnZXQpO1xuICAgIGNvbnN0IGJvdW5kYXJ5ID0gYm91bmRhcnlOZWFyZXN0KHRhcmdldCk7XG4gICAgY29uc3QgaGVhZGluZyA9IGJvdW5kYXJ5ID09PSBtaW4gPyAtMSA6IDE7XG4gICAgbGV0IHByZXY7XG4gICAgbGV0IGN1cnJlbnQ7XG4gICAgY29uc3QgY2hlY2tCb3VuZGFyeSA9ICh2KSA9PiB7XG4gICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgIGN1cnJlbnQgPSB2O1xuICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eVBlclNlY29uZCh2IC0gcHJldiwgZ2V0RnJhbWVEYXRhKCkuZGVsdGEpO1xuICAgICAgaWYgKGhlYWRpbmcgPT09IDEgJiYgdiA+IGJvdW5kYXJ5IHx8IGhlYWRpbmcgPT09IC0xICYmIHYgPCBib3VuZGFyeSkge1xuICAgICAgICBzdGFydFNwcmluZyh7IGZyb206IHYsIHRvOiBib3VuZGFyeSwgdmVsb2NpdHkgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzdGFydEFuaW1hdGlvbjIoe1xuICAgICAgdHlwZTogXCJkZWNheVwiLFxuICAgICAgZnJvbSxcbiAgICAgIHZlbG9jaXR5LFxuICAgICAgdGltZUNvbnN0YW50LFxuICAgICAgcG93ZXIsXG4gICAgICByZXN0RGVsdGEsXG4gICAgICBtb2RpZnlUYXJnZXQsXG4gICAgICBvblVwZGF0ZTogaXNPdXRPZkJvdW5kcyh0YXJnZXQpID8gY2hlY2tCb3VuZGFyeSA6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RvcDogKCkgPT4gY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50QW5pbWF0aW9uLnN0b3AoKVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtcG9pbnQubWpzXG52YXIgaXNQb2ludCA9IChwb2ludDIpID0+IHBvaW50Mi5oYXNPd25Qcm9wZXJ0eShcInhcIikgJiYgcG9pbnQyLmhhc093blByb3BlcnR5KFwieVwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLXBvaW50LTNkLm1qc1xudmFyIGlzUG9pbnQzRCA9IChwb2ludDIpID0+IGlzUG9pbnQocG9pbnQyKSAmJiBwb2ludDIuaGFzT3duUHJvcGVydHkoXCJ6XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvZGlzdGFuY2UubWpzXG52YXIgZGlzdGFuY2UxRCA9IChhMiwgYjIpID0+IE1hdGguYWJzKGEyIC0gYjIpO1xuZnVuY3Rpb24gZGlzdGFuY2UoYTIsIGIyKSB7XG4gIGlmIChpc051bShhMikgJiYgaXNOdW0oYjIpKSB7XG4gICAgcmV0dXJuIGRpc3RhbmNlMUQoYTIsIGIyKTtcbiAgfSBlbHNlIGlmIChpc1BvaW50KGEyKSAmJiBpc1BvaW50KGIyKSkge1xuICAgIGNvbnN0IHhEZWx0YSA9IGRpc3RhbmNlMUQoYTIueCwgYjIueCk7XG4gICAgY29uc3QgeURlbHRhID0gZGlzdGFuY2UxRChhMi55LCBiMi55KTtcbiAgICBjb25zdCB6RGVsdGEgPSBpc1BvaW50M0QoYTIpICYmIGlzUG9pbnQzRChiMikgPyBkaXN0YW5jZTFEKGEyLnosIGIyLnopIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHhEZWx0YSwgMikgKyBNYXRoLnBvdyh5RGVsdGEsIDIpICsgTWF0aC5wb3coekRlbHRhLCAyKSk7XG4gIH1cbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2Vhc2luZy9jdWJpYy1iZXppZXIubWpzXG52YXIgYSA9IChhMSwgYTIpID0+IDEgLSAzICogYTIgKyAzICogYTE7XG52YXIgYiA9IChhMSwgYTIpID0+IDMgKiBhMiAtIDYgKiBhMTtcbnZhciBjMiA9IChhMSkgPT4gMyAqIGExO1xudmFyIGNhbGNCZXppZXIgPSAodCwgYTEsIGEyKSA9PiAoKGEoYTEsIGEyKSAqIHQgKyBiKGExLCBhMikpICogdCArIGMyKGExKSkgKiB0O1xudmFyIGdldFNsb3BlID0gKHQsIGExLCBhMikgPT4gMyAqIGEoYTEsIGEyKSAqIHQgKiB0ICsgMiAqIGIoYTEsIGEyKSAqIHQgKyBjMihhMSk7XG52YXIgc3ViZGl2aXNpb25QcmVjaXNpb24gPSAxZS03O1xudmFyIHN1YmRpdmlzaW9uTWF4SXRlcmF0aW9ucyA9IDEwO1xuZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gIGxldCBjdXJyZW50WDtcbiAgbGV0IGN1cnJlbnRUO1xuICBsZXQgaTIgPSAwO1xuICBkbyB7XG4gICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDI7XG4gICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICBpZiAoY3VycmVudFggPiAwKSB7XG4gICAgICBhQiA9IGN1cnJlbnRUO1xuICAgIH0gZWxzZSB7XG4gICAgICBhQSA9IGN1cnJlbnRUO1xuICAgIH1cbiAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gc3ViZGl2aXNpb25QcmVjaXNpb24gJiYgKytpMiA8IHN1YmRpdmlzaW9uTWF4SXRlcmF0aW9ucyk7XG4gIHJldHVybiBjdXJyZW50VDtcbn1cbnZhciBuZXd0b25JdGVyYXRpb25zID0gODtcbnZhciBuZXd0b25NaW5TbG9wZSA9IDFlLTM7XG5mdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG5ld3Rvbkl0ZXJhdGlvbnM7ICsraTIpIHtcbiAgICBjb25zdCBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICB9XG4gIHJldHVybiBhR3Vlc3NUO1xufVxudmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbnZhciBrU2FtcGxlU3RlcFNpemUgPSAxIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxKTtcbmZ1bmN0aW9uIGN1YmljQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpXG4gICAgcmV0dXJuIGxpbmVhcjtcbiAgY29uc3Qgc2FtcGxlVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGtTcGxpbmVUYWJsZVNpemU7ICsraTIpIHtcbiAgICBzYW1wbGVWYWx1ZXNbaTJdID0gY2FsY0JlemllcihpMiAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG4gICAgbGV0IGludGVydmFsU3RhcnQgPSAwO1xuICAgIGxldCBjdXJyZW50U2FtcGxlID0gMTtcbiAgICBjb25zdCBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG4gICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgIH1cbiAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgY29uc3QgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgY29uc3QgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgY29uc3QgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBuZXd0b25NaW5TbG9wZSkge1xuICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKHQpID0+IHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiBjYWxjQmV6aWVyKGdldFRGb3JYKHQpLCBtWTEsIG1ZMik7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLXRhcC1nZXN0dXJlLm1qc1xuZnVuY3Rpb24gdXNlVGFwR2VzdHVyZSh7IG9uVGFwLCBvblRhcFN0YXJ0LCBvblRhcENhbmNlbCwgd2hpbGVUYXAsIHZpc3VhbEVsZW1lbnQgfSkge1xuICBjb25zdCBoYXNQcmVzc0xpc3RlbmVycyA9IG9uVGFwIHx8IG9uVGFwU3RhcnQgfHwgb25UYXBDYW5jZWwgfHwgd2hpbGVUYXA7XG4gIGNvbnN0IGlzUHJlc3NpbmcgPSB1c2VSZWYzKGZhbHNlKTtcbiAgY29uc3QgY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycyA9IHVzZVJlZjMobnVsbCk7XG4gIGNvbnN0IGV2ZW50T3B0aW9ucyA9IHtcbiAgICBwYXNzaXZlOiAhKG9uVGFwU3RhcnQgfHwgb25UYXAgfHwgb25UYXBDYW5jZWwgfHwgb25Qb2ludGVyRG93bilcbiAgfTtcbiAgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlckVuZExpc3RlbmVyKCkge1xuICAgIGNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMuY3VycmVudCAmJiBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzLmN1cnJlbnQoKTtcbiAgICBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzLmN1cnJlbnQgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrUG9pbnRlckVuZCgpIHtcbiAgICByZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIoKTtcbiAgICBpc1ByZXNzaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlICYmIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuVGFwLCBmYWxzZSk7XG4gICAgcmV0dXJuICFpc0RyYWdBY3RpdmUoKTtcbiAgfVxuICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCwgaW5mbykge1xuICAgIGlmICghY2hlY2tQb2ludGVyRW5kKCkpXG4gICAgICByZXR1cm47XG4gICAgIWlzTm9kZU9yQ2hpbGQodmlzdWFsRWxlbWVudC5jdXJyZW50LCBldmVudC50YXJnZXQpID8gb25UYXBDYW5jZWwgJiYgb25UYXBDYW5jZWwoZXZlbnQsIGluZm8pIDogb25UYXAgJiYgb25UYXAoZXZlbnQsIGluZm8pO1xuICB9XG4gIGZ1bmN0aW9uIG9uUG9pbnRlckNhbmNlbChldmVudCwgaW5mbykge1xuICAgIGlmICghY2hlY2tQb2ludGVyRW5kKCkpXG4gICAgICByZXR1cm47XG4gICAgb25UYXBDYW5jZWwgJiYgb25UYXBDYW5jZWwoZXZlbnQsIGluZm8pO1xuICB9XG4gIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQsIGluZm8pIHtcbiAgICByZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIoKTtcbiAgICBpZiAoaXNQcmVzc2luZy5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGlzUHJlc3NpbmcuY3VycmVudCA9IHRydWU7XG4gICAgY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50ID0gcGlwZShhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgZXZlbnRPcHRpb25zKSwgYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlckNhbmNlbCwgZXZlbnRPcHRpb25zKSk7XG4gICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSAmJiB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLlRhcCwgdHJ1ZSk7XG4gICAgb25UYXBTdGFydCAmJiBvblRhcFN0YXJ0KGV2ZW50LCBpbmZvKTtcbiAgfVxuICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudCwgXCJwb2ludGVyZG93blwiLCBoYXNQcmVzc0xpc3RlbmVycyA/IG9uUG9pbnRlckRvd24gOiB2b2lkIDAsIGV2ZW50T3B0aW9ucyk7XG4gIHVzZVVubW91bnRFZmZlY3QocmVtb3ZlUG9pbnRlckVuZExpc3RlbmVyKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9wcm9jZXNzLm1qc1xudmFyIGRlZmF1bHRFbnZpcm9ubWVudCA9IFwicHJvZHVjdGlvblwiO1xudmFyIGVudiA9IHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52ID09PSB2b2lkIDAgPyBkZWZhdWx0RW52aXJvbm1lbnQgOiBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCBkZWZhdWx0RW52aXJvbm1lbnQ7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL3ZpZXdwb3J0L3VzZS12aWV3cG9ydC5tanNcbmltcG9ydCB7IHVzZVJlZiBhcyB1c2VSZWY0LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3dhcm4tb25jZS5tanNcbnZhciB3YXJuZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gd2Fybk9uY2UoY29uZGl0aW9uLCBtZXNzYWdlLCBlbGVtZW50KSB7XG4gIGlmIChjb25kaXRpb24gfHwgd2FybmVkLmhhcyhtZXNzYWdlKSlcbiAgICByZXR1cm47XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgaWYgKGVsZW1lbnQpXG4gICAgY29uc29sZS53YXJuKGVsZW1lbnQpO1xuICB3YXJuZWQuYWRkKG1lc3NhZ2UpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy92aWV3cG9ydC9vYnNlcnZlcnMubWpzXG52YXIgb2JzZXJ2ZXJDYWxsYmFja3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBvYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBmaXJlT2JzZXJ2ZXJDYWxsYmFjayA9IChlbnRyeSkgPT4ge1xuICBjb25zdCBjYWxsYmFjayA9IG9ic2VydmVyQ2FsbGJhY2tzLmdldChlbnRyeS50YXJnZXQpO1xuICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbnRyeSk7XG59O1xudmFyIGZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcyA9IChlbnRyaWVzKSA9PiB7XG4gIGVudHJpZXMuZm9yRWFjaChmaXJlT2JzZXJ2ZXJDYWxsYmFjayk7XG59O1xuZnVuY3Rpb24gaW5pdEludGVyc2VjdGlvbk9ic2VydmVyKF9hKSB7XG4gIHZhciBfYiA9IF9hLCB7IHJvb3QgfSA9IF9iLCBvcHRpb25zID0gX19vYmpSZXN0KF9iLCBbXCJyb290XCJdKTtcbiAgY29uc3QgbG9va3VwUm9vdCA9IHJvb3QgfHwgZG9jdW1lbnQ7XG4gIGlmICghb2JzZXJ2ZXJzLmhhcyhsb29rdXBSb290KSkge1xuICAgIG9ic2VydmVycy5zZXQobG9va3VwUm9vdCwge30pO1xuICB9XG4gIGNvbnN0IHJvb3RPYnNlcnZlcnMgPSBvYnNlcnZlcnMuZ2V0KGxvb2t1cFJvb3QpO1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgaWYgKCFyb290T2JzZXJ2ZXJzW2tleV0pIHtcbiAgICByb290T2JzZXJ2ZXJzW2tleV0gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZmlyZUFsbE9ic2VydmVyQ2FsbGJhY2tzLCBfX3NwcmVhZFZhbHVlcyh7IHJvb3QgfSwgb3B0aW9ucykpO1xuICB9XG4gIHJldHVybiByb290T2JzZXJ2ZXJzW2tleV07XG59XG5mdW5jdGlvbiBvYnNlcnZlSW50ZXJzZWN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIgPSBpbml0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIob3B0aW9ucyk7XG4gIG9ic2VydmVyQ2FsbGJhY2tzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBvYnNlcnZlckNhbGxiYWNrcy5kZWxldGUoZWxlbWVudCk7XG4gICAgcm9vdEludGVyZXNlY3Rpb25PYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL3ZpZXdwb3J0L3VzZS12aWV3cG9ydC5tanNcbmZ1bmN0aW9uIHVzZVZpZXdwb3J0KHsgdmlzdWFsRWxlbWVudCwgd2hpbGVJblZpZXcsIG9uVmlld3BvcnRFbnRlciwgb25WaWV3cG9ydExlYXZlLCB2aWV3cG9ydCA9IHt9IH0pIHtcbiAgY29uc3Qgc3RhdGUgPSB1c2VSZWY0KHtcbiAgICBoYXNFbnRlcmVkVmlldzogZmFsc2UsXG4gICAgaXNJblZpZXc6IGZhbHNlXG4gIH0pO1xuICBsZXQgc2hvdWxkT2JzZXJ2ZSA9IEJvb2xlYW4od2hpbGVJblZpZXcgfHwgb25WaWV3cG9ydEVudGVyIHx8IG9uVmlld3BvcnRMZWF2ZSk7XG4gIGlmICh2aWV3cG9ydC5vbmNlICYmIHN0YXRlLmN1cnJlbnQuaGFzRW50ZXJlZFZpZXcpXG4gICAgc2hvdWxkT2JzZXJ2ZSA9IGZhbHNlO1xuICBjb25zdCB1c2VPYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIiA/IHVzZU1pc3NpbmdJbnRlcnNlY3Rpb25PYnNlcnZlciA6IHVzZUludGVyc2VjdGlvbk9ic2VydmVyO1xuICB1c2VPYnNlcnZlcihzaG91bGRPYnNlcnZlLCBzdGF0ZS5jdXJyZW50LCB2aXN1YWxFbGVtZW50LCB2aWV3cG9ydCk7XG59XG52YXIgdGhyZXNob2xkTmFtZXMgPSB7XG4gIHNvbWU6IDAsXG4gIGFsbDogMVxufTtcbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbk9ic2VydmVyKHNob3VsZE9ic2VydmUsIHN0YXRlLCB2aXN1YWxFbGVtZW50LCB7IHJvb3QsIG1hcmdpbjogcm9vdE1hcmdpbiwgYW1vdW50ID0gXCJzb21lXCIsIG9uY2UgfSkge1xuICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICBpZiAoIXNob3VsZE9ic2VydmUgfHwgIXZpc3VhbEVsZW1lbnQuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcm9vdDogcm9vdCA9PT0gbnVsbCB8fCByb290ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb290LmN1cnJlbnQsXG4gICAgICByb290TWFyZ2luLFxuICAgICAgdGhyZXNob2xkOiB0eXBlb2YgYW1vdW50ID09PSBcIm51bWJlclwiID8gYW1vdW50IDogdGhyZXNob2xkTmFtZXNbYW1vdW50XVxuICAgIH07XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uQ2FsbGJhY2sgPSAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IHsgaXNJbnRlcnNlY3RpbmcgfSA9IGVudHJ5O1xuICAgICAgaWYgKHN0YXRlLmlzSW5WaWV3ID09PSBpc0ludGVyc2VjdGluZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgc3RhdGUuaXNJblZpZXcgPSBpc0ludGVyc2VjdGluZztcbiAgICAgIGlmIChvbmNlICYmICFpc0ludGVyc2VjdGluZyAmJiBzdGF0ZS5oYXNFbnRlcmVkVmlldykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIHN0YXRlLmhhc0VudGVyZWRWaWV3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuSW5WaWV3LCBpc0ludGVyc2VjdGluZyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gaXNJbnRlcnNlY3RpbmcgPyBwcm9wcy5vblZpZXdwb3J0RW50ZXIgOiBwcm9wcy5vblZpZXdwb3J0TGVhdmU7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbnRyeSk7XG4gICAgfTtcbiAgICByZXR1cm4gb2JzZXJ2ZUludGVyc2VjdGlvbih2aXN1YWxFbGVtZW50LmN1cnJlbnQsIG9wdGlvbnMsIGludGVyc2VjdGlvbkNhbGxiYWNrKTtcbiAgfSwgW3Nob3VsZE9ic2VydmUsIHJvb3QsIHJvb3RNYXJnaW4sIGFtb3VudF0pO1xufVxuZnVuY3Rpb24gdXNlTWlzc2luZ0ludGVyc2VjdGlvbk9ic2VydmVyKHNob3VsZE9ic2VydmUsIHN0YXRlLCB2aXN1YWxFbGVtZW50LCB7IGZhbGxiYWNrID0gdHJ1ZSB9KSB7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIGlmICghc2hvdWxkT2JzZXJ2ZSB8fCAhZmFsbGJhY2spXG4gICAgICByZXR1cm47XG4gICAgaWYgKGVudiAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5PbmNlKGZhbHNlLCBcIkludGVyc2VjdGlvbk9ic2VydmVyIG5vdCBhdmFpbGFibGUgb24gdGhpcyBkZXZpY2UuIHdoaWxlSW5WaWV3IGFuaW1hdGlvbnMgd2lsbCB0cmlnZ2VyIG9uIG1vdW50LlwiKTtcbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHN0YXRlLmhhc0VudGVyZWRWaWV3ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHsgb25WaWV3cG9ydEVudGVyIH0gPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgICBvblZpZXdwb3J0RW50ZXIgJiYgb25WaWV3cG9ydEVudGVyKG51bGwpO1xuICAgICAgaWYgKHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5JblZpZXcsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbc2hvdWxkT2JzZXJ2ZV0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9tYWtlLXJlbmRlcmxlc3MtY29tcG9uZW50Lm1qc1xudmFyIG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50ID0gKGhvb2spID0+IChwcm9wcykgPT4ge1xuICBob29rKHByb3BzKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9nZXN0dXJlcy5tanNcbnZhciBnZXN0dXJlQW5pbWF0aW9ucyA9IHtcbiAgaW5WaWV3OiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VWaWV3cG9ydCksXG4gIHRhcDogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlVGFwR2VzdHVyZSksXG4gIGZvY3VzOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VGb2N1c0dlc3R1cmUpLFxuICBob3ZlcjogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlSG92ZXJHZXN0dXJlKVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvYW5pbWF0aW9ucy5tanNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q3LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ3IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvdXNlLXByZXNlbmNlLm1qc1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NiwgdXNlSWQsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q2IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VQcmVzZW5jZSgpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQ2KFByZXNlbmNlQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKVxuICAgIHJldHVybiBbdHJ1ZSwgbnVsbF07XG4gIGNvbnN0IHsgaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSwgcmVnaXN0ZXIgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IGlkMiA9IHVzZUlkKCk7XG4gIHVzZUVmZmVjdDYoKCkgPT4gcmVnaXN0ZXIoaWQyKSwgW10pO1xuICBjb25zdCBzYWZlVG9SZW1vdmUgPSAoKSA9PiBvbkV4aXRDb21wbGV0ZSAmJiBvbkV4aXRDb21wbGV0ZShpZDIpO1xuICByZXR1cm4gIWlzUHJlc2VudCAmJiBvbkV4aXRDb21wbGV0ZSA/IFtmYWxzZSwgc2FmZVRvUmVtb3ZlXSA6IFt0cnVlXTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9zaGFsbG93LWNvbXBhcmUubWpzXG5mdW5jdGlvbiBzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwcmV2KSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByZXZMZW5ndGggPSBwcmV2Lmxlbmd0aDtcbiAgaWYgKHByZXZMZW5ndGggIT09IG5leHQubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHByZXZMZW5ndGg7IGkyKyspIHtcbiAgICBpZiAocHJldltpMl0gIT09IG5leHRbaTJdKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3RpbWUtY29udmVyc2lvbi5tanNcbnZhciBzZWNvbmRzVG9NaWxsaXNlY29uZHMgPSAoc2Vjb25kcykgPT4gc2Vjb25kcyAqIDFlMztcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvZWFzaW5nLm1qc1xudmFyIGVhc2luZ0xvb2t1cCA9IHtcbiAgbGluZWFyLFxuICBlYXNlSW4sXG4gIGVhc2VJbk91dCxcbiAgZWFzZU91dCxcbiAgY2lyY0luLFxuICBjaXJjSW5PdXQsXG4gIGNpcmNPdXQsXG4gIGJhY2tJbixcbiAgYmFja0luT3V0LFxuICBiYWNrT3V0LFxuICBhbnRpY2lwYXRlLFxuICBib3VuY2VJbixcbiAgYm91bmNlSW5PdXQsXG4gIGJvdW5jZU91dFxufTtcbnZhciBlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbiA9IChkZWZpbml0aW9uKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgaW52YXJpYW50KGRlZmluaXRpb24ubGVuZ3RoID09PSA0LCBgQ3ViaWMgYmV6aWVyIGFycmF5cyBtdXN0IGNvbnRhaW4gZm91ciBudW1lcmljYWwgdmFsdWVzLmApO1xuICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSBkZWZpbml0aW9uO1xuICAgIHJldHVybiBjdWJpY0Jlemllcih4MSwgeTEsIHgyLCB5Mik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICBpbnZhcmlhbnQoZWFzaW5nTG9va3VwW2RlZmluaXRpb25dICE9PSB2b2lkIDAsIGBJbnZhbGlkIGVhc2luZyB0eXBlICcke2RlZmluaXRpb259J2ApO1xuICAgIHJldHVybiBlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl07XG4gIH1cbiAgcmV0dXJuIGRlZmluaXRpb247XG59O1xudmFyIGlzRWFzaW5nQXJyYXkgPSAoZWFzZSkgPT4ge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShlYXNlKSAmJiB0eXBlb2YgZWFzZVswXSAhPT0gXCJudW1iZXJcIjtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGFibGUubWpzXG52YXIgaXNBbmltYXRhYmxlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgaWYgKGtleSA9PT0gXCJ6SW5kZXhcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgY29tcGxleC50ZXN0KHZhbHVlKSAmJiAhdmFsdWUuc3RhcnRzV2l0aChcInVybChcIikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9kZWZhdWx0LXRyYW5zaXRpb25zLm1qc1xudmFyIHVuZGVyRGFtcGVkU3ByaW5nID0gKCkgPT4gKHtcbiAgdHlwZTogXCJzcHJpbmdcIixcbiAgc3RpZmZuZXNzOiA1MDAsXG4gIGRhbXBpbmc6IDI1LFxuICByZXN0U3BlZWQ6IDEwXG59KTtcbnZhciBjcml0aWNhbGx5RGFtcGVkU3ByaW5nID0gKHRvKSA9PiAoe1xuICB0eXBlOiBcInNwcmluZ1wiLFxuICBzdGlmZm5lc3M6IDU1MCxcbiAgZGFtcGluZzogdG8gPT09IDAgPyAyICogTWF0aC5zcXJ0KDU1MCkgOiAzMCxcbiAgcmVzdFNwZWVkOiAxMFxufSk7XG52YXIgbGluZWFyVHdlZW4gPSAoKSA9PiAoe1xuICB0eXBlOiBcImtleWZyYW1lc1wiLFxuICBlYXNlOiBcImxpbmVhclwiLFxuICBkdXJhdGlvbjogMC4zXG59KTtcbnZhciBrZXlmcmFtZXMyID0gKHZhbHVlcykgPT4gKHtcbiAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgZHVyYXRpb246IDAuOCxcbiAgdmFsdWVzXG59KTtcbnZhciBkZWZhdWx0VHJhbnNpdGlvbnMgPSB7XG4gIHg6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICB5OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgejogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHJvdGF0ZTogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHJvdGF0ZVg6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICByb3RhdGVZOiB1bmRlckRhbXBlZFNwcmluZyxcbiAgcm90YXRlWjogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHNjYWxlWDogY3JpdGljYWxseURhbXBlZFNwcmluZyxcbiAgc2NhbGVZOiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nLFxuICBzY2FsZTogY3JpdGljYWxseURhbXBlZFNwcmluZyxcbiAgb3BhY2l0eTogbGluZWFyVHdlZW4sXG4gIGJhY2tncm91bmRDb2xvcjogbGluZWFyVHdlZW4sXG4gIGNvbG9yOiBsaW5lYXJUd2VlbixcbiAgZGVmYXVsdDogY3JpdGljYWxseURhbXBlZFNwcmluZ1xufTtcbnZhciBnZXREZWZhdWx0VHJhbnNpdGlvbiA9ICh2YWx1ZUtleSwgdG8pID0+IHtcbiAgbGV0IHRyYW5zaXRpb25GYWN0b3J5O1xuICBpZiAoaXNLZXlmcmFtZXNUYXJnZXQodG8pKSB7XG4gICAgdHJhbnNpdGlvbkZhY3RvcnkgPSBrZXlmcmFtZXMyO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zaXRpb25GYWN0b3J5ID0gZGVmYXVsdFRyYW5zaXRpb25zW3ZhbHVlS2V5XSB8fCBkZWZhdWx0VHJhbnNpdGlvbnMuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoeyB0byB9LCB0cmFuc2l0aW9uRmFjdG9yeSh0bykpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL2RlZmF1bHRzLm1qc1xudmFyIGRlZmF1bHRWYWx1ZVR5cGVzID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbnVtYmVyVmFsdWVUeXBlcyksIHtcbiAgY29sb3IsXG4gIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gIG91dGxpbmVDb2xvcjogY29sb3IsXG4gIGZpbGw6IGNvbG9yLFxuICBzdHJva2U6IGNvbG9yLFxuICBib3JkZXJDb2xvcjogY29sb3IsXG4gIGJvcmRlclRvcENvbG9yOiBjb2xvcixcbiAgYm9yZGVyUmlnaHRDb2xvcjogY29sb3IsXG4gIGJvcmRlckJvdHRvbUNvbG9yOiBjb2xvcixcbiAgYm9yZGVyTGVmdENvbG9yOiBjb2xvcixcbiAgZmlsdGVyLFxuICBXZWJraXRGaWx0ZXI6IGZpbHRlclxufSk7XG52YXIgZ2V0RGVmYXVsdFZhbHVlVHlwZSA9IChrZXkpID0+IGRlZmF1bHRWYWx1ZVR5cGVzW2tleV07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9hbmltYXRhYmxlLW5vbmUubWpzXG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlTm9uZTIoa2V5LCB2YWx1ZSkge1xuICB2YXIgX2E7XG4gIGxldCBkZWZhdWx0VmFsdWVUeXBlID0gZ2V0RGVmYXVsdFZhbHVlVHlwZShrZXkpO1xuICBpZiAoZGVmYXVsdFZhbHVlVHlwZSAhPT0gZmlsdGVyKVxuICAgIGRlZmF1bHRWYWx1ZVR5cGUgPSBjb21wbGV4O1xuICByZXR1cm4gKF9hID0gZGVmYXVsdFZhbHVlVHlwZS5nZXRBbmltYXRhYmxlTm9uZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGVmYXVsdFZhbHVlVHlwZSwgdmFsdWUpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1pbnN0YW50LXRyYW5zaXRpb24tc3RhdGUubWpzXG52YXIgaW5zdGFudEFuaW1hdGlvblN0YXRlID0ge1xuICBjdXJyZW50OiBmYWxzZVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9kZWxheS5tanNcbmZ1bmN0aW9uIGRlbGF5KGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IGNoZWNrRWxhcHNlZCA9ICh7IHRpbWVzdGFtcCB9KSA9PiB7XG4gICAgY29uc3QgZWxhcHNlZCA9IHRpbWVzdGFtcCAtIHN0YXJ0O1xuICAgIGlmIChlbGFwc2VkID49IHRpbWVvdXQpIHtcbiAgICAgIGNhbmNlbFN5bmMucmVhZChjaGVja0VsYXBzZWQpO1xuICAgICAgY2FsbGJhY2soZWxhcHNlZCAtIHRpbWVvdXQpO1xuICAgIH1cbiAgfTtcbiAgZXNfZGVmYXVsdC5yZWFkKGNoZWNrRWxhcHNlZCwgdHJ1ZSk7XG4gIHJldHVybiAoKSA9PiBjYW5jZWxTeW5jLnJlYWQoY2hlY2tFbGFwc2VkKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvdHJhbnNpdGlvbnMubWpzXG5mdW5jdGlvbiBpc1RyYW5zaXRpb25EZWZpbmVkKF9hKSB7XG4gIHZhciBfYiA9IF9hLCB7IHdoZW4sIGRlbGF5OiBfZGVsYXksIGRlbGF5Q2hpbGRyZW4sIHN0YWdnZXJDaGlsZHJlbiwgc3RhZ2dlckRpcmVjdGlvbiwgcmVwZWF0LCByZXBlYXRUeXBlLCByZXBlYXREZWxheSwgZnJvbSB9ID0gX2IsIHRyYW5zaXRpb24gPSBfX29ialJlc3QoX2IsIFtcIndoZW5cIiwgXCJkZWxheVwiLCBcImRlbGF5Q2hpbGRyZW5cIiwgXCJzdGFnZ2VyQ2hpbGRyZW5cIiwgXCJzdGFnZ2VyRGlyZWN0aW9uXCIsIFwicmVwZWF0XCIsIFwicmVwZWF0VHlwZVwiLCBcInJlcGVhdERlbGF5XCIsIFwiZnJvbVwiXSk7XG4gIHJldHVybiAhIU9iamVjdC5rZXlzKHRyYW5zaXRpb24pLmxlbmd0aDtcbn1cbnZhciBsZWdhY3lSZXBlYXRXYXJuaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNpdGlvblRvQW5pbWF0aW9uT3B0aW9ucyhfYSkge1xuICB2YXIgX2IgPSBfYSwgeyBlYXNlLCB0aW1lcywgeW95bywgZmxpcCwgbG9vcCB9ID0gX2IsIHRyYW5zaXRpb24gPSBfX29ialJlc3QoX2IsIFtcImVhc2VcIiwgXCJ0aW1lc1wiLCBcInlveW9cIiwgXCJmbGlwXCIsIFwibG9vcFwiXSk7XG4gIGNvbnN0IG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdHJhbnNpdGlvbik7XG4gIGlmICh0aW1lcylcbiAgICBvcHRpb25zW1wib2Zmc2V0XCJdID0gdGltZXM7XG4gIGlmICh0cmFuc2l0aW9uLmR1cmF0aW9uKVxuICAgIG9wdGlvbnNbXCJkdXJhdGlvblwiXSA9IHNlY29uZHNUb01pbGxpc2Vjb25kcyh0cmFuc2l0aW9uLmR1cmF0aW9uKTtcbiAgaWYgKHRyYW5zaXRpb24ucmVwZWF0RGVsYXkpXG4gICAgb3B0aW9ucy5yZXBlYXREZWxheSA9IHNlY29uZHNUb01pbGxpc2Vjb25kcyh0cmFuc2l0aW9uLnJlcGVhdERlbGF5KTtcbiAgaWYgKGVhc2UpIHtcbiAgICBvcHRpb25zW1wiZWFzZVwiXSA9IGlzRWFzaW5nQXJyYXkoZWFzZSkgPyBlYXNlLm1hcChlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbikgOiBlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbihlYXNlKTtcbiAgfVxuICBpZiAodHJhbnNpdGlvbi50eXBlID09PSBcInR3ZWVuXCIpXG4gICAgb3B0aW9ucy50eXBlID0gXCJrZXlmcmFtZXNcIjtcbiAgaWYgKHlveW8gfHwgbG9vcCB8fCBmbGlwKSB7XG4gICAgd2FybmluZyghbGVnYWN5UmVwZWF0V2FybmluZywgXCJ5b3lvLCBsb29wIGFuZCBmbGlwIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIEFQSS4gUmVwbGFjZSB3aXRoIHJlcGVhdCBhbmQgcmVwZWF0VHlwZSBvcHRpb25zLlwiKTtcbiAgICBsZWdhY3lSZXBlYXRXYXJuaW5nID0gdHJ1ZTtcbiAgICBpZiAoeW95bykge1xuICAgICAgb3B0aW9ucy5yZXBlYXRUeXBlID0gXCJyZXZlcnNlXCI7XG4gICAgfSBlbHNlIGlmIChsb29wKSB7XG4gICAgICBvcHRpb25zLnJlcGVhdFR5cGUgPSBcImxvb3BcIjtcbiAgICB9IGVsc2UgaWYgKGZsaXApIHtcbiAgICAgIG9wdGlvbnMucmVwZWF0VHlwZSA9IFwibWlycm9yXCI7XG4gICAgfVxuICAgIG9wdGlvbnMucmVwZWF0ID0gbG9vcCB8fCB5b3lvIHx8IGZsaXAgfHwgdHJhbnNpdGlvbi5yZXBlYXQ7XG4gIH1cbiAgaWYgKHRyYW5zaXRpb24udHlwZSAhPT0gXCJzcHJpbmdcIilcbiAgICBvcHRpb25zLnR5cGUgPSBcImtleWZyYW1lc1wiO1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGdldERlbGF5RnJvbVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHZhbHVlVHJhbnNpdGlvbiA9IGdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHx8IHt9O1xuICByZXR1cm4gKF9iID0gKF9hID0gdmFsdWVUcmFuc2l0aW9uLmRlbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cmFuc2l0aW9uLmRlbGF5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xufVxuZnVuY3Rpb24gaHlkcmF0ZUtleWZyYW1lcyhvcHRpb25zKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudG8pICYmIG9wdGlvbnMudG9bMF0gPT09IG51bGwpIHtcbiAgICBvcHRpb25zLnRvID0gWy4uLm9wdGlvbnMudG9dO1xuICAgIG9wdGlvbnMudG9bMF0gPSBvcHRpb25zLmZyb207XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBnZXRQb3Btb3Rpb25BbmltYXRpb25PcHRpb25zKHRyYW5zaXRpb24sIG9wdGlvbnMsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnRvKSAmJiB0cmFuc2l0aW9uLmR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICB0cmFuc2l0aW9uLmR1cmF0aW9uID0gMC44O1xuICB9XG4gIGh5ZHJhdGVLZXlmcmFtZXMob3B0aW9ucyk7XG4gIGlmICghaXNUcmFuc2l0aW9uRGVmaW5lZCh0cmFuc2l0aW9uKSkge1xuICAgIHRyYW5zaXRpb24gPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdHJhbnNpdGlvbiksIGdldERlZmF1bHRUcmFuc2l0aW9uKGtleSwgb3B0aW9ucy50bykpO1xuICB9XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIGNvbnZlcnRUcmFuc2l0aW9uVG9BbmltYXRpb25PcHRpb25zKHRyYW5zaXRpb24pKTtcbn1cbmZ1bmN0aW9uIGdldEFuaW1hdGlvbihrZXksIHZhbHVlLCB0YXJnZXQsIHRyYW5zaXRpb24sIG9uQ29tcGxldGUpIHtcbiAgY29uc3QgdmFsdWVUcmFuc2l0aW9uID0gZ2V0VmFsdWVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleSkgfHwge307XG4gIGxldCBvcmlnaW4gPSB2YWx1ZVRyYW5zaXRpb24uZnJvbSAhPT0gdm9pZCAwID8gdmFsdWVUcmFuc2l0aW9uLmZyb20gOiB2YWx1ZS5nZXQoKTtcbiAgY29uc3QgaXNUYXJnZXRBbmltYXRhYmxlID0gaXNBbmltYXRhYmxlKGtleSwgdGFyZ2V0KTtcbiAgaWYgKG9yaWdpbiA9PT0gXCJub25lXCIgJiYgaXNUYXJnZXRBbmltYXRhYmxlICYmIHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBvcmlnaW4gPSBnZXRBbmltYXRhYmxlTm9uZTIoa2V5LCB0YXJnZXQpO1xuICB9IGVsc2UgaWYgKGlzWmVybyhvcmlnaW4pICYmIHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBvcmlnaW4gPSBnZXRaZXJvVW5pdCh0YXJnZXQpO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNaZXJvKHRhcmdldCkgJiYgdHlwZW9mIG9yaWdpbiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRhcmdldCA9IGdldFplcm9Vbml0KG9yaWdpbik7XG4gIH1cbiAgY29uc3QgaXNPcmlnaW5BbmltYXRhYmxlID0gaXNBbmltYXRhYmxlKGtleSwgb3JpZ2luKTtcbiAgd2FybmluZyhpc09yaWdpbkFuaW1hdGFibGUgPT09IGlzVGFyZ2V0QW5pbWF0YWJsZSwgYFlvdSBhcmUgdHJ5aW5nIHRvIGFuaW1hdGUgJHtrZXl9IGZyb20gXCIke29yaWdpbn1cIiB0byBcIiR7dGFyZ2V0fVwiLiAke29yaWdpbn0gaXMgbm90IGFuIGFuaW1hdGFibGUgdmFsdWUgLSB0byBlbmFibGUgdGhpcyBhbmltYXRpb24gc2V0ICR7b3JpZ2lufSB0byBhIHZhbHVlIGFuaW1hdGFibGUgdG8gJHt0YXJnZXR9IHZpYSB0aGUgXFxgc3R5bGVcXGAgcHJvcGVydHkuYCk7XG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBmcm9tOiBvcmlnaW4sXG4gICAgICB0bzogdGFyZ2V0LFxuICAgICAgdmVsb2NpdHk6IHZhbHVlLmdldFZlbG9jaXR5KCksXG4gICAgICBvbkNvbXBsZXRlLFxuICAgICAgb25VcGRhdGU6ICh2KSA9PiB2YWx1ZS5zZXQodilcbiAgICB9O1xuICAgIHJldHVybiB2YWx1ZVRyYW5zaXRpb24udHlwZSA9PT0gXCJpbmVydGlhXCIgfHwgdmFsdWVUcmFuc2l0aW9uLnR5cGUgPT09IFwiZGVjYXlcIiA/IGluZXJ0aWEoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB2YWx1ZVRyYW5zaXRpb24pKSA6IGFuaW1hdGUoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgZ2V0UG9wbW90aW9uQW5pbWF0aW9uT3B0aW9ucyh2YWx1ZVRyYW5zaXRpb24sIG9wdGlvbnMsIGtleSkpLCB7XG4gICAgICBvblVwZGF0ZTogKHYpID0+IHtcbiAgICAgICAgb3B0aW9ucy5vblVwZGF0ZSh2KTtcbiAgICAgICAgdmFsdWVUcmFuc2l0aW9uLm9uVXBkYXRlICYmIHZhbHVlVHJhbnNpdGlvbi5vblVwZGF0ZSh2KTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgICAgICB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSAmJiB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoKSB7XG4gICAgY29uc3QgZmluYWxUYXJnZXQgPSByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzKHRhcmdldCk7XG4gICAgdmFsdWUuc2V0KGZpbmFsVGFyZ2V0KTtcbiAgICBvbkNvbXBsZXRlKCk7XG4gICAgdmFsdWVUcmFuc2l0aW9uLm9uVXBkYXRlICYmIHZhbHVlVHJhbnNpdGlvbi5vblVwZGF0ZShmaW5hbFRhcmdldCk7XG4gICAgdmFsdWVUcmFuc2l0aW9uLm9uQ29tcGxldGUgJiYgdmFsdWVUcmFuc2l0aW9uLm9uQ29tcGxldGUoKTtcbiAgICByZXR1cm4geyBzdG9wOiAoKSA9PiB7XG4gICAgfSB9O1xuICB9XG4gIHJldHVybiAhaXNPcmlnaW5BbmltYXRhYmxlIHx8ICFpc1RhcmdldEFuaW1hdGFibGUgfHwgdmFsdWVUcmFuc2l0aW9uLnR5cGUgPT09IGZhbHNlID8gc2V0IDogc3RhcnQ7XG59XG5mdW5jdGlvbiBpc1plcm8odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBwYXJzZUZsb2F0KHZhbHVlKSA9PT0gMCAmJiB2YWx1ZS5pbmRleE9mKFwiIFwiKSA9PT0gLTE7XG59XG5mdW5jdGlvbiBnZXRaZXJvVW5pdChwb3RlbnRpYWxVbml0VHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHBvdGVudGlhbFVuaXRUeXBlID09PSBcIm51bWJlclwiID8gMCA6IGdldEFuaW1hdGFibGVOb25lMihcIlwiLCBwb3RlbnRpYWxVbml0VHlwZSk7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB7XG4gIHJldHVybiB0cmFuc2l0aW9uW2tleV0gfHwgdHJhbnNpdGlvbltcImRlZmF1bHRcIl0gfHwgdHJhbnNpdGlvbjtcbn1cbmZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbiA9IHt9KSB7XG4gIGlmIChpbnN0YW50QW5pbWF0aW9uU3RhdGUuY3VycmVudCkge1xuICAgIHRyYW5zaXRpb24gPSB7IHR5cGU6IGZhbHNlIH07XG4gIH1cbiAgcmV0dXJuIHZhbHVlLnN0YXJ0KChvbkNvbXBsZXRlKSA9PiB7XG4gICAgbGV0IGNvbnRyb2xzO1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGdldEFuaW1hdGlvbihrZXksIHZhbHVlLCB0YXJnZXQsIHRyYW5zaXRpb24sIG9uQ29tcGxldGUpO1xuICAgIGNvbnN0IGRlbGF5QnkgPSBnZXREZWxheUZyb21UcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleSk7XG4gICAgY29uc3Qgc3RhcnQgPSAoKSA9PiBjb250cm9scyA9IGFuaW1hdGlvbigpO1xuICAgIGxldCBjYW5jZWxEZWxheTtcbiAgICBpZiAoZGVsYXlCeSkge1xuICAgICAgY2FuY2VsRGVsYXkgPSBkZWxheShzdGFydCwgc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGRlbGF5QnkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbERlbGF5ICYmIGNhbmNlbERlbGF5KCk7XG4gICAgICBjb250cm9scyAmJiBjb250cm9scy5zdG9wKCk7XG4gICAgfTtcbiAgfSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtbnVtZXJpY2FsLXN0cmluZy5tanNcbnZhciBpc051bWVyaWNhbFN0cmluZyA9ICh2KSA9PiAvXlxcLT9cXGQqXFwuP1xcZCskLy50ZXN0KHYpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLXplcm8tdmFsdWUtc3RyaW5nLm1qc1xudmFyIGlzWmVyb1ZhbHVlU3RyaW5nID0gKHYpID0+IC9eMFteLlxcc10rJC8udGVzdCh2KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9hcnJheS5tanNcbmZ1bmN0aW9uIGFkZFVuaXF1ZUl0ZW0oYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIuaW5kZXhPZihpdGVtKSA9PT0gLTEpXG4gICAgYXJyLnB1c2goaXRlbSk7XG59XG5mdW5jdGlvbiByZW1vdmVJdGVtKGFyciwgaXRlbSkge1xuICBjb25zdCBpbmRleDIgPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGluZGV4MiA+IC0xKVxuICAgIGFyci5zcGxpY2UoaW5kZXgyLCAxKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9zdWJzY3JpcHRpb24tbWFuYWdlci5tanNcbnZhciBTdWJzY3JpcHRpb25NYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgfVxuICBhZGQoaGFuZGxlcikge1xuICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5zdWJzY3JpcHRpb25zLCBoYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4gcmVtb3ZlSXRlbSh0aGlzLnN1YnNjcmlwdGlvbnMsIGhhbmRsZXIpO1xuICB9XG4gIG5vdGlmeShhMiwgYjIsIGMzKSB7XG4gICAgY29uc3QgbnVtU3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgaWYgKCFudW1TdWJzY3JpcHRpb25zKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChudW1TdWJzY3JpcHRpb25zID09PSAxKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbMF0oYTIsIGIyLCBjMyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1TdWJzY3JpcHRpb25zOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLnN1YnNjcmlwdGlvbnNbaTJdO1xuICAgICAgICBoYW5kbGVyICYmIGhhbmRsZXIoYTIsIGIyLCBjMyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvaW5kZXgubWpzXG52YXIgaXNGbG9hdCA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbn07XG52YXIgTW90aW9uVmFsdWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGluaXQpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBcIjcuNi43XCI7XG4gICAgdGhpcy50aW1lRGVsdGEgPSAwO1xuICAgIHRoaXMubGFzdFVwZGF0ZWQgPSAwO1xuICAgIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgIHRoaXMudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycyA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgdGhpcy5yZW5kZXJTdWJzY3JpYmVycyA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgdGhpcy5jYW5UcmFja1ZlbG9jaXR5ID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVBbmROb3RpZnkgPSAodiwgcmVuZGVyID0gdHJ1ZSkgPT4ge1xuICAgICAgdGhpcy5wcmV2ID0gdGhpcy5jdXJyZW50O1xuICAgICAgdGhpcy5jdXJyZW50ID0gdjtcbiAgICAgIGNvbnN0IHsgZGVsdGEsIHRpbWVzdGFtcCB9ID0gZ2V0RnJhbWVEYXRhKCk7XG4gICAgICBpZiAodGhpcy5sYXN0VXBkYXRlZCAhPT0gdGltZXN0YW1wKSB7XG4gICAgICAgIHRoaXMudGltZURlbHRhID0gZGVsdGE7XG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZWQgPSB0aW1lc3RhbXA7XG4gICAgICAgIGVzX2RlZmF1bHQucG9zdFJlbmRlcih0aGlzLnNjaGVkdWxlVmVsb2NpdHlDaGVjayk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmV2ICE9PSB0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpYmVycy5ub3RpZnkodGhpcy5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMuZ2V0U2l6ZSgpKSB7XG4gICAgICAgIHRoaXMudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5ub3RpZnkodGhpcy5nZXRWZWxvY2l0eSgpKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZW5kZXIpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5ub3RpZnkodGhpcy5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2NoZWR1bGVWZWxvY2l0eUNoZWNrID0gKCkgPT4gZXNfZGVmYXVsdC5wb3N0UmVuZGVyKHRoaXMudmVsb2NpdHlDaGVjayk7XG4gICAgdGhpcy52ZWxvY2l0eUNoZWNrID0gKHsgdGltZXN0YW1wIH0pID0+IHtcbiAgICAgIGlmICh0aW1lc3RhbXAgIT09IHRoaXMubGFzdFVwZGF0ZWQpIHtcbiAgICAgICAgdGhpcy5wcmV2ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICB0aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMubm90aWZ5KHRoaXMuZ2V0VmVsb2NpdHkoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2ID0gdGhpcy5jdXJyZW50ID0gaW5pdDtcbiAgICB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPSBpc0Zsb2F0KHRoaXMuY3VycmVudCk7XG4gIH1cbiAgb25DaGFuZ2Uoc3Vic2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuYWRkKHN1YnNjcmlwdGlvbik7XG4gIH1cbiAgY2xlYXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy51cGRhdGVTdWJzY3JpYmVycy5jbGVhcigpO1xuICB9XG4gIG9uUmVuZGVyUmVxdWVzdChzdWJzY3JpcHRpb24pIHtcbiAgICBzdWJzY3JpcHRpb24odGhpcy5nZXQoKSk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyU3Vic2NyaWJlcnMuYWRkKHN1YnNjcmlwdGlvbik7XG4gIH1cbiAgYXR0YWNoKHBhc3NpdmVFZmZlY3QpIHtcbiAgICB0aGlzLnBhc3NpdmVFZmZlY3QgPSBwYXNzaXZlRWZmZWN0O1xuICB9XG4gIHNldCh2LCByZW5kZXIgPSB0cnVlKSB7XG4gICAgaWYgKCFyZW5kZXIgfHwgIXRoaXMucGFzc2l2ZUVmZmVjdCkge1xuICAgICAgdGhpcy51cGRhdGVBbmROb3RpZnkodiwgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0KHYsIHRoaXMudXBkYXRlQW5kTm90aWZ5KTtcbiAgICB9XG4gIH1cbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gIH1cbiAgZ2V0UHJldmlvdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJldjtcbiAgfVxuICBnZXRWZWxvY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5UcmFja1ZlbG9jaXR5ID8gdmVsb2NpdHlQZXJTZWNvbmQocGFyc2VGbG9hdCh0aGlzLmN1cnJlbnQpIC0gcGFyc2VGbG9hdCh0aGlzLnByZXYpLCB0aGlzLnRpbWVEZWx0YSkgOiAwO1xuICB9XG4gIHN0YXJ0KGFuaW1hdGlvbikge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5oYXNBbmltYXRlZCA9IHRydWU7XG4gICAgICB0aGlzLnN0b3BBbmltYXRpb24gPSBhbmltYXRpb24ocmVzb2x2ZSk7XG4gICAgfSkudGhlbigoKSA9PiB0aGlzLmNsZWFyQW5pbWF0aW9uKCkpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuc3RvcEFuaW1hdGlvbilcbiAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgIHRoaXMuY2xlYXJBbmltYXRpb24oKTtcbiAgfVxuICBpc0FuaW1hdGluZygpIHtcbiAgICByZXR1cm4gISF0aGlzLnN0b3BBbmltYXRpb247XG4gIH1cbiAgY2xlYXJBbmltYXRpb24oKSB7XG4gICAgdGhpcy5zdG9wQW5pbWF0aW9uID0gbnVsbDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICB0aGlzLnJlbmRlclN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5zdG9wKCk7XG4gIH1cbn07XG5mdW5jdGlvbiBtb3Rpb25WYWx1ZShpbml0KSB7XG4gIHJldHVybiBuZXcgTW90aW9uVmFsdWUoaW5pdCk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy90ZXN0Lm1qc1xudmFyIHRlc3RWYWx1ZVR5cGUgPSAodikgPT4gKHR5cGUpID0+IHR5cGUudGVzdCh2KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3R5cGUtYXV0by5tanNcbnZhciBhdXRvID0ge1xuICB0ZXN0OiAodikgPT4gdiA9PT0gXCJhdXRvXCIsXG4gIHBhcnNlOiAodikgPT4gdlxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL2RpbWVuc2lvbnMubWpzXG52YXIgZGltZW5zaW9uVmFsdWVUeXBlcyA9IFtudW1iZXIsIHB4LCBwZXJjZW50LCBkZWdyZWVzLCB2dywgdmgsIGF1dG9dO1xudmFyIGZpbmREaW1lbnNpb25WYWx1ZVR5cGUgPSAodikgPT4gZGltZW5zaW9uVmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZmluZC5tanNcbnZhciB2YWx1ZVR5cGVzID0gWy4uLmRpbWVuc2lvblZhbHVlVHlwZXMsIGNvbG9yLCBjb21wbGV4XTtcbnZhciBmaW5kVmFsdWVUeXBlID0gKHYpID0+IHZhbHVlVHlwZXMuZmluZCh0ZXN0VmFsdWVUeXBlKHYpKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvcmVzb2x2ZS1keW5hbWljLXZhcmlhbnRzLm1qc1xuZnVuY3Rpb24gZ2V0Q3VycmVudCh2aXN1YWxFbGVtZW50KSB7XG4gIGNvbnN0IGN1cnJlbnQgPSB7fTtcbiAgdmlzdWFsRWxlbWVudC52YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gY3VycmVudFtrZXldID0gdmFsdWUuZ2V0KCkpO1xuICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KHZpc3VhbEVsZW1lbnQpIHtcbiAgY29uc3QgdmVsb2NpdHkgPSB7fTtcbiAgdmlzdWFsRWxlbWVudC52YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdmVsb2NpdHlba2V5XSA9IHZhbHVlLmdldFZlbG9jaXR5KCkpO1xuICByZXR1cm4gdmVsb2NpdHk7XG59XG5mdW5jdGlvbiByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBjdXN0b20pIHtcbiAgY29uc3QgcHJvcHMgPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gIHJldHVybiByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyhwcm9wcywgZGVmaW5pdGlvbiwgY3VzdG9tICE9PSB2b2lkIDAgPyBjdXN0b20gOiBwcm9wcy5jdXN0b20sIGdldEN1cnJlbnQodmlzdWFsRWxlbWVudCksIGdldFZlbG9jaXR5KHZpc3VhbEVsZW1lbnQpKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvc2V0dGVycy5tanNcbmZ1bmN0aW9uIHNldE1vdGlvblZhbHVlKHZpc3VhbEVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgaWYgKHZpc3VhbEVsZW1lbnQuaGFzVmFsdWUoa2V5KSkge1xuICAgIHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KS5zZXQodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZpc3VhbEVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZSh2YWx1ZSkpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbikge1xuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICBsZXQgX2EgPSByZXNvbHZlZCA/IHZpc3VhbEVsZW1lbnQubWFrZVRhcmdldEFuaW1hdGFibGUocmVzb2x2ZWQsIGZhbHNlKSA6IHt9LCB7IHRyYW5zaXRpb25FbmQgPSB7fSwgdHJhbnNpdGlvbiA9IHt9IH0gPSBfYSwgdGFyZ2V0ID0gX19vYmpSZXN0KF9hLCBbXCJ0cmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvblwiXSk7XG4gIHRhcmdldCA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0YXJnZXQpLCB0cmFuc2l0aW9uRW5kKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgY29uc3QgdmFsdWUgPSByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzKHRhcmdldFtrZXldKTtcbiAgICBzZXRNb3Rpb25WYWx1ZSh2aXN1YWxFbGVtZW50LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXModmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4pIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgbmV3VmFsdWVLZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KS5maWx0ZXIoKGtleSkgPT4gIXZpc3VhbEVsZW1lbnQuaGFzVmFsdWUoa2V5KSk7XG4gIGNvbnN0IG51bU5ld1ZhbHVlcyA9IG5ld1ZhbHVlS2V5cy5sZW5ndGg7XG4gIGlmICghbnVtTmV3VmFsdWVzKVxuICAgIHJldHVybjtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bU5ld1ZhbHVlczsgaTIrKykge1xuICAgIGNvbnN0IGtleSA9IG5ld1ZhbHVlS2V5c1tpMl07XG4gICAgY29uc3QgdGFyZ2V0VmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldFZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB0YXJnZXRWYWx1ZVswXTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IChfYiA9IChfYSA9IG9yaWdpbltrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2aXN1YWxFbGVtZW50LnJlYWRWYWx1ZShrZXkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0YXJnZXRba2V5XTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIChpc051bWVyaWNhbFN0cmluZyh2YWx1ZSkgfHwgaXNaZXJvVmFsdWVTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCFmaW5kVmFsdWVUeXBlKHZhbHVlKSAmJiBjb21wbGV4LnRlc3QodGFyZ2V0VmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IGdldEFuaW1hdGFibGVOb25lMihrZXksIHRhcmdldFZhbHVlKTtcbiAgICB9XG4gICAgdmlzdWFsRWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKHZhbHVlKSk7XG4gICAgaWYgKG9yaWdpbltrZXldID09PSB2b2lkIDApIHtcbiAgICAgIG9yaWdpbltrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbClcbiAgICAgIHZpc3VhbEVsZW1lbnQuc2V0QmFzZVRhcmdldChrZXksIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3JpZ2luRnJvbVRyYW5zaXRpb24oa2V5LCB0cmFuc2l0aW9uKSB7XG4gIGlmICghdHJhbnNpdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IHZhbHVlVHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSB8fCB0cmFuc2l0aW9uW1wiZGVmYXVsdFwiXSB8fCB0cmFuc2l0aW9uO1xuICByZXR1cm4gdmFsdWVUcmFuc2l0aW9uLmZyb207XG59XG5mdW5jdGlvbiBnZXRPcmlnaW4odGFyZ2V0LCB0cmFuc2l0aW9uLCB2aXN1YWxFbGVtZW50KSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgb3JpZ2luID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgIGNvbnN0IHRyYW5zaXRpb25PcmlnaW4gPSBnZXRPcmlnaW5Gcm9tVHJhbnNpdGlvbihrZXksIHRyYW5zaXRpb24pO1xuICAgIG9yaWdpbltrZXldID0gdHJhbnNpdGlvbk9yaWdpbiAhPT0gdm9pZCAwID8gdHJhbnNpdGlvbk9yaWdpbiA6IChfYSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldCgpO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLXdpbGwtY2hhbmdlL2lzLm1qc1xuZnVuY3Rpb24gaXNXaWxsQ2hhbmdlTW90aW9uVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4oaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgJiYgdmFsdWUuYWRkKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvYW5pbWF0aW9uLm1qc1xuZnVuY3Rpb24gYW5pbWF0ZVZpc3VhbEVsZW1lbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gIHZpc3VhbEVsZW1lbnQubm90aWZ5KFwiQW5pbWF0aW9uU3RhcnRcIiwgZGVmaW5pdGlvbik7XG4gIGxldCBhbmltYXRpb247XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgY29uc3QgYW5pbWF0aW9uczIgPSBkZWZpbml0aW9uLm1hcCgodmFyaWFudCkgPT4gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucykpO1xuICAgIGFuaW1hdGlvbiA9IFByb21pc2UuYWxsKGFuaW1hdGlvbnMyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgIGFuaW1hdGlvbiA9IGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlc29sdmVkRGVmaW5pdGlvbiA9IHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIgPyByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zLmN1c3RvbSkgOiBkZWZpbml0aW9uO1xuICAgIGFuaW1hdGlvbiA9IGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudCwgcmVzb2x2ZWREZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gYW5pbWF0aW9uLnRoZW4oKCkgPT4gdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJBbmltYXRpb25Db21wbGV0ZVwiLCBkZWZpbml0aW9uKSk7XG59XG5mdW5jdGlvbiBhbmltYXRlVmFyaWFudCh2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hO1xuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMuY3VzdG9tKTtcbiAgbGV0IHsgdHJhbnNpdGlvbiA9IHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSB8fCB7fSB9ID0gcmVzb2x2ZWQgfHwge307XG4gIGlmIChvcHRpb25zLnRyYW5zaXRpb25PdmVycmlkZSkge1xuICAgIHRyYW5zaXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb25PdmVycmlkZTtcbiAgfVxuICBjb25zdCBnZXRBbmltYXRpb24yID0gcmVzb2x2ZWQgPyAoKSA9PiBhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHJlc29sdmVkLCBvcHRpb25zKSA6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICBjb25zdCBnZXRDaGlsZEFuaW1hdGlvbnMgPSAoKF9hID0gdmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplKSA/IChmb3J3YXJkRGVsYXkgPSAwKSA9PiB7XG4gICAgY29uc3QgeyBkZWxheUNoaWxkcmVuID0gMCwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uIH0gPSB0cmFuc2l0aW9uO1xuICAgIHJldHVybiBhbmltYXRlQ2hpbGRyZW4odmlzdWFsRWxlbWVudCwgdmFyaWFudCwgZGVsYXlDaGlsZHJlbiArIGZvcndhcmREZWxheSwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgfSA6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICBjb25zdCB7IHdoZW4gfSA9IHRyYW5zaXRpb247XG4gIGlmICh3aGVuKSB7XG4gICAgY29uc3QgW2ZpcnN0LCBsYXN0XSA9IHdoZW4gPT09IFwiYmVmb3JlQ2hpbGRyZW5cIiA/IFtnZXRBbmltYXRpb24yLCBnZXRDaGlsZEFuaW1hdGlvbnNdIDogW2dldENoaWxkQW5pbWF0aW9ucywgZ2V0QW5pbWF0aW9uMl07XG4gICAgcmV0dXJuIGZpcnN0KCkudGhlbihsYXN0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2dldEFuaW1hdGlvbjIoKSwgZ2V0Q2hpbGRBbmltYXRpb25zKG9wdGlvbnMuZGVsYXkpXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgeyBkZWxheTogZGVsYXkyID0gMCwgdHJhbnNpdGlvbk92ZXJyaWRlLCB0eXBlIH0gPSB7fSkge1xuICB2YXIgX2E7XG4gIGxldCBfYTIgPSB2aXN1YWxFbGVtZW50Lm1ha2VUYXJnZXRBbmltYXRhYmxlKGRlZmluaXRpb24pLCB7IHRyYW5zaXRpb24gPSB2aXN1YWxFbGVtZW50LmdldERlZmF1bHRUcmFuc2l0aW9uKCksIHRyYW5zaXRpb25FbmQgfSA9IF9hMiwgdGFyZ2V0ID0gX19vYmpSZXN0KF9hMiwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xuICBjb25zdCB3aWxsQ2hhbmdlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShcIndpbGxDaGFuZ2VcIik7XG4gIGlmICh0cmFuc2l0aW9uT3ZlcnJpZGUpXG4gICAgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb25PdmVycmlkZTtcbiAgY29uc3QgYW5pbWF0aW9uczIgPSBbXTtcbiAgY29uc3QgYW5pbWF0aW9uVHlwZVN0YXRlID0gdHlwZSAmJiAoKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRlKClbdHlwZV0pO1xuICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICBjb25zdCB2YWx1ZVRhcmdldCA9IHRhcmdldFtrZXldO1xuICAgIGlmICghdmFsdWUgfHwgdmFsdWVUYXJnZXQgPT09IHZvaWQgMCB8fCBhbmltYXRpb25UeXBlU3RhdGUgJiYgc2hvdWxkQmxvY2tBbmltYXRpb24oYW5pbWF0aW9uVHlwZVN0YXRlLCBrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHZhbHVlVHJhbnNpdGlvbiA9IF9fc3ByZWFkVmFsdWVzKHsgZGVsYXk6IGRlbGF5MiB9LCB0cmFuc2l0aW9uKTtcbiAgICBpZiAodmlzdWFsRWxlbWVudC5zaG91bGRSZWR1Y2VNb3Rpb24gJiYgdHJhbnNmb3JtUHJvcHMuaGFzKGtleSkpIHtcbiAgICAgIHZhbHVlVHJhbnNpdGlvbiA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHZhbHVlVHJhbnNpdGlvbiksIHtcbiAgICAgICAgdHlwZTogZmFsc2UsXG4gICAgICAgIGRlbGF5OiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGFuaW1hdGlvbiA9IHN0YXJ0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHZhbHVlVGFyZ2V0LCB2YWx1ZVRyYW5zaXRpb24pO1xuICAgIGlmIChpc1dpbGxDaGFuZ2VNb3Rpb25WYWx1ZSh3aWxsQ2hhbmdlKSkge1xuICAgICAgd2lsbENoYW5nZS5hZGQoa2V5KTtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi50aGVuKCgpID0+IHdpbGxDaGFuZ2UucmVtb3ZlKGtleSkpO1xuICAgIH1cbiAgICBhbmltYXRpb25zMi5wdXNoKGFuaW1hdGlvbik7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKGFuaW1hdGlvbnMyKS50aGVuKCgpID0+IHtcbiAgICB0cmFuc2l0aW9uRW5kICYmIHNldFRhcmdldCh2aXN1YWxFbGVtZW50LCB0cmFuc2l0aW9uRW5kKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhbmltYXRlQ2hpbGRyZW4odmlzdWFsRWxlbWVudCwgdmFyaWFudCwgZGVsYXlDaGlsZHJlbiA9IDAsIHN0YWdnZXJDaGlsZHJlbiA9IDAsIHN0YWdnZXJEaXJlY3Rpb24gPSAxLCBvcHRpb25zKSB7XG4gIGNvbnN0IGFuaW1hdGlvbnMyID0gW107XG4gIGNvbnN0IG1heFN0YWdnZXJEdXJhdGlvbiA9ICh2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbi5zaXplIC0gMSkgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gIGNvbnN0IGdlbmVyYXRlU3RhZ2dlckR1cmF0aW9uID0gc3RhZ2dlckRpcmVjdGlvbiA9PT0gMSA/IChpMiA9IDApID0+IGkyICogc3RhZ2dlckNoaWxkcmVuIDogKGkyID0gMCkgPT4gbWF4U3RhZ2dlckR1cmF0aW9uIC0gaTIgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gIEFycmF5LmZyb20odmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pLnNvcnQoc29ydEJ5VHJlZU9yZGVyKS5mb3JFYWNoKChjaGlsZCwgaTIpID0+IHtcbiAgICBhbmltYXRpb25zMi5wdXNoKGFuaW1hdGVWYXJpYW50KGNoaWxkLCB2YXJpYW50LCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgZGVsYXk6IGRlbGF5Q2hpbGRyZW4gKyBnZW5lcmF0ZVN0YWdnZXJEdXJhdGlvbihpMilcbiAgICB9KSkudGhlbigoKSA9PiBjaGlsZC5ub3RpZnkoXCJBbmltYXRpb25Db21wbGV0ZVwiLCB2YXJpYW50KSkpO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGFuaW1hdGlvbnMyKTtcbn1cbmZ1bmN0aW9uIHNvcnRCeVRyZWVPcmRlcihhMiwgYjIpIHtcbiAgcmV0dXJuIGEyLnNvcnROb2RlUG9zaXRpb24oYjIpO1xufVxuZnVuY3Rpb24gc2hvdWxkQmxvY2tBbmltYXRpb24oeyBwcm90ZWN0ZWRLZXlzLCBuZWVkc0FuaW1hdGluZyB9LCBrZXkpIHtcbiAgY29uc3Qgc2hvdWxkQmxvY2sgPSBwcm90ZWN0ZWRLZXlzLmhhc093blByb3BlcnR5KGtleSkgJiYgbmVlZHNBbmltYXRpbmdba2V5XSAhPT0gdHJ1ZTtcbiAgbmVlZHNBbmltYXRpbmdba2V5XSA9IGZhbHNlO1xuICByZXR1cm4gc2hvdWxkQmxvY2s7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2FuaW1hdGlvbi1zdGF0ZS5tanNcbnZhciB2YXJpYW50UHJpb3JpdHlPcmRlciA9IFtcbiAgQW5pbWF0aW9uVHlwZS5BbmltYXRlLFxuICBBbmltYXRpb25UeXBlLkluVmlldyxcbiAgQW5pbWF0aW9uVHlwZS5Gb2N1cyxcbiAgQW5pbWF0aW9uVHlwZS5Ib3ZlcixcbiAgQW5pbWF0aW9uVHlwZS5UYXAsXG4gIEFuaW1hdGlvblR5cGUuRHJhZyxcbiAgQW5pbWF0aW9uVHlwZS5FeGl0XG5dO1xudmFyIHJldmVyc2VQcmlvcml0eU9yZGVyID0gWy4uLnZhcmlhbnRQcmlvcml0eU9yZGVyXS5yZXZlcnNlKCk7XG52YXIgbnVtQW5pbWF0aW9uVHlwZXMgPSB2YXJpYW50UHJpb3JpdHlPcmRlci5sZW5ndGg7XG5mdW5jdGlvbiBhbmltYXRlTGlzdCh2aXN1YWxFbGVtZW50KSB7XG4gIHJldHVybiAoYW5pbWF0aW9uczIpID0+IFByb21pc2UuYWxsKGFuaW1hdGlvbnMyLm1hcCgoeyBhbmltYXRpb24sIG9wdGlvbnMgfSkgPT4gYW5pbWF0ZVZpc3VhbEVsZW1lbnQodmlzdWFsRWxlbWVudCwgYW5pbWF0aW9uLCBvcHRpb25zKSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9uU3RhdGUodmlzdWFsRWxlbWVudCkge1xuICBsZXQgYW5pbWF0ZTMgPSBhbmltYXRlTGlzdCh2aXN1YWxFbGVtZW50KTtcbiAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdGF0ZSgpO1xuICBsZXQgaXNJbml0aWFsUmVuZGVyID0gdHJ1ZTtcbiAgY29uc3QgYnVpbGRSZXNvbHZlZFR5cGVWYWx1ZXMgPSAoYWNjLCBkZWZpbml0aW9uKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgIGNvbnN0IF9hID0gcmVzb2x2ZWQsIHsgdHJhbnNpdGlvbiwgdHJhbnNpdGlvbkVuZCB9ID0gX2EsIHRhcmdldCA9IF9fb2JqUmVzdChfYSwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xuICAgICAgYWNjID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGFjYyksIHRhcmdldCksIHRyYW5zaXRpb25FbmQpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9O1xuICBmdW5jdGlvbiBzZXRBbmltYXRlRnVuY3Rpb24obWFrZUFuaW1hdG9yKSB7XG4gICAgYW5pbWF0ZTMgPSBtYWtlQW5pbWF0b3IodmlzdWFsRWxlbWVudCk7XG4gIH1cbiAgZnVuY3Rpb24gYW5pbWF0ZUNoYW5nZXMob3B0aW9ucywgY2hhbmdlZEFjdGl2ZVR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcHJvcHMgPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgY29uc3QgY29udGV4dCA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFyaWFudENvbnRleHQodHJ1ZSkgfHwge307XG4gICAgY29uc3QgYW5pbWF0aW9uczIgPSBbXTtcbiAgICBjb25zdCByZW1vdmVkS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGVuY291bnRlcmVkS2V5cyA9IHt9O1xuICAgIGxldCByZW1vdmVkVmFyaWFudEluZGV4ID0gSW5maW5pdHk7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bUFuaW1hdGlvblR5cGVzOyBpMisrKSB7XG4gICAgICBjb25zdCB0eXBlID0gcmV2ZXJzZVByaW9yaXR5T3JkZXJbaTJdO1xuICAgICAgY29uc3QgdHlwZVN0YXRlID0gc3RhdGVbdHlwZV07XG4gICAgICBjb25zdCBwcm9wID0gKF9hID0gcHJvcHNbdHlwZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRleHRbdHlwZV07XG4gICAgICBjb25zdCBwcm9wSXNWYXJpYW50ID0gaXNWYXJpYW50TGFiZWwocHJvcCk7XG4gICAgICBjb25zdCBhY3RpdmVEZWx0YSA9IHR5cGUgPT09IGNoYW5nZWRBY3RpdmVUeXBlID8gdHlwZVN0YXRlLmlzQWN0aXZlIDogbnVsbDtcbiAgICAgIGlmIChhY3RpdmVEZWx0YSA9PT0gZmFsc2UpXG4gICAgICAgIHJlbW92ZWRWYXJpYW50SW5kZXggPSBpMjtcbiAgICAgIGxldCBpc0luaGVyaXRlZCA9IHByb3AgPT09IGNvbnRleHRbdHlwZV0gJiYgcHJvcCAhPT0gcHJvcHNbdHlwZV0gJiYgcHJvcElzVmFyaWFudDtcbiAgICAgIGlmIChpc0luaGVyaXRlZCAmJiBpc0luaXRpYWxSZW5kZXIgJiYgdmlzdWFsRWxlbWVudC5tYW51YWxseUFuaW1hdGVPbk1vdW50KSB7XG4gICAgICAgIGlzSW5oZXJpdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0eXBlU3RhdGUucHJvdGVjdGVkS2V5cyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBlbmNvdW50ZXJlZEtleXMpO1xuICAgICAgaWYgKCF0eXBlU3RhdGUuaXNBY3RpdmUgJiYgYWN0aXZlRGVsdGEgPT09IG51bGwgfHwgIXByb3AgJiYgIXR5cGVTdGF0ZS5wcmV2UHJvcCB8fCBpc0FuaW1hdGlvbkNvbnRyb2xzKHByb3ApIHx8IHR5cGVvZiBwcm9wID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhcmlhbnREaWRDaGFuZ2UgPSBjaGVja1ZhcmlhbnRzRGlkQ2hhbmdlKHR5cGVTdGF0ZS5wcmV2UHJvcCwgcHJvcCk7XG4gICAgICBsZXQgc2hvdWxkQW5pbWF0ZVR5cGUgPSB2YXJpYW50RGlkQ2hhbmdlIHx8IHR5cGUgPT09IGNoYW5nZWRBY3RpdmVUeXBlICYmIHR5cGVTdGF0ZS5pc0FjdGl2ZSAmJiAhaXNJbmhlcml0ZWQgJiYgcHJvcElzVmFyaWFudCB8fCBpMiA+IHJlbW92ZWRWYXJpYW50SW5kZXggJiYgcHJvcElzVmFyaWFudDtcbiAgICAgIGNvbnN0IGRlZmluaXRpb25MaXN0ID0gQXJyYXkuaXNBcnJheShwcm9wKSA/IHByb3AgOiBbcHJvcF07XG4gICAgICBsZXQgcmVzb2x2ZWRWYWx1ZXMgPSBkZWZpbml0aW9uTGlzdC5yZWR1Y2UoYnVpbGRSZXNvbHZlZFR5cGVWYWx1ZXMsIHt9KTtcbiAgICAgIGlmIChhY3RpdmVEZWx0YSA9PT0gZmFsc2UpXG4gICAgICAgIHJlc29sdmVkVmFsdWVzID0ge307XG4gICAgICBjb25zdCB7IHByZXZSZXNvbHZlZFZhbHVlcyA9IHt9IH0gPSB0eXBlU3RhdGU7XG4gICAgICBjb25zdCBhbGxLZXlzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHByZXZSZXNvbHZlZFZhbHVlcyksIHJlc29sdmVkVmFsdWVzKTtcbiAgICAgIGNvbnN0IG1hcmtUb0FuaW1hdGUgPSAoa2V5KSA9PiB7XG4gICAgICAgIHNob3VsZEFuaW1hdGVUeXBlID0gdHJ1ZTtcbiAgICAgICAgcmVtb3ZlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgIHR5cGVTdGF0ZS5uZWVkc0FuaW1hdGluZ1trZXldID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSByZXNvbHZlZFZhbHVlc1trZXldO1xuICAgICAgICBjb25zdCBwcmV2ID0gcHJldlJlc29sdmVkVmFsdWVzW2tleV07XG4gICAgICAgIGlmIChlbmNvdW50ZXJlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKG5leHQgIT09IHByZXYpIHtcbiAgICAgICAgICBpZiAoaXNLZXlmcmFtZXNUYXJnZXQobmV4dCkgJiYgaXNLZXlmcmFtZXNUYXJnZXQocHJldikpIHtcbiAgICAgICAgICAgIGlmICghc2hhbGxvd0NvbXBhcmUobmV4dCwgcHJldikgfHwgdmFyaWFudERpZENoYW5nZSkge1xuICAgICAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0eXBlU3RhdGUucHJvdGVjdGVkS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbWFya1RvQW5pbWF0ZShrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVkS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dCAhPT0gdm9pZCAwICYmIHJlbW92ZWRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgbWFya1RvQW5pbWF0ZShrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGVTdGF0ZS5wcm90ZWN0ZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0eXBlU3RhdGUucHJldlByb3AgPSBwcm9wO1xuICAgICAgdHlwZVN0YXRlLnByZXZSZXNvbHZlZFZhbHVlcyA9IHJlc29sdmVkVmFsdWVzO1xuICAgICAgaWYgKHR5cGVTdGF0ZS5pc0FjdGl2ZSkge1xuICAgICAgICBlbmNvdW50ZXJlZEtleXMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZW5jb3VudGVyZWRLZXlzKSwgcmVzb2x2ZWRWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGlzSW5pdGlhbFJlbmRlciAmJiB2aXN1YWxFbGVtZW50LmJsb2NrSW5pdGlhbEFuaW1hdGlvbikge1xuICAgICAgICBzaG91bGRBbmltYXRlVHlwZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEFuaW1hdGVUeXBlICYmICFpc0luaGVyaXRlZCkge1xuICAgICAgICBhbmltYXRpb25zMi5wdXNoKC4uLmRlZmluaXRpb25MaXN0Lm1hcCgoYW5pbWF0aW9uKSA9PiAoe1xuICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICBvcHRpb25zOiBfX3NwcmVhZFZhbHVlcyh7IHR5cGUgfSwgb3B0aW9ucylcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlbW92ZWRLZXlzLnNpemUpIHtcbiAgICAgIGNvbnN0IGZhbGxiYWNrQW5pbWF0aW9uID0ge307XG4gICAgICByZW1vdmVkS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tUYXJnZXQgPSB2aXN1YWxFbGVtZW50LmdldEJhc2VUYXJnZXQoa2V5KTtcbiAgICAgICAgaWYgKGZhbGxiYWNrVGFyZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBmYWxsYmFja0FuaW1hdGlvbltrZXldID0gZmFsbGJhY2tUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYW5pbWF0aW9uczIucHVzaCh7IGFuaW1hdGlvbjogZmFsbGJhY2tBbmltYXRpb24gfSk7XG4gICAgfVxuICAgIGxldCBzaG91bGRBbmltYXRlID0gQm9vbGVhbihhbmltYXRpb25zMi5sZW5ndGgpO1xuICAgIGlmIChpc0luaXRpYWxSZW5kZXIgJiYgcHJvcHMuaW5pdGlhbCA9PT0gZmFsc2UgJiYgIXZpc3VhbEVsZW1lbnQubWFudWFsbHlBbmltYXRlT25Nb3VudCkge1xuICAgICAgc2hvdWxkQW5pbWF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpc0luaXRpYWxSZW5kZXIgPSBmYWxzZTtcbiAgICByZXR1cm4gc2hvdWxkQW5pbWF0ZSA/IGFuaW1hdGUzKGFuaW1hdGlvbnMyKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHNldEFjdGl2ZSh0eXBlLCBpc0FjdGl2ZSwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoc3RhdGVbdHlwZV0uaXNBY3RpdmUgPT09IGlzQWN0aXZlKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIChfYSA9IHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gKF9hMiA9IGNoaWxkLmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMi5zZXRBY3RpdmUodHlwZSwgaXNBY3RpdmUpO1xuICAgIH0pO1xuICAgIHN0YXRlW3R5cGVdLmlzQWN0aXZlID0gaXNBY3RpdmU7XG4gICAgY29uc3QgYW5pbWF0aW9uczIgPSBhbmltYXRlQ2hhbmdlcyhvcHRpb25zLCB0eXBlKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdGF0ZSkge1xuICAgICAgc3RhdGVba2V5XS5wcm90ZWN0ZWRLZXlzID0ge307XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zMjtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFuaW1hdGVDaGFuZ2VzLFxuICAgIHNldEFjdGl2ZSxcbiAgICBzZXRBbmltYXRlRnVuY3Rpb24sXG4gICAgZ2V0U3RhdGU6ICgpID0+IHN0YXRlXG4gIH07XG59XG5mdW5jdGlvbiBjaGVja1ZhcmlhbnRzRGlkQ2hhbmdlKHByZXYsIG5leHQpIHtcbiAgaWYgKHR5cGVvZiBuZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG5leHQgIT09IHByZXY7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIHJldHVybiAhc2hhbGxvd0NvbXBhcmUobmV4dCwgcHJldik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZVN0YXRlKGlzQWN0aXZlID0gZmFsc2UpIHtcbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZSxcbiAgICBwcm90ZWN0ZWRLZXlzOiB7fSxcbiAgICBuZWVkc0FuaW1hdGluZzoge30sXG4gICAgcHJldlJlc29sdmVkVmFsdWVzOiB7fVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgW0FuaW1hdGlvblR5cGUuQW5pbWF0ZV06IGNyZWF0ZVR5cGVTdGF0ZSh0cnVlKSxcbiAgICBbQW5pbWF0aW9uVHlwZS5JblZpZXddOiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICBbQW5pbWF0aW9uVHlwZS5Ib3Zlcl06IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgIFtBbmltYXRpb25UeXBlLlRhcF06IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgIFtBbmltYXRpb25UeXBlLkRyYWddOiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICBbQW5pbWF0aW9uVHlwZS5Gb2N1c106IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgIFtBbmltYXRpb25UeXBlLkV4aXRdOiBjcmVhdGVUeXBlU3RhdGUoKVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9hbmltYXRpb25zLm1qc1xudmFyIGFuaW1hdGlvbnMgPSB7XG4gIGFuaW1hdGlvbjogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQoKHsgdmlzdWFsRWxlbWVudCwgYW5pbWF0ZTogYW5pbWF0ZTMgfSkgPT4ge1xuICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUgfHwgKHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUgPSBjcmVhdGVBbmltYXRpb25TdGF0ZSh2aXN1YWxFbGVtZW50KSk7XG4gICAgaWYgKGlzQW5pbWF0aW9uQ29udHJvbHMoYW5pbWF0ZTMpKSB7XG4gICAgICB1c2VFZmZlY3Q3KCgpID0+IGFuaW1hdGUzLnN1YnNjcmliZSh2aXN1YWxFbGVtZW50KSwgW2FuaW1hdGUzXSk7XG4gICAgfVxuICB9KSxcbiAgZXhpdDogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQoKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjdXN0b20sIHZpc3VhbEVsZW1lbnQgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtpc1ByZXNlbnQsIHNhZmVUb1JlbW92ZV0gPSB1c2VQcmVzZW5jZSgpO1xuICAgIGNvbnN0IHByZXNlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQ3KFByZXNlbmNlQ29udGV4dCk7XG4gICAgdXNlRWZmZWN0NygoKSA9PiB7XG4gICAgICB2aXN1YWxFbGVtZW50LmlzUHJlc2VudCA9IGlzUHJlc2VudDtcbiAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUgJiYgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5FeGl0LCAhaXNQcmVzZW50LCB7XG4gICAgICAgIGN1c3RvbTogcHJlc2VuY2VDb250ZXh0ICYmIHByZXNlbmNlQ29udGV4dC5jdXN0b20gfHwgY3VzdG9tXG4gICAgICB9KTtcbiAgICAgIGlmIChhbmltYXRpb24gJiYgIWlzUHJlc2VudCkge1xuICAgICAgICBhbmltYXRpb24udGhlbihzYWZlVG9SZW1vdmUpO1xuICAgICAgfVxuICAgIH0sIFtpc1ByZXNlbnRdKTtcbiAgfSlcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91c2UtZHJhZy5tanNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q4IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvUGFuU2Vzc2lvbi5tanNcbnZhciBQYW5TZXNzaW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihldmVudCwgaGFuZGxlcnMsIHsgdHJhbnNmb3JtUGFnZVBvaW50IH0gPSB7fSkge1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XG4gICAgdGhpcy5sYXN0TW92ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gbnVsbDtcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy51cGRhdGVQb2ludCA9ICgpID0+IHtcbiAgICAgIGlmICghKHRoaXMubGFzdE1vdmVFdmVudCAmJiB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaW5mbzIgPSBnZXRQYW5JbmZvKHRoaXMubGFzdE1vdmVFdmVudEluZm8sIHRoaXMuaGlzdG9yeSk7XG4gICAgICBjb25zdCBpc1BhblN0YXJ0ZWQgPSB0aGlzLnN0YXJ0RXZlbnQgIT09IG51bGw7XG4gICAgICBjb25zdCBpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZCA9IGRpc3RhbmNlKGluZm8yLm9mZnNldCwgeyB4OiAwLCB5OiAwIH0pID49IDM7XG4gICAgICBpZiAoIWlzUGFuU3RhcnRlZCAmJiAhaXNEaXN0YW5jZVBhc3RUaHJlc2hvbGQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgcG9pbnQ6IHBvaW50MyB9ID0gaW5mbzI7XG4gICAgICBjb25zdCB7IHRpbWVzdGFtcDogdGltZXN0YW1wMiB9ID0gZ2V0RnJhbWVEYXRhKCk7XG4gICAgICB0aGlzLmhpc3RvcnkucHVzaChfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwb2ludDMpLCB7IHRpbWVzdGFtcDogdGltZXN0YW1wMiB9KSk7XG4gICAgICBjb25zdCB7IG9uU3RhcnQsIG9uTW92ZSB9ID0gdGhpcy5oYW5kbGVycztcbiAgICAgIGlmICghaXNQYW5TdGFydGVkKSB7XG4gICAgICAgIG9uU3RhcnQgJiYgb25TdGFydCh0aGlzLmxhc3RNb3ZlRXZlbnQsIGluZm8yKTtcbiAgICAgICAgdGhpcy5zdGFydEV2ZW50ID0gdGhpcy5sYXN0TW92ZUV2ZW50O1xuICAgICAgfVxuICAgICAgb25Nb3ZlICYmIG9uTW92ZSh0aGlzLmxhc3RNb3ZlRXZlbnQsIGluZm8yKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUgPSAoZXZlbnQyLCBpbmZvMikgPT4ge1xuICAgICAgdGhpcy5sYXN0TW92ZUV2ZW50ID0gZXZlbnQyO1xuICAgICAgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8yLCB0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50MikgJiYgZXZlbnQyLmJ1dHRvbnMgPT09IDApIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAoZXZlbnQyLCBpbmZvMik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVzX2RlZmF1bHQudXBkYXRlKHRoaXMudXBkYXRlUG9pbnQsIHRydWUpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSAoZXZlbnQyLCBpbmZvMikgPT4ge1xuICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIGNvbnN0IHsgb25FbmQsIG9uU2Vzc2lvbkVuZCB9ID0gdGhpcy5oYW5kbGVycztcbiAgICAgIGNvbnN0IHBhbkluZm8gPSBnZXRQYW5JbmZvKHRyYW5zZm9ybVBvaW50KGluZm8yLCB0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCksIHRoaXMuaGlzdG9yeSk7XG4gICAgICBpZiAodGhpcy5zdGFydEV2ZW50ICYmIG9uRW5kKSB7XG4gICAgICAgIG9uRW5kKGV2ZW50MiwgcGFuSW5mbyk7XG4gICAgICB9XG4gICAgICBvblNlc3Npb25FbmQgJiYgb25TZXNzaW9uRW5kKGV2ZW50MiwgcGFuSW5mbyk7XG4gICAgfTtcbiAgICBpZiAoaXNUb3VjaEV2ZW50KGV2ZW50KSAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50ID0gdHJhbnNmb3JtUGFnZVBvaW50O1xuICAgIGNvbnN0IGluZm8gPSBleHRyYWN0RXZlbnRJbmZvKGV2ZW50KTtcbiAgICBjb25zdCBpbml0aWFsSW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICBjb25zdCB7IHBvaW50OiBwb2ludDIgfSA9IGluaXRpYWxJbmZvO1xuICAgIGNvbnN0IHsgdGltZXN0YW1wIH0gPSBnZXRGcmFtZURhdGEoKTtcbiAgICB0aGlzLmhpc3RvcnkgPSBbX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcG9pbnQyKSwgeyB0aW1lc3RhbXAgfSldO1xuICAgIGNvbnN0IHsgb25TZXNzaW9uU3RhcnQgfSA9IGhhbmRsZXJzO1xuICAgIG9uU2Vzc2lvblN0YXJ0ICYmIG9uU2Vzc2lvblN0YXJ0KGV2ZW50LCBnZXRQYW5JbmZvKGluaXRpYWxJbmZvLCB0aGlzLmhpc3RvcnkpKTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyA9IHBpcGUoYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVybW92ZVwiLCB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKSwgYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVydXBcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApLCBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApKTtcbiAgfVxuICB1cGRhdGVIYW5kbGVycyhoYW5kbGVycykge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgfVxuICBlbmQoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMgJiYgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBjYW5jZWxTeW5jLnVwZGF0ZSh0aGlzLnVwZGF0ZVBvaW50KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KGluZm8sIHRyYW5zZm9ybVBhZ2VQb2ludCkge1xuICByZXR1cm4gdHJhbnNmb3JtUGFnZVBvaW50ID8geyBwb2ludDogdHJhbnNmb3JtUGFnZVBvaW50KGluZm8ucG9pbnQpIH0gOiBpbmZvO1xufVxuZnVuY3Rpb24gc3VidHJhY3RQb2ludChhMiwgYjIpIHtcbiAgcmV0dXJuIHsgeDogYTIueCAtIGIyLngsIHk6IGEyLnkgLSBiMi55IH07XG59XG5mdW5jdGlvbiBnZXRQYW5JbmZvKHsgcG9pbnQ6IHBvaW50MiB9LCBoaXN0b3J5KSB7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IHBvaW50MixcbiAgICBkZWx0YTogc3VidHJhY3RQb2ludChwb2ludDIsIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgb2Zmc2V0OiBzdWJ0cmFjdFBvaW50KHBvaW50Miwgc3RhcnREZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgdmVsb2NpdHk6IGdldFZlbG9jaXR5MihoaXN0b3J5LCAwLjEpXG4gIH07XG59XG5mdW5jdGlvbiBzdGFydERldmljZVBvaW50KGhpc3RvcnkpIHtcbiAgcmV0dXJuIGhpc3RvcnlbMF07XG59XG5mdW5jdGlvbiBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSkge1xuICByZXR1cm4gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZ2V0VmVsb2NpdHkyKGhpc3RvcnksIHRpbWVEZWx0YSkge1xuICBpZiAoaGlzdG9yeS5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICB9XG4gIGxldCBpMiA9IGhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgbGV0IHRpbWVzdGFtcGVkUG9pbnQgPSBudWxsO1xuICBjb25zdCBsYXN0UG9pbnQgPSBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSk7XG4gIHdoaWxlIChpMiA+PSAwKSB7XG4gICAgdGltZXN0YW1wZWRQb2ludCA9IGhpc3RvcnlbaTJdO1xuICAgIGlmIChsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXAgPiBzZWNvbmRzVG9NaWxsaXNlY29uZHModGltZURlbHRhKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGkyLS07XG4gIH1cbiAgaWYgKCF0aW1lc3RhbXBlZFBvaW50KSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICB9XG4gIGNvbnN0IHRpbWUgPSAobGFzdFBvaW50LnRpbWVzdGFtcCAtIHRpbWVzdGFtcGVkUG9pbnQudGltZXN0YW1wKSAvIDFlMztcbiAgaWYgKHRpbWUgPT09IDApIHtcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgY29uc3QgY3VycmVudFZlbG9jaXR5ID0ge1xuICAgIHg6IChsYXN0UG9pbnQueCAtIHRpbWVzdGFtcGVkUG9pbnQueCkgLyB0aW1lLFxuICAgIHk6IChsYXN0UG9pbnQueSAtIHRpbWVzdGFtcGVkUG9pbnQueSkgLyB0aW1lXG4gIH07XG4gIGlmIChjdXJyZW50VmVsb2NpdHkueCA9PT0gSW5maW5pdHkpIHtcbiAgICBjdXJyZW50VmVsb2NpdHkueCA9IDA7XG4gIH1cbiAgaWYgKGN1cnJlbnRWZWxvY2l0eS55ID09PSBJbmZpbml0eSkge1xuICAgIGN1cnJlbnRWZWxvY2l0eS55ID0gMDtcbiAgfVxuICByZXR1cm4gY3VycmVudFZlbG9jaXR5O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvZGVsdGEtY2FsYy5tanNcbmZ1bmN0aW9uIGNhbGNMZW5ndGgoYXhpcykge1xuICByZXR1cm4gYXhpcy5tYXggLSBheGlzLm1pbjtcbn1cbmZ1bmN0aW9uIGlzTmVhcih2YWx1ZSwgdGFyZ2V0ID0gMCwgbWF4RGlzdGFuY2UgPSAwLjAxKSB7XG4gIHJldHVybiBkaXN0YW5jZSh2YWx1ZSwgdGFyZ2V0KSA8IG1heERpc3RhbmNlO1xufVxuZnVuY3Rpb24gY2FsY0F4aXNEZWx0YShkZWx0YSwgc291cmNlLCB0YXJnZXQsIG9yaWdpbiA9IDAuNSkge1xuICBkZWx0YS5vcmlnaW4gPSBvcmlnaW47XG4gIGRlbHRhLm9yaWdpblBvaW50ID0gbWl4KHNvdXJjZS5taW4sIHNvdXJjZS5tYXgsIGRlbHRhLm9yaWdpbik7XG4gIGRlbHRhLnNjYWxlID0gY2FsY0xlbmd0aCh0YXJnZXQpIC8gY2FsY0xlbmd0aChzb3VyY2UpO1xuICBpZiAoaXNOZWFyKGRlbHRhLnNjYWxlLCAxLCAxZS00KSB8fCBpc05hTihkZWx0YS5zY2FsZSkpXG4gICAgZGVsdGEuc2NhbGUgPSAxO1xuICBkZWx0YS50cmFuc2xhdGUgPSBtaXgodGFyZ2V0Lm1pbiwgdGFyZ2V0Lm1heCwgZGVsdGEub3JpZ2luKSAtIGRlbHRhLm9yaWdpblBvaW50O1xuICBpZiAoaXNOZWFyKGRlbHRhLnRyYW5zbGF0ZSkgfHwgaXNOYU4oZGVsdGEudHJhbnNsYXRlKSlcbiAgICBkZWx0YS50cmFuc2xhdGUgPSAwO1xufVxuZnVuY3Rpb24gY2FsY0JveERlbHRhKGRlbHRhLCBzb3VyY2UsIHRhcmdldCwgb3JpZ2luKSB7XG4gIGNhbGNBeGlzRGVsdGEoZGVsdGEueCwgc291cmNlLngsIHRhcmdldC54LCBvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW4ub3JpZ2luWCk7XG4gIGNhbGNBeGlzRGVsdGEoZGVsdGEueSwgc291cmNlLnksIHRhcmdldC55LCBvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW4ub3JpZ2luWSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldCwgcmVsYXRpdmUsIHBhcmVudCkge1xuICB0YXJnZXQubWluID0gcGFyZW50Lm1pbiArIHJlbGF0aXZlLm1pbjtcbiAgdGFyZ2V0Lm1heCA9IHRhcmdldC5taW4gKyBjYWxjTGVuZ3RoKHJlbGF0aXZlKTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUJveCh0YXJnZXQsIHJlbGF0aXZlLCBwYXJlbnQpIHtcbiAgY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQueCwgcmVsYXRpdmUueCwgcGFyZW50LngpO1xuICBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldC55LCByZWxhdGl2ZS55LCBwYXJlbnQueSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24odGFyZ2V0LCBsYXlvdXQsIHBhcmVudCkge1xuICB0YXJnZXQubWluID0gbGF5b3V0Lm1pbiAtIHBhcmVudC5taW47XG4gIHRhcmdldC5tYXggPSB0YXJnZXQubWluICsgY2FsY0xlbmd0aChsYXlvdXQpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlUG9zaXRpb24odGFyZ2V0LCBsYXlvdXQsIHBhcmVudCkge1xuICBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24odGFyZ2V0LngsIGxheW91dC54LCBwYXJlbnQueCk7XG4gIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQueSwgbGF5b3V0LnksIHBhcmVudC55KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3V0aWxzL2NvbnN0cmFpbnRzLm1qc1xuZnVuY3Rpb24gYXBwbHlDb25zdHJhaW50cyhwb2ludDIsIHsgbWluLCBtYXggfSwgZWxhc3RpYykge1xuICBpZiAobWluICE9PSB2b2lkIDAgJiYgcG9pbnQyIDwgbWluKSB7XG4gICAgcG9pbnQyID0gZWxhc3RpYyA/IG1peChtaW4sIHBvaW50MiwgZWxhc3RpYy5taW4pIDogTWF0aC5tYXgocG9pbnQyLCBtaW4pO1xuICB9IGVsc2UgaWYgKG1heCAhPT0gdm9pZCAwICYmIHBvaW50MiA+IG1heCkge1xuICAgIHBvaW50MiA9IGVsYXN0aWMgPyBtaXgobWF4LCBwb2ludDIsIGVsYXN0aWMubWF4KSA6IE1hdGgubWluKHBvaW50MiwgbWF4KTtcbiAgfVxuICByZXR1cm4gcG9pbnQyO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGF4aXMsIG1pbiwgbWF4KSB7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4gIT09IHZvaWQgMCA/IGF4aXMubWluICsgbWluIDogdm9pZCAwLFxuICAgIG1heDogbWF4ICE9PSB2b2lkIDAgPyBheGlzLm1heCArIG1heCAtIChheGlzLm1heCAtIGF4aXMubWluKSA6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQ29uc3RyYWludHMobGF5b3V0Qm94LCB7IHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCB9KSB7XG4gIHJldHVybiB7XG4gICAgeDogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC54LCBsZWZ0LCByaWdodCksXG4gICAgeTogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC55LCB0b3AsIGJvdHRvbSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRBeGlzLCBjb25zdHJhaW50c0F4aXMpIHtcbiAgbGV0IG1pbiA9IGNvbnN0cmFpbnRzQXhpcy5taW4gLSBsYXlvdXRBeGlzLm1pbjtcbiAgbGV0IG1heCA9IGNvbnN0cmFpbnRzQXhpcy5tYXggLSBsYXlvdXRBeGlzLm1heDtcbiAgaWYgKGNvbnN0cmFpbnRzQXhpcy5tYXggLSBjb25zdHJhaW50c0F4aXMubWluIDwgbGF5b3V0QXhpcy5tYXggLSBsYXlvdXRBeGlzLm1pbikge1xuICAgIFttaW4sIG1heF0gPSBbbWF4LCBtaW5dO1xuICB9XG4gIHJldHVybiB7IG1pbiwgbWF4IH07XG59XG5mdW5jdGlvbiBjYWxjVmlld3BvcnRDb25zdHJhaW50cyhsYXlvdXRCb3gsIGNvbnN0cmFpbnRzQm94KSB7XG4gIHJldHVybiB7XG4gICAgeDogY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC54LCBjb25zdHJhaW50c0JveC54KSxcbiAgICB5OiBjYWxjVmlld3BvcnRBeGlzQ29uc3RyYWludHMobGF5b3V0Qm94LnksIGNvbnN0cmFpbnRzQm94LnkpXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjT3JpZ2luMihzb3VyY2UsIHRhcmdldCkge1xuICBsZXQgb3JpZ2luID0gMC41O1xuICBjb25zdCBzb3VyY2VMZW5ndGggPSBjYWxjTGVuZ3RoKHNvdXJjZSk7XG4gIGNvbnN0IHRhcmdldExlbmd0aCA9IGNhbGNMZW5ndGgodGFyZ2V0KTtcbiAgaWYgKHRhcmdldExlbmd0aCA+IHNvdXJjZUxlbmd0aCkge1xuICAgIG9yaWdpbiA9IHByb2dyZXNzKHRhcmdldC5taW4sIHRhcmdldC5tYXggLSBzb3VyY2VMZW5ndGgsIHNvdXJjZS5taW4pO1xuICB9IGVsc2UgaWYgKHNvdXJjZUxlbmd0aCA+IHRhcmdldExlbmd0aCkge1xuICAgIG9yaWdpbiA9IHByb2dyZXNzKHNvdXJjZS5taW4sIHNvdXJjZS5tYXggLSB0YXJnZXRMZW5ndGgsIHRhcmdldC5taW4pO1xuICB9XG4gIHJldHVybiBjbGFtcDIoMCwgMSwgb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHJlYmFzZUF4aXNDb25zdHJhaW50cyhsYXlvdXQsIGNvbnN0cmFpbnRzKSB7XG4gIGNvbnN0IHJlbGF0aXZlQ29uc3RyYWludHMgPSB7fTtcbiAgaWYgKGNvbnN0cmFpbnRzLm1pbiAhPT0gdm9pZCAwKSB7XG4gICAgcmVsYXRpdmVDb25zdHJhaW50cy5taW4gPSBjb25zdHJhaW50cy5taW4gLSBsYXlvdXQubWluO1xuICB9XG4gIGlmIChjb25zdHJhaW50cy5tYXggIT09IHZvaWQgMCkge1xuICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWF4ID0gY29uc3RyYWludHMubWF4IC0gbGF5b3V0Lm1pbjtcbiAgfVxuICByZXR1cm4gcmVsYXRpdmVDb25zdHJhaW50cztcbn1cbnZhciBkZWZhdWx0RWxhc3RpYyA9IDAuMzU7XG5mdW5jdGlvbiByZXNvbHZlRHJhZ0VsYXN0aWMoZHJhZ0VsYXN0aWMgPSBkZWZhdWx0RWxhc3RpYykge1xuICBpZiAoZHJhZ0VsYXN0aWMgPT09IGZhbHNlKSB7XG4gICAgZHJhZ0VsYXN0aWMgPSAwO1xuICB9IGVsc2UgaWYgKGRyYWdFbGFzdGljID09PSB0cnVlKSB7XG4gICAgZHJhZ0VsYXN0aWMgPSBkZWZhdWx0RWxhc3RpYztcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgXCJsZWZ0XCIsIFwicmlnaHRcIiksXG4gICAgeTogcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBcInRvcFwiLCBcImJvdHRvbVwiKVxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBtaW5MYWJlbCwgbWF4TGFiZWwpIHtcbiAgcmV0dXJuIHtcbiAgICBtaW46IHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIG1pbkxhYmVsKSxcbiAgICBtYXg6IHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIG1heExhYmVsKVxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbGFiZWwpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gdHlwZW9mIGRyYWdFbGFzdGljID09PSBcIm51bWJlclwiID8gZHJhZ0VsYXN0aWMgOiAoX2EgPSBkcmFnRWxhc3RpY1tsYWJlbF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9tb2RlbHMubWpzXG52YXIgY3JlYXRlQXhpc0RlbHRhID0gKCkgPT4gKHtcbiAgdHJhbnNsYXRlOiAwLFxuICBzY2FsZTogMSxcbiAgb3JpZ2luOiAwLFxuICBvcmlnaW5Qb2ludDogMFxufSk7XG52YXIgY3JlYXRlRGVsdGEgPSAoKSA9PiAoe1xuICB4OiBjcmVhdGVBeGlzRGVsdGEoKSxcbiAgeTogY3JlYXRlQXhpc0RlbHRhKClcbn0pO1xudmFyIGNyZWF0ZUF4aXMgPSAoKSA9PiAoeyBtaW46IDAsIG1heDogMCB9KTtcbnZhciBjcmVhdGVCb3ggPSAoKSA9PiAoe1xuICB4OiBjcmVhdGVBeGlzKCksXG4gIHk6IGNyZWF0ZUF4aXMoKVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi91dGlscy9lYWNoLWF4aXMubWpzXG5mdW5jdGlvbiBlYWNoQXhpcyhjYWxsYmFjaykge1xuICByZXR1cm4gW2NhbGxiYWNrKFwieFwiKSwgY2FsbGJhY2soXCJ5XCIpXTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2NvbnZlcnNpb24ubWpzXG5mdW5jdGlvbiBjb252ZXJ0Qm91bmRpbmdCb3hUb0JveCh7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSB9KSB7XG4gIHJldHVybiB7XG4gICAgeDogeyBtaW46IGxlZnQsIG1heDogcmlnaHQgfSxcbiAgICB5OiB7IG1pbjogdG9wLCBtYXg6IGJvdHRvbSB9XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveCh7IHgsIHkgfSkge1xuICByZXR1cm4geyB0b3A6IHkubWluLCByaWdodDogeC5tYXgsIGJvdHRvbTogeS5tYXgsIGxlZnQ6IHgubWluIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1Cb3hQb2ludHMocG9pbnQyLCB0cmFuc2Zvcm1Qb2ludDIpIHtcbiAgaWYgKCF0cmFuc2Zvcm1Qb2ludDIpXG4gICAgcmV0dXJuIHBvaW50MjtcbiAgY29uc3QgdG9wTGVmdCA9IHRyYW5zZm9ybVBvaW50Mih7IHg6IHBvaW50Mi5sZWZ0LCB5OiBwb2ludDIudG9wIH0pO1xuICBjb25zdCBib3R0b21SaWdodCA9IHRyYW5zZm9ybVBvaW50Mih7IHg6IHBvaW50Mi5yaWdodCwgeTogcG9pbnQyLmJvdHRvbSB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHRvcExlZnQueSxcbiAgICBsZWZ0OiB0b3BMZWZ0LngsXG4gICAgYm90dG9tOiBib3R0b21SaWdodC55LFxuICAgIHJpZ2h0OiBib3R0b21SaWdodC54XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi91dGlscy9oYXMtdHJhbnNmb3JtLm1qc1xuZnVuY3Rpb24gaXNJZGVudGl0eVNjYWxlKHNjYWxlMikge1xuICByZXR1cm4gc2NhbGUyID09PSB2b2lkIDAgfHwgc2NhbGUyID09PSAxO1xufVxuZnVuY3Rpb24gaGFzU2NhbGUoeyBzY2FsZTogc2NhbGUyLCBzY2FsZVgsIHNjYWxlWSB9KSB7XG4gIHJldHVybiAhaXNJZGVudGl0eVNjYWxlKHNjYWxlMikgfHwgIWlzSWRlbnRpdHlTY2FsZShzY2FsZVgpIHx8ICFpc0lkZW50aXR5U2NhbGUoc2NhbGVZKTtcbn1cbmZ1bmN0aW9uIGhhc1RyYW5zZm9ybSh2YWx1ZXMpIHtcbiAgcmV0dXJuIGhhc1NjYWxlKHZhbHVlcykgfHwgaGFzMkRUcmFuc2xhdGUodmFsdWVzKSB8fCB2YWx1ZXMueiB8fCB2YWx1ZXMucm90YXRlIHx8IHZhbHVlcy5yb3RhdGVYIHx8IHZhbHVlcy5yb3RhdGVZO1xufVxuZnVuY3Rpb24gaGFzMkRUcmFuc2xhdGUodmFsdWVzKSB7XG4gIHJldHVybiBpczJEVHJhbnNsYXRlKHZhbHVlcy54KSB8fCBpczJEVHJhbnNsYXRlKHZhbHVlcy55KTtcbn1cbmZ1bmN0aW9uIGlzMkRUcmFuc2xhdGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlICE9PSBcIjAlXCI7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9kZWx0YS1hcHBseS5tanNcbmZ1bmN0aW9uIHNjYWxlUG9pbnQocG9pbnQyLCBzY2FsZTIsIG9yaWdpblBvaW50KSB7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbU9yaWdpbiA9IHBvaW50MiAtIG9yaWdpblBvaW50O1xuICBjb25zdCBzY2FsZWQgPSBzY2FsZTIgKiBkaXN0YW5jZUZyb21PcmlnaW47XG4gIHJldHVybiBvcmlnaW5Qb2ludCArIHNjYWxlZDtcbn1cbmZ1bmN0aW9uIGFwcGx5UG9pbnREZWx0YShwb2ludDIsIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgaWYgKGJveFNjYWxlICE9PSB2b2lkIDApIHtcbiAgICBwb2ludDIgPSBzY2FsZVBvaW50KHBvaW50MiwgYm94U2NhbGUsIG9yaWdpblBvaW50KTtcbiAgfVxuICByZXR1cm4gc2NhbGVQb2ludChwb2ludDIsIHNjYWxlMiwgb3JpZ2luUG9pbnQpICsgdHJhbnNsYXRlO1xufVxuZnVuY3Rpb24gYXBwbHlBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlID0gMCwgc2NhbGUyID0gMSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKSB7XG4gIGF4aXMubWluID0gYXBwbHlQb2ludERlbHRhKGF4aXMubWluLCB0cmFuc2xhdGUsIHNjYWxlMiwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbiAgYXhpcy5tYXggPSBhcHBseVBvaW50RGVsdGEoYXhpcy5tYXgsIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xufVxuZnVuY3Rpb24gYXBwbHlCb3hEZWx0YShib3gsIHsgeCwgeSB9KSB7XG4gIGFwcGx5QXhpc0RlbHRhKGJveC54LCB4LnRyYW5zbGF0ZSwgeC5zY2FsZSwgeC5vcmlnaW5Qb2ludCk7XG4gIGFwcGx5QXhpc0RlbHRhKGJveC55LCB5LnRyYW5zbGF0ZSwgeS5zY2FsZSwgeS5vcmlnaW5Qb2ludCk7XG59XG5mdW5jdGlvbiBhcHBseVRyZWVEZWx0YXMoYm94LCB0cmVlU2NhbGUsIHRyZWVQYXRoLCBpc1NoYXJlZFRyYW5zaXRpb24gPSBmYWxzZSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB0cmVlTGVuZ3RoID0gdHJlZVBhdGgubGVuZ3RoO1xuICBpZiAoIXRyZWVMZW5ndGgpXG4gICAgcmV0dXJuO1xuICB0cmVlU2NhbGUueCA9IHRyZWVTY2FsZS55ID0gMTtcbiAgbGV0IG5vZGU7XG4gIGxldCBkZWx0YTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRyZWVMZW5ndGg7IGkyKyspIHtcbiAgICBub2RlID0gdHJlZVBhdGhbaTJdO1xuICAgIGRlbHRhID0gbm9kZS5wcm9qZWN0aW9uRGVsdGE7XG4gICAgaWYgKCgoX2IgPSAoX2EgPSBub2RlLmluc3RhbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3R5bGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNwbGF5KSA9PT0gXCJjb250ZW50c1wiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGlzU2hhcmVkVHJhbnNpdGlvbiAmJiBub2RlLm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmIG5vZGUuc2Nyb2xsICYmIG5vZGUgIT09IG5vZGUucm9vdCkge1xuICAgICAgdHJhbnNmb3JtQm94KGJveCwgeyB4OiAtbm9kZS5zY3JvbGwueCwgeTogLW5vZGUuc2Nyb2xsLnkgfSk7XG4gICAgfVxuICAgIGlmIChkZWx0YSkge1xuICAgICAgdHJlZVNjYWxlLnggKj0gZGVsdGEueC5zY2FsZTtcbiAgICAgIHRyZWVTY2FsZS55ICo9IGRlbHRhLnkuc2NhbGU7XG4gICAgICBhcHBseUJveERlbHRhKGJveCwgZGVsdGEpO1xuICAgIH1cbiAgICBpZiAoaXNTaGFyZWRUcmFuc2l0aW9uICYmIGhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgIHRyYW5zZm9ybUJveChib3gsIG5vZGUubGF0ZXN0VmFsdWVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZUF4aXMoYXhpcywgZGlzdGFuY2UyKSB7XG4gIGF4aXMubWluID0gYXhpcy5taW4gKyBkaXN0YW5jZTI7XG4gIGF4aXMubWF4ID0gYXhpcy5tYXggKyBkaXN0YW5jZTI7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1BeGlzKGF4aXMsIHRyYW5zZm9ybXMsIFtrZXksIHNjYWxlS2V5LCBvcmlnaW5LZXldKSB7XG4gIGNvbnN0IGF4aXNPcmlnaW4gPSB0cmFuc2Zvcm1zW29yaWdpbktleV0gIT09IHZvaWQgMCA/IHRyYW5zZm9ybXNbb3JpZ2luS2V5XSA6IDAuNTtcbiAgY29uc3Qgb3JpZ2luUG9pbnQgPSBtaXgoYXhpcy5taW4sIGF4aXMubWF4LCBheGlzT3JpZ2luKTtcbiAgYXBwbHlBeGlzRGVsdGEoYXhpcywgdHJhbnNmb3Jtc1trZXldLCB0cmFuc2Zvcm1zW3NjYWxlS2V5XSwgb3JpZ2luUG9pbnQsIHRyYW5zZm9ybXMuc2NhbGUpO1xufVxudmFyIHhLZXlzID0gW1wieFwiLCBcInNjYWxlWFwiLCBcIm9yaWdpblhcIl07XG52YXIgeUtleXMgPSBbXCJ5XCIsIFwic2NhbGVZXCIsIFwib3JpZ2luWVwiXTtcbmZ1bmN0aW9uIHRyYW5zZm9ybUJveChib3gsIHRyYW5zZm9ybSkge1xuICB0cmFuc2Zvcm1BeGlzKGJveC54LCB0cmFuc2Zvcm0sIHhLZXlzKTtcbiAgdHJhbnNmb3JtQXhpcyhib3gueSwgdHJhbnNmb3JtLCB5S2V5cyk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi91dGlscy9tZWFzdXJlLm1qc1xuZnVuY3Rpb24gbWVhc3VyZVZpZXdwb3J0Qm94KGluc3RhbmNlLCB0cmFuc2Zvcm1Qb2ludDIpIHtcbiAgcmV0dXJuIGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHRyYW5zZm9ybUJveFBvaW50cyhpbnN0YW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJhbnNmb3JtUG9pbnQyKSk7XG59XG5mdW5jdGlvbiBtZWFzdXJlUGFnZUJveChlbGVtZW50LCByb290UHJvamVjdGlvbk5vZGUyLCB0cmFuc2Zvcm1QYWdlUG9pbnQpIHtcbiAgY29uc3Qgdmlld3BvcnRCb3ggPSBtZWFzdXJlVmlld3BvcnRCb3goZWxlbWVudCwgdHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgY29uc3QgeyBzY3JvbGw6IHNjcm9sbDIgfSA9IHJvb3RQcm9qZWN0aW9uTm9kZTI7XG4gIGlmIChzY3JvbGwyKSB7XG4gICAgdHJhbnNsYXRlQXhpcyh2aWV3cG9ydEJveC54LCBzY3JvbGwyLngpO1xuICAgIHRyYW5zbGF0ZUF4aXModmlld3BvcnRCb3gueSwgc2Nyb2xsMi55KTtcbiAgfVxuICByZXR1cm4gdmlld3BvcnRCb3g7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy9WaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLm1qc1xudmFyIGVsZW1lbnREcmFnQ29udHJvbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2aXN1YWxFbGVtZW50KSB7XG4gICAgdGhpcy5vcGVuR2xvYmFsTG9jayA9IG51bGw7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgdGhpcy5jb25zdHJhaW50cyA9IGZhbHNlO1xuICAgIHRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgdGhpcy5lbGFzdGljID0gY3JlYXRlQm94KCk7XG4gICAgdGhpcy52aXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudDtcbiAgfVxuICBzdGFydChvcmlnaW5FdmVudCwgeyBzbmFwVG9DdXJzb3IgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy52aXN1YWxFbGVtZW50LmlzUHJlc2VudCA9PT0gZmFsc2UpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb25TZXNzaW9uU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgaWYgKHNuYXBUb0N1cnNvcikge1xuICAgICAgICB0aGlzLnNuYXBUb0N1cnNvcihleHRyYWN0RXZlbnRJbmZvKGV2ZW50LCBcInBhZ2VcIikucG9pbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25TdGFydCA9IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBkcmFnOiBkcmFnMiwgZHJhZ1Byb3BhZ2F0aW9uLCBvbkRyYWdTdGFydCB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgaWYgKGRyYWcyICYmICFkcmFnUHJvcGFnYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMub3Blbkdsb2JhbExvY2spXG4gICAgICAgICAgdGhpcy5vcGVuR2xvYmFsTG9jaygpO1xuICAgICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrID0gZ2V0R2xvYmFsTG9jayhkcmFnMik7XG4gICAgICAgIGlmICghdGhpcy5vcGVuR2xvYmFsTG9jaylcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMucmVzb2x2ZUNvbnN0cmFpbnRzKCk7XG4gICAgICBpZiAodGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24pIHtcbiAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24uaXNBbmltYXRpb25CbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24udGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuZ2V0KCkgfHwgMDtcbiAgICAgICAgaWYgKHBlcmNlbnQudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVkQXhpcyA9IChfYiA9IChfYTIgPSB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIubGF5b3V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICAgIGlmIChtZWFzdXJlZEF4aXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGNhbGNMZW5ndGgobWVhc3VyZWRBeGlzKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBsZW5ndGggKiAocGFyc2VGbG9hdChjdXJyZW50KSAvIDEwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3JpZ2luUG9pbnRbYXhpc10gPSBjdXJyZW50O1xuICAgICAgfSk7XG4gICAgICBvbkRyYWdTdGFydCA9PT0gbnVsbCB8fCBvbkRyYWdTdGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnU3RhcnQoZXZlbnQsIGluZm8pO1xuICAgICAgKF9hID0gdGhpcy52aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuRHJhZywgdHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdmUgPSAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgIGNvbnN0IHsgZHJhZ1Byb3BhZ2F0aW9uLCBkcmFnRGlyZWN0aW9uTG9jaywgb25EaXJlY3Rpb25Mb2NrLCBvbkRyYWcgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgIGlmICghZHJhZ1Byb3BhZ2F0aW9uICYmICF0aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IG9mZnNldCB9ID0gaW5mbztcbiAgICAgIGlmIChkcmFnRGlyZWN0aW9uTG9jayAmJiB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gZ2V0Q3VycmVudERpcmVjdGlvbihvZmZzZXQpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50RGlyZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgb25EaXJlY3Rpb25Mb2NrID09PSBudWxsIHx8IG9uRGlyZWN0aW9uTG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EaXJlY3Rpb25Mb2NrKHRoaXMuY3VycmVudERpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVBeGlzKFwieFwiLCBpbmZvLnBvaW50LCBvZmZzZXQpO1xuICAgICAgdGhpcy51cGRhdGVBeGlzKFwieVwiLCBpbmZvLnBvaW50LCBvZmZzZXQpO1xuICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnJlbmRlcigpO1xuICAgICAgb25EcmFnID09PSBudWxsIHx8IG9uRHJhZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnKGV2ZW50LCBpbmZvKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uU2Vzc2lvbkVuZCA9IChldmVudCwgaW5mbykgPT4gdGhpcy5zdG9wKGV2ZW50LCBpbmZvKTtcbiAgICB0aGlzLnBhblNlc3Npb24gPSBuZXcgUGFuU2Vzc2lvbihvcmlnaW5FdmVudCwge1xuICAgICAgb25TZXNzaW9uU3RhcnQsXG4gICAgICBvblN0YXJ0LFxuICAgICAgb25Nb3ZlLFxuICAgICAgb25TZXNzaW9uRW5kXG4gICAgfSwgeyB0cmFuc2Zvcm1QYWdlUG9pbnQ6IHRoaXMudmlzdWFsRWxlbWVudC5nZXRUcmFuc2Zvcm1QYWdlUG9pbnQoKSB9KTtcbiAgfVxuICBzdG9wKGV2ZW50LCBpbmZvKSB7XG4gICAgY29uc3QgaXNEcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZztcbiAgICB0aGlzLmNhbmNlbCgpO1xuICAgIGlmICghaXNEcmFnZ2luZylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHZlbG9jaXR5IH0gPSBpbmZvO1xuICAgIHRoaXMuc3RhcnRBbmltYXRpb24odmVsb2NpdHkpO1xuICAgIGNvbnN0IHsgb25EcmFnRW5kIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgb25EcmFnRW5kID09PSBudWxsIHx8IG9uRHJhZ0VuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnRW5kKGV2ZW50LCBpbmZvKTtcbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24pIHtcbiAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLmlzQW5pbWF0aW9uQmxvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLnBhblNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmQoKTtcbiAgICB0aGlzLnBhblNlc3Npb24gPSB2b2lkIDA7XG4gICAgY29uc3QgeyBkcmFnUHJvcGFnYXRpb24gfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICBpZiAoIWRyYWdQcm9wYWdhdGlvbiAmJiB0aGlzLm9wZW5HbG9iYWxMb2NrKSB7XG4gICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrKCk7XG4gICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrID0gbnVsbDtcbiAgICB9XG4gICAgKF9iID0gdGhpcy52aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuRHJhZywgZmFsc2UpO1xuICB9XG4gIHVwZGF0ZUF4aXMoYXhpcywgX3BvaW50LCBvZmZzZXQpIHtcbiAgICBjb25zdCB7IGRyYWc6IGRyYWcyIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgaWYgKCFvZmZzZXQgfHwgIXNob3VsZERyYWcoYXhpcywgZHJhZzIsIHRoaXMuY3VycmVudERpcmVjdGlvbikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgbGV0IG5leHQgPSB0aGlzLm9yaWdpblBvaW50W2F4aXNdICsgb2Zmc2V0W2F4aXNdO1xuICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzICYmIHRoaXMuY29uc3RyYWludHNbYXhpc10pIHtcbiAgICAgIG5leHQgPSBhcHBseUNvbnN0cmFpbnRzKG5leHQsIHRoaXMuY29uc3RyYWludHNbYXhpc10sIHRoaXMuZWxhc3RpY1theGlzXSk7XG4gICAgfVxuICAgIGF4aXNWYWx1ZS5zZXQobmV4dCk7XG4gIH1cbiAgcmVzb2x2ZUNvbnN0cmFpbnRzKCkge1xuICAgIGNvbnN0IHsgZHJhZ0NvbnN0cmFpbnRzLCBkcmFnRWxhc3RpYyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgIGNvbnN0IHsgbGF5b3V0IH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbiB8fCB7fTtcbiAgICBjb25zdCBwcmV2Q29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgIGlmIChkcmFnQ29uc3RyYWludHMgJiYgaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSkge1xuICAgICAgaWYgKCF0aGlzLmNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSB0aGlzLnJlc29sdmVSZWZDb25zdHJhaW50cygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHJhZ0NvbnN0cmFpbnRzICYmIGxheW91dCkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gY2FsY1JlbGF0aXZlQ29uc3RyYWludHMobGF5b3V0LmxheW91dEJveCwgZHJhZ0NvbnN0cmFpbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbGFzdGljID0gcmVzb2x2ZURyYWdFbGFzdGljKGRyYWdFbGFzdGljKTtcbiAgICBpZiAocHJldkNvbnN0cmFpbnRzICE9PSB0aGlzLmNvbnN0cmFpbnRzICYmIGxheW91dCAmJiB0aGlzLmNvbnN0cmFpbnRzICYmICF0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cykge1xuICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJhaW50c1theGlzXSA9IHJlYmFzZUF4aXNDb25zdHJhaW50cyhsYXlvdXQubGF5b3V0Qm94W2F4aXNdLCB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlc29sdmVSZWZDb25zdHJhaW50cygpIHtcbiAgICBjb25zdCB7IGRyYWdDb25zdHJhaW50czogY29uc3RyYWludHMsIG9uTWVhc3VyZURyYWdDb25zdHJhaW50cyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgIGlmICghY29uc3RyYWludHMgfHwgIWlzUmVmT2JqZWN0KGNvbnN0cmFpbnRzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBjb25zdHJhaW50c0VsZW1lbnQgPSBjb25zdHJhaW50cy5jdXJyZW50O1xuICAgIGludmFyaWFudChjb25zdHJhaW50c0VsZW1lbnQgIT09IG51bGwsIFwiSWYgYGRyYWdDb25zdHJhaW50c2AgaXMgc2V0IGFzIGEgUmVhY3QgcmVmLCB0aGF0IHJlZiBtdXN0IGJlIHBhc3NlZCB0byBhbm90aGVyIGNvbXBvbmVudCdzIGByZWZgIHByb3AuXCIpO1xuICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgIGlmICghcHJvamVjdGlvbiB8fCAhcHJvamVjdGlvbi5sYXlvdXQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY29uc3RyYWludHNCb3ggPSBtZWFzdXJlUGFnZUJveChjb25zdHJhaW50c0VsZW1lbnQsIHByb2plY3Rpb24ucm9vdCwgdGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpKTtcbiAgICBsZXQgbWVhc3VyZWRDb25zdHJhaW50cyA9IGNhbGNWaWV3cG9ydENvbnN0cmFpbnRzKHByb2plY3Rpb24ubGF5b3V0LmxheW91dEJveCwgY29uc3RyYWludHNCb3gpO1xuICAgIGlmIChvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMpIHtcbiAgICAgIGNvbnN0IHVzZXJDb25zdHJhaW50cyA9IG9uTWVhc3VyZURyYWdDb25zdHJhaW50cyhjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveChtZWFzdXJlZENvbnN0cmFpbnRzKSk7XG4gICAgICB0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cyA9ICEhdXNlckNvbnN0cmFpbnRzO1xuICAgICAgaWYgKHVzZXJDb25zdHJhaW50cykge1xuICAgICAgICBtZWFzdXJlZENvbnN0cmFpbnRzID0gY29udmVydEJvdW5kaW5nQm94VG9Cb3godXNlckNvbnN0cmFpbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lYXN1cmVkQ29uc3RyYWludHM7XG4gIH1cbiAgc3RhcnRBbmltYXRpb24odmVsb2NpdHkpIHtcbiAgICBjb25zdCB7IGRyYWc6IGRyYWcyLCBkcmFnTW9tZW50dW0sIGRyYWdFbGFzdGljLCBkcmFnVHJhbnNpdGlvbiwgZHJhZ1NuYXBUb09yaWdpbiwgb25EcmFnVHJhbnNpdGlvbkVuZCB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyB8fCB7fTtcbiAgICBjb25zdCBtb21lbnR1bUFuaW1hdGlvbnMgPSBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcyLCB0aGlzLmN1cnJlbnREaXJlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0cmFuc2l0aW9uID0gKF9hID0gY29uc3RyYWludHMgPT09IG51bGwgfHwgY29uc3RyYWludHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnN0cmFpbnRzW2F4aXNdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgIGlmIChkcmFnU25hcFRvT3JpZ2luKVxuICAgICAgICB0cmFuc2l0aW9uID0geyBtaW46IDAsIG1heDogMCB9O1xuICAgICAgY29uc3QgYm91bmNlU3RpZmZuZXNzID0gZHJhZ0VsYXN0aWMgPyAyMDAgOiAxZTY7XG4gICAgICBjb25zdCBib3VuY2VEYW1waW5nID0gZHJhZ0VsYXN0aWMgPyA0MCA6IDFlNztcbiAgICAgIGNvbnN0IGluZXJ0aWEyID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICB0eXBlOiBcImluZXJ0aWFcIixcbiAgICAgICAgdmVsb2NpdHk6IGRyYWdNb21lbnR1bSA/IHZlbG9jaXR5W2F4aXNdIDogMCxcbiAgICAgICAgYm91bmNlU3RpZmZuZXNzLFxuICAgICAgICBib3VuY2VEYW1waW5nLFxuICAgICAgICB0aW1lQ29uc3RhbnQ6IDc1MCxcbiAgICAgICAgcmVzdERlbHRhOiAxLFxuICAgICAgICByZXN0U3BlZWQ6IDEwXG4gICAgICB9LCBkcmFnVHJhbnNpdGlvbiksIHRyYW5zaXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRBeGlzVmFsdWVBbmltYXRpb24oYXhpcywgaW5lcnRpYTIpO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChtb21lbnR1bUFuaW1hdGlvbnMpLnRoZW4ob25EcmFnVHJhbnNpdGlvbkVuZCk7XG4gIH1cbiAgc3RhcnRBeGlzVmFsdWVBbmltYXRpb24oYXhpcywgdHJhbnNpdGlvbikge1xuICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgIHJldHVybiBzdGFydEFuaW1hdGlvbihheGlzLCBheGlzVmFsdWUsIDAsIHRyYW5zaXRpb24pO1xuICB9XG4gIHN0b3BBbmltYXRpb24oKSB7XG4gICAgZWFjaEF4aXMoKGF4aXMpID0+IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpLnN0b3AoKSk7XG4gIH1cbiAgZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRyYWdLZXkgPSBcIl9kcmFnXCIgKyBheGlzLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgZXh0ZXJuYWxNb3Rpb25WYWx1ZSA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpW2RyYWdLZXldO1xuICAgIHJldHVybiBleHRlcm5hbE1vdGlvblZhbHVlID8gZXh0ZXJuYWxNb3Rpb25WYWx1ZSA6IHRoaXMudmlzdWFsRWxlbWVudC5nZXRWYWx1ZShheGlzLCAoX2IgPSAoX2EgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKS5pbml0aWFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYXhpc10pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICB9XG4gIHNuYXBUb0N1cnNvcihwb2ludDIpIHtcbiAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgY29uc3QgeyBkcmFnOiBkcmFnMiB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcyLCB0aGlzLmN1cnJlbnREaXJlY3Rpb24pKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgaWYgKHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gcHJvamVjdGlvbi5sYXlvdXQubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICBheGlzVmFsdWUuc2V0KHBvaW50MltheGlzXSAtIG1peChtaW4sIG1heCwgMC41KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZHJhZzogZHJhZzIsIGRyYWdDb25zdHJhaW50cyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgIGlmICghaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSB8fCAhcHJvamVjdGlvbiB8fCAhdGhpcy5jb25zdHJhaW50cylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICBjb25zdCBib3hQcm9ncmVzcyA9IHsgeDogMCwgeTogMCB9O1xuICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgIGlmIChheGlzVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0ID0gYXhpc1ZhbHVlLmdldCgpO1xuICAgICAgICBib3hQcm9ncmVzc1theGlzXSA9IGNhbGNPcmlnaW4yKHsgbWluOiBsYXRlc3QsIG1heDogbGF0ZXN0IH0sIHRoaXMuY29uc3RyYWludHNbYXhpc10pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtVGVtcGxhdGUgfSA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgIHRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlID8gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpIDogXCJub25lXCI7XG4gICAgKF9hID0gcHJvamVjdGlvbi5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlU2Nyb2xsKCk7XG4gICAgcHJvamVjdGlvbi51cGRhdGVMYXlvdXQoKTtcbiAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygpO1xuICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZzIsIG51bGwpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMuY29uc3RyYWludHNbYXhpc107XG4gICAgICBheGlzVmFsdWUuc2V0KG1peChtaW4sIG1heCwgYm94UHJvZ3Jlc3NbYXhpc10pKTtcbiAgICB9KTtcbiAgfVxuICBhZGRMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy52aXN1YWxFbGVtZW50LmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgZWxlbWVudERyYWdDb250cm9scy5zZXQodGhpcy52aXN1YWxFbGVtZW50LCB0aGlzKTtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy52aXN1YWxFbGVtZW50LmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcFBvaW50ZXJMaXN0ZW5lciA9IGFkZFBvaW50ZXJFdmVudChlbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBkcmFnOiBkcmFnMiwgZHJhZ0xpc3RlbmVyID0gdHJ1ZSB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgZHJhZzIgJiYgZHJhZ0xpc3RlbmVyICYmIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIH0pO1xuICAgIGNvbnN0IG1lYXN1cmVEcmFnQ29uc3RyYWludHMgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IGRyYWdDb25zdHJhaW50cyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgaWYgKGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IHRoaXMucmVzb2x2ZVJlZkNvbnN0cmFpbnRzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICBjb25zdCBzdG9wTWVhc3VyZUxheW91dExpc3RlbmVyID0gcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwibWVhc3VyZVwiLCBtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKTtcbiAgICBpZiAocHJvamVjdGlvbiAmJiAhcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgIChfYSA9IHByb2plY3Rpb24ucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgcHJvamVjdGlvbi51cGRhdGVMYXlvdXQoKTtcbiAgICB9XG4gICAgbWVhc3VyZURyYWdDb25zdHJhaW50cygpO1xuICAgIGNvbnN0IHN0b3BSZXNpemVMaXN0ZW5lciA9IGFkZERvbUV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5zY2FsZVBvc2l0aW9uV2l0aGluQ29uc3RyYWludHMoKSk7XG4gICAgY29uc3Qgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyID0gcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiZGlkVXBkYXRlXCIsICh7IGRlbHRhLCBoYXNMYXlvdXRDaGFuZ2VkIH0pID0+IHtcbiAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcgJiYgaGFzTGF5b3V0Q2hhbmdlZCkge1xuICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vdGlvblZhbHVlMiA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgIGlmICghbW90aW9uVmFsdWUyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHRoaXMub3JpZ2luUG9pbnRbYXhpc10gKz0gZGVsdGFbYXhpc10udHJhbnNsYXRlO1xuICAgICAgICAgIG1vdGlvblZhbHVlMi5zZXQobW90aW9uVmFsdWUyLmdldCgpICsgZGVsdGFbYXhpc10udHJhbnNsYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3RvcFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICBzdG9wUG9pbnRlckxpc3RlbmVyKCk7XG4gICAgICBzdG9wTWVhc3VyZUxheW91dExpc3RlbmVyKCk7XG4gICAgICBzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIgPT09IG51bGwgfHwgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG4gIGdldFByb3BzKCkge1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgY29uc3QgeyBkcmFnOiBkcmFnMiA9IGZhbHNlLCBkcmFnRGlyZWN0aW9uTG9jayA9IGZhbHNlLCBkcmFnUHJvcGFnYXRpb24gPSBmYWxzZSwgZHJhZ0NvbnN0cmFpbnRzID0gZmFsc2UsIGRyYWdFbGFzdGljID0gZGVmYXVsdEVsYXN0aWMsIGRyYWdNb21lbnR1bSA9IHRydWUgfSA9IHByb3BzO1xuICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcyksIHtcbiAgICAgIGRyYWc6IGRyYWcyLFxuICAgICAgZHJhZ0RpcmVjdGlvbkxvY2ssXG4gICAgICBkcmFnUHJvcGFnYXRpb24sXG4gICAgICBkcmFnQ29uc3RyYWludHMsXG4gICAgICBkcmFnRWxhc3RpYyxcbiAgICAgIGRyYWdNb21lbnR1bVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkRHJhZyhkaXJlY3Rpb24sIGRyYWcyLCBjdXJyZW50RGlyZWN0aW9uKSB7XG4gIHJldHVybiAoZHJhZzIgPT09IHRydWUgfHwgZHJhZzIgPT09IGRpcmVjdGlvbikgJiYgKGN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwgfHwgY3VycmVudERpcmVjdGlvbiA9PT0gZGlyZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnREaXJlY3Rpb24ob2Zmc2V0LCBsb2NrVGhyZXNob2xkID0gMTApIHtcbiAgbGV0IGRpcmVjdGlvbiA9IG51bGw7XG4gIGlmIChNYXRoLmFicyhvZmZzZXQueSkgPiBsb2NrVGhyZXNob2xkKSB7XG4gICAgZGlyZWN0aW9uID0gXCJ5XCI7XG4gIH0gZWxzZSBpZiAoTWF0aC5hYnMob2Zmc2V0LngpID4gbG9ja1RocmVzaG9sZCkge1xuICAgIGRpcmVjdGlvbiA9IFwieFwiO1xuICB9XG4gIHJldHVybiBkaXJlY3Rpb247XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91c2UtZHJhZy5tanNcbmZ1bmN0aW9uIHVzZURyYWcocHJvcHMpIHtcbiAgY29uc3QgeyBkcmFnQ29udHJvbHM6IGdyb3VwRHJhZ0NvbnRyb2xzLCB2aXN1YWxFbGVtZW50IH0gPSBwcm9wcztcbiAgY29uc3QgZHJhZ0NvbnRyb2xzID0gdXNlQ29uc3RhbnQoKCkgPT4gbmV3IFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHModmlzdWFsRWxlbWVudCkpO1xuICB1c2VFZmZlY3Q4KCgpID0+IGdyb3VwRHJhZ0NvbnRyb2xzICYmIGdyb3VwRHJhZ0NvbnRyb2xzLnN1YnNjcmliZShkcmFnQ29udHJvbHMpLCBbZHJhZ0NvbnRyb2xzLCBncm91cERyYWdDb250cm9sc10pO1xuICB1c2VFZmZlY3Q4KCgpID0+IGRyYWdDb250cm9scy5hZGRMaXN0ZW5lcnMoKSwgW2RyYWdDb250cm9sc10pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS1wYW4tZ2VzdHVyZS5tanNcbmltcG9ydCB7IHVzZVJlZiBhcyB1c2VSZWY1LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ4LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0OSB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlUGFuR2VzdHVyZSh7IG9uUGFuLCBvblBhblN0YXJ0LCBvblBhbkVuZCwgb25QYW5TZXNzaW9uU3RhcnQsIHZpc3VhbEVsZW1lbnQgfSkge1xuICBjb25zdCBoYXNQYW5FdmVudHMgPSBvblBhbiB8fCBvblBhblN0YXJ0IHx8IG9uUGFuRW5kIHx8IG9uUGFuU2Vzc2lvblN0YXJ0O1xuICBjb25zdCBwYW5TZXNzaW9uID0gdXNlUmVmNShudWxsKTtcbiAgY29uc3QgeyB0cmFuc2Zvcm1QYWdlUG9pbnQgfSA9IHVzZUNvbnRleHQ4KE1vdGlvbkNvbmZpZ0NvbnRleHQpO1xuICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICBvblNlc3Npb25TdGFydDogb25QYW5TZXNzaW9uU3RhcnQsXG4gICAgb25TdGFydDogb25QYW5TdGFydCxcbiAgICBvbk1vdmU6IG9uUGFuLFxuICAgIG9uRW5kOiAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgIHBhblNlc3Npb24uY3VycmVudCA9IG51bGw7XG4gICAgICBvblBhbkVuZCAmJiBvblBhbkVuZChldmVudCwgaW5mbyk7XG4gICAgfVxuICB9O1xuICB1c2VFZmZlY3Q5KCgpID0+IHtcbiAgICBpZiAocGFuU2Vzc2lvbi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBwYW5TZXNzaW9uLmN1cnJlbnQudXBkYXRlSGFuZGxlcnMoaGFuZGxlcnMpO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICBwYW5TZXNzaW9uLmN1cnJlbnQgPSBuZXcgUGFuU2Vzc2lvbihldmVudCwgaGFuZGxlcnMsIHtcbiAgICAgIHRyYW5zZm9ybVBhZ2VQb2ludFxuICAgIH0pO1xuICB9XG4gIHVzZVBvaW50ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIGhhc1BhbkV2ZW50cyAmJiBvblBvaW50ZXJEb3duKTtcbiAgdXNlVW5tb3VudEVmZmVjdCgoKSA9PiBwYW5TZXNzaW9uLmN1cnJlbnQgJiYgcGFuU2Vzc2lvbi5jdXJyZW50LmVuZCgpKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvZHJhZy5tanNcbnZhciBkcmFnID0ge1xuICBwYW46IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZVBhbkdlc3R1cmUpLFxuICBkcmFnOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VEcmFnKVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2Nzcy12YXJpYWJsZXMtY29udmVyc2lvbi5tanNcbmZ1bmN0aW9uIGlzQ1NTVmFyaWFibGUyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChcInZhcigtLVwiKTtcbn1cbnZhciBjc3NWYXJpYWJsZVJlZ2V4ID0gL3ZhclxcKCgtLVthLXpBLVowLTktX10rKSw/ID8oW2EtekEtWjAtOSAoKSUjLiwtXSspP1xcKS87XG5mdW5jdGlvbiBwYXJzZUNTU1ZhcmlhYmxlKGN1cnJlbnQpIHtcbiAgY29uc3QgbWF0Y2ggPSBjc3NWYXJpYWJsZVJlZ2V4LmV4ZWMoY3VycmVudCk7XG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIFssXTtcbiAgY29uc3QgWywgdG9rZW4sIGZhbGxiYWNrXSA9IG1hdGNoO1xuICByZXR1cm4gW3Rva2VuLCBmYWxsYmFja107XG59XG52YXIgbWF4RGVwdGggPSA0O1xuZnVuY3Rpb24gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50LCBkZXB0aCA9IDEpIHtcbiAgaW52YXJpYW50KGRlcHRoIDw9IG1heERlcHRoLCBgTWF4IENTUyB2YXJpYWJsZSBmYWxsYmFjayBkZXB0aCBkZXRlY3RlZCBpbiBwcm9wZXJ0eSBcIiR7Y3VycmVudH1cIi4gVGhpcyBtYXkgaW5kaWNhdGUgYSBjaXJjdWxhciBmYWxsYmFjayBkZXBlbmRlbmN5LmApO1xuICBjb25zdCBbdG9rZW4sIGZhbGxiYWNrXSA9IHBhcnNlQ1NTVmFyaWFibGUoY3VycmVudCk7XG4gIGlmICghdG9rZW4pXG4gICAgcmV0dXJuO1xuICBjb25zdCByZXNvbHZlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUodG9rZW4pO1xuICBpZiAocmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWQudHJpbSgpO1xuICB9IGVsc2UgaWYgKGlzQ1NTVmFyaWFibGUyKGZhbGxiYWNrKSkge1xuICAgIHJldHVybiBnZXRWYXJpYWJsZVZhbHVlKGZhbGxiYWNrLCBlbGVtZW50LCBkZXB0aCArIDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNTU1ZhcmlhYmxlcyh2aXN1YWxFbGVtZW50LCBfYSwgdHJhbnNpdGlvbkVuZCkge1xuICB2YXIgdGFyZ2V0ID0gX19vYmpSZXN0KF9hLCBbXSk7XG4gIGNvbnN0IGVsZW1lbnQgPSB2aXN1YWxFbGVtZW50LmN1cnJlbnQ7XG4gIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSlcbiAgICByZXR1cm4geyB0YXJnZXQsIHRyYW5zaXRpb25FbmQgfTtcbiAgaWYgKHRyYW5zaXRpb25FbmQpIHtcbiAgICB0cmFuc2l0aW9uRW5kID0gX19zcHJlYWRWYWx1ZXMoe30sIHRyYW5zaXRpb25FbmQpO1xuICB9XG4gIHZpc3VhbEVsZW1lbnQudmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IHZhbHVlLmdldCgpO1xuICAgIGlmICghaXNDU1NWYXJpYWJsZTIoY3VycmVudCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBnZXRWYXJpYWJsZVZhbHVlKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgIGlmIChyZXNvbHZlZClcbiAgICAgIHZhbHVlLnNldChyZXNvbHZlZCk7XG4gIH0pO1xuICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKCFpc0NTU1ZhcmlhYmxlMihjdXJyZW50KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHJlc29sdmVkID0gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50KTtcbiAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSByZXNvbHZlZDtcbiAgICBpZiAodHJhbnNpdGlvbkVuZCAmJiB0cmFuc2l0aW9uRW5kW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgdHJhbnNpdGlvbkVuZFtrZXldID0gY3VycmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy91bml0LWNvbnZlcnNpb24ubWpzXG52YXIgcG9zaXRpb25hbEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwid2lkdGhcIixcbiAgXCJoZWlnaHRcIixcbiAgXCJ0b3BcIixcbiAgXCJsZWZ0XCIsXG4gIFwicmlnaHRcIixcbiAgXCJib3R0b21cIixcbiAgXCJ4XCIsXG4gIFwieVwiXG5dKTtcbnZhciBpc1Bvc2l0aW9uYWxLZXkgPSAoa2V5KSA9PiBwb3NpdGlvbmFsS2V5cy5oYXMoa2V5KTtcbnZhciBoYXNQb3NpdGlvbmFsS2V5ID0gKHRhcmdldCkgPT4ge1xuICByZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5zb21lKGlzUG9zaXRpb25hbEtleSk7XG59O1xudmFyIHNldEFuZFJlc2V0VmVsb2NpdHkgPSAodmFsdWUsIHRvKSA9PiB7XG4gIHZhbHVlLnNldCh0bywgZmFsc2UpO1xuICB2YWx1ZS5zZXQodG8pO1xufTtcbnZhciBpc051bU9yUHhUeXBlID0gKHYpID0+IHYgPT09IG51bWJlciB8fCB2ID09PSBweDtcbnZhciBCb3VuZGluZ0JveERpbWVuc2lvbjtcbihmdW5jdGlvbihCb3VuZGluZ0JveERpbWVuc2lvbjIpIHtcbiAgQm91bmRpbmdCb3hEaW1lbnNpb24yW1wid2lkdGhcIl0gPSBcIndpZHRoXCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcImhlaWdodFwiXSA9IFwiaGVpZ2h0XCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcImxlZnRcIl0gPSBcImxlZnRcIjtcbiAgQm91bmRpbmdCb3hEaW1lbnNpb24yW1wicmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcInRvcFwiXSA9IFwidG9wXCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcImJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG59KShCb3VuZGluZ0JveERpbWVuc2lvbiB8fCAoQm91bmRpbmdCb3hEaW1lbnNpb24gPSB7fSkpO1xudmFyIGdldFBvc0Zyb21NYXRyaXggPSAobWF0cml4LCBwb3MpID0+IHBhcnNlRmxvYXQobWF0cml4LnNwbGl0KFwiLCBcIilbcG9zXSk7XG52YXIgZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCA9IChwb3MyLCBwb3MzKSA9PiAoX2Jib3gsIHsgdHJhbnNmb3JtIH0pID0+IHtcbiAgaWYgKHRyYW5zZm9ybSA9PT0gXCJub25lXCIgfHwgIXRyYW5zZm9ybSlcbiAgICByZXR1cm4gMDtcbiAgY29uc3QgbWF0cml4M2QgPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXgzZFxcKCguKylcXCkkLyk7XG4gIGlmIChtYXRyaXgzZCkge1xuICAgIHJldHVybiBnZXRQb3NGcm9tTWF0cml4KG1hdHJpeDNkWzFdLCBwb3MzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtYXRyaXggPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXhcXCgoLispXFwpJC8pO1xuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHJldHVybiBnZXRQb3NGcm9tTWF0cml4KG1hdHJpeFsxXSwgcG9zMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxufTtcbnZhciB0cmFuc2Zvcm1LZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wieFwiLCBcInlcIiwgXCJ6XCJdKTtcbnZhciBub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cyA9IHRyYW5zZm9ybVByb3BPcmRlci5maWx0ZXIoKGtleSkgPT4gIXRyYW5zZm9ybUtleXMuaGFzKGtleSkpO1xuZnVuY3Rpb24gcmVtb3ZlTm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybSh2aXN1YWxFbGVtZW50KSB7XG4gIGNvbnN0IHJlbW92ZWRUcmFuc2Zvcm1zID0gW107XG4gIG5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm1LZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZW1vdmVkVHJhbnNmb3Jtcy5wdXNoKFtrZXksIHZhbHVlLmdldCgpXSk7XG4gICAgICB2YWx1ZS5zZXQoa2V5LnN0YXJ0c1dpdGgoXCJzY2FsZVwiKSA/IDEgOiAwKTtcbiAgICB9XG4gIH0pO1xuICBpZiAocmVtb3ZlZFRyYW5zZm9ybXMubGVuZ3RoKVxuICAgIHZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gIHJldHVybiByZW1vdmVkVHJhbnNmb3Jtcztcbn1cbnZhciBwb3NpdGlvbmFsVmFsdWVzID0ge1xuICB3aWR0aDogKHsgeCB9LCB7IHBhZGRpbmdMZWZ0ID0gXCIwXCIsIHBhZGRpbmdSaWdodCA9IFwiMFwiIH0pID0+IHgubWF4IC0geC5taW4gLSBwYXJzZUZsb2F0KHBhZGRpbmdMZWZ0KSAtIHBhcnNlRmxvYXQocGFkZGluZ1JpZ2h0KSxcbiAgaGVpZ2h0OiAoeyB5IH0sIHsgcGFkZGluZ1RvcCA9IFwiMFwiLCBwYWRkaW5nQm90dG9tID0gXCIwXCIgfSkgPT4geS5tYXggLSB5Lm1pbiAtIHBhcnNlRmxvYXQocGFkZGluZ1RvcCkgLSBwYXJzZUZsb2F0KHBhZGRpbmdCb3R0b20pLFxuICB0b3A6IChfYmJveCwgeyB0b3AgfSkgPT4gcGFyc2VGbG9hdCh0b3ApLFxuICBsZWZ0OiAoX2Jib3gsIHsgbGVmdCB9KSA9PiBwYXJzZUZsb2F0KGxlZnQpLFxuICBib3R0b206ICh7IHkgfSwgeyB0b3AgfSkgPT4gcGFyc2VGbG9hdCh0b3ApICsgKHkubWF4IC0geS5taW4pLFxuICByaWdodDogKHsgeCB9LCB7IGxlZnQgfSkgPT4gcGFyc2VGbG9hdChsZWZ0KSArICh4Lm1heCAtIHgubWluKSxcbiAgeDogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg0LCAxMyksXG4gIHk6IGdldFRyYW5zbGF0ZUZyb21NYXRyaXgoNSwgMTQpXG59O1xudmFyIGNvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyA9ICh0YXJnZXQsIHZpc3VhbEVsZW1lbnQsIGNoYW5nZWRLZXlzKSA9PiB7XG4gIGNvbnN0IG9yaWdpbkJib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICBjb25zdCBlbGVtZW50ID0gdmlzdWFsRWxlbWVudC5jdXJyZW50O1xuICBjb25zdCBlbGVtZW50Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIGNvbnN0IHsgZGlzcGxheSB9ID0gZWxlbWVudENvbXB1dGVkU3R5bGU7XG4gIGNvbnN0IG9yaWdpbiA9IHt9O1xuICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICB2aXN1YWxFbGVtZW50LnNldFN0YXRpY1ZhbHVlKFwiZGlzcGxheVwiLCB0YXJnZXQuZGlzcGxheSB8fCBcImJsb2NrXCIpO1xuICB9XG4gIGNoYW5nZWRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIG9yaWdpbltrZXldID0gcG9zaXRpb25hbFZhbHVlc1trZXldKG9yaWdpbkJib3gsIGVsZW1lbnRDb21wdXRlZFN0eWxlKTtcbiAgfSk7XG4gIHZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gIGNvbnN0IHRhcmdldEJib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICBjaGFuZ2VkS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICBzZXRBbmRSZXNldFZlbG9jaXR5KHZhbHVlLCBvcmlnaW5ba2V5XSk7XG4gICAgdGFyZ2V0W2tleV0gPSBwb3NpdGlvbmFsVmFsdWVzW2tleV0odGFyZ2V0QmJveCwgZWxlbWVudENvbXB1dGVkU3R5bGUpO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgY2hlY2tBbmRDb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXMgPSAodmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4gPSB7fSwgdHJhbnNpdGlvbkVuZCA9IHt9KSA9PiB7XG4gIHRhcmdldCA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0YXJnZXQpO1xuICB0cmFuc2l0aW9uRW5kID0gX19zcHJlYWRWYWx1ZXMoe30sIHRyYW5zaXRpb25FbmQpO1xuICBjb25zdCB0YXJnZXRQb3NpdGlvbmFsS2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCkuZmlsdGVyKGlzUG9zaXRpb25hbEtleSk7XG4gIGxldCByZW1vdmVkVHJhbnNmb3JtVmFsdWVzID0gW107XG4gIGxldCBoYXNBdHRlbXB0ZWRUb1JlbW92ZVRyYW5zZm9ybVZhbHVlcyA9IGZhbHNlO1xuICBjb25zdCBjaGFuZ2VkVmFsdWVUeXBlS2V5cyA9IFtdO1xuICB0YXJnZXRQb3NpdGlvbmFsS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnQuaGFzVmFsdWUoa2V5KSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZnJvbSA9IG9yaWdpbltrZXldO1xuICAgIGxldCBmcm9tVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUoZnJvbSk7XG4gICAgY29uc3QgdG8gPSB0YXJnZXRba2V5XTtcbiAgICBsZXQgdG9UeXBlO1xuICAgIGlmIChpc0tleWZyYW1lc1RhcmdldCh0bykpIHtcbiAgICAgIGNvbnN0IG51bUtleWZyYW1lcyA9IHRvLmxlbmd0aDtcbiAgICAgIGNvbnN0IGZyb21JbmRleCA9IHRvWzBdID09PSBudWxsID8gMSA6IDA7XG4gICAgICBmcm9tID0gdG9bZnJvbUluZGV4XTtcbiAgICAgIGZyb21UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZShmcm9tKTtcbiAgICAgIGZvciAobGV0IGkyID0gZnJvbUluZGV4OyBpMiA8IG51bUtleWZyYW1lczsgaTIrKykge1xuICAgICAgICBpZiAoIXRvVHlwZSkge1xuICAgICAgICAgIHRvVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodG9baTJdKTtcbiAgICAgICAgICBpbnZhcmlhbnQodG9UeXBlID09PSBmcm9tVHlwZSB8fCBpc051bU9yUHhUeXBlKGZyb21UeXBlKSAmJiBpc051bU9yUHhUeXBlKHRvVHlwZSksIFwiS2V5ZnJhbWVzIG11c3QgYmUgb2YgdGhlIHNhbWUgZGltZW5zaW9uIGFzIHRoZSBjdXJyZW50IHZhbHVlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludmFyaWFudChmaW5kRGltZW5zaW9uVmFsdWVUeXBlKHRvW2kyXSkgPT09IHRvVHlwZSwgXCJBbGwga2V5ZnJhbWVzIG11c3QgYmUgb2YgdGhlIHNhbWUgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0b1R5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKHRvKTtcbiAgICB9XG4gICAgaWYgKGZyb21UeXBlICE9PSB0b1R5cGUpIHtcbiAgICAgIGlmIChpc051bU9yUHhUeXBlKGZyb21UeXBlKSAmJiBpc051bU9yUHhUeXBlKHRvVHlwZSkpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHZhbHVlLmdldCgpO1xuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YWx1ZS5zZXQocGFyc2VGbG9hdChjdXJyZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gcGFyc2VGbG9hdCh0byk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0bykgJiYgdG9UeXBlID09PSBweCkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdG8ubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChmcm9tVHlwZSA9PT0gbnVsbCB8fCBmcm9tVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnJvbVR5cGUudHJhbnNmb3JtKSAmJiAodG9UeXBlID09PSBudWxsIHx8IHRvVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9UeXBlLnRyYW5zZm9ybSkgJiYgKGZyb20gPT09IDAgfHwgdG8gPT09IDApKSB7XG4gICAgICAgIGlmIChmcm9tID09PSAwKSB7XG4gICAgICAgICAgdmFsdWUuc2V0KHRvVHlwZS50cmFuc2Zvcm0oZnJvbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gZnJvbVR5cGUudHJhbnNmb3JtKHRvKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNBdHRlbXB0ZWRUb1JlbW92ZVRyYW5zZm9ybVZhbHVlcykge1xuICAgICAgICAgIHJlbW92ZWRUcmFuc2Zvcm1WYWx1ZXMgPSByZW1vdmVOb25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtKHZpc3VhbEVsZW1lbnQpO1xuICAgICAgICAgIGhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkVmFsdWVUeXBlS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHRyYW5zaXRpb25FbmRba2V5XSA9IHRyYW5zaXRpb25FbmRba2V5XSAhPT0gdm9pZCAwID8gdHJhbnNpdGlvbkVuZFtrZXldIDogdGFyZ2V0W2tleV07XG4gICAgICAgIHNldEFuZFJlc2V0VmVsb2NpdHkodmFsdWUsIHRvKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoY2hhbmdlZFZhbHVlVHlwZUtleXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc2Nyb2xsWSA9IGNoYW5nZWRWYWx1ZVR5cGVLZXlzLmluZGV4T2YoXCJoZWlnaHRcIikgPj0gMCA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IG51bGw7XG4gICAgY29uc3QgY29udmVydGVkVGFyZ2V0ID0gY29udmVydENoYW5nZWRWYWx1ZVR5cGVzKHRhcmdldCwgdmlzdWFsRWxlbWVudCwgY2hhbmdlZFZhbHVlVHlwZUtleXMpO1xuICAgIGlmIChyZW1vdmVkVHJhbnNmb3JtVmFsdWVzLmxlbmd0aCkge1xuICAgICAgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpLnNldCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgICBpZiAoaXNCcm93c2VyICYmIHNjcm9sbFkgIT09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyh7IHRvcDogc2Nyb2xsWSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGFyZ2V0OiBjb252ZXJ0ZWRUYXJnZXQsIHRyYW5zaXRpb25FbmQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB0YXJnZXQsIHRyYW5zaXRpb25FbmQgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVuaXRDb252ZXJzaW9uKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKSB7XG4gIHJldHVybiBoYXNQb3NpdGlvbmFsS2V5KHRhcmdldCkgPyBjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCkgOiB7IHRhcmdldCwgdHJhbnNpdGlvbkVuZCB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvcGFyc2UtZG9tLXZhcmlhbnQubWpzXG52YXIgcGFyc2VEb21WYXJpYW50ID0gKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKSA9PiB7XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUNTU1ZhcmlhYmxlcyh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIHRyYW5zaXRpb25FbmQpO1xuICB0YXJnZXQgPSByZXNvbHZlZC50YXJnZXQ7XG4gIHRyYW5zaXRpb25FbmQgPSByZXNvbHZlZC50cmFuc2l0aW9uRW5kO1xuICByZXR1cm4gdW5pdENvbnZlcnNpb24odmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvVmlzdWFsRWxlbWVudC5tanNcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDMgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9yZWR1Y2VkLW1vdGlvbi9zdGF0ZS5tanNcbnZhciBwcmVmZXJzUmVkdWNlZE1vdGlvbiA9IHsgY3VycmVudDogbnVsbCB9O1xudmFyIGhhc1JlZHVjZWRNb3Rpb25MaXN0ZW5lciA9IHsgY3VycmVudDogZmFsc2UgfTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9yZWR1Y2VkLW1vdGlvbi9pbmRleC5tanNcbmZ1bmN0aW9uIGluaXRQcmVmZXJzUmVkdWNlZE1vdGlvbigpIHtcbiAgaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLmN1cnJlbnQgPSB0cnVlO1xuICBpZiAoIWlzQnJvd3NlcilcbiAgICByZXR1cm47XG4gIGlmICh3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgIGNvbnN0IG1vdGlvbk1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uKVwiKTtcbiAgICBjb25zdCBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMgPSAoKSA9PiBwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50ID0gbW90aW9uTWVkaWFRdWVyeS5tYXRjaGVzO1xuICAgIG1vdGlvbk1lZGlhUXVlcnkuYWRkTGlzdGVuZXIoc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzKTtcbiAgICBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMoKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvbW90aW9uLXZhbHVlcy5tanNcbmZ1bmN0aW9uIHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhlbGVtZW50LCBuZXh0LCBwcmV2KSB7XG4gIGNvbnN0IHsgd2lsbENoYW5nZSB9ID0gbmV4dDtcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9IG5leHRba2V5XTtcbiAgICBjb25zdCBwcmV2VmFsdWUgPSBwcmV2W2tleV07XG4gICAgaWYgKGlzTW90aW9uVmFsdWUobmV4dFZhbHVlKSkge1xuICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG5leHRWYWx1ZSk7XG4gICAgICBpZiAoaXNXaWxsQ2hhbmdlTW90aW9uVmFsdWUod2lsbENoYW5nZSkpIHtcbiAgICAgICAgd2lsbENoYW5nZS5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIHdhcm5PbmNlKG5leHRWYWx1ZS52ZXJzaW9uID09PSBcIjcuNi43XCIsIGBBdHRlbXB0aW5nIHRvIG1peCBGcmFtZXIgTW90aW9uIHZlcnNpb25zICR7bmV4dFZhbHVlLnZlcnNpb259IHdpdGggNy42LjcgbWF5IG5vdCB3b3JrIGFzIGV4cGVjdGVkLmApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNNb3Rpb25WYWx1ZShwcmV2VmFsdWUpKSB7XG4gICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUobmV4dFZhbHVlKSk7XG4gICAgICBpZiAoaXNXaWxsQ2hhbmdlTW90aW9uVmFsdWUod2lsbENoYW5nZSkpIHtcbiAgICAgICAgd2lsbENoYW5nZS5yZW1vdmUoa2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG4gICAgICBpZiAoZWxlbWVudC5oYXNWYWx1ZShrZXkpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSBlbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgICAgICFleGlzdGluZ1ZhbHVlLmhhc0FuaW1hdGVkICYmIGV4aXN0aW5nVmFsdWUuc2V0KG5leHRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsYXRlc3RWYWx1ZSA9IGVsZW1lbnQuZ2V0U3RhdGljVmFsdWUoa2V5KTtcbiAgICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKGxhdGVzdFZhbHVlICE9PSB2b2lkIDAgPyBsYXRlc3RWYWx1ZSA6IG5leHRWYWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgaWYgKG5leHRba2V5XSA9PT0gdm9pZCAwKVxuICAgICAgZWxlbWVudC5yZW1vdmVWYWx1ZShrZXkpO1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9WaXN1YWxFbGVtZW50Lm1qc1xudmFyIGZlYXR1cmVOYW1lcyA9IE9iamVjdC5rZXlzKGZlYXR1cmVEZWZpbml0aW9ucyk7XG52YXIgbnVtRmVhdHVyZXMgPSBmZWF0dXJlTmFtZXMubGVuZ3RoO1xudmFyIHByb3BFdmVudEhhbmRsZXJzID0gW1xuICBcIkFuaW1hdGlvblN0YXJ0XCIsXG4gIFwiQW5pbWF0aW9uQ29tcGxldGVcIixcbiAgXCJVcGRhdGVcIixcbiAgXCJVbm1vdW50XCIsXG4gIFwiQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICBcIkxheW91dE1lYXN1cmVcIixcbiAgXCJMYXlvdXRBbmltYXRpb25TdGFydFwiLFxuICBcIkxheW91dEFuaW1hdGlvbkNvbXBsZXRlXCJcbl07XG52YXIgVmlzdWFsRWxlbWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyBwYXJlbnQsIHByb3BzLCByZWR1Y2VkTW90aW9uQ29uZmlnLCB2aXN1YWxTdGF0ZSB9LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuaXNWYXJpYW50Tm9kZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNDb250cm9sbGluZ1ZhcmlhbnRzID0gZmFsc2U7XG4gICAgdGhpcy5zaG91bGRSZWR1Y2VNb3Rpb24gPSBudWxsO1xuICAgIHRoaXMudmFsdWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmlzUHJlc2VudCA9IHRydWU7XG4gICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJldk1vdGlvblZhbHVlcyA9IHt9O1xuICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgdGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zID0ge307XG4gICAgdGhpcy5ub3RpZnlVcGRhdGUgPSAoKSA9PiB0aGlzLm5vdGlmeShcIlVwZGF0ZVwiLCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgdGhpcy5yZW5kZXIgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuY3VycmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy50cmlnZ2VyQnVpbGQoKTtcbiAgICAgIHRoaXMucmVuZGVySW5zdGFuY2UodGhpcy5jdXJyZW50LCB0aGlzLnJlbmRlclN0YXRlLCB0aGlzLnByb3BzLnN0eWxlLCB0aGlzLnByb2plY3Rpb24pO1xuICAgIH07XG4gICAgdGhpcy5zY2hlZHVsZVJlbmRlciA9ICgpID0+IGVzX2RlZmF1bHQucmVuZGVyKHRoaXMucmVuZGVyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgY29uc3QgeyBsYXRlc3RWYWx1ZXMsIHJlbmRlclN0YXRlIH0gPSB2aXN1YWxTdGF0ZTtcbiAgICB0aGlzLmxhdGVzdFZhbHVlcyA9IGxhdGVzdFZhbHVlcztcbiAgICB0aGlzLmJhc2VUYXJnZXQgPSBfX3NwcmVhZFZhbHVlcyh7fSwgbGF0ZXN0VmFsdWVzKTtcbiAgICB0aGlzLmluaXRpYWxWYWx1ZXMgPSBwcm9wcy5pbml0aWFsID8gX19zcHJlYWRWYWx1ZXMoe30sIGxhdGVzdFZhbHVlcykgOiB7fTtcbiAgICB0aGlzLnJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMuZGVwdGggPSBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcbiAgICB0aGlzLnJlZHVjZWRNb3Rpb25Db25maWcgPSByZWR1Y2VkTW90aW9uQ29uZmlnO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHMgPSBpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpO1xuICAgIHRoaXMuaXNWYXJpYW50Tm9kZSA9IGlzVmFyaWFudE5vZGUocHJvcHMpO1xuICAgIGlmICh0aGlzLmlzVmFyaWFudE5vZGUpIHtcbiAgICAgIHRoaXMudmFyaWFudENoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB9XG4gICAgdGhpcy5tYW51YWxseUFuaW1hdGVPbk1vdW50ID0gQm9vbGVhbihwYXJlbnQgJiYgcGFyZW50LmN1cnJlbnQpO1xuICAgIGNvbnN0IF9hID0gdGhpcy5zY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpLCB7IHdpbGxDaGFuZ2UgfSA9IF9hLCBpbml0aWFsTW90aW9uVmFsdWVzID0gX19vYmpSZXN0KF9hLCBbXCJ3aWxsQ2hhbmdlXCJdKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbml0aWFsTW90aW9uVmFsdWVzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxNb3Rpb25WYWx1ZXNba2V5XTtcbiAgICAgIGlmIChsYXRlc3RWYWx1ZXNba2V5XSAhPT0gdm9pZCAwICYmIGlzTW90aW9uVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLnNldChsYXRlc3RWYWx1ZXNba2V5XSwgZmFsc2UpO1xuICAgICAgICBpZiAoaXNXaWxsQ2hhbmdlTW90aW9uVmFsdWUod2lsbENoYW5nZSkpIHtcbiAgICAgICAgICB3aWxsQ2hhbmdlLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhfcHJvcHMpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgbW91bnQoaW5zdGFuY2UpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgaWYgKHRoaXMucHJvamVjdGlvbikge1xuICAgICAgdGhpcy5wcm9qZWN0aW9uLm1vdW50KGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMuaXNWYXJpYW50Tm9kZSAmJiAhdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHMpIHtcbiAgICAgIHRoaXMucmVtb3ZlRnJvbVZhcmlhbnRUcmVlID0gKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRWYXJpYW50Q2hpbGQodGhpcyk7XG4gICAgfVxuICAgIHRoaXMudmFsdWVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHRoaXMuYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICAgIGlmICghaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLmN1cnJlbnQpIHtcbiAgICAgIGluaXRQcmVmZXJzUmVkdWNlZE1vdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLnNob3VsZFJlZHVjZU1vdGlvbiA9IHRoaXMucmVkdWNlZE1vdGlvbkNvbmZpZyA9PT0gXCJuZXZlclwiID8gZmFsc2UgOiB0aGlzLnJlZHVjZWRNb3Rpb25Db25maWcgPT09IFwiYWx3YXlzXCIgPyB0cnVlIDogcHJlZmVyc1JlZHVjZWRNb3Rpb24uY3VycmVudDtcbiAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5hZGQodGhpcyk7XG4gICAgdGhpcy5zZXRQcm9wcyh0aGlzLnByb3BzKTtcbiAgfVxuICB1bm1vdW50KCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIChfYSA9IHRoaXMucHJvamVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVubW91bnQoKTtcbiAgICBjYW5jZWxTeW5jLnVwZGF0ZSh0aGlzLm5vdGlmeVVwZGF0ZSk7XG4gICAgY2FuY2VsU3luYy5yZW5kZXIodGhpcy5yZW5kZXIpO1xuICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmZvckVhY2goKHJlbW92ZSkgPT4gcmVtb3ZlKCkpO1xuICAgIChfYiA9IHRoaXMucmVtb3ZlRnJvbVZhcmlhbnRUcmVlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzKTtcbiAgICAoX2MgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNoaWxkcmVuLmRlbGV0ZSh0aGlzKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmV2ZW50cykge1xuICAgICAgdGhpcy5ldmVudHNba2V5XS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB9XG4gIGJpbmRUb01vdGlvblZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCByZW1vdmVPbkNoYW5nZSA9IHZhbHVlLm9uQ2hhbmdlKChsYXRlc3RWYWx1ZSkgPT4ge1xuICAgICAgdGhpcy5sYXRlc3RWYWx1ZXNba2V5XSA9IGxhdGVzdFZhbHVlO1xuICAgICAgdGhpcy5wcm9wcy5vblVwZGF0ZSAmJiBlc19kZWZhdWx0LnVwZGF0ZSh0aGlzLm5vdGlmeVVwZGF0ZSwgZmFsc2UsIHRydWUpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlbW92ZU9uUmVuZGVyUmVxdWVzdCA9IHZhbHVlLm9uUmVuZGVyUmVxdWVzdCh0aGlzLnNjaGVkdWxlUmVuZGVyKTtcbiAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5zZXQoa2V5LCAoKSA9PiB7XG4gICAgICByZW1vdmVPbkNoYW5nZSgpO1xuICAgICAgcmVtb3ZlT25SZW5kZXJSZXF1ZXN0KCk7XG4gICAgfSk7XG4gIH1cbiAgc29ydE5vZGVQb3NpdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5jdXJyZW50IHx8ICF0aGlzLnNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbiB8fCB0aGlzLnR5cGUgIT09IG90aGVyLnR5cGUpXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gdGhpcy5zb3J0SW5zdGFuY2VOb2RlUG9zaXRpb24odGhpcy5jdXJyZW50LCBvdGhlci5jdXJyZW50KTtcbiAgfVxuICBsb2FkRmVhdHVyZXMocmVuZGVyZWRQcm9wcywgaXNTdHJpY3QsIHByZWxvYWRlZEZlYXR1cmVzLCBwcm9qZWN0aW9uSWQsIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsIGluaXRpYWxMYXlvdXRHcm91cENvbmZpZykge1xuICAgIGNvbnN0IGZlYXR1cmVzID0gW107XG4gICAgaWYgKGVudiAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgcHJlbG9hZGVkRmVhdHVyZXMgJiYgaXNTdHJpY3QpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJZb3UgaGF2ZSByZW5kZXJlZCBhIGBtb3Rpb25gIGNvbXBvbmVudCB3aXRoaW4gYSBgTGF6eU1vdGlvbmAgY29tcG9uZW50LiBUaGlzIHdpbGwgYnJlYWsgdHJlZSBzaGFraW5nLiBJbXBvcnQgYW5kIHJlbmRlciBhIGBtYCBjb21wb25lbnQgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1GZWF0dXJlczsgaTIrKykge1xuICAgICAgY29uc3QgbmFtZSA9IGZlYXR1cmVOYW1lc1tpMl07XG4gICAgICBjb25zdCB7IGlzRW5hYmxlZCwgQ29tcG9uZW50IH0gPSBmZWF0dXJlRGVmaW5pdGlvbnNbbmFtZV07XG4gICAgICBpZiAoaXNFbmFibGVkKHJlbmRlcmVkUHJvcHMpICYmIENvbXBvbmVudCkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZUVsZW1lbnQzKENvbXBvbmVudCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAga2V5OiBuYW1lXG4gICAgICAgIH0sIHJlbmRlcmVkUHJvcHMpLCB7XG4gICAgICAgICAgdmlzdWFsRWxlbWVudDogdGhpc1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMucHJvamVjdGlvbiAmJiBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLnByb2plY3Rpb24gPSBuZXcgUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3Rvcihwcm9qZWN0aW9uSWQsIHRoaXMubGF0ZXN0VmFsdWVzLCB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5wcm9qZWN0aW9uKTtcbiAgICAgIGNvbnN0IHsgbGF5b3V0SWQsIGxheW91dCwgZHJhZzogZHJhZzIsIGRyYWdDb25zdHJhaW50cywgbGF5b3V0U2Nyb2xsIH0gPSByZW5kZXJlZFByb3BzO1xuICAgICAgdGhpcy5wcm9qZWN0aW9uLnNldE9wdGlvbnMoe1xuICAgICAgICBsYXlvdXRJZCxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBhbHdheXNNZWFzdXJlTGF5b3V0OiBCb29sZWFuKGRyYWcyKSB8fCBkcmFnQ29uc3RyYWludHMgJiYgaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSxcbiAgICAgICAgdmlzdWFsRWxlbWVudDogdGhpcyxcbiAgICAgICAgc2NoZWR1bGVSZW5kZXI6ICgpID0+IHRoaXMuc2NoZWR1bGVSZW5kZXIoKSxcbiAgICAgICAgYW5pbWF0aW9uVHlwZTogdHlwZW9mIGxheW91dCA9PT0gXCJzdHJpbmdcIiA/IGxheW91dCA6IFwiYm90aFwiLFxuICAgICAgICBpbml0aWFsUHJvbW90aW9uQ29uZmlnOiBpbml0aWFsTGF5b3V0R3JvdXBDb25maWcsXG4gICAgICAgIGxheW91dFNjcm9sbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuICB0cmlnZ2VyQnVpbGQoKSB7XG4gICAgdGhpcy5idWlsZCh0aGlzLnJlbmRlclN0YXRlLCB0aGlzLmxhdGVzdFZhbHVlcywgdGhpcy5vcHRpb25zLCB0aGlzLnByb3BzKTtcbiAgfVxuICBtZWFzdXJlVmlld3BvcnRCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudCA/IHRoaXMubWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3godGhpcy5jdXJyZW50LCB0aGlzLnByb3BzKSA6IGNyZWF0ZUJveCgpO1xuICB9XG4gIGdldFN0YXRpY1ZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLmxhdGVzdFZhbHVlc1trZXldO1xuICB9XG4gIHNldFN0YXRpY1ZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmxhdGVzdFZhbHVlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgbWFrZVRhcmdldEFuaW1hdGFibGUodGFyZ2V0LCBjYW5NdXRhdGUgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVRhcmdldEFuaW1hdGFibGVGcm9tSW5zdGFuY2UodGFyZ2V0LCB0aGlzLnByb3BzLCBjYW5NdXRhdGUpO1xuICB9XG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlIHx8IHRoaXMucHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICB9XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBwcm9wRXZlbnRIYW5kbGVycy5sZW5ndGg7IGkyKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IHByb3BFdmVudEhhbmRsZXJzW2kyXTtcbiAgICAgIGlmICh0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XSkge1xuICAgICAgICB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IHByb3BzW1wib25cIiArIGtleV07XG4gICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zW2tleV0gPSB0aGlzLm9uKGtleSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByZXZNb3Rpb25WYWx1ZXMgPSB1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHModGhpcywgdGhpcy5zY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpLCB0aGlzLnByZXZNb3Rpb25WYWx1ZXMpO1xuICB9XG4gIGdldFByb3BzKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzO1xuICB9XG4gIGdldFZhcmlhbnQobmFtZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5wcm9wcy52YXJpYW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW25hbWVdO1xuICB9XG4gIGdldERlZmF1bHRUcmFuc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnRyYW5zaXRpb247XG4gIH1cbiAgZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgfVxuICBnZXRDbG9zZXN0VmFyaWFudE5vZGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiB0aGlzLmlzVmFyaWFudE5vZGUgPyB0aGlzIDogKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRDbG9zZXN0VmFyaWFudE5vZGUoKTtcbiAgfVxuICBnZXRWYXJpYW50Q29udGV4dChzdGFydEF0UGFyZW50ID0gZmFsc2UpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChzdGFydEF0UGFyZW50KVxuICAgICAgcmV0dXJuIChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VmFyaWFudENvbnRleHQoKTtcbiAgICBpZiAoIXRoaXMuaXNDb250cm9sbGluZ1ZhcmlhbnRzKSB7XG4gICAgICBjb25zdCBjb250ZXh0MiA9ICgoX2IgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFZhcmlhbnRDb250ZXh0KCkpIHx8IHt9O1xuICAgICAgaWYgKHRoaXMucHJvcHMuaW5pdGlhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQyLmluaXRpYWwgPSB0aGlzLnByb3BzLmluaXRpYWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGV4dDI7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB7fTtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtVmFyaWFudFByb3BzOyBpMisrKSB7XG4gICAgICBjb25zdCBuYW1lID0gdmFyaWFudFByb3BzMltpMl07XG4gICAgICBjb25zdCBwcm9wID0gdGhpcy5wcm9wc1tuYW1lXTtcbiAgICAgIGlmIChpc1ZhcmlhbnRMYWJlbChwcm9wKSB8fCBwcm9wID09PSBmYWxzZSkge1xuICAgICAgICBjb250ZXh0W25hbWVdID0gcHJvcDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgYWRkVmFyaWFudENoaWxkKGNoaWxkKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNsb3Nlc3RWYXJpYW50Tm9kZSA9IHRoaXMuZ2V0Q2xvc2VzdFZhcmlhbnROb2RlKCk7XG4gICAgaWYgKGNsb3Nlc3RWYXJpYW50Tm9kZSkge1xuICAgICAgKF9hID0gY2xvc2VzdFZhcmlhbnROb2RlLnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZChjaGlsZCk7XG4gICAgICByZXR1cm4gKCkgPT4gY2xvc2VzdFZhcmlhbnROb2RlLnZhcmlhbnRDaGlsZHJlbi5kZWxldGUoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBhZGRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaGFzVmFsdWUoa2V5KSlcbiAgICAgIHRoaXMucmVtb3ZlVmFsdWUoa2V5KTtcbiAgICB0aGlzLnZhbHVlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgdGhpcy5sYXRlc3RWYWx1ZXNba2V5XSA9IHZhbHVlLmdldCgpO1xuICAgIHRoaXMuYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmVtb3ZlVmFsdWUoa2V5KSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMudmFsdWVzLmRlbGV0ZShrZXkpO1xuICAgIChfYSA9IHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoKTtcbiAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5kZWxldGUoa2V5KTtcbiAgICBkZWxldGUgdGhpcy5sYXRlc3RWYWx1ZXNba2V5XTtcbiAgICB0aGlzLnJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlKGtleSwgdGhpcy5yZW5kZXJTdGF0ZSk7XG4gIH1cbiAgaGFzVmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzLmhhcyhrZXkpO1xuICB9XG4gIGdldFZhbHVlKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHRoaXMucHJvcHMudmFsdWVzICYmIHRoaXMucHJvcHMudmFsdWVzW2tleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLnZhbHVlc1trZXldO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSB0aGlzLnZhbHVlcy5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCAmJiBkZWZhdWx0VmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBtb3Rpb25WYWx1ZShkZWZhdWx0VmFsdWUpO1xuICAgICAgdGhpcy5hZGRWYWx1ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlc3RWYWx1ZXNba2V5XSAhPT0gdm9pZCAwIHx8ICF0aGlzLmN1cnJlbnQgPyB0aGlzLmxhdGVzdFZhbHVlc1trZXldIDogdGhpcy5yZWFkVmFsdWVGcm9tSW5zdGFuY2UodGhpcy5jdXJyZW50LCBrZXksIHRoaXMub3B0aW9ucyk7XG4gIH1cbiAgc2V0QmFzZVRhcmdldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5iYXNlVGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgfVxuICBnZXRCYXNlVGFyZ2V0KGtleSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGluaXRpYWwgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgdmFsdWVGcm9tSW5pdGlhbCA9IHR5cGVvZiBpbml0aWFsID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBpbml0aWFsID09PSBcIm9iamVjdFwiID8gKF9hID0gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHModGhpcy5wcm9wcywgaW5pdGlhbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtrZXldIDogdm9pZCAwO1xuICAgIGlmIChpbml0aWFsICYmIHZhbHVlRnJvbUluaXRpYWwgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZhbHVlRnJvbUluaXRpYWw7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyh0aGlzLnByb3BzLCBrZXkpO1xuICAgIGlmICh0YXJnZXQgIT09IHZvaWQgMCAmJiAhaXNNb3Rpb25WYWx1ZSh0YXJnZXQpKVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWVzW2tleV0gIT09IHZvaWQgMCAmJiB2YWx1ZUZyb21Jbml0aWFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGlzLmJhc2VUYXJnZXRba2V5XTtcbiAgfVxuICBvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uYWRkKGNhbGxiYWNrKTtcbiAgfVxuICBub3RpZnkoZXZlbnROYW1lLCAuLi5hcmdzKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub3RpZnkoLi4uYXJncyk7XG4gIH1cbn07XG52YXIgdmFyaWFudFByb3BzMiA9IFtcImluaXRpYWxcIiwgLi4udmFyaWFudFByaW9yaXR5T3JkZXJdO1xudmFyIG51bVZhcmlhbnRQcm9wcyA9IHZhcmlhbnRQcm9wczIubGVuZ3RoO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vRE9NVmlzdWFsRWxlbWVudC5tanNcbnZhciBET01WaXN1YWxFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBWaXN1YWxFbGVtZW50IHtcbiAgc29ydEluc3RhbmNlTm9kZVBvc2l0aW9uKGEyLCBiMikge1xuICAgIHJldHVybiBhMi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiMikgJiAyID8gMSA6IC0xO1xuICB9XG4gIGdldEJhc2VUYXJnZXRGcm9tUHJvcHMocHJvcHMsIGtleSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gcHJvcHMuc3R5bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtrZXldO1xuICB9XG4gIHJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlKGtleSwgeyB2YXJzLCBzdHlsZSB9KSB7XG4gICAgZGVsZXRlIHZhcnNba2V5XTtcbiAgICBkZWxldGUgc3R5bGVba2V5XTtcbiAgfVxuICBtYWtlVGFyZ2V0QW5pbWF0YWJsZUZyb21JbnN0YW5jZShfYSwgeyB0cmFuc2Zvcm1WYWx1ZXMgfSwgaXNNb3VudGVkKSB7XG4gICAgdmFyIF9iID0gX2EsIHsgdHJhbnNpdGlvbiwgdHJhbnNpdGlvbkVuZCB9ID0gX2IsIHRhcmdldCA9IF9fb2JqUmVzdChfYiwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xuICAgIGxldCBvcmlnaW4gPSBnZXRPcmlnaW4odGFyZ2V0LCB0cmFuc2l0aW9uIHx8IHt9LCB0aGlzKTtcbiAgICBpZiAodHJhbnNmb3JtVmFsdWVzKSB7XG4gICAgICBpZiAodHJhbnNpdGlvbkVuZClcbiAgICAgICAgdHJhbnNpdGlvbkVuZCA9IHRyYW5zZm9ybVZhbHVlcyh0cmFuc2l0aW9uRW5kKTtcbiAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgIHRhcmdldCA9IHRyYW5zZm9ybVZhbHVlcyh0YXJnZXQpO1xuICAgICAgaWYgKG9yaWdpbilcbiAgICAgICAgb3JpZ2luID0gdHJhbnNmb3JtVmFsdWVzKG9yaWdpbik7XG4gICAgfVxuICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgIGNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzKHRoaXMsIHRhcmdldCwgb3JpZ2luKTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRG9tVmFyaWFudCh0aGlzLCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCk7XG4gICAgICB0cmFuc2l0aW9uRW5kID0gcGFyc2VkLnRyYW5zaXRpb25FbmQ7XG4gICAgICB0YXJnZXQgPSBwYXJzZWQudGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIHRyYW5zaXRpb25FbmRcbiAgICB9LCB0YXJnZXQpO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL0hUTUxWaXN1YWxFbGVtZW50Lm1qc1xuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZTIoZWxlbWVudCkge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG52YXIgSFRNTFZpc3VhbEVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIERPTVZpc3VhbEVsZW1lbnQge1xuICByZWFkVmFsdWVGcm9tSW5zdGFuY2UoaW5zdGFuY2UsIGtleSkge1xuICAgIGlmICh0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSkge1xuICAgICAgY29uc3QgZGVmYXVsdFR5cGUgPSBnZXREZWZhdWx0VmFsdWVUeXBlKGtleSk7XG4gICAgICByZXR1cm4gZGVmYXVsdFR5cGUgPyBkZWZhdWx0VHlwZS5kZWZhdWx0IHx8IDAgOiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZTIoaW5zdGFuY2UpO1xuICAgICAgY29uc3QgdmFsdWUgPSAoaXNDU1NWYXJpYWJsZShrZXkpID8gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGtleSkgOiBjb21wdXRlZFN0eWxlW2tleV0pIHx8IDA7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUudHJpbSgpIDogdmFsdWU7XG4gICAgfVxuICB9XG4gIG1lYXN1cmVJbnN0YW5jZVZpZXdwb3J0Qm94KGluc3RhbmNlLCB7IHRyYW5zZm9ybVBhZ2VQb2ludCB9KSB7XG4gICAgcmV0dXJuIG1lYXN1cmVWaWV3cG9ydEJveChpbnN0YW5jZSwgdHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgfVxuICBidWlsZChyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBvcHRpb25zLCBwcm9wcykge1xuICAgIGJ1aWxkSFRNTFN0eWxlcyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBvcHRpb25zLCBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gIH1cbiAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcyk7XG4gIH1cbiAgcmVuZGVySW5zdGFuY2UoaW5zdGFuY2UsIHJlbmRlclN0YXRlLCBzdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgICByZW5kZXJIVE1MKGluc3RhbmNlLCByZW5kZXJTdGF0ZSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL1NWR1Zpc3VhbEVsZW1lbnQubWpzXG52YXIgU1ZHVmlzdWFsRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgRE9NVmlzdWFsRWxlbWVudCB7XG4gIGdldEJhc2VUYXJnZXRGcm9tUHJvcHMocHJvcHMsIGtleSkge1xuICAgIHJldHVybiBwcm9wc1trZXldO1xuICB9XG4gIHJlYWRWYWx1ZUZyb21JbnN0YW5jZShpbnN0YW5jZSwga2V5KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuICgoX2EgPSBnZXREZWZhdWx0VmFsdWVUeXBlKGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0KSB8fCAwO1xuICAgIH1cbiAgICBrZXkgPSAhY2FtZWxDYXNlQXR0cmlidXRlcy5oYXMoa2V5KSA/IGNhbWVsVG9EYXNoKGtleSkgOiBrZXk7XG4gICAgcmV0dXJuIGluc3RhbmNlLmdldEF0dHJpYnV0ZShrZXkpO1xuICB9XG4gIG1lYXN1cmVJbnN0YW5jZVZpZXdwb3J0Qm94KCkge1xuICAgIHJldHVybiBjcmVhdGVCb3goKTtcbiAgfVxuICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMihwcm9wcyk7XG4gIH1cbiAgYnVpbGQocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMpIHtcbiAgICBidWlsZFNWR0F0dHJzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgfVxuICByZW5kZXJJbnN0YW5jZShpbnN0YW5jZSwgcmVuZGVyU3RhdGUsIHN0eWxlUHJvcCwgcHJvamVjdGlvbikge1xuICAgIHJlbmRlclNWRyhpbnN0YW5jZSwgcmVuZGVyU3RhdGUsIHN0eWxlUHJvcCwgcHJvamVjdGlvbik7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS9jcmVhdGUtdmlzdWFsLWVsZW1lbnQubWpzXG52YXIgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCA9IChDb21wb25lbnQsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudCkgPyBuZXcgU1ZHVmlzdWFsRWxlbWVudChvcHRpb25zLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiBmYWxzZSB9KSA6IG5ldyBIVE1MVmlzdWFsRWxlbWVudChvcHRpb25zLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiB0cnVlIH0pO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvbGF5b3V0L01lYXN1cmVMYXlvdXQubWpzXG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQyLCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDkgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1ib3JkZXItcmFkaXVzLm1qc1xuZnVuY3Rpb24gcGl4ZWxzVG9QZXJjZW50KHBpeGVscywgYXhpcykge1xuICBpZiAoYXhpcy5tYXggPT09IGF4aXMubWluKVxuICAgIHJldHVybiAwO1xuICByZXR1cm4gcGl4ZWxzIC8gKGF4aXMubWF4IC0gYXhpcy5taW4pICogMTAwO1xufVxudmFyIGNvcnJlY3RCb3JkZXJSYWRpdXMgPSB7XG4gIGNvcnJlY3Q6IChsYXRlc3QsIG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUudGFyZ2V0KVxuICAgICAgcmV0dXJuIGxhdGVzdDtcbiAgICBpZiAodHlwZW9mIGxhdGVzdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHB4LnRlc3QobGF0ZXN0KSkge1xuICAgICAgICBsYXRlc3QgPSBwYXJzZUZsb2F0KGxhdGVzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGF0ZXN0O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB4ID0gcGl4ZWxzVG9QZXJjZW50KGxhdGVzdCwgbm9kZS50YXJnZXQueCk7XG4gICAgY29uc3QgeSA9IHBpeGVsc1RvUGVyY2VudChsYXRlc3QsIG5vZGUudGFyZ2V0LnkpO1xuICAgIHJldHVybiBgJHt4fSUgJHt5fSVgO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWJveC1zaGFkb3cubWpzXG52YXIgdmFyVG9rZW4gPSBcIl8kY3NzXCI7XG52YXIgY29ycmVjdEJveFNoYWRvdyA9IHtcbiAgY29ycmVjdDogKGxhdGVzdCwgeyB0cmVlU2NhbGUsIHByb2plY3Rpb25EZWx0YSB9KSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSBsYXRlc3Q7XG4gICAgY29uc3QgY29udGFpbnNDU1NWYXJpYWJsZXMgPSBsYXRlc3QuaW5jbHVkZXMoXCJ2YXIoXCIpO1xuICAgIGNvbnN0IGNzc1ZhcmlhYmxlcyA9IFtdO1xuICAgIGlmIChjb250YWluc0NTU1ZhcmlhYmxlcykge1xuICAgICAgbGF0ZXN0ID0gbGF0ZXN0LnJlcGxhY2UoY3NzVmFyaWFibGVSZWdleCwgKG1hdGNoKSA9PiB7XG4gICAgICAgIGNzc1ZhcmlhYmxlcy5wdXNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHZhclRva2VuO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNoYWRvdyA9IGNvbXBsZXgucGFyc2UobGF0ZXN0KTtcbiAgICBpZiAoc2hhZG93Lmxlbmd0aCA+IDUpXG4gICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBjb21wbGV4LmNyZWF0ZVRyYW5zZm9ybWVyKGxhdGVzdCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdHlwZW9mIHNoYWRvd1swXSAhPT0gXCJudW1iZXJcIiA/IDEgOiAwO1xuICAgIGNvbnN0IHhTY2FsZSA9IHByb2plY3Rpb25EZWx0YS54LnNjYWxlICogdHJlZVNjYWxlLng7XG4gICAgY29uc3QgeVNjYWxlID0gcHJvamVjdGlvbkRlbHRhLnkuc2NhbGUgKiB0cmVlU2NhbGUueTtcbiAgICBzaGFkb3dbMCArIG9mZnNldF0gLz0geFNjYWxlO1xuICAgIHNoYWRvd1sxICsgb2Zmc2V0XSAvPSB5U2NhbGU7XG4gICAgY29uc3QgYXZlcmFnZVNjYWxlID0gbWl4KHhTY2FsZSwgeVNjYWxlLCAwLjUpO1xuICAgIGlmICh0eXBlb2Ygc2hhZG93WzIgKyBvZmZzZXRdID09PSBcIm51bWJlclwiKVxuICAgICAgc2hhZG93WzIgKyBvZmZzZXRdIC89IGF2ZXJhZ2VTY2FsZTtcbiAgICBpZiAodHlwZW9mIHNoYWRvd1szICsgb2Zmc2V0XSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHNoYWRvd1szICsgb2Zmc2V0XSAvPSBhdmVyYWdlU2NhbGU7XG4gICAgbGV0IG91dHB1dCA9IHRlbXBsYXRlKHNoYWRvdyk7XG4gICAgaWYgKGNvbnRhaW5zQ1NTVmFyaWFibGVzKSB7XG4gICAgICBsZXQgaTIgPSAwO1xuICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UodmFyVG9rZW4sICgpID0+IHtcbiAgICAgICAgY29uc3QgY3NzVmFyaWFibGUgPSBjc3NWYXJpYWJsZXNbaTJdO1xuICAgICAgICBpMisrO1xuICAgICAgICByZXR1cm4gY3NzVmFyaWFibGU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvbGF5b3V0L01lYXN1cmVMYXlvdXQubWpzXG52YXIgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdF9fZGVmYXVsdDIuQ29tcG9uZW50IHtcbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyB2aXN1YWxFbGVtZW50LCBsYXlvdXRHcm91cCwgc3dpdGNoTGF5b3V0R3JvdXAsIGxheW91dElkIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICBhZGRTY2FsZUNvcnJlY3RvcihkZWZhdWx0U2NhbGVDb3JyZWN0b3JzKTtcbiAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgaWYgKGxheW91dEdyb3VwLmdyb3VwKVxuICAgICAgICBsYXlvdXRHcm91cC5ncm91cC5hZGQocHJvamVjdGlvbik7XG4gICAgICBpZiAoc3dpdGNoTGF5b3V0R3JvdXAgJiYgc3dpdGNoTGF5b3V0R3JvdXAucmVnaXN0ZXIgJiYgbGF5b3V0SWQpIHtcbiAgICAgICAgc3dpdGNoTGF5b3V0R3JvdXAucmVnaXN0ZXIocHJvamVjdGlvbik7XG4gICAgICB9XG4gICAgICBwcm9qZWN0aW9uLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25Db21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICAgIHByb2plY3Rpb24uc2V0T3B0aW9ucyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9qZWN0aW9uLm9wdGlvbnMpLCB7XG4gICAgICAgIG9uRXhpdENvbXBsZXRlOiAoKSA9PiB0aGlzLnNhZmVUb1JlbW92ZSgpXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNFdmVyVXBkYXRlZCA9IHRydWU7XG4gIH1cbiAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzKSB7XG4gICAgY29uc3QgeyBsYXlvdXREZXBlbmRlbmN5LCB2aXN1YWxFbGVtZW50LCBkcmFnOiBkcmFnMiwgaXNQcmVzZW50IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSB2aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgaWYgKCFwcm9qZWN0aW9uKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcHJvamVjdGlvbi5pc1ByZXNlbnQgPSBpc1ByZXNlbnQ7XG4gICAgaWYgKGRyYWcyIHx8IHByZXZQcm9wcy5sYXlvdXREZXBlbmRlbmN5ICE9PSBsYXlvdXREZXBlbmRlbmN5IHx8IGxheW91dERlcGVuZGVuY3kgPT09IHZvaWQgMCkge1xuICAgICAgcHJvamVjdGlvbi53aWxsVXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmIChwcmV2UHJvcHMuaXNQcmVzZW50ICE9PSBpc1ByZXNlbnQpIHtcbiAgICAgIGlmIChpc1ByZXNlbnQpIHtcbiAgICAgICAgcHJvamVjdGlvbi5wcm9tb3RlKCk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9qZWN0aW9uLnJlbGVnYXRlKCkpIHtcbiAgICAgICAgZXNfZGVmYXVsdC5wb3N0UmVuZGVyKCgpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgaWYgKCEoKF9hID0gcHJvamVjdGlvbi5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVtYmVycy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMucHJvcHMudmlzdWFsRWxlbWVudDtcbiAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgcHJvamVjdGlvbi5yb290LmRpZFVwZGF0ZSgpO1xuICAgICAgaWYgKCFwcm9qZWN0aW9uLmN1cnJlbnRBbmltYXRpb24gJiYgcHJvamVjdGlvbi5pc0xlYWQoKSkge1xuICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQsIGxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cDogcHJvbW90ZUNvbnRleHQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB2aXN1YWxFbGVtZW50O1xuICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICBwcm9qZWN0aW9uLnNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQoKTtcbiAgICAgIGlmIChsYXlvdXRHcm91cCA9PT0gbnVsbCB8fCBsYXlvdXRHcm91cCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0R3JvdXAuZ3JvdXApXG4gICAgICAgIGxheW91dEdyb3VwLmdyb3VwLnJlbW92ZShwcm9qZWN0aW9uKTtcbiAgICAgIGlmIChwcm9tb3RlQ29udGV4dCA9PT0gbnVsbCB8fCBwcm9tb3RlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvbW90ZUNvbnRleHQuZGVyZWdpc3RlcilcbiAgICAgICAgcHJvbW90ZUNvbnRleHQuZGVyZWdpc3Rlcihwcm9qZWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgc2FmZVRvUmVtb3ZlKCkge1xuICAgIGNvbnN0IHsgc2FmZVRvUmVtb3ZlIH0gPSB0aGlzLnByb3BzO1xuICAgIHNhZmVUb1JlbW92ZSA9PT0gbnVsbCB8fCBzYWZlVG9SZW1vdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNhZmVUb1JlbW92ZSgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbmZ1bmN0aW9uIE1lYXN1cmVMYXlvdXQocHJvcHMpIHtcbiAgY29uc3QgW2lzUHJlc2VudCwgc2FmZVRvUmVtb3ZlXSA9IHVzZVByZXNlbmNlKCk7XG4gIGNvbnN0IGxheW91dEdyb3VwID0gdXNlQ29udGV4dDkoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0Mi5jcmVhdGVFbGVtZW50KE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpLCB7IGxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cDogdXNlQ29udGV4dDkoU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0KSwgaXNQcmVzZW50LCBzYWZlVG9SZW1vdmUgfSkpO1xufVxudmFyIGRlZmF1bHRTY2FsZUNvcnJlY3RvcnMgPSB7XG4gIGJvcmRlclJhZGl1czogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgY29ycmVjdEJvcmRlclJhZGl1cyksIHtcbiAgICBhcHBseVRvOiBbXG4gICAgICBcImJvcmRlclRvcExlZnRSYWRpdXNcIixcbiAgICAgIFwiYm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcbiAgICAgIFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiLFxuICAgICAgXCJib3JkZXJCb3R0b21SaWdodFJhZGl1c1wiXG4gICAgXVxuICB9KSxcbiAgYm9yZGVyVG9wTGVmdFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICBib3hTaGFkb3c6IGNvcnJlY3RCb3hTaGFkb3dcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xheW91dC9pbmRleC5tanNcbnZhciBsYXlvdXRGZWF0dXJlcyA9IHtcbiAgbWVhc3VyZUxheW91dDogTWVhc3VyZUxheW91dFxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vYW5pbWF0ZS5tanNcbmZ1bmN0aW9uIGFuaW1hdGUyKGZyb20sIHRvLCB0cmFuc2l0aW9uID0ge30pIHtcbiAgY29uc3QgdmFsdWUgPSBpc01vdGlvblZhbHVlKGZyb20pID8gZnJvbSA6IG1vdGlvblZhbHVlKGZyb20pO1xuICBzdGFydEFuaW1hdGlvbihcIlwiLCB2YWx1ZSwgdG8sIHRyYW5zaXRpb24pO1xuICByZXR1cm4ge1xuICAgIHN0b3A6ICgpID0+IHZhbHVlLnN0b3AoKSxcbiAgICBpc0FuaW1hdGluZzogKCkgPT4gdmFsdWUuaXNBbmltYXRpbmcoKVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vYW5pbWF0aW9uL21peC12YWx1ZXMubWpzXG52YXIgYm9yZGVycyA9IFtcIlRvcExlZnRcIiwgXCJUb3BSaWdodFwiLCBcIkJvdHRvbUxlZnRcIiwgXCJCb3R0b21SaWdodFwiXTtcbnZhciBudW1Cb3JkZXJzID0gYm9yZGVycy5sZW5ndGg7XG52YXIgYXNOdW1iZXIgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG52YXIgaXNQeCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHB4LnRlc3QodmFsdWUpO1xuZnVuY3Rpb24gbWl4VmFsdWVzKHRhcmdldCwgZm9sbG93LCBsZWFkLCBwcm9ncmVzczMsIHNob3VsZENyb3NzZmFkZU9wYWNpdHksIGlzT25seU1lbWJlcikge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGlmIChzaG91bGRDcm9zc2ZhZGVPcGFjaXR5KSB7XG4gICAgdGFyZ2V0Lm9wYWNpdHkgPSBtaXgoXG4gICAgICAwLFxuICAgICAgKF9hID0gbGVhZC5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLFxuICAgICAgZWFzZUNyb3NzZmFkZUluKHByb2dyZXNzMylcbiAgICApO1xuICAgIHRhcmdldC5vcGFjaXR5RXhpdCA9IG1peCgoX2IgPSBmb2xsb3cub3BhY2l0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMSwgMCwgZWFzZUNyb3NzZmFkZU91dChwcm9ncmVzczMpKTtcbiAgfSBlbHNlIGlmIChpc09ubHlNZW1iZXIpIHtcbiAgICB0YXJnZXQub3BhY2l0eSA9IG1peCgoX2MgPSBmb2xsb3cub3BhY2l0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMSwgKF9kID0gbGVhZC5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAxLCBwcm9ncmVzczMpO1xuICB9XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1Cb3JkZXJzOyBpMisrKSB7XG4gICAgY29uc3QgYm9yZGVyTGFiZWwgPSBgYm9yZGVyJHtib3JkZXJzW2kyXX1SYWRpdXNgO1xuICAgIGxldCBmb2xsb3dSYWRpdXMgPSBnZXRSYWRpdXMoZm9sbG93LCBib3JkZXJMYWJlbCk7XG4gICAgbGV0IGxlYWRSYWRpdXMgPSBnZXRSYWRpdXMobGVhZCwgYm9yZGVyTGFiZWwpO1xuICAgIGlmIChmb2xsb3dSYWRpdXMgPT09IHZvaWQgMCAmJiBsZWFkUmFkaXVzID09PSB2b2lkIDApXG4gICAgICBjb250aW51ZTtcbiAgICBmb2xsb3dSYWRpdXMgfHwgKGZvbGxvd1JhZGl1cyA9IDApO1xuICAgIGxlYWRSYWRpdXMgfHwgKGxlYWRSYWRpdXMgPSAwKTtcbiAgICBjb25zdCBjYW5NaXggPSBmb2xsb3dSYWRpdXMgPT09IDAgfHwgbGVhZFJhZGl1cyA9PT0gMCB8fCBpc1B4KGZvbGxvd1JhZGl1cykgPT09IGlzUHgobGVhZFJhZGl1cyk7XG4gICAgaWYgKGNhbk1peCkge1xuICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IE1hdGgubWF4KG1peChhc051bWJlcihmb2xsb3dSYWRpdXMpLCBhc051bWJlcihsZWFkUmFkaXVzKSwgcHJvZ3Jlc3MzKSwgMCk7XG4gICAgICBpZiAocGVyY2VudC50ZXN0KGxlYWRSYWRpdXMpIHx8IHBlcmNlbnQudGVzdChmb2xsb3dSYWRpdXMpKSB7XG4gICAgICAgIHRhcmdldFtib3JkZXJMYWJlbF0gKz0gXCIlXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFtib3JkZXJMYWJlbF0gPSBsZWFkUmFkaXVzO1xuICAgIH1cbiAgfVxuICBpZiAoZm9sbG93LnJvdGF0ZSB8fCBsZWFkLnJvdGF0ZSkge1xuICAgIHRhcmdldC5yb3RhdGUgPSBtaXgoZm9sbG93LnJvdGF0ZSB8fCAwLCBsZWFkLnJvdGF0ZSB8fCAwLCBwcm9ncmVzczMpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSYWRpdXModmFsdWVzLCByYWRpdXNOYW1lKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IHZhbHVlc1tyYWRpdXNOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWVzLmJvcmRlclJhZGl1cztcbn1cbnZhciBlYXNlQ3Jvc3NmYWRlSW4gPSBjb21wcmVzcygwLCAwLjUsIGNpcmNPdXQpO1xudmFyIGVhc2VDcm9zc2ZhZGVPdXQgPSBjb21wcmVzcygwLjUsIDAuOTUsIGxpbmVhcik7XG5mdW5jdGlvbiBjb21wcmVzcyhtaW4sIG1heCwgZWFzaW5nKSB7XG4gIHJldHVybiAocDIpID0+IHtcbiAgICBpZiAocDIgPCBtaW4pXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAocDIgPiBtYXgpXG4gICAgICByZXR1cm4gMTtcbiAgICByZXR1cm4gZWFzaW5nKHByb2dyZXNzKG1pbiwgbWF4LCBwMikpO1xuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvY29weS5tanNcbmZ1bmN0aW9uIGNvcHlBeGlzSW50byhheGlzLCBvcmlnaW5BeGlzKSB7XG4gIGF4aXMubWluID0gb3JpZ2luQXhpcy5taW47XG4gIGF4aXMubWF4ID0gb3JpZ2luQXhpcy5tYXg7XG59XG5mdW5jdGlvbiBjb3B5Qm94SW50byhib3gsIG9yaWdpbkJveCkge1xuICBjb3B5QXhpc0ludG8oYm94LngsIG9yaWdpbkJveC54KTtcbiAgY29weUF4aXNJbnRvKGJveC55LCBvcmlnaW5Cb3gueSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9kZWx0YS1yZW1vdmUubWpzXG5mdW5jdGlvbiByZW1vdmVQb2ludERlbHRhKHBvaW50MiwgdHJhbnNsYXRlLCBzY2FsZTIsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICBwb2ludDIgLT0gdHJhbnNsYXRlO1xuICBwb2ludDIgPSBzY2FsZVBvaW50KHBvaW50MiwgMSAvIHNjYWxlMiwgb3JpZ2luUG9pbnQpO1xuICBpZiAoYm94U2NhbGUgIT09IHZvaWQgMCkge1xuICAgIHBvaW50MiA9IHNjYWxlUG9pbnQocG9pbnQyLCAxIC8gYm94U2NhbGUsIG9yaWdpblBvaW50KTtcbiAgfVxuICByZXR1cm4gcG9pbnQyO1xufVxuZnVuY3Rpb24gcmVtb3ZlQXhpc0RlbHRhKGF4aXMsIHRyYW5zbGF0ZSA9IDAsIHNjYWxlMiA9IDEsIG9yaWdpbiA9IDAuNSwgYm94U2NhbGUsIG9yaWdpbkF4aXMgPSBheGlzLCBzb3VyY2VBeGlzID0gYXhpcykge1xuICBpZiAocGVyY2VudC50ZXN0KHRyYW5zbGF0ZSkpIHtcbiAgICB0cmFuc2xhdGUgPSBwYXJzZUZsb2F0KHRyYW5zbGF0ZSk7XG4gICAgY29uc3QgcmVsYXRpdmVQcm9ncmVzcyA9IG1peChzb3VyY2VBeGlzLm1pbiwgc291cmNlQXhpcy5tYXgsIHRyYW5zbGF0ZSAvIDEwMCk7XG4gICAgdHJhbnNsYXRlID0gcmVsYXRpdmVQcm9ncmVzcyAtIHNvdXJjZUF4aXMubWluO1xuICB9XG4gIGlmICh0eXBlb2YgdHJhbnNsYXRlICE9PSBcIm51bWJlclwiKVxuICAgIHJldHVybjtcbiAgbGV0IG9yaWdpblBvaW50ID0gbWl4KG9yaWdpbkF4aXMubWluLCBvcmlnaW5BeGlzLm1heCwgb3JpZ2luKTtcbiAgaWYgKGF4aXMgPT09IG9yaWdpbkF4aXMpXG4gICAgb3JpZ2luUG9pbnQgLT0gdHJhbnNsYXRlO1xuICBheGlzLm1pbiA9IHJlbW92ZVBvaW50RGVsdGEoYXhpcy5taW4sIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xuICBheGlzLm1heCA9IHJlbW92ZVBvaW50RGVsdGEoYXhpcy5tYXgsIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYXhpcywgdHJhbnNmb3JtcywgW2tleSwgc2NhbGVLZXksIG9yaWdpbktleV0sIG9yaWdpbiwgc291cmNlQXhpcykge1xuICByZW1vdmVBeGlzRGVsdGEoYXhpcywgdHJhbnNmb3Jtc1trZXldLCB0cmFuc2Zvcm1zW3NjYWxlS2V5XSwgdHJhbnNmb3Jtc1tvcmlnaW5LZXldLCB0cmFuc2Zvcm1zLnNjYWxlLCBvcmlnaW4sIHNvdXJjZUF4aXMpO1xufVxudmFyIHhLZXlzMiA9IFtcInhcIiwgXCJzY2FsZVhcIiwgXCJvcmlnaW5YXCJdO1xudmFyIHlLZXlzMiA9IFtcInlcIiwgXCJzY2FsZVlcIiwgXCJvcmlnaW5ZXCJdO1xuZnVuY3Rpb24gcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3gsIHRyYW5zZm9ybXMsIG9yaWdpbkJveCwgc291cmNlQm94KSB7XG4gIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGJveC54LCB0cmFuc2Zvcm1zLCB4S2V5czIsIG9yaWdpbkJveCA9PT0gbnVsbCB8fCBvcmlnaW5Cb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbkJveC54LCBzb3VyY2VCb3ggPT09IG51bGwgfHwgc291cmNlQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2VCb3gueCk7XG4gIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGJveC55LCB0cmFuc2Zvcm1zLCB5S2V5czIsIG9yaWdpbkJveCA9PT0gbnVsbCB8fCBvcmlnaW5Cb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbkJveC55LCBzb3VyY2VCb3ggPT09IG51bGwgfHwgc291cmNlQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2VCb3gueSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS91dGlscy5tanNcbmZ1bmN0aW9uIGlzQXhpc0RlbHRhWmVybyhkZWx0YSkge1xuICByZXR1cm4gZGVsdGEudHJhbnNsYXRlID09PSAwICYmIGRlbHRhLnNjYWxlID09PSAxO1xufVxuZnVuY3Rpb24gaXNEZWx0YVplcm8oZGVsdGEpIHtcbiAgcmV0dXJuIGlzQXhpc0RlbHRhWmVybyhkZWx0YS54KSAmJiBpc0F4aXNEZWx0YVplcm8oZGVsdGEueSk7XG59XG5mdW5jdGlvbiBib3hFcXVhbHMoYTIsIGIyKSB7XG4gIHJldHVybiBhMi54Lm1pbiA9PT0gYjIueC5taW4gJiYgYTIueC5tYXggPT09IGIyLngubWF4ICYmIGEyLnkubWluID09PSBiMi55Lm1pbiAmJiBhMi55Lm1heCA9PT0gYjIueS5tYXg7XG59XG5mdW5jdGlvbiBhc3BlY3RSYXRpbyhib3gpIHtcbiAgcmV0dXJuIGNhbGNMZW5ndGgoYm94LngpIC8gY2FsY0xlbmd0aChib3gueSk7XG59XG5mdW5jdGlvbiBpc0Nsb3NlVG8oYTIsIGIyLCBtYXggPSAwLjEpIHtcbiAgcmV0dXJuIGRpc3RhbmNlKGEyLCBiMikgPD0gbWF4O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc2hhcmVkL3N0YWNrLm1qc1xudmFyIE5vZGVTdGFjayA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tZW1iZXJzID0gW107XG4gIH1cbiAgYWRkKG5vZGUpIHtcbiAgICBhZGRVbmlxdWVJdGVtKHRoaXMubWVtYmVycywgbm9kZSk7XG4gICAgbm9kZS5zY2hlZHVsZVJlbmRlcigpO1xuICB9XG4gIHJlbW92ZShub2RlKSB7XG4gICAgcmVtb3ZlSXRlbSh0aGlzLm1lbWJlcnMsIG5vZGUpO1xuICAgIGlmIChub2RlID09PSB0aGlzLnByZXZMZWFkKSB7XG4gICAgICB0aGlzLnByZXZMZWFkID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gdGhpcy5sZWFkKSB7XG4gICAgICBjb25zdCBwcmV2TGVhZCA9IHRoaXMubWVtYmVyc1t0aGlzLm1lbWJlcnMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAocHJldkxlYWQpIHtcbiAgICAgICAgdGhpcy5wcm9tb3RlKHByZXZMZWFkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVsZWdhdGUobm9kZSkge1xuICAgIGNvbnN0IGluZGV4T2ZOb2RlID0gdGhpcy5tZW1iZXJzLmZpbmRJbmRleCgobWVtYmVyKSA9PiBub2RlID09PSBtZW1iZXIpO1xuICAgIGlmIChpbmRleE9mTm9kZSA9PT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcHJldkxlYWQ7XG4gICAgZm9yIChsZXQgaTIgPSBpbmRleE9mTm9kZTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgY29uc3QgbWVtYmVyID0gdGhpcy5tZW1iZXJzW2kyXTtcbiAgICAgIGlmIChtZW1iZXIuaXNQcmVzZW50ICE9PSBmYWxzZSkge1xuICAgICAgICBwcmV2TGVhZCA9IG1lbWJlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgdGhpcy5wcm9tb3RlKHByZXZMZWFkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHByb21vdGUobm9kZSwgcHJlc2VydmVGb2xsb3dPcGFjaXR5KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByZXZMZWFkID0gdGhpcy5sZWFkO1xuICAgIGlmIChub2RlID09PSBwcmV2TGVhZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnByZXZMZWFkID0gcHJldkxlYWQ7XG4gICAgdGhpcy5sZWFkID0gbm9kZTtcbiAgICBub2RlLnNob3coKTtcbiAgICBpZiAocHJldkxlYWQpIHtcbiAgICAgIHByZXZMZWFkLmluc3RhbmNlICYmIHByZXZMZWFkLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICBub2RlLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICBub2RlLnJlc3VtZUZyb20gPSBwcmV2TGVhZDtcbiAgICAgIGlmIChwcmVzZXJ2ZUZvbGxvd09wYWNpdHkpIHtcbiAgICAgICAgbm9kZS5yZXN1bWVGcm9tLnByZXNlcnZlT3BhY2l0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJldkxlYWQuc25hcHNob3QpIHtcbiAgICAgICAgbm9kZS5zbmFwc2hvdCA9IHByZXZMZWFkLnNuYXBzaG90O1xuICAgICAgICBub2RlLnNuYXBzaG90LmxhdGVzdFZhbHVlcyA9IHByZXZMZWFkLmFuaW1hdGlvblZhbHVlcyB8fCBwcmV2TGVhZC5sYXRlc3RWYWx1ZXM7XG4gICAgICAgIG5vZGUuc25hcHNob3QuaXNTaGFyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKChfYSA9IG5vZGUucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgbm9kZS5pc0xheW91dERpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY3Jvc3NmYWRlIH0gPSBub2RlLm9wdGlvbnM7XG4gICAgICBpZiAoY3Jvc3NmYWRlID09PSBmYWxzZSkge1xuICAgICAgICBwcmV2TGVhZC5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4aXRBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICB0aGlzLm1lbWJlcnMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgIChfYiA9IChfYSA9IG5vZGUub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgIChfZSA9IChfYyA9IG5vZGUucmVzdW1pbmdGcm9tKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9kID0gX2Mub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKTtcbiAgICB9KTtcbiAgfVxuICBzY2hlZHVsZVJlbmRlcigpIHtcbiAgICB0aGlzLm1lbWJlcnMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZS5pbnN0YW5jZSAmJiBub2RlLnNjaGVkdWxlUmVuZGVyKGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICByZW1vdmVMZWFkU25hcHNob3QoKSB7XG4gICAgaWYgKHRoaXMubGVhZCAmJiB0aGlzLmxlYWQuc25hcHNob3QpIHtcbiAgICAgIHRoaXMubGVhZC5zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9zdHlsZXMvdHJhbnNmb3JtLm1qc1xudmFyIGlkZW50aXR5UHJvamVjdGlvbiA9IFwidHJhbnNsYXRlM2QoMHB4LCAwcHgsIDApIHNjYWxlKDEsIDEpIHNjYWxlKDEsIDEpXCI7XG5mdW5jdGlvbiBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0oZGVsdGEsIHRyZWVTY2FsZSwgbGF0ZXN0VHJhbnNmb3JtKSB7XG4gIGNvbnN0IHhUcmFuc2xhdGUgPSBkZWx0YS54LnRyYW5zbGF0ZSAvIHRyZWVTY2FsZS54O1xuICBjb25zdCB5VHJhbnNsYXRlID0gZGVsdGEueS50cmFuc2xhdGUgLyB0cmVlU2NhbGUueTtcbiAgbGV0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3hUcmFuc2xhdGV9cHgsICR7eVRyYW5zbGF0ZX1weCwgMCkgYDtcbiAgdHJhbnNmb3JtICs9IGBzY2FsZSgkezEgLyB0cmVlU2NhbGUueH0sICR7MSAvIHRyZWVTY2FsZS55fSkgYDtcbiAgaWYgKGxhdGVzdFRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHsgcm90YXRlLCByb3RhdGVYLCByb3RhdGVZIH0gPSBsYXRlc3RUcmFuc2Zvcm07XG4gICAgaWYgKHJvdGF0ZSlcbiAgICAgIHRyYW5zZm9ybSArPSBgcm90YXRlKCR7cm90YXRlfWRlZykgYDtcbiAgICBpZiAocm90YXRlWClcbiAgICAgIHRyYW5zZm9ybSArPSBgcm90YXRlWCgke3JvdGF0ZVh9ZGVnKSBgO1xuICAgIGlmIChyb3RhdGVZKVxuICAgICAgdHJhbnNmb3JtICs9IGByb3RhdGVZKCR7cm90YXRlWX1kZWcpIGA7XG4gIH1cbiAgY29uc3QgZWxlbWVudFNjYWxlWCA9IGRlbHRhLnguc2NhbGUgKiB0cmVlU2NhbGUueDtcbiAgY29uc3QgZWxlbWVudFNjYWxlWSA9IGRlbHRhLnkuc2NhbGUgKiB0cmVlU2NhbGUueTtcbiAgdHJhbnNmb3JtICs9IGBzY2FsZSgke2VsZW1lbnRTY2FsZVh9LCAke2VsZW1lbnRTY2FsZVl9KWA7XG4gIHJldHVybiB0cmFuc2Zvcm0gPT09IGlkZW50aXR5UHJvamVjdGlvbiA/IFwibm9uZVwiIDogdHJhbnNmb3JtO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9jb21wYXJlLWJ5LWRlcHRoLm1qc1xudmFyIGNvbXBhcmVCeURlcHRoID0gKGEyLCBiMikgPT4gYTIuZGVwdGggLSBiMi5kZXB0aDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvZmxhdC10cmVlLm1qc1xudmFyIEZsYXRUcmVlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gIH1cbiAgYWRkKGNoaWxkKSB7XG4gICAgYWRkVW5pcXVlSXRlbSh0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XG4gICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgfVxuICByZW1vdmUoY2hpbGQpIHtcbiAgICByZW1vdmVJdGVtKHRoaXMuY2hpbGRyZW4sIGNoaWxkKTtcbiAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICB9XG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmlzRGlydHkgJiYgdGhpcy5jaGlsZHJlbi5zb3J0KGNvbXBhcmVCeURlcHRoKTtcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2FsbGJhY2spO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9jcmVhdGUtcHJvamVjdGlvbi1ub2RlLm1qc1xudmFyIHRyYW5zZm9ybUF4ZXMgPSBbXCJcIiwgXCJYXCIsIFwiWVwiLCBcIlpcIl07XG52YXIgYW5pbWF0aW9uVGFyZ2V0ID0gMWUzO1xuZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbk5vZGUoeyBhdHRhY2hSZXNpemVMaXN0ZW5lciwgZGVmYXVsdFBhcmVudCwgbWVhc3VyZVNjcm9sbCwgY2hlY2tJc1Njcm9sbFJvb3QsIHJlc2V0VHJhbnNmb3JtIH0pIHtcbiAgcmV0dXJuIGNsYXNzIFByb2plY3Rpb25Ob2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50SWQsIGxhdGVzdFZhbHVlcyA9IHt9LCBwYXJlbnQgPSBkZWZhdWx0UGFyZW50ID09PSBudWxsIHx8IGRlZmF1bHRQYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmF1bHRQYXJlbnQoKSkge1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuaXNUcmVlQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmlzQW5pbWF0aW9uQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gZmFsc2U7XG4gICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IGZhbHNlO1xuICAgICAgdGhpcy51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1NWRyA9IGZhbHNlO1xuICAgICAgdGhpcy5uZWVkc1Jlc2V0ID0gZmFsc2U7XG4gICAgICB0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgICB0aGlzLnRyZWVTY2FsZSA9IHsgeDogMSwgeTogMSB9O1xuICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5jaGVja1VwZGF0ZUZhaWxlZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNVcGRhdGluZykge1xuICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHJlc29sdmVUYXJnZXREZWx0YSk7XG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChjYWxjUHJvamVjdGlvbik7XG4gICAgICB9O1xuICAgICAgdGhpcy5oYXNQcm9qZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSAwO1xuICAgICAgdGhpcy5zaGFyZWROb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB0aGlzLmVsZW1lbnRJZCA9IGVsZW1lbnRJZDtcbiAgICAgIHRoaXMubGF0ZXN0VmFsdWVzID0gbGF0ZXN0VmFsdWVzO1xuICAgICAgdGhpcy5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgfHwgcGFyZW50IDogdGhpcztcbiAgICAgIHRoaXMucGF0aCA9IHBhcmVudCA/IFsuLi5wYXJlbnQucGF0aCwgcGFyZW50XSA6IFtdO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLmRlcHRoID0gcGFyZW50ID8gcGFyZW50LmRlcHRoICsgMSA6IDA7XG4gICAgICBlbGVtZW50SWQgJiYgdGhpcy5yb290LnJlZ2lzdGVyUG90ZW50aWFsTm9kZShlbGVtZW50SWQsIHRoaXMpO1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGF0aC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgdGhpcy5wYXRoW2kyXS5zaG91bGRSZXNldFRyYW5zZm9ybSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yb290ID09PSB0aGlzKVxuICAgICAgICB0aGlzLm5vZGVzID0gbmV3IEZsYXRUcmVlKCk7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCF0aGlzLmV2ZW50SGFuZGxlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycy5zZXQobmFtZSwgbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5ldmVudEhhbmRsZXJzLmdldChuYW1lKS5hZGQoaGFuZGxlcik7XG4gICAgfVxuICAgIG5vdGlmeUxpc3RlbmVycyhuYW1lLCAuLi5hcmdzKSB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25NYW5hZ2VyID0gdGhpcy5ldmVudEhhbmRsZXJzLmdldChuYW1lKTtcbiAgICAgIHN1YnNjcmlwdGlvbk1hbmFnZXIgPT09IG51bGwgfHwgc3Vic2NyaXB0aW9uTWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Vic2NyaXB0aW9uTWFuYWdlci5ub3RpZnkoLi4uYXJncyk7XG4gICAgfVxuICAgIGhhc0xpc3RlbmVycyhuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudEhhbmRsZXJzLmhhcyhuYW1lKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJQb3RlbnRpYWxOb2RlKGlkMiwgbm9kZSkge1xuICAgICAgdGhpcy5wb3RlbnRpYWxOb2Rlcy5zZXQoaWQyLCBub2RlKTtcbiAgICB9XG4gICAgbW91bnQoaW5zdGFuY2UsIGlzTGF5b3V0RGlydHkgPSBmYWxzZSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuaXNTVkcgPSBpbnN0YW5jZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgJiYgaW5zdGFuY2UudGFnTmFtZSAhPT0gXCJzdmdcIjtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgIGNvbnN0IHsgbGF5b3V0SWQsIGxheW91dCwgdmlzdWFsRWxlbWVudCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKHZpc3VhbEVsZW1lbnQgJiYgIXZpc3VhbEVsZW1lbnQuY3VycmVudCkge1xuICAgICAgICB2aXN1YWxFbGVtZW50Lm1vdW50KGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucm9vdC5ub2Rlcy5hZGQodGhpcyk7XG4gICAgICAoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkcmVuLmFkZCh0aGlzKTtcbiAgICAgIHRoaXMuZWxlbWVudElkICYmIHRoaXMucm9vdC5wb3RlbnRpYWxOb2Rlcy5kZWxldGUodGhpcy5lbGVtZW50SWQpO1xuICAgICAgaWYgKGlzTGF5b3V0RGlydHkgJiYgKGxheW91dCB8fCBsYXlvdXRJZCkpIHtcbiAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRhY2hSZXNpemVMaXN0ZW5lcikge1xuICAgICAgICBsZXQgY2FuY2VsRGVsYXk7XG4gICAgICAgIGNvbnN0IHJlc2l6ZVVuYmxvY2tVcGRhdGUgPSAoKSA9PiB0aGlzLnJvb3QudXBkYXRlQmxvY2tlZEJ5UmVzaXplID0gZmFsc2U7XG4gICAgICAgIGF0dGFjaFJlc2l6ZUxpc3RlbmVyKGluc3RhbmNlLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yb290LnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IHRydWU7XG4gICAgICAgICAgY2FuY2VsRGVsYXkgJiYgY2FuY2VsRGVsYXkoKTtcbiAgICAgICAgICBjYW5jZWxEZWxheSA9IGRlbGF5KHJlc2l6ZVVuYmxvY2tVcGRhdGUsIDI1MCk7XG4gICAgICAgICAgaWYgKGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplKSB7XG4gICAgICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGZpbmlzaEFuaW1hdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXlvdXRJZCkge1xuICAgICAgICB0aGlzLnJvb3QucmVnaXN0ZXJTaGFyZWROb2RlKGxheW91dElkLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UgJiYgdmlzdWFsRWxlbWVudCAmJiAobGF5b3V0SWQgfHwgbGF5b3V0KSkge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwgKHsgZGVsdGEsIGhhc0xheW91dENoYW5nZWQsIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCwgbGF5b3V0OiBuZXdMYXlvdXQgfSkgPT4ge1xuICAgICAgICAgIHZhciBfYTIsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgIGlmICh0aGlzLmlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsYXlvdXRUcmFuc2l0aW9uID0gKF9iID0gKF9hMiA9IHRoaXMub3B0aW9ucy50cmFuc2l0aW9uKSAhPT0gbnVsbCAmJiBfYTIgIT09IHZvaWQgMCA/IF9hMiA6IHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdExheW91dFRyYW5zaXRpb247XG4gICAgICAgICAgY29uc3QgeyBvbkxheW91dEFuaW1hdGlvblN0YXJ0LCBvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlIH0gPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Q2hhbmdlZCA9ICF0aGlzLnRhcmdldExheW91dCB8fCAhYm94RXF1YWxzKHRoaXMudGFyZ2V0TGF5b3V0LCBuZXdMYXlvdXQpIHx8IGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZDtcbiAgICAgICAgICBjb25zdCBoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gIWhhc0xheW91dENoYW5nZWQgJiYgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkO1xuICAgICAgICAgIGlmICgoKF9jID0gdGhpcy5yZXN1bWVGcm9tKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaW5zdGFuY2UpIHx8IGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgfHwgaGFzTGF5b3V0Q2hhbmdlZCAmJiAodGFyZ2V0Q2hhbmdlZCB8fCAhdGhpcy5jdXJyZW50QW5pbWF0aW9uKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1lRnJvbSkge1xuICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbSA9IHRoaXMucmVzdW1lRnJvbTtcbiAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20ucmVzdW1pbmdGcm9tID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRBbmltYXRpb25PcmlnaW4oZGVsdGEsIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQpO1xuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGdldFZhbHVlVHJhbnNpdGlvbihsYXlvdXRUcmFuc2l0aW9uLCBcImxheW91dFwiKSksIHtcbiAgICAgICAgICAgICAgb25QbGF5OiBvbkxheW91dEFuaW1hdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh2aXN1YWxFbGVtZW50LnNob3VsZFJlZHVjZU1vdGlvbikge1xuICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLmRlbGF5ID0gMDtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9ucy50eXBlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKGFuaW1hdGlvbk9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc0xheW91dENoYW5nZWQgJiYgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9PT0gMCkge1xuICAgICAgICAgICAgICBmaW5pc2hBbmltYXRpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzTGVhZCgpICYmICgoX2UgPSAoX2QgPSB0aGlzLm9wdGlvbnMpLm9uRXhpdENvbXBsZXRlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRhcmdldExheW91dCA9IG5ld0xheW91dDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVubW91bnQoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdGhpcy5vcHRpb25zLmxheW91dElkICYmIHRoaXMud2lsbFVwZGF0ZSgpO1xuICAgICAgdGhpcy5yb290Lm5vZGVzLnJlbW92ZSh0aGlzKTtcbiAgICAgIChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSh0aGlzKTtcbiAgICAgIChfYiA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hpbGRyZW4uZGVsZXRlKHRoaXMpO1xuICAgICAgdGhpcy5pbnN0YW5jZSA9IHZvaWQgMDtcbiAgICAgIGNhbmNlbFN5bmMucHJlUmVuZGVyKHRoaXMudXBkYXRlUHJvamVjdGlvbik7XG4gICAgfVxuICAgIGJsb2NrVXBkYXRlKCkge1xuICAgICAgdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgPSB0cnVlO1xuICAgIH1cbiAgICB1bmJsb2NrVXBkYXRlKCkge1xuICAgICAgdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaXNVcGRhdGVCbG9ja2VkKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkIHx8IHRoaXMudXBkYXRlQmxvY2tlZEJ5UmVzaXplO1xuICAgIH1cbiAgICBpc1RyZWVBbmltYXRpb25CbG9ja2VkKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIHRoaXMuaXNBbmltYXRpb25CbG9ja2VkIHx8ICgoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSkgfHwgZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0VXBkYXRlKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMuaXNVcGRhdGVCbG9ja2VkKCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuaXNVcGRhdGluZyA9IHRydWU7XG4gICAgICAoX2EgPSB0aGlzLm5vZGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChyZXNldFJvdGF0aW9uKTtcbiAgICB9XG4gICAgd2lsbFVwZGF0ZShzaG91bGROb3RpZnlMaXN0ZW5lcnMgPSB0cnVlKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGlmICh0aGlzLnJvb3QuaXNVcGRhdGVCbG9ja2VkKCkpIHtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAhdGhpcy5yb290LmlzVXBkYXRpbmcgJiYgdGhpcy5yb290LnN0YXJ0VXBkYXRlKCk7XG4gICAgICBpZiAodGhpcy5pc0xheW91dERpcnR5KVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGF0aC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpMl07XG4gICAgICAgIG5vZGUuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICBub2RlLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBsYXlvdXRJZCwgbGF5b3V0IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAobGF5b3V0SWQgPT09IHZvaWQgMCAmJiAhbGF5b3V0KVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZSA9IChfYyA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0UHJvcHMoKS50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICAgIHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB0cmFuc2Zvcm1UZW1wbGF0ZSA9PT0gbnVsbCB8fCB0cmFuc2Zvcm1UZW1wbGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpO1xuICAgICAgdGhpcy51cGRhdGVTbmFwc2hvdCgpO1xuICAgICAgc2hvdWxkTm90aWZ5TGlzdGVuZXJzICYmIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwid2lsbFVwZGF0ZVwiKTtcbiAgICB9XG4gICAgZGlkVXBkYXRlKCkge1xuICAgICAgY29uc3QgdXBkYXRlV2FzQmxvY2tlZCA9IHRoaXMuaXNVcGRhdGVCbG9ja2VkKCk7XG4gICAgICBpZiAodXBkYXRlV2FzQmxvY2tlZCkge1xuICAgICAgICB0aGlzLnVuYmxvY2tVcGRhdGUoKTtcbiAgICAgICAgdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJNZWFzdXJlbWVudHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNVcGRhdGluZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5wb3RlbnRpYWxOb2Rlcy5zaXplKSB7XG4gICAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMuZm9yRWFjaChtb3VudE5vZGVFYXJseSk7XG4gICAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChyZXNldFRyYW5zZm9ybVN0eWxlKTtcbiAgICAgIHRoaXMubm9kZXMuZm9yRWFjaCh1cGRhdGVMYXlvdXQpO1xuICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKG5vdGlmeUxheW91dFVwZGF0ZSk7XG4gICAgICB0aGlzLmNsZWFyQWxsU25hcHNob3RzKCk7XG4gICAgICBmbHVzaFN5bmMudXBkYXRlKCk7XG4gICAgICBmbHVzaFN5bmMucHJlUmVuZGVyKCk7XG4gICAgICBmbHVzaFN5bmMucmVuZGVyKCk7XG4gICAgfVxuICAgIGNsZWFyQWxsU25hcHNob3RzKCkge1xuICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNsZWFyU25hcHNob3QpO1xuICAgICAgdGhpcy5zaGFyZWROb2Rlcy5mb3JFYWNoKHJlbW92ZUxlYWRTbmFwc2hvdHMpO1xuICAgIH1cbiAgICBzY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24oKSB7XG4gICAgICBlc19kZWZhdWx0LnByZVJlbmRlcih0aGlzLnVwZGF0ZVByb2plY3Rpb24sIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgc2NoZWR1bGVDaGVja0FmdGVyVW5tb3VudCgpIHtcbiAgICAgIGVzX2RlZmF1bHQucG9zdFJlbmRlcigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgICB0aGlzLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yb290LmNoZWNrVXBkYXRlRmFpbGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVTbmFwc2hvdCgpIHtcbiAgICAgIGlmICh0aGlzLnNuYXBzaG90IHx8ICF0aGlzLmluc3RhbmNlKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnNuYXBzaG90ID0gdGhpcy5tZWFzdXJlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUxheW91dCgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy51cGRhdGVTY3JvbGwoKTtcbiAgICAgIGlmICghKHRoaXMub3B0aW9ucy5hbHdheXNNZWFzdXJlTGF5b3V0ICYmIHRoaXMuaXNMZWFkKCkpICYmICF0aGlzLmlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVzdW1lRnJvbSAmJiAhdGhpcy5yZXN1bWVGcm9tLmluc3RhbmNlKSB7XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0aGlzLnBhdGgubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpMl07XG4gICAgICAgICAgbm9kZS51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcHJldkxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgICAgdGhpcy5sYXlvdXQgPSB0aGlzLm1lYXN1cmUoZmFsc2UpO1xuICAgICAgdGhpcy5sYXlvdXRDb3JyZWN0ZWQgPSBjcmVhdGVCb3goKTtcbiAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xuICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSB2b2lkIDA7XG4gICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcIm1lYXN1cmVcIiwgdGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgIChfYSA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm90aWZ5KFwiTGF5b3V0TWVhc3VyZVwiLCB0aGlzLmxheW91dC5sYXlvdXRCb3gsIHByZXZMYXlvdXQgPT09IG51bGwgfHwgcHJldkxheW91dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldkxheW91dC5sYXlvdXRCb3gpO1xuICAgIH1cbiAgICB1cGRhdGVTY3JvbGwoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxheW91dFNjcm9sbCAmJiB0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuaXNTY3JvbGxSb290ID0gY2hlY2tJc1Njcm9sbFJvb3QodGhpcy5pbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsID0gbWVhc3VyZVNjcm9sbCh0aGlzLmluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXJlc2V0VHJhbnNmb3JtKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpc1Jlc2V0UmVxdWVzdGVkID0gdGhpcy5pc0xheW91dERpcnR5IHx8IHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm07XG4gICAgICBjb25zdCBoYXNQcm9qZWN0aW9uID0gdGhpcy5wcm9qZWN0aW9uRGVsdGEgJiYgIWlzRGVsdGFaZXJvKHRoaXMucHJvamVjdGlvbkRlbHRhKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlID0gKF9hID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQcm9wcygpLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHRyYW5zZm9ybVRlbXBsYXRlID09PSBudWxsIHx8IHRyYW5zZm9ybVRlbXBsYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLmxhdGVzdFZhbHVlcywgXCJcIik7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZUhhc0NoYW5nZWQgPSB0cmFuc2Zvcm1UZW1wbGF0ZVZhbHVlICE9PSB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlO1xuICAgICAgaWYgKGlzUmVzZXRSZXF1ZXN0ZWQgJiYgKGhhc1Byb2plY3Rpb24gfHwgaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSB8fCB0cmFuc2Zvcm1UZW1wbGF0ZUhhc0NoYW5nZWQpKSB7XG4gICAgICAgIHJlc2V0VHJhbnNmb3JtKHRoaXMuaW5zdGFuY2UsIHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUpO1xuICAgICAgICB0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZShyZW1vdmVUcmFuc2Zvcm0gPSB0cnVlKSB7XG4gICAgICBjb25zdCBwYWdlQm94ID0gdGhpcy5tZWFzdXJlUGFnZUJveCgpO1xuICAgICAgbGV0IGxheW91dEJveCA9IHRoaXMucmVtb3ZlRWxlbWVudFNjcm9sbChwYWdlQm94KTtcbiAgICAgIGlmIChyZW1vdmVUcmFuc2Zvcm0pIHtcbiAgICAgICAgbGF5b3V0Qm94ID0gdGhpcy5yZW1vdmVUcmFuc2Zvcm0obGF5b3V0Qm94KTtcbiAgICAgIH1cbiAgICAgIHJvdW5kQm94KGxheW91dEJveCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWFzdXJlZEJveDogcGFnZUJveCxcbiAgICAgICAgbGF5b3V0Qm94LFxuICAgICAgICBsYXRlc3RWYWx1ZXM6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBtZWFzdXJlUGFnZUJveCgpIHtcbiAgICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICByZXR1cm4gY3JlYXRlQm94KCk7XG4gICAgICBjb25zdCBib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICAgICAgY29uc3QgeyBzY3JvbGw6IHNjcm9sbDIgfSA9IHRoaXMucm9vdDtcbiAgICAgIGlmIChzY3JvbGwyKSB7XG4gICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94LngsIHNjcm9sbDIueCk7XG4gICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94LnksIHNjcm9sbDIueSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm94O1xuICAgIH1cbiAgICByZW1vdmVFbGVtZW50U2Nyb2xsKGJveCkge1xuICAgICAgY29uc3QgYm94V2l0aG91dFNjcm9sbCA9IGNyZWF0ZUJveCgpO1xuICAgICAgY29weUJveEludG8oYm94V2l0aG91dFNjcm9sbCwgYm94KTtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0aGlzLnBhdGgubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaTJdO1xuICAgICAgICBjb25zdCB7IHNjcm9sbDogc2Nyb2xsMiwgb3B0aW9ucywgaXNTY3JvbGxSb290IH0gPSBub2RlO1xuICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5yb290ICYmIHNjcm9sbDIgJiYgb3B0aW9ucy5sYXlvdXRTY3JvbGwpIHtcbiAgICAgICAgICBpZiAoaXNTY3JvbGxSb290KSB7XG4gICAgICAgICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0U2Nyb2xsLCBib3gpO1xuICAgICAgICAgICAgY29uc3QgeyBzY3JvbGw6IHJvb3RTY3JvbGwgfSA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIGlmIChyb290U2Nyb2xsKSB7XG4gICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC54LCAtcm9vdFNjcm9sbC54KTtcbiAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLnksIC1yb290U2Nyb2xsLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueCwgc2Nyb2xsMi54KTtcbiAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueSwgc2Nyb2xsMi55KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJveFdpdGhvdXRTY3JvbGw7XG4gICAgfVxuICAgIGFwcGx5VHJhbnNmb3JtKGJveCwgdHJhbnNmb3JtT25seSA9IGZhbHNlKSB7XG4gICAgICBjb25zdCB3aXRoVHJhbnNmb3JtcyA9IGNyZWF0ZUJveCgpO1xuICAgICAgY29weUJveEludG8od2l0aFRyYW5zZm9ybXMsIGJveCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgdGhpcy5wYXRoLmxlbmd0aDsgaTIrKykge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2kyXTtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1Pbmx5ICYmIG5vZGUub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiYgbm9kZS5zY3JvbGwgJiYgbm9kZSAhPT0gbm9kZS5yb290KSB7XG4gICAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCB7XG4gICAgICAgICAgICB4OiAtbm9kZS5zY3JvbGwueCxcbiAgICAgICAgICAgIHk6IC1ub2RlLnNjcm9sbC55XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0cmFuc2Zvcm1Cb3god2l0aFRyYW5zZm9ybXMsIG5vZGUubGF0ZXN0VmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3JtcywgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhUcmFuc2Zvcm1zO1xuICAgIH1cbiAgICByZW1vdmVUcmFuc2Zvcm0oYm94KSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBib3hXaXRob3V0VHJhbnNmb3JtID0gY3JlYXRlQm94KCk7XG4gICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0VHJhbnNmb3JtLCBib3gpO1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGF0aC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpMl07XG4gICAgICAgIGlmICghbm9kZS5pbnN0YW5jZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBoYXNTY2FsZShub2RlLmxhdGVzdFZhbHVlcykgJiYgbm9kZS51cGRhdGVTbmFwc2hvdCgpO1xuICAgICAgICBjb25zdCBzb3VyY2VCb3ggPSBjcmVhdGVCb3goKTtcbiAgICAgICAgY29uc3Qgbm9kZUJveCA9IG5vZGUubWVhc3VyZVBhZ2VCb3goKTtcbiAgICAgICAgY29weUJveEludG8oc291cmNlQm94LCBub2RlQm94KTtcbiAgICAgICAgcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3hXaXRob3V0VHJhbnNmb3JtLCBub2RlLmxhdGVzdFZhbHVlcywgKF9hID0gbm9kZS5zbmFwc2hvdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxheW91dEJveCwgc291cmNlQm94KTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94V2l0aG91dFRyYW5zZm9ybSwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveFdpdGhvdXRUcmFuc2Zvcm07XG4gICAgfVxuICAgIHNldFRhcmdldERlbHRhKGRlbHRhKSB7XG4gICAgICB0aGlzLnRhcmdldERlbHRhID0gZGVsdGE7XG4gICAgICB0aGlzLnJvb3Quc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uKCk7XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucyksIHtcbiAgICAgICAgY3Jvc3NmYWRlOiBvcHRpb25zLmNyb3NzZmFkZSAhPT0gdm9pZCAwID8gb3B0aW9ucy5jcm9zc2ZhZGUgOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJNZWFzdXJlbWVudHMoKSB7XG4gICAgICB0aGlzLnNjcm9sbCA9IHZvaWQgMDtcbiAgICAgIHRoaXMubGF5b3V0ID0gdm9pZCAwO1xuICAgICAgdGhpcy5zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICAgIHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLnRhcmdldERlbHRhID0gdm9pZCAwO1xuICAgICAgdGhpcy50YXJnZXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVzb2x2ZVRhcmdldERlbHRhKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBsYXlvdXQsIGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICEobGF5b3V0IHx8IGxheW91dElkKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLnRhcmdldERlbHRhICYmICF0aGlzLnJlbGF0aXZlVGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGFyZW50ID0gdGhpcy5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICBpZiAocmVsYXRpdmVQYXJlbnQgJiYgcmVsYXRpdmVQYXJlbnQubGF5b3V0KSB7XG4gICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudCA9IHJlbGF0aXZlUGFyZW50O1xuICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24odGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCByZWxhdGl2ZVBhcmVudC5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmICF0aGlzLnRhcmdldERlbHRhKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoIXRoaXMudGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgIHRoaXMudGFyZ2V0V2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gJiYgKChfYSA9IHRoaXMucmVsYXRpdmVQYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50YXJnZXQpKSB7XG4gICAgICAgIGNhbGNSZWxhdGl2ZUJveCh0aGlzLnRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVBhcmVudC50YXJnZXQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldERlbHRhKSB7XG4gICAgICAgIGlmIChCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSkge1xuICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5hcHBseVRyYW5zZm9ybSh0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMudGFyZ2V0LCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5Qm94RGVsdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0RGVsdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUJveEludG8odGhpcy50YXJnZXQsIHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXJlbnQgPSB0aGlzLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhcmVudCAmJiBCb29sZWFuKHJlbGF0aXZlUGFyZW50LnJlc3VtaW5nRnJvbSkgPT09IEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pICYmICFyZWxhdGl2ZVBhcmVudC5vcHRpb25zLmxheW91dFNjcm9sbCAmJiByZWxhdGl2ZVBhcmVudC50YXJnZXQpIHtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gcmVsYXRpdmVQYXJlbnQ7XG4gICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbih0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCB0aGlzLnRhcmdldCwgcmVsYXRpdmVQYXJlbnQudGFyZ2V0KTtcbiAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpIHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQgfHwgaGFzU2NhbGUodGhpcy5wYXJlbnQubGF0ZXN0VmFsdWVzKSB8fCBoYXMyRFRyYW5zbGF0ZSh0aGlzLnBhcmVudC5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgaWYgKCh0aGlzLnBhcmVudC5yZWxhdGl2ZVRhcmdldCB8fCB0aGlzLnBhcmVudC50YXJnZXREZWx0YSkgJiYgdGhpcy5wYXJlbnQubGF5b3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYWxjUHJvamVjdGlvbigpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHsgbGF5b3V0LCBsYXlvdXRJZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy5pc1RyZWVBbmltYXRpbmcgPSBCb29sZWFuKCgoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVHJlZUFuaW1hdGluZykgfHwgdGhpcy5jdXJyZW50QW5pbWF0aW9uIHx8IHRoaXMucGVuZGluZ0FuaW1hdGlvbik7XG4gICAgICBpZiAoIXRoaXMuaXNUcmVlQW5pbWF0aW5nKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmxheW91dCB8fCAhKGxheW91dCB8fCBsYXlvdXRJZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgIGNvcHlCb3hJbnRvKHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgYXBwbHlUcmVlRGVsdGFzKHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0aGlzLnRyZWVTY2FsZSwgdGhpcy5wYXRoLCBCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSB8fCB0aGlzICE9PSBsZWFkKTtcbiAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBsZWFkO1xuICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghdGhpcy5wcm9qZWN0aW9uRGVsdGEpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0gPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldlRyZWVTY2FsZVggPSB0aGlzLnRyZWVTY2FsZS54O1xuICAgICAgY29uc3QgcHJldlRyZWVTY2FsZVkgPSB0aGlzLnRyZWVTY2FsZS55O1xuICAgICAgY29uc3QgcHJldlByb2plY3Rpb25UcmFuc2Zvcm0gPSB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm07XG4gICAgICBjYWxjQm94RGVsdGEodGhpcy5wcm9qZWN0aW9uRGVsdGEsIHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0YXJnZXQsIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybSA9IGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSh0aGlzLnByb2plY3Rpb25EZWx0YSwgdGhpcy50cmVlU2NhbGUpO1xuICAgICAgaWYgKHRoaXMucHJvamVjdGlvblRyYW5zZm9ybSAhPT0gcHJldlByb2plY3Rpb25UcmFuc2Zvcm0gfHwgdGhpcy50cmVlU2NhbGUueCAhPT0gcHJldlRyZWVTY2FsZVggfHwgdGhpcy50cmVlU2NhbGUueSAhPT0gcHJldlRyZWVTY2FsZVkpIHtcbiAgICAgICAgdGhpcy5oYXNQcm9qZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwicHJvamVjdGlvblVwZGF0ZVwiLCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgc2NoZWR1bGVSZW5kZXIobm90aWZ5QWxsMiA9IHRydWUpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5zY2hlZHVsZVJlbmRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgbm90aWZ5QWxsMiAmJiAoKF9jID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2NoZWR1bGVSZW5kZXIoKSk7XG4gICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20gJiYgIXRoaXMucmVzdW1pbmdGcm9tLmluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMucmVzdW1pbmdGcm9tID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRBbmltYXRpb25PcmlnaW4oZGVsdGEsIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSBmYWxzZSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLnNuYXBzaG90O1xuICAgICAgY29uc3Qgc25hcHNob3RMYXRlc3RWYWx1ZXMgPSAoc25hcHNob3QgPT09IG51bGwgfHwgc25hcHNob3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNuYXBzaG90LmxhdGVzdFZhbHVlcykgfHwge307XG4gICAgICBjb25zdCBtaXhlZFZhbHVlcyA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICBjb25zdCB0YXJnZXREZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0ID0gIWhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICBjb25zdCByZWxhdGl2ZUxheW91dCA9IGNyZWF0ZUJveCgpO1xuICAgICAgY29uc3QgaXNTaGFyZWRMYXlvdXRBbmltYXRpb24gPSBzbmFwc2hvdCA9PT0gbnVsbCB8fCBzbmFwc2hvdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc25hcHNob3QuaXNTaGFyZWQ7XG4gICAgICBjb25zdCBpc09ubHlNZW1iZXIgPSAoKChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lbWJlcnMubGVuZ3RoKSB8fCAwKSA8PSAxO1xuICAgICAgY29uc3Qgc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSA9IEJvb2xlYW4oaXNTaGFyZWRMYXlvdXRBbmltYXRpb24gJiYgIWlzT25seU1lbWJlciAmJiB0aGlzLm9wdGlvbnMuY3Jvc3NmYWRlID09PSB0cnVlICYmICF0aGlzLnBhdGguc29tZShoYXNPcGFjaXR5Q3Jvc3NmYWRlKSk7XG4gICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzID0gMDtcbiAgICAgIHRoaXMubWl4VGFyZ2V0RGVsdGEgPSAobGF0ZXN0KSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzMyA9IGxhdGVzdCAvIDFlMztcbiAgICAgICAgbWl4QXhpc0RlbHRhKHRhcmdldERlbHRhLngsIGRlbHRhLngsIHByb2dyZXNzMyk7XG4gICAgICAgIG1peEF4aXNEZWx0YSh0YXJnZXREZWx0YS55LCBkZWx0YS55LCBwcm9ncmVzczMpO1xuICAgICAgICB0aGlzLnNldFRhcmdldERlbHRhKHRhcmdldERlbHRhKTtcbiAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVUYXJnZXQgJiYgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiAmJiB0aGlzLmxheW91dCAmJiAoKF9hMiA9IHRoaXMucmVsYXRpdmVQYXJlbnQpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLmxheW91dCkpIHtcbiAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZUxheW91dCwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCB0aGlzLnJlbGF0aXZlUGFyZW50LmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgIG1peEJveCh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCByZWxhdGl2ZUxheW91dCwgcHJvZ3Jlc3MzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTaGFyZWRMYXlvdXRBbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvblZhbHVlcyA9IG1peGVkVmFsdWVzO1xuICAgICAgICAgIG1peFZhbHVlcyhtaXhlZFZhbHVlcywgc25hcHNob3RMYXRlc3RWYWx1ZXMsIHRoaXMubGF0ZXN0VmFsdWVzLCBwcm9ncmVzczMsIHNob3VsZENyb3NzZmFkZU9wYWNpdHksIGlzT25seU1lbWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290LnNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSBwcm9ncmVzczM7XG4gICAgICB9O1xuICAgICAgdGhpcy5taXhUYXJnZXREZWx0YSgwKTtcbiAgICB9XG4gICAgc3RhcnRBbmltYXRpb24ob3B0aW9ucykge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwiYW5pbWF0aW9uU3RhcnRcIik7XG4gICAgICAoX2EgPSB0aGlzLmN1cnJlbnRBbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7XG4gICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgKF9iID0gdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdBbmltYXRpb24pIHtcbiAgICAgICAgY2FuY2VsU3luYy51cGRhdGUodGhpcy5wZW5kaW5nQW5pbWF0aW9uKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gZXNfZGVmYXVsdC51cGRhdGUoKCkgPT4ge1xuICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGUyKDAsIGFuaW1hdGlvblRhcmdldCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgICBvblVwZGF0ZTogKGxhdGVzdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgIHRoaXMubWl4VGFyZ2V0RGVsdGEobGF0ZXN0KTtcbiAgICAgICAgICAgIChfYTIgPSBvcHRpb25zLm9uVXBkYXRlKSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMi5jYWxsKG9wdGlvbnMsIGxhdGVzdCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgKF9hMiA9IG9wdGlvbnMub25Db21wbGV0ZSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVBbmltYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHRoaXMucmVzdW1pbmdGcm9tKSB7XG4gICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuY3VycmVudEFuaW1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSB2b2lkIDA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29tcGxldGVBbmltYXRpb24oKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20ucHJlc2VydmVPcGFjaXR5ID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXhpdEFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICB0aGlzLnJlc3VtaW5nRnJvbSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uVmFsdWVzID0gdm9pZCAwO1xuICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJhbmltYXRpb25Db21wbGV0ZVwiKTtcbiAgICB9XG4gICAgZmluaXNoQW5pbWF0aW9uKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgICAoX2EgPSB0aGlzLm1peFRhcmdldERlbHRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBhbmltYXRpb25UYXJnZXQpO1xuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24uc3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpO1xuICAgIH1cbiAgICBhcHBseVRyYW5zZm9ybXNUb1RhcmdldCgpIHtcbiAgICAgIGNvbnN0IGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgIGxldCB7IHRhcmdldFdpdGhUcmFuc2Zvcm1zLCB0YXJnZXQsIGxheW91dCwgbGF0ZXN0VmFsdWVzIH0gPSBsZWFkO1xuICAgICAgaWYgKCF0YXJnZXRXaXRoVHJhbnNmb3JtcyB8fCAhdGFyZ2V0IHx8ICFsYXlvdXQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzICE9PSBsZWFkICYmIHRoaXMubGF5b3V0ICYmIGxheW91dCAmJiBzaG91bGRBbmltYXRlUG9zaXRpb25Pbmx5KHRoaXMub3B0aW9ucy5hbmltYXRpb25UeXBlLCB0aGlzLmxheW91dC5sYXlvdXRCb3gsIGxheW91dC5sYXlvdXRCb3gpKSB7XG4gICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0IHx8IGNyZWF0ZUJveCgpO1xuICAgICAgICBjb25zdCB4TGVuZ3RoID0gY2FsY0xlbmd0aCh0aGlzLmxheW91dC5sYXlvdXRCb3gueCk7XG4gICAgICAgIHRhcmdldC54Lm1pbiA9IGxlYWQudGFyZ2V0LngubWluO1xuICAgICAgICB0YXJnZXQueC5tYXggPSB0YXJnZXQueC5taW4gKyB4TGVuZ3RoO1xuICAgICAgICBjb25zdCB5TGVuZ3RoID0gY2FsY0xlbmd0aCh0aGlzLmxheW91dC5sYXlvdXRCb3gueSk7XG4gICAgICAgIHRhcmdldC55Lm1pbiA9IGxlYWQudGFyZ2V0LnkubWluO1xuICAgICAgICB0YXJnZXQueS5tYXggPSB0YXJnZXQueS5taW4gKyB5TGVuZ3RoO1xuICAgICAgfVxuICAgICAgY29weUJveEludG8odGFyZ2V0V2l0aFRyYW5zZm9ybXMsIHRhcmdldCk7XG4gICAgICB0cmFuc2Zvcm1Cb3godGFyZ2V0V2l0aFRyYW5zZm9ybXMsIGxhdGVzdFZhbHVlcyk7XG4gICAgICBjYWxjQm94RGVsdGEodGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtLCB0aGlzLmxheW91dENvcnJlY3RlZCwgdGFyZ2V0V2l0aFRyYW5zZm9ybXMsIGxhdGVzdFZhbHVlcyk7XG4gICAgfVxuICAgIHJlZ2lzdGVyU2hhcmVkTm9kZShsYXlvdXRJZCwgbm9kZSkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBpZiAoIXRoaXMuc2hhcmVkTm9kZXMuaGFzKGxheW91dElkKSkge1xuICAgICAgICB0aGlzLnNoYXJlZE5vZGVzLnNldChsYXlvdXRJZCwgbmV3IE5vZGVTdGFjaygpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5zaGFyZWROb2Rlcy5nZXQobGF5b3V0SWQpO1xuICAgICAgc3RhY2suYWRkKG5vZGUpO1xuICAgICAgbm9kZS5wcm9tb3RlKHtcbiAgICAgICAgdHJhbnNpdGlvbjogKF9hID0gbm9kZS5vcHRpb25zLmluaXRpYWxQcm9tb3Rpb25Db25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmFuc2l0aW9uLFxuICAgICAgICBwcmVzZXJ2ZUZvbGxvd09wYWNpdHk6IChfYyA9IChfYiA9IG5vZGUub3B0aW9ucy5pbml0aWFsUHJvbW90aW9uQ29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hvdWxkUHJlc2VydmVGb2xsb3dPcGFjaXR5KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgbm9kZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpc0xlYWQoKSB7XG4gICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgIHJldHVybiBzdGFjayA/IHN0YWNrLmxlYWQgPT09IHRoaXMgOiB0cnVlO1xuICAgIH1cbiAgICBnZXRMZWFkKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBsYXlvdXRJZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgcmV0dXJuIGxheW91dElkID8gKChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlYWQpIHx8IHRoaXMgOiB0aGlzO1xuICAgIH1cbiAgICBnZXRQcmV2TGVhZCgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHsgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIHJldHVybiBsYXlvdXRJZCA/IChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZXZMZWFkIDogdm9pZCAwO1xuICAgIH1cbiAgICBnZXRTdGFjaygpIHtcbiAgICAgIGNvbnN0IHsgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChsYXlvdXRJZClcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5zaGFyZWROb2Rlcy5nZXQobGF5b3V0SWQpO1xuICAgIH1cbiAgICBwcm9tb3RlKHsgbmVlZHNSZXNldCwgdHJhbnNpdGlvbiwgcHJlc2VydmVGb2xsb3dPcGFjaXR5IH0gPSB7fSkge1xuICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICBpZiAoc3RhY2spXG4gICAgICAgIHN0YWNrLnByb21vdGUodGhpcywgcHJlc2VydmVGb2xsb3dPcGFjaXR5KTtcbiAgICAgIGlmIChuZWVkc1Jlc2V0KSB7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zaXRpb24pXG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyh7IHRyYW5zaXRpb24gfSk7XG4gICAgfVxuICAgIHJlbGVnYXRlKCkge1xuICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrLnJlbGVnYXRlKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXNldFJvdGF0aW9uKCkge1xuICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBoYXNSb3RhdGUgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHJlc2V0VmFsdWVzID0ge307XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgdHJhbnNmb3JtQXhlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgY29uc3QgYXhpcyA9IHRyYW5zZm9ybUF4ZXNbaTJdO1xuICAgICAgICBjb25zdCBrZXkgPSBcInJvdGF0ZVwiICsgYXhpcztcbiAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50LmdldFN0YXRpY1ZhbHVlKGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBoYXNSb3RhdGUgPSB0cnVlO1xuICAgICAgICByZXNldFZhbHVlc1trZXldID0gdmlzdWFsRWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXkpO1xuICAgICAgICB2aXN1YWxFbGVtZW50LnNldFN0YXRpY1ZhbHVlKGtleSwgMCk7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1JvdGF0ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50LnJlbmRlcigpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzZXRWYWx1ZXMpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRTdGF0aWNWYWx1ZShrZXksIHJlc2V0VmFsdWVzW2tleV0pO1xuICAgICAgfVxuICAgICAgdmlzdWFsRWxlbWVudC5zY2hlZHVsZVJlbmRlcigpO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0aW9uU3R5bGVzKHN0eWxlUHJvcCA9IHt9KSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHt9O1xuICAgICAgaWYgKCF0aGlzLmluc3RhbmNlIHx8IHRoaXMuaXNTVkcpXG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlcy52aXNpYmlsaXR5ID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlID0gKF9hID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQcm9wcygpLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgaWYgKHRoaXMubmVlZHNSZXNldCkge1xuICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3R5bGVzLm9wYWNpdHkgPSBcIlwiO1xuICAgICAgICBzdHlsZXMucG9pbnRlckV2ZW50cyA9IHJlc29sdmVNb3Rpb25WYWx1ZShzdHlsZVByb3AucG9pbnRlckV2ZW50cykgfHwgXCJcIjtcbiAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlID8gdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpIDogXCJub25lXCI7XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICB9XG4gICAgICBjb25zdCBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICBpZiAoIXRoaXMucHJvamVjdGlvbkRlbHRhIHx8ICF0aGlzLmxheW91dCB8fCAhbGVhZC50YXJnZXQpIHtcbiAgICAgICAgY29uc3QgZW1wdHlTdHlsZXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRJZCkge1xuICAgICAgICAgIGVtcHR5U3R5bGVzLm9wYWNpdHkgPSB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5ICE9PSB2b2lkIDAgPyB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5IDogMTtcbiAgICAgICAgICBlbXB0eVN0eWxlcy5wb2ludGVyRXZlbnRzID0gcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc1Byb2plY3RlZCAmJiAhaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgIGVtcHR5U3R5bGVzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlID8gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpIDogXCJub25lXCI7XG4gICAgICAgICAgdGhpcy5oYXNQcm9qZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1wdHlTdHlsZXM7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZXNUb1JlbmRlciA9IGxlYWQuYW5pbWF0aW9uVmFsdWVzIHx8IGxlYWQubGF0ZXN0VmFsdWVzO1xuICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXNUb1RhcmdldCgpO1xuICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSh0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0sIHRoaXMudHJlZVNjYWxlLCB2YWx1ZXNUb1JlbmRlcik7XG4gICAgICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlKHZhbHVlc1RvUmVuZGVyLCBzdHlsZXMudHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5wcm9qZWN0aW9uRGVsdGE7XG4gICAgICBzdHlsZXMudHJhbnNmb3JtT3JpZ2luID0gYCR7eC5vcmlnaW4gKiAxMDB9JSAke3kub3JpZ2luICogMTAwfSUgMGA7XG4gICAgICBpZiAobGVhZC5hbmltYXRpb25WYWx1ZXMpIHtcbiAgICAgICAgc3R5bGVzLm9wYWNpdHkgPSBsZWFkID09PSB0aGlzID8gKF9jID0gKF9iID0gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMSA6IHRoaXMucHJlc2VydmVPcGFjaXR5ID8gdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eSA6IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHlFeGl0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVzLm9wYWNpdHkgPSBsZWFkID09PSB0aGlzID8gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSAhPT0gdm9pZCAwID8gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSA6IFwiXCIgOiB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdCAhPT0gdm9pZCAwID8gdmFsdWVzVG9SZW5kZXIub3BhY2l0eUV4aXQgOiAwO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NhbGVDb3JyZWN0b3JzKSB7XG4gICAgICAgIGlmICh2YWx1ZXNUb1JlbmRlcltrZXldID09PSB2b2lkIDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHsgY29ycmVjdCwgYXBwbHlUbyB9ID0gc2NhbGVDb3JyZWN0b3JzW2tleV07XG4gICAgICAgIGNvbnN0IGNvcnJlY3RlZCA9IGNvcnJlY3QodmFsdWVzVG9SZW5kZXJba2V5XSwgbGVhZCk7XG4gICAgICAgIGlmIChhcHBseVRvKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gYXBwbHlUby5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG51bTsgaTIrKykge1xuICAgICAgICAgICAgc3R5bGVzW2FwcGx5VG9baTJdXSA9IGNvcnJlY3RlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVzW2tleV0gPSBjb3JyZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0SWQpIHtcbiAgICAgICAgc3R5bGVzLnBvaW50ZXJFdmVudHMgPSBsZWFkID09PSB0aGlzID8gcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiIDogXCJub25lXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH1cbiAgICBjbGVhclNuYXBzaG90KCkge1xuICAgICAgdGhpcy5yZXN1bWVGcm9tID0gdGhpcy5zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmVzZXRUcmVlKCkge1xuICAgICAgdGhpcy5yb290Lm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gbm9kZS5jdXJyZW50QW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJvb3Qubm9kZXMuZm9yRWFjaChjbGVhck1lYXN1cmVtZW50cyk7XG4gICAgICB0aGlzLnJvb3Quc2hhcmVkTm9kZXMuY2xlYXIoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVMYXlvdXQobm9kZSkge1xuICBub2RlLnVwZGF0ZUxheW91dCgpO1xufVxuZnVuY3Rpb24gbm90aWZ5TGF5b3V0VXBkYXRlKG5vZGUpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGNvbnN0IHNuYXBzaG90ID0gKChfYSA9IG5vZGUucmVzdW1lRnJvbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNuYXBzaG90KSB8fCBub2RlLnNuYXBzaG90O1xuICBpZiAobm9kZS5pc0xlYWQoKSAmJiBub2RlLmxheW91dCAmJiBzbmFwc2hvdCAmJiBub2RlLmhhc0xpc3RlbmVycyhcImRpZFVwZGF0ZVwiKSkge1xuICAgIGNvbnN0IHsgbGF5b3V0Qm94OiBsYXlvdXQsIG1lYXN1cmVkQm94OiBtZWFzdXJlZExheW91dCB9ID0gbm9kZS5sYXlvdXQ7XG4gICAgY29uc3QgeyBhbmltYXRpb25UeXBlIH0gPSBub2RlLm9wdGlvbnM7XG4gICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IFwic2l6ZVwiKSB7XG4gICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICBjb25zdCBheGlzU25hcHNob3QgPSBzbmFwc2hvdC5pc1NoYXJlZCA/IHNuYXBzaG90Lm1lYXN1cmVkQm94W2F4aXNdIDogc25hcHNob3QubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjYWxjTGVuZ3RoKGF4aXNTbmFwc2hvdCk7XG4gICAgICAgIGF4aXNTbmFwc2hvdC5taW4gPSBsYXlvdXRbYXhpc10ubWluO1xuICAgICAgICBheGlzU25hcHNob3QubWF4ID0gYXhpc1NuYXBzaG90Lm1pbiArIGxlbmd0aDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkQW5pbWF0ZVBvc2l0aW9uT25seShhbmltYXRpb25UeXBlLCBzbmFwc2hvdC5sYXlvdXRCb3gsIGxheW91dCkpIHtcbiAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgIGNvbnN0IGF4aXNTbmFwc2hvdCA9IHNuYXBzaG90LmlzU2hhcmVkID8gc25hcHNob3QubWVhc3VyZWRCb3hbYXhpc10gOiBzbmFwc2hvdC5sYXlvdXRCb3hbYXhpc107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNhbGNMZW5ndGgobGF5b3V0W2F4aXNdKTtcbiAgICAgICAgYXhpc1NuYXBzaG90Lm1heCA9IGF4aXNTbmFwc2hvdC5taW4gKyBsZW5ndGg7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbGF5b3V0RGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgIGNhbGNCb3hEZWx0YShsYXlvdXREZWx0YSwgbGF5b3V0LCBzbmFwc2hvdC5sYXlvdXRCb3gpO1xuICAgIGNvbnN0IHZpc3VhbERlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICBpZiAoc25hcHNob3QuaXNTaGFyZWQpIHtcbiAgICAgIGNhbGNCb3hEZWx0YSh2aXN1YWxEZWx0YSwgbm9kZS5hcHBseVRyYW5zZm9ybShtZWFzdXJlZExheW91dCwgdHJ1ZSksIHNuYXBzaG90Lm1lYXN1cmVkQm94KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsY0JveERlbHRhKHZpc3VhbERlbHRhLCBsYXlvdXQsIHNuYXBzaG90LmxheW91dEJveCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc0xheW91dENoYW5nZWQgPSAhaXNEZWx0YVplcm8obGF5b3V0RGVsdGEpO1xuICAgIGxldCBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAoIW5vZGUucmVzdW1lRnJvbSkge1xuICAgICAgY29uc3QgcmVsYXRpdmVQYXJlbnQgPSBub2RlLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICBpZiAocmVsYXRpdmVQYXJlbnQgJiYgIXJlbGF0aXZlUGFyZW50LnJlc3VtZUZyb20pIHtcbiAgICAgICAgY29uc3QgeyBzbmFwc2hvdDogcGFyZW50U25hcHNob3QsIGxheW91dDogcGFyZW50TGF5b3V0IH0gPSByZWxhdGl2ZVBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudFNuYXBzaG90ICYmIHBhcmVudExheW91dCkge1xuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlU25hcHNob3QgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZVNuYXBzaG90LCBzbmFwc2hvdC5sYXlvdXRCb3gsIHBhcmVudFNuYXBzaG90LmxheW91dEJveCk7XG4gICAgICAgICAgY29uc3QgcmVsYXRpdmVMYXlvdXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZUxheW91dCwgbGF5b3V0LCBwYXJlbnRMYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICBpZiAoIWJveEVxdWFscyhyZWxhdGl2ZVNuYXBzaG90LCByZWxhdGl2ZUxheW91dCkpIHtcbiAgICAgICAgICAgIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUubm90aWZ5TGlzdGVuZXJzKFwiZGlkVXBkYXRlXCIsIHtcbiAgICAgIGxheW91dCxcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZGVsdGE6IHZpc3VhbERlbHRhLFxuICAgICAgbGF5b3V0RGVsdGEsXG4gICAgICBoYXNMYXlvdXRDaGFuZ2VkLFxuICAgICAgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobm9kZS5pc0xlYWQoKSkge1xuICAgIChfYyA9IChfYiA9IG5vZGUub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgfVxuICBub2RlLm9wdGlvbnMudHJhbnNpdGlvbiA9IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGNsZWFyU25hcHNob3Qobm9kZSkge1xuICBub2RlLmNsZWFyU25hcHNob3QoKTtcbn1cbmZ1bmN0aW9uIGNsZWFyTWVhc3VyZW1lbnRzKG5vZGUpIHtcbiAgbm9kZS5jbGVhck1lYXN1cmVtZW50cygpO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm1TdHlsZShub2RlKSB7XG4gIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gbm9kZS5vcHRpb25zO1xuICBpZiAodmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50LmdldFByb3BzKCkub25CZWZvcmVMYXlvdXRNZWFzdXJlKSB7XG4gICAgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJCZWZvcmVMYXlvdXRNZWFzdXJlXCIpO1xuICB9XG4gIG5vZGUucmVzZXRUcmFuc2Zvcm0oKTtcbn1cbmZ1bmN0aW9uIGZpbmlzaEFuaW1hdGlvbihub2RlKSB7XG4gIG5vZGUuZmluaXNoQW5pbWF0aW9uKCk7XG4gIG5vZGUudGFyZ2V0RGVsdGEgPSBub2RlLnJlbGF0aXZlVGFyZ2V0ID0gbm9kZS50YXJnZXQgPSB2b2lkIDA7XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0RGVsdGEobm9kZSkge1xuICBub2RlLnJlc29sdmVUYXJnZXREZWx0YSgpO1xufVxuZnVuY3Rpb24gY2FsY1Byb2plY3Rpb24obm9kZSkge1xuICBub2RlLmNhbGNQcm9qZWN0aW9uKCk7XG59XG5mdW5jdGlvbiByZXNldFJvdGF0aW9uKG5vZGUpIHtcbiAgbm9kZS5yZXNldFJvdGF0aW9uKCk7XG59XG5mdW5jdGlvbiByZW1vdmVMZWFkU25hcHNob3RzKHN0YWNrKSB7XG4gIHN0YWNrLnJlbW92ZUxlYWRTbmFwc2hvdCgpO1xufVxuZnVuY3Rpb24gbWl4QXhpc0RlbHRhKG91dHB1dCwgZGVsdGEsIHAyKSB7XG4gIG91dHB1dC50cmFuc2xhdGUgPSBtaXgoZGVsdGEudHJhbnNsYXRlLCAwLCBwMik7XG4gIG91dHB1dC5zY2FsZSA9IG1peChkZWx0YS5zY2FsZSwgMSwgcDIpO1xuICBvdXRwdXQub3JpZ2luID0gZGVsdGEub3JpZ2luO1xuICBvdXRwdXQub3JpZ2luUG9pbnQgPSBkZWx0YS5vcmlnaW5Qb2ludDtcbn1cbmZ1bmN0aW9uIG1peEF4aXMob3V0cHV0LCBmcm9tLCB0bywgcDIpIHtcbiAgb3V0cHV0Lm1pbiA9IG1peChmcm9tLm1pbiwgdG8ubWluLCBwMik7XG4gIG91dHB1dC5tYXggPSBtaXgoZnJvbS5tYXgsIHRvLm1heCwgcDIpO1xufVxuZnVuY3Rpb24gbWl4Qm94KG91dHB1dCwgZnJvbSwgdG8sIHAyKSB7XG4gIG1peEF4aXMob3V0cHV0LngsIGZyb20ueCwgdG8ueCwgcDIpO1xuICBtaXhBeGlzKG91dHB1dC55LCBmcm9tLnksIHRvLnksIHAyKTtcbn1cbmZ1bmN0aW9uIGhhc09wYWNpdHlDcm9zc2ZhZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5hbmltYXRpb25WYWx1ZXMgJiYgbm9kZS5hbmltYXRpb25WYWx1ZXMub3BhY2l0eUV4aXQgIT09IHZvaWQgMDtcbn1cbnZhciBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbiA9IHtcbiAgZHVyYXRpb246IDAuNDUsXG4gIGVhc2U6IFswLjQsIDAsIDAuMSwgMV1cbn07XG5mdW5jdGlvbiBtb3VudE5vZGVFYXJseShub2RlLCBpZDIpIHtcbiAgbGV0IHNlYXJjaE5vZGUgPSBub2RlLnJvb3Q7XG4gIGZvciAobGV0IGkyID0gbm9kZS5wYXRoLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBpZiAoQm9vbGVhbihub2RlLnBhdGhbaTJdLmluc3RhbmNlKSkge1xuICAgICAgc2VhcmNoTm9kZSA9IG5vZGUucGF0aFtpMl07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2VhcmNoRWxlbWVudCA9IHNlYXJjaE5vZGUgJiYgc2VhcmNoTm9kZSAhPT0gbm9kZS5yb290ID8gc2VhcmNoTm9kZS5pbnN0YW5jZSA6IGRvY3VtZW50O1xuICBjb25zdCBlbGVtZW50ID0gc2VhcmNoRWxlbWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wcm9qZWN0aW9uLWlkPVwiJHtpZDJ9XCJdYCk7XG4gIGlmIChlbGVtZW50KVxuICAgIG5vZGUubW91bnQoZWxlbWVudCwgdHJ1ZSk7XG59XG5mdW5jdGlvbiByb3VuZEF4aXMoYXhpcykge1xuICBheGlzLm1pbiA9IE1hdGgucm91bmQoYXhpcy5taW4pO1xuICBheGlzLm1heCA9IE1hdGgucm91bmQoYXhpcy5tYXgpO1xufVxuZnVuY3Rpb24gcm91bmRCb3goYm94KSB7XG4gIHJvdW5kQXhpcyhib3gueCk7XG4gIHJvdW5kQXhpcyhib3gueSk7XG59XG5mdW5jdGlvbiBzaG91bGRBbmltYXRlUG9zaXRpb25Pbmx5KGFuaW1hdGlvblR5cGUsIHNuYXBzaG90LCBsYXlvdXQpIHtcbiAgcmV0dXJuIGFuaW1hdGlvblR5cGUgPT09IFwicG9zaXRpb25cIiB8fCBhbmltYXRpb25UeXBlID09PSBcInByZXNlcnZlLWFzcGVjdFwiICYmICFpc0Nsb3NlVG8oYXNwZWN0UmF0aW8oc25hcHNob3QpLCBhc3BlY3RSYXRpbyhsYXlvdXQpLCAwLjIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9Eb2N1bWVudFByb2plY3Rpb25Ob2RlLm1qc1xudmFyIERvY3VtZW50UHJvamVjdGlvbk5vZGUgPSBjcmVhdGVQcm9qZWN0aW9uTm9kZSh7XG4gIGF0dGFjaFJlc2l6ZUxpc3RlbmVyOiAocmVmLCBub3RpZnkpID0+IGFkZERvbUV2ZW50KHJlZiwgXCJyZXNpemVcIiwgbm90aWZ5KSxcbiAgbWVhc3VyZVNjcm9sbDogKCkgPT4gKHtcbiAgICB4OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsXG4gICAgeTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcFxuICB9KSxcbiAgY2hlY2tJc1Njcm9sbFJvb3Q6ICgpID0+IHRydWVcbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9IVE1MUHJvamVjdGlvbk5vZGUubWpzXG52YXIgcm9vdFByb2plY3Rpb25Ob2RlID0ge1xuICBjdXJyZW50OiB2b2lkIDBcbn07XG52YXIgSFRNTFByb2plY3Rpb25Ob2RlID0gY3JlYXRlUHJvamVjdGlvbk5vZGUoe1xuICBtZWFzdXJlU2Nyb2xsOiAoaW5zdGFuY2UpID0+ICh7XG4gICAgeDogaW5zdGFuY2Uuc2Nyb2xsTGVmdCxcbiAgICB5OiBpbnN0YW5jZS5zY3JvbGxUb3BcbiAgfSksXG4gIGRlZmF1bHRQYXJlbnQ6ICgpID0+IHtcbiAgICBpZiAoIXJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50KSB7XG4gICAgICBjb25zdCBkb2N1bWVudE5vZGUgPSBuZXcgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSgwLCB7fSk7XG4gICAgICBkb2N1bWVudE5vZGUubW91bnQod2luZG93KTtcbiAgICAgIGRvY3VtZW50Tm9kZS5zZXRPcHRpb25zKHsgbGF5b3V0U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQgPSBkb2N1bWVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiByb290UHJvamVjdGlvbk5vZGUuY3VycmVudDtcbiAgfSxcbiAgcmVzZXRUcmFuc2Zvcm06IChpbnN0YW5jZSwgdmFsdWUpID0+IHtcbiAgICBpbnN0YW5jZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBcIm5vbmVcIjtcbiAgfSxcbiAgY2hlY2tJc1Njcm9sbFJvb3Q6IChpbnN0YW5jZSkgPT4gQm9vbGVhbih3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbnN0YW5jZSkucG9zaXRpb24gPT09IFwiZml4ZWRcIilcbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vbW90aW9uLm1qc1xudmFyIGZlYXR1cmVCdW5kbGUgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgYW5pbWF0aW9ucyksIGdlc3R1cmVBbmltYXRpb25zKSwgZHJhZyksIGxheW91dEZlYXR1cmVzKTtcbnZhciBtb3Rpb24gPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlTW90aW9uUHJveHkoKENvbXBvbmVudCwgY29uZmlnKSA9PiBjcmVhdGVEb21Nb3Rpb25Db25maWcoQ29tcG9uZW50LCBjb25maWcsIGZlYXR1cmVCdW5kbGUsIGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQsIEhUTUxQcm9qZWN0aW9uTm9kZSkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2NsYW1wLmVzLmpzXG52YXIgY2xhbXAzID0gKG1pbiwgbWF4LCB2KSA9PiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2lzLW51bWJlci5lcy5qc1xudmFyIGlzTnVtYmVyID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvaXMtZWFzaW5nLWxpc3QuZXMuanNcbnZhciBpc0Vhc2luZ0xpc3QgPSAoZWFzaW5nKSA9PiBBcnJheS5pc0FycmF5KGVhc2luZykgJiYgIWlzTnVtYmVyKGVhc2luZ1swXSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3Qvd3JhcC5lcy5qc1xudmFyIHdyYXAgPSAobWluLCBtYXgsIHYpID0+IHtcbiAgY29uc3QgcmFuZ2VTaXplID0gbWF4IC0gbWluO1xuICByZXR1cm4gKCh2IC0gbWluKSAlIHJhbmdlU2l6ZSArIHJhbmdlU2l6ZSkgJSByYW5nZVNpemUgKyBtaW47XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2Vhc2luZy5lcy5qc1xuZnVuY3Rpb24gZ2V0RWFzaW5nRm9yU2VnbWVudChlYXNpbmcsIGkyKSB7XG4gIHJldHVybiBpc0Vhc2luZ0xpc3QoZWFzaW5nKSA/IGVhc2luZ1t3cmFwKDAsIGVhc2luZy5sZW5ndGgsIGkyKV0gOiBlYXNpbmc7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvbWl4LmVzLmpzXG52YXIgbWl4MiA9IChtaW4sIG1heCwgcHJvZ3Jlc3MzKSA9PiAtcHJvZ3Jlc3MzICogbWluICsgcHJvZ3Jlc3MzICogbWF4ICsgbWluO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L25vb3AuZXMuanNcbnZhciBub29wUmV0dXJuID0gKHYpID0+IHY7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvcHJvZ3Jlc3MuZXMuanNcbnZhciBwcm9ncmVzczIgPSAobWluLCBtYXgsIHZhbHVlKSA9PiBtYXggLSBtaW4gPT09IDAgPyAxIDogKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L29mZnNldC5lcy5qc1xuZnVuY3Rpb24gZmlsbE9mZnNldChvZmZzZXQsIHJlbWFpbmluZykge1xuICBjb25zdCBtaW4gPSBvZmZzZXRbb2Zmc2V0Lmxlbmd0aCAtIDFdO1xuICBmb3IgKGxldCBpMiA9IDE7IGkyIDw9IHJlbWFpbmluZzsgaTIrKykge1xuICAgIGNvbnN0IG9mZnNldFByb2dyZXNzID0gcHJvZ3Jlc3MyKDAsIHJlbWFpbmluZywgaTIpO1xuICAgIG9mZnNldC5wdXNoKG1peDIobWluLCAxLCBvZmZzZXRQcm9ncmVzcykpO1xuICB9XG59XG5mdW5jdGlvbiBkZWZhdWx0T2Zmc2V0MihsZW5ndGgpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gWzBdO1xuICBmaWxsT2Zmc2V0KG9mZnNldCwgbGVuZ3RoIC0gMSk7XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvaW50ZXJwb2xhdGUuZXMuanNcbmZ1bmN0aW9uIGludGVycG9sYXRlMihvdXRwdXQsIGlucHV0ID0gZGVmYXVsdE9mZnNldDIob3V0cHV0Lmxlbmd0aCksIGVhc2luZyA9IG5vb3BSZXR1cm4pIHtcbiAgY29uc3QgbGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcbiAgY29uc3QgcmVtYWluZGVyID0gbGVuZ3RoIC0gaW5wdXQubGVuZ3RoO1xuICByZW1haW5kZXIgPiAwICYmIGZpbGxPZmZzZXQoaW5wdXQsIHJlbWFpbmRlcik7XG4gIHJldHVybiAodCkgPT4ge1xuICAgIGxldCBpMiA9IDA7XG4gICAgZm9yICg7IGkyIDwgbGVuZ3RoIC0gMjsgaTIrKykge1xuICAgICAgaWYgKHQgPCBpbnB1dFtpMiArIDFdKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IHByb2dyZXNzSW5SYW5nZSA9IGNsYW1wMygwLCAxLCBwcm9ncmVzczIoaW5wdXRbaTJdLCBpbnB1dFtpMiArIDFdLCB0KSk7XG4gICAgY29uc3Qgc2VnbWVudEVhc2luZyA9IGdldEVhc2luZ0ZvclNlZ21lbnQoZWFzaW5nLCBpMik7XG4gICAgcHJvZ3Jlc3NJblJhbmdlID0gc2VnbWVudEVhc2luZyhwcm9ncmVzc0luUmFuZ2UpO1xuICAgIHJldHVybiBtaXgyKG91dHB1dFtpMl0sIG91dHB1dFtpMiArIDFdLCBwcm9ncmVzc0luUmFuZ2UpO1xuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2lzLWZ1bmN0aW9uLmVzLmpzXG52YXIgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvaXMtc3RyaW5nLmVzLmpzXG52YXIgaXNTdHJpbmcyID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvdmVsb2NpdHkuZXMuanNcbmZ1bmN0aW9uIHZlbG9jaXR5UGVyU2Vjb25kMih2ZWxvY2l0eSwgZnJhbWVEdXJhdGlvbikge1xuICByZXR1cm4gZnJhbWVEdXJhdGlvbiA/IHZlbG9jaXR5ICogKDFlMyAvIGZyYW1lRHVyYXRpb24pIDogMDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvdXRpbHMvcmVzb2x2ZS1lbGVtZW50cy5lcy5qc1xuZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnRzKGVsZW1lbnRzLCBzZWxlY3RvckNhY2hlKSB7XG4gIHZhciBfYTtcbiAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChzZWxlY3RvckNhY2hlKSB7XG4gICAgICAoX2EgPSBzZWxlY3RvckNhY2hlW2VsZW1lbnRzXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2VsZWN0b3JDYWNoZVtlbGVtZW50c10gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRzKTtcbiAgICAgIGVsZW1lbnRzID0gc2VsZWN0b3JDYWNoZVtlbGVtZW50c107XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbGVtZW50cyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50cyB8fCBbXSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy90c2xpYi9tb2R1bGVzL2luZGV4LmpzXG52YXIgaW1wb3J0X3RzbGliNCA9IF9fdG9FU00ocmVxdWlyZV90c2xpYjIoKSwgMSk7XG52YXIge1xuICBfX2V4dGVuZHM6IF9fZXh0ZW5kczIsXG4gIF9fYXNzaWduOiBfX2Fzc2lnbjIsXG4gIF9fcmVzdDogX19yZXN0MixcbiAgX19kZWNvcmF0ZTogX19kZWNvcmF0ZTIsXG4gIF9fcGFyYW06IF9fcGFyYW0yLFxuICBfX21ldGFkYXRhOiBfX21ldGFkYXRhMixcbiAgX19hd2FpdGVyOiBfX2F3YWl0ZXIyLFxuICBfX2dlbmVyYXRvcjogX19nZW5lcmF0b3IyLFxuICBfX2V4cG9ydFN0YXI6IF9fZXhwb3J0U3RhcjIsXG4gIF9fY3JlYXRlQmluZGluZzogX19jcmVhdGVCaW5kaW5nMixcbiAgX192YWx1ZXM6IF9fdmFsdWVzMixcbiAgX19yZWFkOiBfX3JlYWQyLFxuICBfX3NwcmVhZDogX19zcHJlYWQyLFxuICBfX3NwcmVhZEFycmF5czogX19zcHJlYWRBcnJheXMyLFxuICBfX3NwcmVhZEFycmF5OiBfX3NwcmVhZEFycmF5MixcbiAgX19hd2FpdDogX19hd2FpdDIsXG4gIF9fYXN5bmNHZW5lcmF0b3I6IF9fYXN5bmNHZW5lcmF0b3IyLFxuICBfX2FzeW5jRGVsZWdhdG9yOiBfX2FzeW5jRGVsZWdhdG9yMixcbiAgX19hc3luY1ZhbHVlczogX19hc3luY1ZhbHVlczIsXG4gIF9fbWFrZVRlbXBsYXRlT2JqZWN0OiBfX21ha2VUZW1wbGF0ZU9iamVjdDIsXG4gIF9faW1wb3J0U3RhcjogX19pbXBvcnRTdGFyMixcbiAgX19pbXBvcnREZWZhdWx0OiBfX2ltcG9ydERlZmF1bHQyLFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MixcbiAgX19jbGFzc1ByaXZhdGVGaWVsZFNldDogX19jbGFzc1ByaXZhdGVGaWVsZFNldDIsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJbjogX19jbGFzc1ByaXZhdGVGaWVsZEluMlxufSA9IGltcG9ydF90c2xpYjQuZGVmYXVsdDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvcmVzaXplL2hhbmRsZS1lbGVtZW50LmVzLmpzXG52YXIgcmVzaXplSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBvYnNlcnZlcjtcbmZ1bmN0aW9uIGdldEVsZW1lbnRTaXplKHRhcmdldCwgYm9yZGVyQm94U2l6ZSkge1xuICBpZiAoYm9yZGVyQm94U2l6ZSkge1xuICAgIGNvbnN0IHsgaW5saW5lU2l6ZSwgYmxvY2tTaXplIH0gPSBib3JkZXJCb3hTaXplWzBdO1xuICAgIHJldHVybiB7IHdpZHRoOiBpbmxpbmVTaXplLCBoZWlnaHQ6IGJsb2NrU2l6ZSB9O1xuICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgJiYgXCJnZXRCQm94XCIgaW4gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5nZXRCQm94KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0YXJnZXQub2Zmc2V0V2lkdGgsXG4gICAgICBoZWlnaHQ6IHRhcmdldC5vZmZzZXRIZWlnaHRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBub3RpZnlUYXJnZXQoeyB0YXJnZXQsIGNvbnRlbnRSZWN0LCBib3JkZXJCb3hTaXplIH0pIHtcbiAgdmFyIF9hO1xuICAoX2EgPSByZXNpemVIYW5kbGVycy5nZXQodGFyZ2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICBoYW5kbGVyKHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRlbnRTaXplOiBjb250ZW50UmVjdCxcbiAgICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gZ2V0RWxlbWVudFNpemUodGFyZ2V0LCBib3JkZXJCb3hTaXplKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBub3RpZnlBbGwoZW50cmllcykge1xuICBlbnRyaWVzLmZvckVhY2gobm90aWZ5VGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKCkge1xuICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybjtcbiAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIobm90aWZ5QWxsKTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUVsZW1lbnQodGFyZ2V0LCBoYW5kbGVyKSB7XG4gIGlmICghb2JzZXJ2ZXIpXG4gICAgY3JlYXRlUmVzaXplT2JzZXJ2ZXIoKTtcbiAgY29uc3QgZWxlbWVudHMgPSByZXNvbHZlRWxlbWVudHModGFyZ2V0KTtcbiAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgIGxldCBlbGVtZW50SGFuZGxlcnMgPSByZXNpemVIYW5kbGVycy5nZXQoZWxlbWVudCk7XG4gICAgaWYgKCFlbGVtZW50SGFuZGxlcnMpIHtcbiAgICAgIGVsZW1lbnRIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICByZXNpemVIYW5kbGVycy5zZXQoZWxlbWVudCwgZWxlbWVudEhhbmRsZXJzKTtcbiAgICB9XG4gICAgZWxlbWVudEhhbmRsZXJzLmFkZChoYW5kbGVyKTtcbiAgICBvYnNlcnZlciA9PT0gbnVsbCB8fCBvYnNlcnZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudEhhbmRsZXJzID0gcmVzaXplSGFuZGxlcnMuZ2V0KGVsZW1lbnQpO1xuICAgICAgZWxlbWVudEhhbmRsZXJzID09PSBudWxsIHx8IGVsZW1lbnRIYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudEhhbmRsZXJzLmRlbGV0ZShoYW5kbGVyKTtcbiAgICAgIGlmICghKGVsZW1lbnRIYW5kbGVycyA9PT0gbnVsbCB8fCBlbGVtZW50SGFuZGxlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnRIYW5kbGVycy5zaXplKSkge1xuICAgICAgICBvYnNlcnZlciA9PT0gbnVsbCB8fCBvYnNlcnZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9yZXNpemUvaGFuZGxlLXdpbmRvdy5lcy5qc1xudmFyIHdpbmRvd0NhbGxiYWNrcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgd2luZG93UmVzaXplSGFuZGxlcjtcbmZ1bmN0aW9uIGNyZWF0ZVdpbmRvd1Jlc2l6ZUhhbmRsZXIoKSB7XG4gIHdpbmRvd1Jlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBpbmZvID0ge1xuICAgICAgdGFyZ2V0OiB3aW5kb3csXG4gICAgICBzaXplLFxuICAgICAgY29udGVudFNpemU6IHNpemVcbiAgICB9O1xuICAgIHdpbmRvd0NhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soaW5mbykpO1xuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB3aW5kb3dSZXNpemVIYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZVdpbmRvdyhjYWxsYmFjaykge1xuICB3aW5kb3dDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgaWYgKCF3aW5kb3dSZXNpemVIYW5kbGVyKVxuICAgIGNyZWF0ZVdpbmRvd1Jlc2l6ZUhhbmRsZXIoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB3aW5kb3dDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICBpZiAoIXdpbmRvd0NhbGxiYWNrcy5zaXplICYmIHdpbmRvd1Jlc2l6ZUhhbmRsZXIpIHtcbiAgICAgIHdpbmRvd1Jlc2l6ZUhhbmRsZXIgPSB2b2lkIDA7XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9yZXNpemUvaW5kZXguZXMuanNcbmZ1bmN0aW9uIHJlc2l6ZShhMiwgYjIpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oYTIpID8gcmVzaXplV2luZG93KGEyKSA6IHJlc2l6ZUVsZW1lbnQoYTIsIGIyKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL2luZm8uZXMuanNcbnZhciBtYXhFbGFwc2VkMiA9IDUwO1xudmFyIGNyZWF0ZUF4aXNJbmZvID0gKCkgPT4gKHtcbiAgY3VycmVudDogMCxcbiAgb2Zmc2V0OiBbXSxcbiAgcHJvZ3Jlc3M6IDAsXG4gIHNjcm9sbExlbmd0aDogMCxcbiAgdGFyZ2V0T2Zmc2V0OiAwLFxuICB0YXJnZXRMZW5ndGg6IDAsXG4gIGNvbnRhaW5lckxlbmd0aDogMCxcbiAgdmVsb2NpdHk6IDBcbn0pO1xudmFyIGNyZWF0ZVNjcm9sbEluZm8gPSAoKSA9PiAoe1xuICB0aW1lOiAwLFxuICB4OiBjcmVhdGVBeGlzSW5mbygpLFxuICB5OiBjcmVhdGVBeGlzSW5mbygpXG59KTtcbnZhciBrZXlzID0ge1xuICB4OiB7XG4gICAgbGVuZ3RoOiBcIldpZHRoXCIsXG4gICAgcG9zaXRpb246IFwiTGVmdFwiXG4gIH0sXG4gIHk6IHtcbiAgICBsZW5ndGg6IFwiSGVpZ2h0XCIsXG4gICAgcG9zaXRpb246IFwiVG9wXCJcbiAgfVxufTtcbmZ1bmN0aW9uIHVwZGF0ZUF4aXNJbmZvKGVsZW1lbnQsIGF4aXNOYW1lLCBpbmZvLCB0aW1lKSB7XG4gIGNvbnN0IGF4aXMgPSBpbmZvW2F4aXNOYW1lXTtcbiAgY29uc3QgeyBsZW5ndGgsIHBvc2l0aW9uIH0gPSBrZXlzW2F4aXNOYW1lXTtcbiAgY29uc3QgcHJldiA9IGF4aXMuY3VycmVudDtcbiAgY29uc3QgcHJldlRpbWUgPSBpbmZvLnRpbWU7XG4gIGF4aXMuY3VycmVudCA9IGVsZW1lbnRbXCJzY3JvbGxcIiArIHBvc2l0aW9uXTtcbiAgYXhpcy5zY3JvbGxMZW5ndGggPSBlbGVtZW50W1wic2Nyb2xsXCIgKyBsZW5ndGhdIC0gZWxlbWVudFtcImNsaWVudFwiICsgbGVuZ3RoXTtcbiAgYXhpcy5vZmZzZXQubGVuZ3RoID0gMDtcbiAgYXhpcy5vZmZzZXRbMF0gPSAwO1xuICBheGlzLm9mZnNldFsxXSA9IGF4aXMuc2Nyb2xsTGVuZ3RoO1xuICBheGlzLnByb2dyZXNzID0gcHJvZ3Jlc3MyKDAsIGF4aXMuc2Nyb2xsTGVuZ3RoLCBheGlzLmN1cnJlbnQpO1xuICBjb25zdCBlbGFwc2VkID0gdGltZSAtIHByZXZUaW1lO1xuICBheGlzLnZlbG9jaXR5ID0gZWxhcHNlZCA+IG1heEVsYXBzZWQyID8gMCA6IHZlbG9jaXR5UGVyU2Vjb25kMihheGlzLmN1cnJlbnQgLSBwcmV2LCBlbGFwc2VkKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNjcm9sbEluZm8oZWxlbWVudCwgaW5mbywgdGltZSkge1xuICB1cGRhdGVBeGlzSW5mbyhlbGVtZW50LCBcInhcIiwgaW5mbywgdGltZSk7XG4gIHVwZGF0ZUF4aXNJbmZvKGVsZW1lbnQsIFwieVwiLCBpbmZvLCB0aW1lKTtcbiAgaW5mby50aW1lID0gdGltZTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL29mZnNldHMvaW5zZXQuZXMuanNcbmZ1bmN0aW9uIGNhbGNJbnNldChlbGVtZW50LCBjb250YWluZXIpIHtcbiAgbGV0IGluc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gIGxldCBjdXJyZW50ID0gZWxlbWVudDtcbiAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gY29udGFpbmVyKSB7XG4gICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgaW5zZXQueCArPSBjdXJyZW50Lm9mZnNldExlZnQ7XG4gICAgICBpbnNldC55ICs9IGN1cnJlbnQub2Zmc2V0VG9wO1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQub2Zmc2V0UGFyZW50O1xuICAgIH0gZWxzZSBpZiAoY3VycmVudCBpbnN0YW5jZW9mIFNWR0dyYXBoaWNzRWxlbWVudCAmJiBcImdldEJCb3hcIiBpbiBjdXJyZW50KSB7XG4gICAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gY3VycmVudC5nZXRCQm94KCk7XG4gICAgICBpbnNldC54ICs9IGxlZnQ7XG4gICAgICBpbnNldC55ICs9IHRvcDtcbiAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQudGFnTmFtZSAhPT0gXCJzdmdcIikge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5zZXQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9vZmZzZXRzL3ByZXNldHMuZXMuanNcbnZhciBTY3JvbGxPZmZzZXQgPSB7XG4gIEVudGVyOiBbXG4gICAgWzAsIDFdLFxuICAgIFsxLCAxXVxuICBdLFxuICBFeGl0OiBbXG4gICAgWzAsIDBdLFxuICAgIFsxLCAwXVxuICBdLFxuICBBbnk6IFtcbiAgICBbMSwgMF0sXG4gICAgWzAsIDFdXG4gIF0sXG4gIEFsbDogW1xuICAgIFswLCAwXSxcbiAgICBbMSwgMV1cbiAgXVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL29mZnNldHMvZWRnZS5lcy5qc1xudmFyIG5hbWVkRWRnZXMgPSB7XG4gIHN0YXJ0OiAwLFxuICBjZW50ZXI6IDAuNSxcbiAgZW5kOiAxXG59O1xuZnVuY3Rpb24gcmVzb2x2ZUVkZ2UoZWRnZSwgbGVuZ3RoLCBpbnNldCA9IDApIHtcbiAgbGV0IGRlbHRhID0gMDtcbiAgaWYgKG5hbWVkRWRnZXNbZWRnZV0gIT09IHZvaWQgMCkge1xuICAgIGVkZ2UgPSBuYW1lZEVkZ2VzW2VkZ2VdO1xuICB9XG4gIGlmIChpc1N0cmluZzIoZWRnZSkpIHtcbiAgICBjb25zdCBhc051bWJlcjIgPSBwYXJzZUZsb2F0KGVkZ2UpO1xuICAgIGlmIChlZGdlLmVuZHNXaXRoKFwicHhcIikpIHtcbiAgICAgIGRlbHRhID0gYXNOdW1iZXIyO1xuICAgIH0gZWxzZSBpZiAoZWRnZS5lbmRzV2l0aChcIiVcIikpIHtcbiAgICAgIGVkZ2UgPSBhc051bWJlcjIgLyAxMDA7XG4gICAgfSBlbHNlIGlmIChlZGdlLmVuZHNXaXRoKFwidndcIikpIHtcbiAgICAgIGRlbHRhID0gYXNOdW1iZXIyIC8gMTAwICogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIH0gZWxzZSBpZiAoZWRnZS5lbmRzV2l0aChcInZoXCIpKSB7XG4gICAgICBkZWx0YSA9IGFzTnVtYmVyMiAvIDEwMCAqIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkZ2UgPSBhc051bWJlcjI7XG4gICAgfVxuICB9XG4gIGlmIChpc051bWJlcihlZGdlKSkge1xuICAgIGRlbHRhID0gbGVuZ3RoICogZWRnZTtcbiAgfVxuICByZXR1cm4gaW5zZXQgKyBkZWx0YTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL29mZnNldHMvb2Zmc2V0LmVzLmpzXG52YXIgZGVmYXVsdE9mZnNldDMgPSBbMCwgMF07XG5mdW5jdGlvbiByZXNvbHZlT2Zmc2V0KG9mZnNldCwgY29udGFpbmVyTGVuZ3RoLCB0YXJnZXRMZW5ndGgsIHRhcmdldEluc2V0KSB7XG4gIGxldCBvZmZzZXREZWZpbml0aW9uID0gQXJyYXkuaXNBcnJheShvZmZzZXQpID8gb2Zmc2V0IDogZGVmYXVsdE9mZnNldDM7XG4gIGxldCB0YXJnZXRQb2ludCA9IDA7XG4gIGxldCBjb250YWluZXJQb2ludCA9IDA7XG4gIGlmIChpc051bWJlcihvZmZzZXQpKSB7XG4gICAgb2Zmc2V0RGVmaW5pdGlvbiA9IFtvZmZzZXQsIG9mZnNldF07XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcyKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQudHJpbSgpO1xuICAgIGlmIChvZmZzZXQuaW5jbHVkZXMoXCIgXCIpKSB7XG4gICAgICBvZmZzZXREZWZpbml0aW9uID0gb2Zmc2V0LnNwbGl0KFwiIFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0RGVmaW5pdGlvbiA9IFtvZmZzZXQsIG5hbWVkRWRnZXNbb2Zmc2V0XSA/IG9mZnNldCA6IGAwYF07XG4gICAgfVxuICB9XG4gIHRhcmdldFBvaW50ID0gcmVzb2x2ZUVkZ2Uob2Zmc2V0RGVmaW5pdGlvblswXSwgdGFyZ2V0TGVuZ3RoLCB0YXJnZXRJbnNldCk7XG4gIGNvbnRhaW5lclBvaW50ID0gcmVzb2x2ZUVkZ2Uob2Zmc2V0RGVmaW5pdGlvblsxXSwgY29udGFpbmVyTGVuZ3RoKTtcbiAgcmV0dXJuIHRhcmdldFBvaW50IC0gY29udGFpbmVyUG9pbnQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9vZmZzZXRzL2luZGV4LmVzLmpzXG52YXIgcG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbmZ1bmN0aW9uIHJlc29sdmVPZmZzZXRzKGNvbnRhaW5lciwgaW5mbywgb3B0aW9ucykge1xuICBsZXQgeyBvZmZzZXQ6IG9mZnNldERlZmluaXRpb24gPSBTY3JvbGxPZmZzZXQuQWxsIH0gPSBvcHRpb25zO1xuICBjb25zdCB7IHRhcmdldCA9IGNvbnRhaW5lciwgYXhpcyA9IFwieVwiIH0gPSBvcHRpb25zO1xuICBjb25zdCBsZW5ndGhMYWJlbCA9IGF4aXMgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgY29uc3QgaW5zZXQgPSB0YXJnZXQgIT09IGNvbnRhaW5lciA/IGNhbGNJbnNldCh0YXJnZXQsIGNvbnRhaW5lcikgOiBwb2ludDtcbiAgY29uc3QgdGFyZ2V0U2l6ZSA9IHRhcmdldCA9PT0gY29udGFpbmVyID8geyB3aWR0aDogY29udGFpbmVyLnNjcm9sbFdpZHRoLCBoZWlnaHQ6IGNvbnRhaW5lci5zY3JvbGxIZWlnaHQgfSA6IHsgd2lkdGg6IHRhcmdldC5jbGllbnRXaWR0aCwgaGVpZ2h0OiB0YXJnZXQuY2xpZW50SGVpZ2h0IH07XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSB7XG4gICAgd2lkdGg6IGNvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGNvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgfTtcbiAgaW5mb1theGlzXS5vZmZzZXQubGVuZ3RoID0gMDtcbiAgbGV0IGhhc0NoYW5nZWQgPSAhaW5mb1theGlzXS5pbnRlcnBvbGF0ZTtcbiAgY29uc3QgbnVtT2Zmc2V0cyA9IG9mZnNldERlZmluaXRpb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbnVtT2Zmc2V0czsgaTIrKykge1xuICAgIGNvbnN0IG9mZnNldCA9IHJlc29sdmVPZmZzZXQob2Zmc2V0RGVmaW5pdGlvbltpMl0sIGNvbnRhaW5lclNpemVbbGVuZ3RoTGFiZWxdLCB0YXJnZXRTaXplW2xlbmd0aExhYmVsXSwgaW5zZXRbYXhpc10pO1xuICAgIGlmICghaGFzQ2hhbmdlZCAmJiBvZmZzZXQgIT09IGluZm9bYXhpc10uaW50ZXJwb2xhdG9yT2Zmc2V0c1tpMl0pIHtcbiAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpbmZvW2F4aXNdLm9mZnNldFtpMl0gPSBvZmZzZXQ7XG4gIH1cbiAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICBpbmZvW2F4aXNdLmludGVycG9sYXRlID0gaW50ZXJwb2xhdGUyKGRlZmF1bHRPZmZzZXQyKG51bU9mZnNldHMpLCBpbmZvW2F4aXNdLm9mZnNldCk7XG4gICAgaW5mb1theGlzXS5pbnRlcnBvbGF0b3JPZmZzZXRzID0gWy4uLmluZm9bYXhpc10ub2Zmc2V0XTtcbiAgfVxuICBpbmZvW2F4aXNdLnByb2dyZXNzID0gaW5mb1theGlzXS5pbnRlcnBvbGF0ZShpbmZvW2F4aXNdLmN1cnJlbnQpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvb24tc2Nyb2xsLWhhbmRsZXIuZXMuanNcbmZ1bmN0aW9uIG1lYXN1cmUoY29udGFpbmVyLCB0YXJnZXQgPSBjb250YWluZXIsIGluZm8pIHtcbiAgaW5mby54LnRhcmdldE9mZnNldCA9IDA7XG4gIGluZm8ueS50YXJnZXRPZmZzZXQgPSAwO1xuICBpZiAodGFyZ2V0ICE9PSBjb250YWluZXIpIHtcbiAgICBsZXQgbm9kZSA9IHRhcmdldDtcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9IGNvbnRhaW5lcikge1xuICAgICAgaW5mby54LnRhcmdldE9mZnNldCArPSBub2RlLm9mZnNldExlZnQ7XG4gICAgICBpbmZvLnkudGFyZ2V0T2Zmc2V0ICs9IG5vZGUub2Zmc2V0VG9wO1xuICAgICAgbm9kZSA9IG5vZGUub2Zmc2V0UGFyZW50O1xuICAgIH1cbiAgfVxuICBpbmZvLngudGFyZ2V0TGVuZ3RoID0gdGFyZ2V0ID09PSBjb250YWluZXIgPyB0YXJnZXQuc2Nyb2xsV2lkdGggOiB0YXJnZXQuY2xpZW50V2lkdGg7XG4gIGluZm8ueS50YXJnZXRMZW5ndGggPSB0YXJnZXQgPT09IGNvbnRhaW5lciA/IHRhcmdldC5zY3JvbGxIZWlnaHQgOiB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICBpbmZvLnguY29udGFpbmVyTGVuZ3RoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICBpbmZvLnkuY29udGFpbmVyTGVuZ3RoID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9uU2Nyb2xsSGFuZGxlcihlbGVtZW50LCBvblNjcm9sbCwgaW5mbywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgXCJ5XCI7XG4gIHJldHVybiB7XG4gICAgbWVhc3VyZTogKCkgPT4gbWVhc3VyZShlbGVtZW50LCBvcHRpb25zLnRhcmdldCwgaW5mbyksXG4gICAgdXBkYXRlOiAodGltZSkgPT4ge1xuICAgICAgdXBkYXRlU2Nyb2xsSW5mbyhlbGVtZW50LCBpbmZvLCB0aW1lKTtcbiAgICAgIGlmIChvcHRpb25zLm9mZnNldCB8fCBvcHRpb25zLnRhcmdldCkge1xuICAgICAgICByZXNvbHZlT2Zmc2V0cyhlbGVtZW50LCBpbmZvLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5vdGlmeTogaXNGdW5jdGlvbihvblNjcm9sbCkgPyAoKSA9PiBvblNjcm9sbChpbmZvKSA6IHNjcnViQW5pbWF0aW9uKG9uU2Nyb2xsLCBpbmZvW2F4aXNdKVxuICB9O1xufVxuZnVuY3Rpb24gc2NydWJBbmltYXRpb24oY29udHJvbHMsIGF4aXNJbmZvKSB7XG4gIGNvbnRyb2xzLnBhdXNlKCk7XG4gIGNvbnRyb2xzLmZvckVhY2hOYXRpdmUoKGFuaW1hdGlvbiwgeyBlYXNpbmcgfSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGFuaW1hdGlvbi51cGRhdGVEdXJhdGlvbikge1xuICAgICAgaWYgKCFlYXNpbmcpXG4gICAgICAgIGFuaW1hdGlvbi5lYXNpbmcgPSBub29wUmV0dXJuO1xuICAgICAgYW5pbWF0aW9uLnVwZGF0ZUR1cmF0aW9uKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0aW1pbmdPcHRpb25zID0geyBkdXJhdGlvbjogMWUzIH07XG4gICAgICBpZiAoIWVhc2luZylcbiAgICAgICAgdGltaW5nT3B0aW9ucy5lYXNpbmcgPSBcImxpbmVhclwiO1xuICAgICAgKF9iID0gKF9hID0gYW5pbWF0aW9uLmVmZmVjdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZVRpbWluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRpbWluZ09wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29udHJvbHMuY3VycmVudFRpbWUgPSBheGlzSW5mby5wcm9ncmVzcztcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvc2Nyb2xsL2luZGV4LmVzLmpzXG52YXIgc2Nyb2xsTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgcmVzaXplTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgb25TY3JvbGxIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIGdldEV2ZW50VGFyZ2V0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/IHdpbmRvdyA6IGVsZW1lbnQ7XG5mdW5jdGlvbiBzY3JvbGwob25TY3JvbGwsIF9hID0ge30pIHtcbiAgdmFyIHsgY29udGFpbmVyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IH0gPSBfYSwgb3B0aW9ucyA9IF9fcmVzdDIoX2EsIFtcImNvbnRhaW5lclwiXSk7XG4gIGxldCBjb250YWluZXJIYW5kbGVycyA9IG9uU2Nyb2xsSGFuZGxlcnMuZ2V0KGNvbnRhaW5lcik7XG4gIGlmICghY29udGFpbmVySGFuZGxlcnMpIHtcbiAgICBjb250YWluZXJIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgb25TY3JvbGxIYW5kbGVycy5zZXQoY29udGFpbmVyLCBjb250YWluZXJIYW5kbGVycyk7XG4gIH1cbiAgY29uc3QgaW5mbyA9IGNyZWF0ZVNjcm9sbEluZm8oKTtcbiAgY29uc3QgY29udGFpbmVySGFuZGxlciA9IGNyZWF0ZU9uU2Nyb2xsSGFuZGxlcihjb250YWluZXIsIG9uU2Nyb2xsLCBpbmZvLCBvcHRpb25zKTtcbiAgY29udGFpbmVySGFuZGxlcnMuYWRkKGNvbnRhaW5lckhhbmRsZXIpO1xuICBpZiAoIXNjcm9sbExpc3RlbmVycy5oYXMoY29udGFpbmVyKSkge1xuICAgIGNvbnN0IGxpc3RlbmVyMiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBjb250YWluZXJIYW5kbGVycylcbiAgICAgICAgaGFuZGxlci5tZWFzdXJlKCk7XG4gICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgY29udGFpbmVySGFuZGxlcnMpXG4gICAgICAgIGhhbmRsZXIudXBkYXRlKHRpbWUpO1xuICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGNvbnRhaW5lckhhbmRsZXJzKVxuICAgICAgICBoYW5kbGVyLm5vdGlmeSgpO1xuICAgIH07XG4gICAgc2Nyb2xsTGlzdGVuZXJzLnNldChjb250YWluZXIsIGxpc3RlbmVyMik7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoY29udGFpbmVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBsaXN0ZW5lcjIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICBpZiAoY29udGFpbmVyICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHJlc2l6ZUxpc3RlbmVycy5zZXQoY29udGFpbmVyLCByZXNpemUoY29udGFpbmVyLCBsaXN0ZW5lcjIpKTtcbiAgICB9XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbGlzdGVuZXIyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIH1cbiAgY29uc3QgbGlzdGVuZXIgPSBzY3JvbGxMaXN0ZW5lcnMuZ2V0KGNvbnRhaW5lcik7XG4gIGNvbnN0IG9uTG9hZFByb2Nlc3NzID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxpc3RlbmVyKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICh0eXBlb2Ygb25TY3JvbGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIG9uU2Nyb2xsLnN0b3AoKTtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShvbkxvYWRQcm9jZXNzcyk7XG4gICAgY29uc3QgY29udGFpbmVySGFuZGxlcnMyID0gb25TY3JvbGxIYW5kbGVycy5nZXQoY29udGFpbmVyKTtcbiAgICBpZiAoIWNvbnRhaW5lckhhbmRsZXJzMilcbiAgICAgIHJldHVybjtcbiAgICBjb250YWluZXJIYW5kbGVyczIuZGVsZXRlKGNvbnRhaW5lckhhbmRsZXIpO1xuICAgIGlmIChjb250YWluZXJIYW5kbGVyczIuc2l6ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsaXN0ZW5lcjIgPSBzY3JvbGxMaXN0ZW5lcnMuZ2V0KGNvbnRhaW5lcik7XG4gICAgc2Nyb2xsTGlzdGVuZXJzLmRlbGV0ZShjb250YWluZXIpO1xuICAgIGlmIChsaXN0ZW5lcjIpIHtcbiAgICAgIGdldEV2ZW50VGFyZ2V0KGNvbnRhaW5lcikucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBsaXN0ZW5lcjIpO1xuICAgICAgKF9hMiA9IHJlc2l6ZUxpc3RlbmVycy5nZXQoY29udGFpbmVyKSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIoKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGxpc3RlbmVyMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3VzZS1zY3JvbGwubWpzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTAgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBjcmVhdGVTY3JvbGxNb3Rpb25WYWx1ZXMgPSAoKSA9PiAoe1xuICBzY3JvbGxYOiBtb3Rpb25WYWx1ZSgwKSxcbiAgc2Nyb2xsWTogbW90aW9uVmFsdWUoMCksXG4gIHNjcm9sbFhQcm9ncmVzczogbW90aW9uVmFsdWUoMCksXG4gIHNjcm9sbFlQcm9ncmVzczogbW90aW9uVmFsdWUoMClcbn0pO1xuZnVuY3Rpb24gdXNlU2Nyb2xsKF9hID0ge30pIHtcbiAgdmFyIF9iID0gX2EsIHsgY29udGFpbmVyLCB0YXJnZXQsIGxheW91dEVmZmVjdCA9IHRydWUgfSA9IF9iLCBvcHRpb25zID0gX19vYmpSZXN0KF9iLCBbXCJjb250YWluZXJcIiwgXCJ0YXJnZXRcIiwgXCJsYXlvdXRFZmZlY3RcIl0pO1xuICBjb25zdCB2YWx1ZXMgPSB1c2VDb25zdGFudChjcmVhdGVTY3JvbGxNb3Rpb25WYWx1ZXMpO1xuICBjb25zdCB1c2VMaWZlY3ljbGVFZmZlY3QgPSBsYXlvdXRFZmZlY3QgPyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0MTA7XG4gIHVzZUxpZmVjeWNsZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHNjcm9sbCgoeyB4LCB5IH0pID0+IHtcbiAgICAgIHZhbHVlcy5zY3JvbGxYLnNldCh4LmN1cnJlbnQpO1xuICAgICAgdmFsdWVzLnNjcm9sbFhQcm9ncmVzcy5zZXQoeC5wcm9ncmVzcyk7XG4gICAgICB2YWx1ZXMuc2Nyb2xsWS5zZXQoeS5jdXJyZW50KTtcbiAgICAgIHZhbHVlcy5zY3JvbGxZUHJvZ3Jlc3Muc2V0KHkucHJvZ3Jlc3MpO1xuICAgIH0sIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICBjb250YWluZXI6IChjb250YWluZXIgPT09IG51bGwgfHwgY29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250YWluZXIuY3VycmVudCkgfHwgdm9pZCAwLFxuICAgICAgdGFyZ2V0OiAodGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0LmN1cnJlbnQpIHx8IHZvaWQgMFxuICAgIH0pKTtcbiAgfSwgW10pO1xuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vLyBzcmMvTWVudS50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyLCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG57XG4gIG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKFwiZW4tVVNcIiwge1xuICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgIG1pbnV0ZTogXCJudW1lcmljXCJcbiAgfSk7XG59XG52YXIgTWVudSA9ICgpID0+IHtcbiAgY29uc3QgeyBzY3JvbGxZUHJvZ3Jlc3MgfSA9IHVzZVNjcm9sbCgpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJoaWRkZW4gc206YmxvY2tcIixcbiAgICBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIobW90aW9uLmRpdiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicHJvZ3Jlc3MtYmFyXCIsXG4gICAgICAgIHN0eWxlOiB7IHNjYWxlWDogc2Nyb2xsWVByb2dyZXNzIH1cbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwiZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIGJnLWdyYWRpZW50LXRvLXIgZnJvbS1ibHVlLTQwMCB0by1ibHVlLTUwMFwiLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyb3VuZGVkLXhsIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYVwiLCB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiL1wiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJQeWxhclxcdTIxMjIgQUkgYnkgU1VQRVJEQVRBU1wiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyb3VuZGVkLXhsIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYVwiLCB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiL2Jsb2dcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiRGFpbHkgV29ya1wiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyb3VuZGVkLXhsIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYVwiLCB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiL3doYXQtaXMtcHlsYXJcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQWJvdXRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicm91bmRlZC14bCBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGVcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihcImFcIiwge1xuICAgICAgICAgICAgICBocmVmOiBcIi9weWxhci1saWNlbnNlXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlRoZSBMaWNlbnNlXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCJodHRwczovL3BlbmNpbC5kb21haW5zXCIsXG4gICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgcmVsOiBcIm5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUGVuY2lsIERvbWFpbnNcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiaGlkZGVuIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZSBtZDpibG9ja1wiLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaGlkZGVuIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZSBtZDpibG9ja1wiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihcImFcIiwge1xuICAgICAgICAgICAgICAgICAgaHJlZjogXCJodHRwOi8vdHdpdHRlci5jb20vc3VwZXJkYXRhc1wiLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlR3aXR0ZXJcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcImFcIiwge1xuICAgICAgICAgICAgICAgIGhyZWY6IFwiaHR0cDovL2dpdGh1Yi5jb20vbWlndWVsZ2FyZ2FsbG8vbmV4dDEzLWdhbGxlcnktaW1hZ2UtdHVyYm9cIixcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaGlkZGVuIHB5LTIgcHgtNCBmb250LWJvbGQgdGV4dC13aGl0ZSBtZDpibG9ja1wiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihcInBpY3R1cmVcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiaW1nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjOiBcImh0dHBzOi8vaW1nLnNoaWVsZHMuaW8vZ2l0aHViL3N0YXJzL21pZ3VlbGdhcmdhbGxvL05leHQxMy1nYWxsZXJ5LWltYWdlLXR1cmJvP3N0eWxlPXNvY2lhbFwiLFxuICAgICAgICAgICAgICAgICAgICBhbHQ6IFwiTGFuZHNjYXBlIHBpY3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyMFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFZlcnNpb24sIHt9KVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICAgIH0pXG4gICAgXVxuICB9KTtcbn07XG5cbi8vIHNyYy9NZW51UHlsYXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MywganN4cyBhcyBqc3hzMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE1lbnVQeWxhciA9ICgpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwiZmxleCBoaWRkZW4gZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBiZy1ncmFkaWVudC10by1yIGZyb20tYmx1ZS00MDAgdG8tYmx1ZS01MDAgc206YmxvY2tcIixcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMyKFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJmbGV4IGZsZXgtcm93XCIsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MyhcImJ1dHRvblwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzKFwiYVwiLCB7XG4gICAgICAgICAgICBocmVmOiBcIi9ibG9nXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJPdXIgRGFpbHkgV29ya1wiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicm91bmRlZC14bCBweS0yIHB4LTQgZm9udC1ib2xkIHRleHQtd2hpdGVcIixcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMoXCJhXCIsIHtcbiAgICAgICAgICAgIGhyZWY6IFwiL3doYXQtaXMtcHlsYXJcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIldoYXQgaXMgUHlsYXIgQUlcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MyhcImJ1dHRvblwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJvdW5kZWQteGwgcHktMiBweC00IGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzKFwiYVwiLCB7XG4gICAgICAgICAgICBocmVmOiBcIi9weWxhci1saWNlbnNlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJMaWNlbnNlXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgXVxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL1RpdGxlUHlsYXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NCwganN4cyBhcyBqc3hzMyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFRpdGxlUHlsYXIgPSAoKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4czMoXCJkaXZcIiwge1xuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4czMoXCJoMVwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJweS04IHRleHQtY2VudGVyIHRleHQtNXhsIGZvbnQtYm9sZFwiLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMC41LCBkdXJhdGlvbjogMS41IH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJQXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NChtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDAuNiwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwieVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDQobW90aW9uLnNwYW4sIHtcbiAgICAgICAgICAgIGluaXRpYWw6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgYW5pbWF0ZTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB7IGRlbGF5OiAwLjcsIGR1cmF0aW9uOiAxLjUgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcImxcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMC44LCBkdXJhdGlvbjogMS41IH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJhXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NChtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDAuOSwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiclxcdTIxMjJcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMSwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiXFx4QTBcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KG1vdGlvbi5zcGFuLCB7XG4gICAgICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogeyBkZWxheTogMS4xLCBkdXJhdGlvbjogMS41IH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NChtb3Rpb24uc3Bhbiwge1xuICAgICAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDEuMiwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiSVwiXG4gICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4czMobW90aW9uLmgyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJweS04IHRleHQtY2VudGVyIHRleHQtNHhsIGZvbnQtYm9sZFwiLFxuICAgICAgICBpbml0aWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgYW5pbWF0ZTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHRyYW5zaXRpb246IHsgZGVsYXk6IDEuNCwgZHVyYXRpb246IDEuNSB9LFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiUHlcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIFwidGhvblwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiTFwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJlYXJuaW5nXCIsXG4gICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDQoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJ0ZXh0LWJsdWUtNTAwXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBcInJ0aWZpY2lhbFwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiUlwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJlc2VhcmNoXFx1MjEyMlwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibGFja1wiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiIFwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDQoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJ0ZXh0LWJsdWUtNTAwXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBcInJ0aWZpY2lhbFwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiSVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJudGVsbGlnZW5jZVwiLFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgIF1cbiAgICAgIH0pXG4gICAgXVxuICB9KTtcbn07XG5cbi8vIHNyYy9MaXN0UHlsYXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NSwganN4cyBhcyBqc3hzNCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIExpc3RQeWxhciA9ICgpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g1KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwibXQtOCBmbGV4IGZsZXgtcm93IGp1c3RpZnktY2VudGVyXCIsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hzNChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwiZmxleCB3LTMvNCBmbGV4LWNvbFwiLFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDUoXCJoMlwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInRleHQtMnhsIGZvbnQtYm9sZFwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBcIldlbGNvbWUgdG8gdGhlIFB5bGFyIEFJIEJsb2dcIlxuICAgICAgICB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHM0KFwicFwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm10LTQgdGV4dC1sZ1wiLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBcIlB5bGFyIEFJIGlzOlwiLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHM0KFwidWxcIiwge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibGlzdC1pbnNpZGUgbGlzdC1kaXNjXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDUoXCJsaVwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJHZW5lcmF0aXZlIGFydCByZXN1bHRzXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NShcImFcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiV2hhdCBpcyBnZW5lcmF0aXZlIGFydD8gR2VuZXJhdGl2ZSBhcnQgaXMgYSBmb3JtIG9mIGFydCB0aGF0IHVzZXMgYSBjb21wdXRlciB0byBjcmVhdGUgYXJ0LiBUaGUgY29tcHV0ZXIgaXMgcHJvZ3JhbW1lZCB0byBjcmVhdGUgYXJ0IGJhc2VkIG9uIGEgc2V0IG9mIHJ1bGVzLlwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDUoXCJwXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlxceEEwXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NShcImxpXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlByb210IEVuZ2luZWVyaW5nIGRlc2lnblwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDUoXCJhXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlByb210IEVuZ2luZWVyaW5nIGlzIGEgZm9ybSBvZiBlbmdpbmVlcmluZyB0aGF0IHVzZXMgYSBjb21wdXRlciB0byBjcmVhdGUgZW5naW5lZXJpbmcuIFRoZSBjb21wdXRlciBpcyBwcm9ncmFtbWVkIHRvIGNyZWF0ZSBlbmdpbmVlcmluZyBiYXNlZCBvbiBhIHNldCBvZiBydWxlcy5cIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g1KFwicFwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJcXHhBMFwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDUoXCJsaVwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJTdGFibGVEaWZmdXNpb24gMi4wIG1vZGlmaWVkXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NShcImFcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiU3RhYmxlRGlmZnVzaW9uIDIuMCBpcyBhIGNvbXB1dGVyIHByb2dyYW0gdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSBhcnQgYmFzZWQgb24gYSBzZXQgb2YgcnVsZXMuXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NShcInBcIiwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiXFx4QTBcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgXVxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL0Zvb3Rlci50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g2LCBqc3hzIGFzIGpzeHM1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRm9vdGVyID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHM1KFwiZm9vdGVyXCIsIHtcbiAgICBjbGFzc05hbWU6IFwiYmctd2hpdGUgcHktOCB0ZXh0LWNlbnRlclwiLFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4NihcImRpdlwiLCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4czUoXCJhXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgXCJNYWRlIHdpdGggXFx1Mjc2NFxcdUZFMEYgYnlcIixcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDYoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCJodHRwczovL3R3aXR0ZXIuY29tL21pZ3VlbGdhcmdhbGxvXCIsXG4gICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImhvdmVyOnRleHQtYmx1ZSB0ZXh0LWluZGlnby02MDBcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiTWlndWVsIEdhcmdhbGxvXCJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCIuXCJcbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g2KFwiZGl2XCIsIHtcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hzNShcImFcIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBcIjIwMjIgXFx4QTlcIixcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDYoXCJhXCIsIHtcbiAgICAgICAgICAgICAgaHJlZjogXCJodHRwczovL2h1Z2dpbmdmYWNlLmNvL3NwYWNlcy9zdXBlcmRhdGFzL0xJQ0VOU0VcIixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgICByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaG92ZXI6dGV4dC1ibHVlIHRleHQtaW5kaWdvLTYwMFwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJQeWxhclxcdTIxMjIgQUkgY3JlYXRpdmUgTUwgbGljZW5zZVwiXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwiLlwiXG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4NihcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJoaWRkZW4gc206YmxvY2tcIixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hzNShcImRpdlwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImZsZXggdy1mdWxsIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NihcImFcIiwge1xuICAgICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vdmVyY2VsLmNvbS9uZXcvY2xvbmU/cmVwb3NpdG9yeS11cmw9aHR0cHMlM0ElMkYlMkZnaXRodWIuY29tJTJGbWlndWVsZ2FyZ2FsbG8lMkZOZXh0MTMtRmV0Y2gtRGF0YS10dXJibyZwcm9qZWN0LW5hbWU9bWlndWVsZ2FyZ2FsbG8tbmV4dDEzLWZldGNoLWRhdGEtdHVyYm8mcmVwby1uYW1lPW1pZ3VlbGdhcmdhbGxvLW5leHQxMy1mZXRjaC1kYXRhLXR1cmJvXCIsXG4gICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImhpZGRlbiBwLTIgbWQ6YmxvY2tcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g2KFwicGljdHVyZVwiLCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g2KFwiaW1nXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNyYzogXCJodHRwczovL3ZlcmNlbC5jb20vYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICBhbHQ6IFwiTGFuZHNjYXBlIHBpY3R1cmVcIixcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiA3NSxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogMjBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NihcImFcIiwge1xuICAgICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vc3BhY2VzL3N1cGVyZGF0YXMvTElDRU5TRVwiLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWRkZW4gcC0yIG1kOmJsb2NrXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NihcInBpY3R1cmVcIiwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NihcImltZ1wiLCB7XG4gICAgICAgICAgICAgICAgICBzcmM6IFwiaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9mcm9udC9hc3NldHMvaHVnZ2luZ2ZhY2VfbG9nby5zdmdcIixcbiAgICAgICAgICAgICAgICAgIGFsdDogXCJMYW5kc2NhcGUgcGljdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgd2lkdGg6IDQwLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyMFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeDYoXCJwXCIsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiUGxlYXNlIGRvIG5vdCBjb25zaWRlciB0aGUgc2NvcmUgYXMgaW52ZXN0bWVudCBhZHZpY2UuXCJcbiAgICAgIH0pXG4gICAgXVxuICB9KTtcbn07XG5cbi8vIHNyYy9TY3JvbGxhYmxlLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDcgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBTY3JvbGxhYmxlID0gKCkgPT4ge1xuICBjb25zdCB7IHNjcm9sbFlQcm9ncmVzcyB9ID0gdXNlU2Nyb2xsKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4Nyhtb3Rpb24uZGl2LCB7XG4gICAgY2xhc3NOYW1lOiBcInByb2dyZXNzLWJhclwiLFxuICAgIHN0eWxlOiB7IHNjYWxlWDogc2Nyb2xsWVByb2dyZXNzIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvQmxvZ1B5bGFyL2Jsb2cudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4OCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEVMRU1FTlRTMiA9IDU7XG52YXIgYmxvZyA9ICgpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g4KFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDgoXCJzdmdcIiwge1xuICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgIHdpZHRoOiBcIjk1XCIsXG4gICAgICBoZWlnaHQ6IFwiOTVcIixcbiAgICAgIHN0cm9rZTogXCIjRkZGXCIsXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiBcIjBcIixcbiAgICAgIHZpZXdCb3g6IFwiMCAwIDk1IDk1XCIsXG4gICAgICBjbGFzc05hbWU6IFwibS0yIHJvdW5kZWQteGwgcHktMiBzaGFkb3ctbWQgaG92ZXI6c2hhZG93LXhsXCIsXG4gICAgICBzdHlsZTogayhFTEVNRU5UUzIpLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g4KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IFwiTTMyLjgxNiwxMi45NSwzMC4zNDksOC41NjhoNC43OGEuNDM5LjQzOSwwLDAsMSwuMzQ2LjJsLjkzMSwxLjUzNGMuNTU4LjkyLDEuMjI1LDIuMDIsMS42MDcsMi42NDhaTTIzLjk3NSwzOS40OTVhLjMzOS4zMzksMCwwLDEtLjMxNS4yMDdIMTguNzcybDcuNTk1LTEzLjYzNWEuNzMxLjczMSwwLDAsMC0uNjM2LTEuMDg3aDBMMTIuNzg3LDI1bC0yLjU3NC00LjQ1NkgyOS4wNzZjLjAxMSwwLC4wMiwwLC4wMzEsMGEuNjc3LjY3NywwLDAsMCwuMjE3LS4wNDVsLjA0Ny0uMDJhLjcyMi43MjIsMCwwLDAsLjM0Ni0uMzEzbDMuMTA4LTUuNzQ1aDUuMTNabS02LjQ2OC0uNTE4LS42MTMtMS4wMDljLS43ODUtMS4zLTEuNzkxLTIuOTU1LTEuOS0zLjEzN2EuMzg1LjM4NSwwLDAsMSwuMDI0LS4zNTVsNC40NTctOC4wMjcsNS4wMTktLjAwNlpNOC45NDgsMzAuNDQ0LDYuNDUzLDI2LjAxMSw4Ljk2OCwyMS4zbDIuNTIyLDQuMzY3QzEwLjcwNiwyNy4xNCw5LjQ4MywyOS40NDIsOC45NDgsMzAuNDQ0Wm0tMy4zNDguNjlIMi44ODFhLjQ0My40NDMsMCwwLDEtLjM0My0uMkwxLjcyNiwyOS42QzEuMTQ3LDI4LjY0MS40MDksMjcuNDI1LDAsMjYuNzUySDUuMmwyLjQ2Niw0LjM4M1pNMTQuMDM3LjIwOEEuMzM4LjMzOCwwLDAsMSwxNC4zNTEsMGg0LjkxTDExLjY0NiwxMy42MzZjLS4wMDYuMDExLS4wMS4wMjMtLjAxNi4wMzVzLS4wMjEuMDQ2LS4wMy4wNy0uMDE1LjA0Ni0uMDIxLjA2OS0uMDExLjA0NC0uMDE0LjA2NmEuNjQ4LjY0OCwwLDAsMC0uMDA4LjA4MWMwLC4wMTIsMCwuMDIzLDAsLjAzNnMwLC4wMTgsMCwuMDI3YS41OTEuNTkxLDAsMCwwLC4wMDguMDc5LjUzOC41MzgsMCwwLDAsLjAxMi4wNjZjLjAwNi4wMjMuMDEzLjA0NS4wMjEuMDY4cy4wMTYuMDQ1LjAyNS4wNjYuMDIxLjA0MS4wMzMuMDYyLjAyMy4wNC4wMzcuMDU5YS42NDQuNjQ0LDAsMCwwLC4wNDUuMDU1Yy4wMTYuMDE3LjAzMS4wMzUuMDQ4LjA1MXMuMDM1LjAyOS4wNTMuMDQzYS42MzQuNjM0LDAsMCwwLC4wNjMuMDQ1bC4wMjMuMDE2Yy4wMDgsMCwuMDE4LjAwNi4wMjcuMDExYS43MjkuNzI5LDAsMCwwLC4xMTkuMDQ4Yy4wMTUsMCwuMDI5LjAxLjA0NC4wMTNhLjcuNywwLDAsMCwuMTY0LjAyMWguMzNsMTIuNjE5LS4wMTdjLjMzNC41OC45NTcsMS42NzMsMS40ODksMi42cS42MTIsMS4wNzIsMS4wMSwxLjc2OEg4Ljk0OWMtLjAwOCwwLS4wMTYsMC0uMDI0LDBhLjcyNS43MjUsMCwwLDAtLjYzMS4zODJMNS4xODUsMjUuMjlILjA1OVptNi40NzkuNTM0LjQ1Ni43NWMuOCwxLjMyMSwxLjkzMiwzLjE4NSwyLjA1MiwzLjM3OUEuMzgzLjM4MywwLDAsMSwyMyw1LjIyN2wtNC40NTcsOC4wMjctNS4wMTcuMDA2Wm04LjU0Niw4LjUxMSwyLjUsNC40MzUtMi41NDUsNC43Yy0uMy0uNTI5LS42OC0xLjE4OS0xLjAzNC0xLjgwOC0uNy0xLjIyNC0xLjIwOC0yLjExNS0xLjQ5NS0yLjYxM0MyNy4wMjgsMTIuOTc3LDI4LjQ2MiwxMC4zNDksMjkuMDYyLDkuMjUzWlwiLFxuICAgICAgICBpZDogXCJGaWxsLTFcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcImZpbGwteWVsbG93LTUwMFwiXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL0Jsb2dQeWxhci9wb3N0MTIwMzIwMjIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4OSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEVMRU1FTlRTMyA9IDU7XG52YXIgcG9zdDEyMDMyMDIyID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDkoXCJkaXZcIiwge1xuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4OShcInN2Z1wiLCB7XG4gICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgd2lkdGg6IFwiOTVcIixcbiAgICAgIGhlaWdodDogXCI5NVwiLFxuICAgICAgc3Ryb2tlOiBcIiNGRkZcIixcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IFwiMFwiLFxuICAgICAgdmlld0JveDogXCIwIDAgOTUgOTVcIixcbiAgICAgIGNsYXNzTmFtZTogXCJtLTIgcm91bmRlZC14bCBweS0yIHNoYWRvdy1tZCBob3ZlcjpzaGFkb3cteGxcIixcbiAgICAgIHN0eWxlOiBrKEVMRU1FTlRTMyksXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDkoXCJwYXRoXCIsIHtcbiAgICAgICAgZDogXCJNMzIuODE2LDEyLjk1LDMwLjM0OSw4LjU2OGg0Ljc4YS40MzkuNDM5LDAsMCwxLC4zNDYuMmwuOTMxLDEuNTM0Yy41NTguOTIsMS4yMjUsMi4wMiwxLjYwNywyLjY0OFpNMjMuOTc1LDM5LjQ5NWEuMzM5LjMzOSwwLDAsMS0uMzE1LjIwN0gxOC43NzJsNy41OTUtMTMuNjM1YS43MzEuNzMxLDAsMCwwLS42MzYtMS4wODdoMEwxMi43ODcsMjVsLTIuNTc0LTQuNDU2SDI5LjA3NmMuMDExLDAsLjAyLDAsLjAzMSwwYS42NzcuNjc3LDAsMCwwLC4yMTctLjA0NWwuMDQ3LS4wMmEuNzIyLjcyMiwwLDAsMCwuMzQ2LS4zMTNsMy4xMDgtNS43NDVoNS4xM1ptLTYuNDY4LS41MTgtLjYxMy0xLjAwOWMtLjc4NS0xLjMtMS43OTEtMi45NTUtMS45LTMuMTM3YS4zODUuMzg1LDAsMCwxLC4wMjQtLjM1NWw0LjQ1Ny04LjAyNyw1LjAxOS0uMDA2Wk04Ljk0OCwzMC40NDQsNi40NTMsMjYuMDExLDguOTY4LDIxLjNsMi41MjIsNC4zNjdDMTAuNzA2LDI3LjE0LDkuNDgzLDI5LjQ0Miw4Ljk0OCwzMC40NDRabS0zLjM0OC42OUgyLjg4MWEuNDQzLjQ0MywwLDAsMS0uMzQzLS4yTDEuNzI2LDI5LjZDMS4xNDcsMjguNjQxLjQwOSwyNy40MjUsMCwyNi43NTJINS4ybDIuNDY2LDQuMzgzWk0xNC4wMzcuMjA4QS4zMzguMzM4LDAsMCwxLDE0LjM1MSwwaDQuOTFMMTEuNjQ2LDEzLjYzNmMtLjAwNi4wMTEtLjAxLjAyMy0uMDE2LjAzNXMtLjAyMS4wNDYtLjAzLjA3LS4wMTUuMDQ2LS4wMjEuMDY5LS4wMTEuMDQ0LS4wMTQuMDY2YS42NDguNjQ4LDAsMCwwLS4wMDguMDgxYzAsLjAxMiwwLC4wMjMsMCwuMDM2czAsLjAxOCwwLC4wMjdhLjU5MS41OTEsMCwwLDAsLjAwOC4wNzkuNTM4LjUzOCwwLDAsMCwuMDEyLjA2NmMuMDA2LjAyMy4wMTMuMDQ1LjAyMS4wNjhzLjAxNi4wNDUuMDI1LjA2Ni4wMjEuMDQxLjAzMy4wNjIuMDIzLjA0LjAzNy4wNTlhLjY0NC42NDQsMCwwLDAsLjA0NS4wNTVjLjAxNi4wMTcuMDMxLjAzNS4wNDguMDUxcy4wMzUuMDI5LjA1My4wNDNhLjYzNC42MzQsMCwwLDAsLjA2My4wNDVsLjAyMy4wMTZjLjAwOCwwLC4wMTguMDA2LjAyNy4wMTFhLjcyOS43MjksMCwwLDAsLjExOS4wNDhjLjAxNSwwLC4wMjkuMDEuMDQ0LjAxM2EuNy43LDAsMCwwLC4xNjQuMDIxaC4zM2wxMi42MTktLjAxN2MuMzM0LjU4Ljk1NywxLjY3MywxLjQ4OSwyLjZxLjYxMiwxLjA3MiwxLjAxLDEuNzY4SDguOTQ5Yy0uMDA4LDAtLjAxNiwwLS4wMjQsMGEuNzI1LjcyNSwwLDAsMC0uNjMxLjM4Mkw1LjE4NSwyNS4yOUguMDU5Wm02LjQ3OS41MzQuNDU2Ljc1Yy44LDEuMzIxLDEuOTMyLDMuMTg1LDIuMDUyLDMuMzc5QS4zODMuMzgzLDAsMCwxLDIzLDUuMjI3bC00LjQ1Nyw4LjAyNy01LjAxNy4wMDZabTguNTQ2LDguNTExLDIuNSw0LjQzNS0yLjU0NSw0LjdjLS4zLS41MjktLjY4LTEuMTg5LTEuMDM0LTEuODA4LS43LTEuMjI0LTEuMjA4LTIuMTE1LTEuNDk1LTIuNjEzQzI3LjAyOCwxMi45NzcsMjguNDYyLDEwLjM0OSwyOS4wNjIsOS4yNTNaXCIsXG4gICAgICAgIGlkOiBcIkZpbGwtMVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiZmlsbC15ZWxsb3ctNTAwXCJcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59O1xuZXhwb3J0IHtcbiAgRm9vdGVyLFxuICBMaXN0UHlsYXIsXG4gIE1lbnUsXG4gIE1lbnVQeWxhcixcbiAgU2Nyb2xsYWJsZSxcbiAgVGl0bGVQeWxhcixcbiAgVmVyc2lvbixcbiAgYmxvZyxcbiAgcG9zdDEyMDMyMDIyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../packages/ui/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Falex%2Fframeworks%2Fstaff%2FNext13-Gallery-Image-Turbo%2Fapps%2Fweb%2Fsrc%2Fpages%2Findex.tsx&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);